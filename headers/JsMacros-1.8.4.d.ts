
/**
 * The global context  
 * If you're trying to access the context in {@link JsMacros.on},  
 * use the second param of callback
 */
declare const context: EventContainer;
/**
 * Cast event in javascript:  
 * Remove the `\` between `*` and `///` because jsdoc doesn't escape it
 * ```js
 * /** @type {Events.Service} *\/// @ts-ignore
 * ```
 * ```js
 * const e = event;
 * ```
 * Cast event in typescript:
 * ```ts
 * const e = event as Events.Service;
 * ```
 */
declare const event: Events.BaseEvent;
declare const file: Packages.java.io.File;

declare namespace Events {

    interface BaseEvent extends JavaObject {

        getEventName(): string;

    }

    interface JoinedKey extends BaseEvent {
        cancel: boolean;

        cancel(): void;
        isCanceled(): boolean;

    }

    interface JoinedRecvPacket extends BaseEvent {
        cancel: boolean;
        packet: /* minecraft class */ any;
        readonly type: PacketName;

        /**
         * After modifying the buffer, use {@link PacketByteBufferHelper#toPacket} to get the modified
         *  packet and replace this packet with the modified one.
         * @return a helper for accessing and modifying the packet's data.
         * @since 1.8.4
         */
        getPacketBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;
        cancel(): void;
        isCanceled(): boolean;

    }

    interface JoinedSendPacket extends BaseEvent {
        cancel: boolean;
        packet: /* minecraft class */ any;
        readonly type: PacketName;

        /**
         * Replaces the packet of this event with a new one of the same type, created from the given
         *  arguments. It's recommended to use {@link #getPacketBuffer} to modify the packet instead.
         * @param args the arguments to pass to the packet's constructor
         * @since 1.8.4
         */
        replacePacket(...args: any[]): void;

        /**
         * After modifying the buffer, use {@link PacketByteBufferHelper#toPacket} to get the modified
         *  packet and replace this packet with the modified one.
         * @return a helper for accessing and modifying the packet's data.
         * @since 1.8.4
         */
        getPacketBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;
        cancel(): void;
        isCanceled(): boolean;

    }

    interface JoinedTick extends BaseEvent {}

    interface Key extends BaseEvent {
        readonly action: number;
        readonly key: globalThis.Key;
        readonly mods: KeyMods;
    }

    interface LaunchGame extends BaseEvent {
        readonly playerName: string;
    }

    interface QuitGame extends BaseEvent {}

    interface RecvMessage extends BaseEvent {
        text: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
        /** @since 1.8.2 */
        signature: JavaArray<number>;
        /** @since 1.8.2 */
        messageType: string | null;
    }

    interface RecvPacket extends BaseEvent {
        readonly packet: /* minecraft class */ any;
        readonly type: PacketName;

        /**
         * After modifying the buffer, use {@link PacketByteBufferHelper#toPacket} to get the modified
         *  packet and replace this packet with the modified one.
         * @return a helper for accessing and modifying the packet's data.
         * @since 1.8.4
         */
        getPacketBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;

    }

    interface ResourcePackLoaded extends BaseEvent {
        readonly isGameStart: boolean;
        readonly loadedPacks: JavaList<string>;
    }

    interface SendMessage extends BaseEvent {
        message: string;
    }

    interface SendPacket extends BaseEvent {
        readonly packet: /* minecraft class */ any;
        readonly type: PacketName;

        /**
         * After modifying the buffer, use {@link PacketByteBufferHelper#toPacket} to get the modified
         *  packet and replace this packet with the modified one.
         * @return a helper for accessing and modifying the packet's data.
         * @since 1.8.4
         */
        getPacketBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;

    }

    interface Title extends BaseEvent {
        readonly type: TitleType;
        message: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
    }

    interface ClickSlot extends BaseEvent {

        /**
         * [https://wiki.vg/Protocol#Click_Window](https://wiki.vg/Protocol#Click_Window)
         */
        readonly mode: number;
        readonly button: ClickSlotButton;
        readonly slot: number;

        /**
         * set to `true` to prevent the default action
         */
        cancel: boolean;

        /**
         * @return inventory associated with the event
         */
        getInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<any>;
        cancel(): void;
        isCanceled(): boolean;

    }

    interface DropSlot extends BaseEvent {
        readonly slot: number;

        /**
         * whether it's all or a single item being dropped
         */
        readonly all: boolean;

        /**
         * set to `true` to cancel the default action
         */
        cancel: boolean;

        /**
         * @return inventory associated with the event
         */
        getInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<any>;
        cancel(): void;
        isCanceled(): boolean;

    }

    interface InventoryChange extends BaseEvent {
        readonly inventory: Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<any>;
        readonly changedSlots: JavaArray<number>;
        readonly oldItems: JavaMap<number, Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;
        readonly newItems: JavaMap<number, Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;
    }

    interface ItemDamage extends BaseEvent {
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly damage: number;
    }

    interface ItemPickup extends BaseEvent {
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
    }

    interface OpenContainer extends BaseEvent {
        readonly inventory: Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<any>;
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
        cancelled: boolean;

        cancel(): void;
        isCanceled(): boolean;

    }

    interface AirChange extends BaseEvent {
        readonly air: number;
    }

    interface ArmorChange extends BaseEvent {
        readonly slot: ArmorSlot;
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly oldItem: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
    }

    interface AttackBlock extends BaseEvent {
        readonly block: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
        readonly side: Side;
    }

    interface AttackEntity extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface Damage extends BaseEvent {
        readonly attacker: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        readonly source: DamageSource;
        readonly health: number;
        readonly change: number;
    }

    interface Death extends BaseEvent {
        readonly deathPos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;
        readonly inventory: JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

        /**
         * Respawns the player. Should be used with some delay, one tick should be enough.
         * @since 1.8.5
         */
        respawn(): void;

    }

    interface EXPChange extends BaseEvent {
        readonly progress: number;
        readonly total: number;
        readonly level: number;
        /** @since 1.6.5 */
        readonly prevProgress: number;
        /** @since 1.6.5 */
        readonly prevTotal: number;
        /** @since 1.6.5 */
        readonly prevLevel: number;
    }

    interface FallFlying extends BaseEvent {
        readonly state: boolean;
    }

    interface Heal extends BaseEvent {
        readonly source: HealSource;
        readonly health: number;
        readonly change: number;
    }

    interface HealthChange extends BaseEvent {
        readonly health: number;
        readonly change: number;
    }

    interface HeldItemChange extends BaseEvent {
        readonly offHand: boolean;
        readonly item: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
        readonly oldItem: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
    }

    interface HungerChange extends BaseEvent {
        readonly foodLevel: number;
    }

    interface InteractBlock extends BaseEvent {
        readonly offhand: boolean;
        readonly result: ActionResult;
        readonly block: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
        readonly side: Side;
    }

    interface InteractEntity extends BaseEvent {
        readonly offhand: boolean;
        readonly result: ActionResult;
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface OpenScreen extends BaseEvent {
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
        readonly screenName: ScreenName;
    }

    interface Riding extends BaseEvent {
        readonly state: boolean;
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface SignEdit extends BaseEvent {
        readonly pos: Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
        closeScreen: boolean;
        signText: JavaList<string>;
    }

    interface StatusEffectUpdate extends BaseEvent {
        readonly oldEffect: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;
        readonly newEffect: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;
        readonly added: boolean;
        readonly removed: boolean;
    }

    interface BlockUpdate extends BaseEvent {
        readonly block: BlockUpdateType;
        readonly updateType: string;
    }

    interface Bossbar extends BaseEvent {
        readonly bossBar: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.BossBarHelper;
        readonly uuid: string;
        readonly type: BossBarUpdateType;
    }

    interface ChunkLoad extends BaseEvent {
        readonly x: number;
        readonly z: number;
        readonly isFull: boolean;
    }

    interface ChunkUnload extends BaseEvent {
        readonly x: number;
        readonly z: number;
    }

    interface DimensionChange extends BaseEvent {
        readonly dimension: Dimension;
    }

    interface Disconnect extends BaseEvent {
        /** @since 1.6.4 */
        readonly message: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
    }

    interface EntityDamaged extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        /** @since 1.6.5 */
        readonly health: number;
        readonly damage: number;
    }

    interface EntityHealed extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        readonly health: number;
        readonly damage: number;
    }

    interface EntityLoad extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
    }

    interface EntityUnload extends BaseEvent {
        readonly entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
        readonly reason: EntityUnloadReason;
    }

    interface JoinServer extends BaseEvent {
        readonly player: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ClientPlayerEntityHelper</* minecraft class */ any>;
        readonly address: string;
    }

    interface PlayerJoin extends BaseEvent {
        readonly UUID: string;
        readonly player: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;
    }

    interface PlayerLeave extends BaseEvent {
        readonly UUID: string;
        readonly player: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;
    }

    interface Sound extends BaseEvent {
        readonly sound: SoundId;
        readonly volume: number;
        readonly pitch: number;
        readonly position: Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
    }

    interface Tick extends BaseEvent {}

    interface CommandContext extends BaseEvent {

        /**
         * @param name
         * @return 
         * @since 1.4.2
         * @throws CommandSyntaxException
         */
        getArg(name: string): any;
        getChild(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper;
        getRange(): Packages.com.mojang.brigadier.context.StringRange;
        getInput(): string;

    }

    interface CodeRender extends BaseEvent {
        readonly cursor: Packages.xyz.wagyourtail.jsmacros.client.gui.editor.SelectCursor;
        readonly code: string;
        readonly language: string;
        readonly screen: Packages.xyz.wagyourtail.jsmacros.client.gui.screens.EditorScreen;

        /**
         * you are expected to fill this in with text styling, if not filled, nothing will render
         *  if the code is an empty string, you are still expected to put an empty string as the first line here
         */
        readonly textLines: JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

        /**
         * you are expected to fill this with suggestions for autocomplete created using
         *  {@link #createSuggestion}
         */
        readonly autoCompleteSuggestions: JavaList<Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion>;

        /**
         * you are expected to fill this with a method to create right click actions.  
         *  method should be `(index:number) => Map<string,() => void>`,  
         *  meaning it accepts a character index and returns a map of names to actions.
         */
        rightClickActions: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<number, any, JavaMap<string, Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>>, any>;

        /**
         * @return [Prism4j's
         *      node list](https://github.com/noties/Prism4j/blob/75ac3dae6f8eff5b1b0396df3b806f44ce86c484/prism4j/src/main/java/io/noties/prism4j/Prism4j.java#L54) you don't have to use it but if you're not compiling your own...
         *      peek at the code of {@link TextStyleCompiler} for the default impl for walking the node tree.
         */
        genPrismNodes(): JavaList<Packages.io.noties.prism4j.Prism4j$Node>;

        /**
         * Easy access to the {@link Map} object for use with {@link #rightClickActions}
         * @return specifically a {@link LinkedHashMap}
         */
        createMap(): JavaMap<any, any>;

        /**
         * more convenient access to TextBuilder
         * @return new instance for use with {@link #textLines}
         */
        createTextBuilder(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder;
        createSuggestion(startIndex: int, suggestion: string): Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion;

        /**
         * @param startIndex index that is where the suggestion starts from before the already typed part
         * @param suggestion complete suggestion including the already typed part
         * @param displayText how the text should be displayed in the dropdown, default is suggestion text
         * @return a new suggestion object
         */
        createSuggestion(startIndex: int, suggestion: string, displayText: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion;

        /**
         * prefix tree data structure written for you, it's a bit intensive to add things to, especially how I wrote it, but
         *  lookup times are much better at least on larger data sets,  
         *  so create a single copy of this for your static autocompletes and don't be re-creating this every time, store it
         *  in `globalvars`, probably per language
         *
         *  or just don't use it, I'm not forcing you to.
         * @return a new {@link StringHashTrie}
         */
        createPrefixTree(): Packages.xyz.wagyourtail.StringHashTrie;

        /**
         * @return {@code key -> hex integer} values for theme data points, this can be used with the prism data for
         *      coloring, just have to use {@link TextBuilder#withColor(int, int, int)}
         *      on 1.15 and older versions the integer values with be the default color's index so you can directly pass it
         *      to {@link TextBuilder#withColor(int)}
         */
        getThemeData(): JavaMap<string, JavaArray<number>>;

    }

    interface Custom extends BaseEvent {
        eventName: string;

        /**
         * Triggers the event.  
         *  Try not to cause infinite looping by triggering the same {@link EventCustom} from its own listeners.
         * @since 1.2.8
         */
        trigger(): void;

        /**
         * trigger the event listeners, then run `callback` when they finish.
         * @since 1.3.1
         * @param callback used as a {@link Runnable}, so no args, no return value.
         */
        trigger(callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): void;

        /**
         * Triggers the event and waits for it to complete.  
         *  In languages with threading issues (js/jep) this may cause circular waiting when triggered from the same thread as
         *  the `jsmacros.on` registration for the event
         * @since 1.2.8
         */
        triggerJoin(): void;

        /**
         * Put an Integer into the event.
         * @param name
         * @param i
         * @return 
         * @since 1.2.8
         */
        putInt(name: string, i: int): number;

        /**
         * put a String into the event.
         * @param name
         * @param str
         * @return 
         * @since 1.2.8
         */
        putString(name: string, str: string): string;

        /**
         * put a Double into the event.
         * @param name
         * @param d
         * @return 
         * @since 1.2.8
         */
        putDouble(name: string, d: double): number;

        /**
         * put a Boolean into the event.
         * @param name
         * @param b
         * @return 
         * @since 1.2.8
         */
        putBoolean(name: string, b: boolean): boolean;

        /**
         * put anything else into the event.
         * @param name
         * @param o
         * @return 
         * @since 1.2.8
         */
        putObject(name: string, o: any): any;

        /**
         * Returns the type of the defined item in the event as a string.
         * @param name
         * @return 
         * @since 1.2.8
         */
        getType(name: string): string;

        /**
         * Gets an Integer from the event.
         * @param name
         * @return 
         * @since 1.2.8
         */
        getInt(name: string): number;

        /**
         * Gets a String from the event
         * @param name
         * @return 
         * @since 1.2.8
         */
        getString(name: string): string;

        /**
         * Gets a Double from the event.
         * @param name
         * @return 
         * @since 1.2.8
         */
        getDouble(name: string): number;

        /**
         * Gets a Boolean from the event.
         * @param name
         * @return 
         * @since 1.2.8
         */
        getBoolean(name: string): boolean;

        /**
         * Gets an Object from the event.
         * @param name
         * @return 
         * @since 1.2.8
         */
        getObject(name: string): any;

        /**
         * @since 1.6.4
         * @return map backing the event
         */
        getUnderlyingMap(): JavaMap<string, any>;

        /**
         * registers event so you can see it in the gui
         * @since 1.3.0
         */
        registerEvent(): void;

    }

    interface ProfileLoad extends BaseEvent {
        readonly profileName: string;
    }

    interface WrappedScript extends BaseEvent {
        readonly arg1: T;
        readonly arg2: U;
        result: R;

        setReturnBoolean(b: boolean): void;
        setReturnInt(i: int): void;
        setReturnDouble(d: double): void;
        setReturnString(s: string): void;
        setReturnObject(o: any): void;

    }

    interface Service extends BaseEvent {
        readonly serviceName: string;

        /**
         * when this service is stopped, this is run...
         */
        stopListener: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>;

        /**
         * Put an Integer into the global variable space.
         * @param name
         * @param i
         * @return 
         * @since 1.6.5
         */
        putInt(name: string, i: int): number;

        /**
         * put a String into the global variable space.
         * @param name
         * @param str
         * @return 
         * @since 1.6.5
         */
        putString(name: string, str: string): string;

        /**
         * put a Double into the global variable space.
         * @param name
         * @param d
         * @return 
         * @since 1.6.5
         */
        putDouble(name: string, d: double): number;

        /**
         * put a Boolean into the global variable space.
         * @param name
         * @param b
         * @return 
         * @since 1.6.5
         */
        putBoolean(name: string, b: boolean): boolean;

        /**
         * put anything else into the global variable space.
         * @param name
         * @param o
         * @return 
         * @since 1.6.5
         */
        putObject(name: string, o: any): any;

        /**
         * Returns the type of the defined item in the global variable space as a string.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getType(name: string): string;

        /**
         * Gets an Integer from the global variable space.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getInt(name: string): number;

        /**
         * Gets an Integer from the global variable space. and then increment it there.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getAndIncrementInt(name: string): number;

        /**
         * Gets an integer from the global variable pace. and then decrement it there.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getAndDecrementInt(name: string): number;

        /**
         * increment an Integer in the global variable space. then return it.
         * @param name
         * @return 
         * @since 1.6.5
         */
        incrementAndGetInt(name: string): number;

        /**
         * decrement an Integer in the global variable space. then return it.
         * @param name
         * @return 
         * @since 1.6.5
         */
        decrementAndGetInt(name: string): number;

        /**
         * Gets a String from the global variable space
         * @param name
         * @return 
         * @since 1.6.5
         */
        getString(name: string): string;

        /**
         * Gets a Double from the global variable space.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getDouble(name: string): number;

        /**
         * Gets a Boolean from the global variable space.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getBoolean(name: string): boolean;

        /**
         * toggles a global boolean and returns its new value
         * @param name
         * @return 
         * @since 1.6.5
         */
        toggleBoolean(name: string): boolean;

        /**
         * Gets an Object from the global variable space.
         * @param name
         * @return 
         * @since 1.6.5
         */
        getObject(name: string): any;

        /**
         * removes a key from the global variable space.
         * @param key
         * @since 1.6.5
         */
        remove(key: string): void;
        getRaw(): JavaMap<string, any>;

    }

}

interface Events {

    JoinedKey: Events.JoinedKey;
    JoinedRecvPacket: Events.JoinedRecvPacket;
    JoinedSendPacket: Events.JoinedSendPacket;
    JoinedTick: Events.JoinedTick;
    Key: Events.Key;
    LaunchGame: Events.LaunchGame;
    QuitGame: Events.QuitGame;
    RecvMessage: Events.RecvMessage;
    RecvPacket: Events.RecvPacket;
    ResourcePackLoaded: Events.ResourcePackLoaded;
    SendMessage: Events.SendMessage;
    SendPacket: Events.SendPacket;
    Title: Events.Title;
    ClickSlot: Events.ClickSlot;
    DropSlot: Events.DropSlot;
    InventoryChange: Events.InventoryChange;
    ItemDamage: Events.ItemDamage;
    ItemPickup: Events.ItemPickup;
    OpenContainer: Events.OpenContainer;
    AirChange: Events.AirChange;
    ArmorChange: Events.ArmorChange;
    AttackBlock: Events.AttackBlock;
    AttackEntity: Events.AttackEntity;
    Damage: Events.Damage;
    Death: Events.Death;
    EXPChange: Events.EXPChange;
    FallFlying: Events.FallFlying;
    Heal: Events.Heal;
    HealthChange: Events.HealthChange;
    HeldItemChange: Events.HeldItemChange;
    HungerChange: Events.HungerChange;
    InteractBlock: Events.InteractBlock;
    InteractEntity: Events.InteractEntity;
    OpenScreen: Events.OpenScreen;
    Riding: Events.Riding;
    SignEdit: Events.SignEdit;
    StatusEffectUpdate: Events.StatusEffectUpdate;
    BlockUpdate: Events.BlockUpdate;
    Bossbar: Events.Bossbar;
    ChunkLoad: Events.ChunkLoad;
    ChunkUnload: Events.ChunkUnload;
    DimensionChange: Events.DimensionChange;
    Disconnect: Events.Disconnect;
    EntityDamaged: Events.EntityDamaged;
    EntityHealed: Events.EntityHealed;
    EntityLoad: Events.EntityLoad;
    EntityUnload: Events.EntityUnload;
    JoinServer: Events.JoinServer;
    PlayerJoin: Events.PlayerJoin;
    PlayerLeave: Events.PlayerLeave;
    Sound: Events.Sound;
    Tick: Events.Tick;
    CommandContext: Events.CommandContext;
    CodeRender: Events.CodeRender;
    Custom: Events.Custom;
    ProfileLoad: Events.ProfileLoad;
    WrappedScript: Events.WrappedScript;
    Service: Events.Service;

}

/**
 * Functions for interacting with chat.  
 *
 * @author Wagyourtail
 */
declare namespace Chat {

    /**
     * Log to player chat.
     * @since 1.1.3
     * @param message
     */
    function log(message: any): void;

    /**
     * @param message
     * @param await should wait for message to actually be sent to chat to continue.
     * @throws InterruptedException
     */
    function log(message: any, await: boolean): void;

    /**
     * Logs the formatted message to the player's chat. The message is formatted using the default
     *  java {@link String#format} syntax.
     * @param message the message to format and log
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function logf(message: string, ...args: any[]): void;

    /**
     * Logs the formatted message to the player's chat. The message is formatted using the default
     *  java {@link String#format} syntax.
     * @param message the message to format and log
     * @param await whether to wait for message to be sent to chat before continuing
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function logf(message: string, await: boolean, ...args: any[]): void;

    /**
     * Say to server as player.
     * @since 1.0.0
     * @param message
     */
    function say(message: string): void;

    /**
     * Say to server as player.
     * @param message
     * @param await
     * @since 1.3.1
     * @throws InterruptedException
     */
    function say(message: string, await: boolean): void;

    /**
     * Sends the formatted message to the server. The message is formatted using the default java
     *  {@link String#format} syntax.
     * @param message the message to format and send to the server
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function sayf(message: string, ...args: any[]): void;

    /**
     * Sends the formatted message to the server. The message is formatted using the default java
     *  {@link String#format} syntax.
     * @param message the message to format and send to the server
     * @param await whether to wait for message to be sent to chat before continuing
     * @param args the arguments used to format the message
     * @throws InterruptedException
     * @since 1.8.4
     */
    function sayf(message: string, await: boolean, ...args: any[]): void;

    /**
     * open the chat input box with specific text already typed.
     * @since 1.6.4
     * @param message the message to start the chat screen with
     */
    function open(message: string): void;

    /**
     * open the chat input box with specific text already typed.  
     *  hint: you can combine with {@link xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros#waitForEvent} or
     *  {@link xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros#once} to wait for the chat screen
     *  to close and/or the to wait for the sent message
     * @since 1.6.4
     * @param message the message to start the chat screen with
     * @param await
     */
    function open(message: string, await: boolean): void;

    /**
     * Display a Title to the player.
     * @since 1.2.1
     * @param title
     * @param subtitle
     * @param fadeIn
     * @param remain
     * @param fadeOut
     */
    function title(title: any, subtitle: any, fadeIn: int, remain: int, fadeOut: int): void;

    /**
     * @since 1.8.1
     * @param text
     */
    function actionbar(text: any): void;

    /**
     * Display the smaller title that's above the actionbar.
     * @since 1.2.1
     * @param text
     * @param tinted
     */
    function actionbar(text: any, tinted: boolean): void;

    /**
     * Display a toast.
     * @since 1.2.5
     * @param title
     * @param desc
     */
    function toast(title: any, desc: any): void;

    /**
     * Creates a {@link xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper} for use where you need one and not a string.
     * @see xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper
     * @since 1.1.3
     * @param content
     * @return a new {@link xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper TextHelper}
     */
    function createTextHelperFromString(content: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

    /**
     * @since 1.5.2
     * @return
     */
    function getLogger(): Packages.org.slf4j.Logger;

    /**
     * returns a log4j logger, for logging to console only.
     * @since 1.5.2
     * @param name
     * @return
     */
    function getLogger(name: string): Packages.org.slf4j.Logger;

    /**
     * Create a  {@link xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper} for use where you need one and not a string.
     * @see xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper
     * @since 1.1.3
     * @param json
     * @return a new {@link xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper TextHelper}
     */
    function createTextHelperFromJSON(json: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

    /**
     * @see TextBuilder
     * @since 1.3.0
     * @return a new builder
     */
    function createTextBuilder(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder;

    /**
     * @param name name of command
     * @since 1.4.2
     * @return 
     * @see #getCommandManager()
     * @deprecated
     */
    function createCommandBuilder(name: string): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandBuilder;

    /**
     * @param name
     * @since 1.6.5
     * @see #getCommandManager()
     * @deprecated
     */
    function unregisterCommand(name: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper;

    /**
     * @since 1.6.5
     * @param node
     * @see #getCommandManager()
     * @deprecated
     */
    function reRegisterCommand(node: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper): void;

    /**
     * @since 1.7.0
     * @return
     */
    function getCommandManager(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandManager;

    /**
     * @since 1.7.0
     * @return
     */
    function getHistory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.ChatHistoryManager;

    /**
     * @param text the text to get the width of
     * @return the width of the given text in pixels.
     * @since 1.8.4
     */
    function getTextWidth(text: string): number;

    /**
     * @param string
     * @since 1.6.5
     * @return &#167; -> &amp;
     */
    function sectionSymbolToAmpersand(string: string): string;

    /**
     * @param string
     * @since 1.6.5
     * @return &amp; -> &#167;
     */
    function ampersandToSectionSymbol(string: string): string;

    /**
     * @param string
     * @since 1.6.5
     * @return
     */
    function stripFormatting(string: string): string;

}

/**
 * Functions that interact with minecraft that don't fit into their own module.  
 *
 * @author Wagyourtail
 * @since 1.2.9
 */
declare namespace Client {

    /**
     * @since 1.0.0 (was in the {@code jsmacros} library until 1.2.9)
     * @return the raw minecraft client class, it may be useful to use [Minecraft Mappings Viewer](https://wagyourtail.xyz/Projects/Minecraft%20Mappings%20Viewer/App) for this.
     */
    function getMinecraft(): /* minecraft class */ any;

    /**
     * @return a helper for interacting with minecraft's registry.
     * @since 1.8.4
     */
    function getRegistryManager(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.RegistryHelper;

    /**
     * @return a helper to modify and send minecraft packets.
     * @since 1.8.4
     */
    function createPacketByteBuffer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;

    /**
     * Run your task on the main minecraft thread
     * @param runnable task to run
     * @since 1.4.0
     */
    function runOnMainThread(runnable: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): void;

    /**
     * @since 1.6.5
     * @param runnable
     * @param watchdogMaxTime max time for the watchdog to wait before killing the script
     */
    function runOnMainThread(runnable: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>, watchdogMaxTime: long): void;

    /**
     * @return a helper which gives access to all game options and some other useful features.
     * @since 1.1.7 (was in the {@code jsmacros} library until 1.2.9)
     */
    function getGameOptions(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper;

    /**
     * @return the current minecraft version as a {@link java.lang.String String}.
     * @since 1.1.2 (was in the {@code jsmacros} library until 1.2.9)
     */
    function mcVersion(): string;

    /**
     * @since 1.2.0 (was in the {@code jsmacros} library until 1.2.9)
     * @return the fps debug string from minecraft.
     */
    function getFPS(): string;

    /**
     * Join singleplayer world
     * @since 1.6.6
     * @param folderName
     */
    function loadWorld(folderName: string): void;

    /**
     * @since 1.2.3 (was in the {@code jsmacros} library until 1.2.9)
     * @see #connect(String, int)
     * @param ip
     */
    function connect(ip: string): void;

    /**
     * Connect to a server
     * @since 1.2.3 (was in the {@code jsmacros} library until 1.2.9)
     * @param ip
     * @param port
     */
    function connect(ip: string, port: int): void;

    /**
     * @since 1.2.3 (was in the {@code jsmacros} library until 1.2.9)
     * @see #disconnect(MethodWrapper)
     */
    function disconnect(): void;

    /**
     * Disconnect from a server with callback.
     * @since 1.2.3 (was in the {@code jsmacros} library until 1.2.9)
     *
     *  {@code callback} defaults to {@code null}
     * @param callback calls your method as a {@link java.util.function.Consumer Consumer}<{@link java.lang.Boolean Boolean}>
     */
    function disconnect(callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<boolean, any, any, any>): void;

    /**
     * Closes the client (stops the game).  
     *  Waits until the game has stopped, meaning no further code is executed (for obvious reasons).  
     *  Warning: this does not wait on joined threads, so your script may stop at an undefined point.
     * @since 1.6.0
     */
    function shutdown(): void;

    /**
     * @since 1.2.4
     * @see #waitTick(int)
     * @throws InterruptedException
     */
    function waitTick(): void;

    /**
     * waits the specified number of client ticks.  
     *  don't use this on an event that the main thread waits on (joins)... that'll cause circular waiting.
     * @since 1.2.6
     * @param i
     * @throws InterruptedException
     */
    function waitTick(i: int): void;

    /**
     * @param ip
     * @return 
     * @since 1.6.5
     * @throws UnknownHostException
     * @throws InterruptedException
     */
    function ping(ip: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ServerInfoHelper;

    /**
     * @param ip
     * @param callback
     * @since 1.6.5
     * @throws UnknownHostException
     */
    function pingAsync(ip: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ServerInfoHelper, Packages.java.io.IOException, any, any>): void;
    /** @since 1.6.5 */
    function cancelAllPings(): void;

    /**
     * @return a list of all loaded mods.
     * @since 1.8.4
     */
    function getLoadedMods(): JavaList<any>;

    /**
     * @param modId the mod modId
     * @return {@code true} if the mod with the given modId is loaded, {@code false} otherwise.
     * @since 1.8.4
     */
    function isModLoaded(modId: string): boolean;

    /**
     * @param modId the mod modId
     * @return the mod container for the given modId or {@code null} if the mod is not loaded.
     * @since 1.8.4
     */
    function getMod(modId: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.ModContainerHelper<any>;

    /**
     * Makes minecraft believe that the mouse is currently inside the window.  
     *  This will automatically set pause on lost focus to false.
     * @since 1.8.4
     */
    function grabMouse(): void;

    /**
     * @return {@code true} if the mod is loaded inside a development environment, {@code false} otherwise.
     * @since 1.8.4
     */
    function isDevEnv(): boolean;

    /**
     * @return the name of the mod loader.
     * @since 1.8.4
     */
    function getModLoader(): string;

    /**
     * @return a list of all loaded blocks as {@link BlockHelper BlockHelper} objects.
     * @since 1.8.4
     */
    function getRegisteredBlocks(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper>;

    /**
     * @return a list of all loaded items as {@link ItemHelper ItemHelper} objects.
     * @since 1.8.4
     */
    function getRegisteredItems(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper>;

    /**
     * Tries to peacefully close the game.
     * @since 1.8.4
     */
    function exitGamePeacefully(): void;

    /**
     * Will close the game forcefully.
     * @since 1.8.4
     */
    function exitGameForcefully(): void;

    /**
     * @param packet the packet to send
     * @see #createPacketByteBuffer()
     * @since 1.8.4
     */
    function sendPacket(packet: /* minecraft class */ any): void;

    /**
     * @param packet the packet to receive
     * @see #createPacketByteBuffer()
     * @since 1.8.4
     */
    function receivePacket(packet: /* minecraft class */ any): void;

}

/**
 * Functions for displaying stuff in 2 to 3 dimensions
 *
 * @since 1.0.5
 * @author Wagyourtail
 */
declare namespace Hud {

    /**
     * @see IScreen
     * @since 1.0.5
     * @param title
     * @param dirtBG boolean of whether to use a dirt background or not.
     * @return a new {@link IScreen IScreen} Object.
     */
    function createScreen(title: string, dirtBG: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.ScriptScreen;

    /**
     * Opens a {@link IScreen} Object.
     * @since 1.0.5
     * @see IScreen
     * @param s
     */
    function openScreen(s: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen): void;

    /**
     * @since 1.2.7
     * @see IScreen
     * @return the currently open Screen as an {@link IScreen IScreen}
     */
    function getOpenScreen(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;

    /**
     * @param width the width of the canvas
     * @param height the height of the canvas
     * @return a {@link CustomImage} that can be used as a texture for screen backgrounds, rendering
     *          images, etc.
     * @since 1.8.4
     */
    function createTexture(width: int, height: int, name: string): Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage;

    /**
     * @param path absolute path to an image file
     * @return a {@link CustomImage} that can be used as a texture for screen backgrounds, rendering
     *          images, etc.
     * @since 1.8.4
     */
    function createTexture(path: string, name: string): Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage;

    /**
     * @return an immutable Map of all registered custom textures.
     * @since 1.8.4
     */
    function getRegisteredTextures(): JavaMap<string, Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage>;

    /**
     * @return the current gui scale factor of minecraft.
     * @since 1.8.4
     */
    function getScaleFactor(): number;

    /**
     * @since 1.0.5, renamed from {@code getOpenScreen} in 1.2.7
     * @return The name of the currently open screen.
     */
    function getOpenScreenName(): ScreenName;

    /**
     * @since 1.1.2
     * @return a {@link java.lang.Boolean boolean} denoting if the currently open screen is a container.
     */
    function isContainer(): boolean;

    /**
     * @since 1.0.5
     * @see IDraw2D
     * @return
     */
    function createDraw2D(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;

    /**
     * @since 1.0.5
     *
     *  Registers an {@link IDraw2D IDraw2D} to be rendered.
     * @deprecated since 1.6.5, use {@link Draw2D#register()} instead.
     * @see IDraw2D
     * @param overlay
     */
    function registerDraw2D(overlay: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D>): void;

    /**
     * @since 1.0.5
     *
     *  Unregisters an {@link IDraw2D IDraw2D} to stop it being rendered.
     * @deprecated since 1.6.5, use {@link Draw2D#unregister()} instead.
     * @see IDraw2D
     * @param overlay
     */
    function unregisterDraw2D(overlay: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D>): void;

    /**
     * @since 1.0.5
     * @see IDraw2D
     * @return A list of current {@link IDraw2D IDraw2Ds}.
     */
    function listDraw2Ds(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D>>;

    /**
     * @since 1.0.5
     *
     *  clears the Draw2D render list.
     * @see IDraw2D
     */
    function clearDraw2Ds(): void;

    /**
     * @since 1.0.6
     * @see Draw3D
     * @return a new {@link Draw3D Draw3D}.
     */
    function createDraw3D(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D;

    /**
     * @since 1.0.6
     *
     *  Registers an {@link Draw3D Draw3D} to be rendered.
     * @deprecated since 1.6.5 use {@link Draw3D#register()} instead.
     * @see Draw3D
     * @param draw
     */
    function registerDraw3D(draw: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): void;

    /**
     * @since 1.0.6
     *
     *  Unregisters an {@link Draw3D Draw3D} to stop it being rendered.
     * @since 1.6.5 use {@link Draw3D#unregister()} instead.
     * @see Draw3D
     * @param draw
     * @deprecated
     */
    function unregisterDraw3D(draw: Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): void;

    /**
     * @since 1.0.6
     * @see Draw3D
     * @return A list of current {@link Draw3D Draw3D}.
     */
    function listDraw3Ds(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D>;

    /**
     * @since 1.0.6
     *
     *  clears the Draw2D render list.
     * @see Draw3D
     */
    function clearDraw3Ds(): void;

    /**
     * @since 1.1.3
     * @return the current X coordinate of the mouse
     */
    function getMouseX(): number;

    /**
     * @since 1.1.3
     * @return the current Y coordinate of the mouse
     */
    function getMouseY(): number;

    /**
     * @return the current window width.
     * @since 1.8.4
     */
    function getWindowWidth(): number;

    /**
     * @return the current window height.
     * @since 1.8.4
     */
    function getWindowHeight(): number;

}

/**
 * @author Etheradon
 * @since 1.8.4
 */
declare namespace JavaUtils {

    /**
     * Creates a java {@link ArrayList}.
     * @return a java ArrayList.
     * @since 1.8.4
     */
    function createArrayList(): Packages.java.util.ArrayList<any>;

    /**
     * Creates a java {@link ArrayList}.
     * @param array the array to add to the list
     * @param <T> the type of the array
     * @return a java ArrayList from the given array.
     * @since 1.8.4
     */
    function createArrayList<T>(array: T[]): Packages.java.util.ArrayList<T>;

    /**
     * Creates a java {@link HashMap}.
     * @return a java HashMap.
     * @since 1.8.4
     */
    function createHashMap(): Packages.java.util.HashMap<any, any>;

    /**
     * Creates a java {@link HashSet}.
     * @return a java HashSet.
     * @since 1.8.4
     */
    function createHashSet(): Packages.java.util.HashSet<any>;

    /**
     * Returns a {@link SplittableRandom}.
     * @return a SplittableRandom.
     * @since 1.8.4
     */
    function getRandom(): Packages.java.util.SplittableRandom;

    /**
     * Returns {@link SplittableRandom}, initialized with the seed to get identical sequences of
     *  values at all times.
     * @param seed the seed
     * @return a SplittableRandom.
     * @since 1.8.4
     */
    function getRandom(seed: long): Packages.java.util.SplittableRandom;

    /**
     * @param raw the object to wrap
     * @return the correct instance of {@link BaseHelper} for the given object if it exists and
     *          {@code null} otherwise.
     * @since 1.8.4
     */
    function getHelperFromRaw(raw: any): Packages.xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<any>;

    /**
     * @param array the array to convert
     * @return the String representation of the given array.
     * @since 1.8.4
     */
    function arrayToString(array: any[]): string;

    /**
     * This method will convert any objects hold in the array data to Strings and should be used for
     *  multidimensional arrays.
     * @param array the array to convert
     * @return the String representation of the given array.
     * @since 1.8.4
     */
    function arrayDeepToString(array: any[]): string;

}

/**
 * Functions for getting and modifying key pressed states.  
 *
 * @author Wagyourtail
 */
declare namespace KeyBind {

    /**
     * Dont use this one... get the raw minecraft keycode class.
     * @param keyName
     * @return the raw minecraft keycode class
     */
    function getKeyCode(keyName: Key): /* minecraft class */ any;

    /**
     * @since 1.2.2
     * @return A {@link java.util.Map Map} of all the minecraft keybinds.
     */
    function getKeyBindings(): JavaMap<Bind, Key>;

    /**
     * Sets a minecraft keybind to the specified key.
     * @since 1.2.2
     * @param bind
     * @param key
     */
    function setKeyBind(bind: Bind, key: Key): void;

    /**
     * Set a key-state for a key.
     * @param keyName
     * @param keyState
     */
    function key(keyName: Key, keyState: boolean): void;

    /**
     * Calls {@link #key} with keyState set to true.
     * @param keyName the name of the key to press
     * @since 1.8.4
     */
    function pressKey(keyName: Key): void;

    /**
     * Calls {@link #key} with keyState set to false.
     * @param keyName the name of the key to release
     * @since 1.8.4
     */
    function releaseKey(keyName: Key): void;

    /**
     * Set a key-state using the name of the keybind rather than the name of the key.  
     *
     *  This is probably the one you should use.
     * @since 1.2.2
     * @param keyBind
     * @param keyState
     */
    function keyBind(keyBind: Bind, keyState: boolean): void;

    /**
     * Calls {@link #keyBind} with keyState set to true.
     * @param keyBind the name of the keybinding to press
     * @since 1.8.4
     */
    function pressKeyBind(keyBind: Bind): void;

    /**
     * Calls {@link #keyBind} with keyState set to false.
     * @param keyBind the name of the keybinding to release
     * @since 1.8.4
     */
    function releaseKeyBind(keyBind: Bind): void;

    /**
     * @since 1.2.6 (turned into set instead of list in 1.6.5)
     * @return a set of currently pressed keys.
     */
    function getPressedKeys(): JavaSet<Key>;

}

/**
 * Functions for getting and modifying the player's state.  
 *
 * @author Wagyourtail
 */
declare namespace Player {

    /**
     * @return the Inventory handler
     * @see Inventory
     */
    function openInventory(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<any>;

    /**
     * @return the player entity wrapper.
     * @see ClientPlayerEntityHelper
     * @since 1.0.3
     */
    function getPlayer(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ClientPlayerEntityHelper</* minecraft class */ any>;

    /**
     * @return the player's current gamemode.
     * @since 1.0.9
     */
    function getGameMode(): Gamemode;

    /**
     * @param gameMode possible values are survival, creative, adventure, spectator (case insensitive)
     * @since 1.8.4
     */
    function setGameMode(gameMode: Gamemode): void;

    /**
     * @param distance
     * @param fluid
     * @return the block/liquid the player is currently looking at.
     * @see BlockDataHelper
     * @since 1.0.5
     */
    function rayTraceBlock(distance: double, fluid: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;

    /**
     * @return the entity the camera is currently looking at.
     * @see EntityHelper
     * @since 1.0.5
     */
    function rayTraceEntity(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

    /**
     * @param distance
     * @since 1.8.3
     * @return entity the player entity is currently looking at (if any).
     */
    function rayTraceEntity(distance: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

    /**
     * Write to a sign screen if a sign screen is currently open.
     * @param l1
     * @param l2
     * @param l3
     * @param l4
     * @return of success.
     * @since 1.2.2
     */
    function writeSign(l1: string, l2: string, l3: string, l4: string): boolean;

    /**
     * @param folder
     * @param callback calls your method as a {@link Consumer}<{@link TextHelper}>
     * @see #takeScreenshot(String, String, MethodWrapper)
     * @since 1.2.6
     */
    function takeScreenshot(folder: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any, any, any>): void;

    /**
     * Take a screenshot and save to a file.  
     *
     *  `file` is the optional one, typescript doesn't like it not being the last one that's optional
     * @param folder
     * @param file
     * @param callback calls your method as a {@link Consumer}<{@link TextHelper}>
     * @since 1.2.6
     */
    function takeScreenshot(folder: string, file: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any, any, any>): void;

    /**
     * @param folder the folder to save the screenshot to, relative to the macro folder
     * @param width the width of the panorama
     * @param height the height of the panorama
     * @param callback calls your method as a {@link Consumer}<{@link TextHelper}>
     * @since 1.8.4
     */
    function takePanorama(folder: string, width: int, height: int, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any, any, any>): void;
    function getStatistics(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatsHelper;

    /**
     * @return the current reach distance of the player.
     * @since 1.8.4
     */
    function getReach(): number;

    /**
     * Creates a new PlayerInput object.
     * @see xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new PlayerInput object.
     * @see xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(movementForward: double, movementSideways: double, yaw: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new PlayerInput object.
     * @see xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(movementForward: double, yaw: double, jumping: boolean, sprinting: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new PlayerInput object.
     * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
     * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
     * @param yaw yaw of the player
     * @param pitch pitch of the player
     * @param jumping jump input
     * @param sneaking sneak input
     * @param sprinting sprint input
     * @see xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput
     * @since 1.4.0
     */
    function createPlayerInput(movementForward: double, movementSideways: double, yaw: double, pitch: double, jumping: boolean, sneaking: boolean, sprinting: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Parses each row of CSV string into a `PlayerInput`.  
     *  The capitalization of the header matters.<br>  
     *  About the columns:  
     *  <ul>  
     *    <li> `movementForward` and `movementSideways` as a number</li>  
     *    <li>`yaw` and `pitch` as an absolute number</li>  
     *    <li>`jumping`, `sneaking` and `sprinting` have to be boolean</li>  
     *  </ul>  
     *
     *  The separation must be a "," it's a csv...(but spaces don't matter)<br>  
     *  Quoted values don't work
     * @param csv CSV string to be parsed
     * @see PlayerInput#PlayerInput(float, float, float, float, boolean, boolean, boolean)
     * @since 1.4.0
     */
    function createPlayerInputsFromCsv(csv: string): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput>;

    /**
     * Parses a JSON string into a `PlayerInput` Object.  
     *  For details see `PlayerInput.fromCsv()`, on what has to be present.<br>  
     *  Capitalization of the keys matters.
     * @param json JSON string to be parsed
     * @return The JSON parsed into a {@code PlayerInput}
     * @see #createPlayerInputsFromCsv(String)
     * @since 1.4.0
     */
    function createPlayerInputsFromJson(json: string): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Creates a new `PlayerInput` object with the current inputs of the player.
     * @see xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput
     * @since 1.4.0
     */
    function getCurrentPlayerInput(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;

    /**
     * Adds a new `PlayerInput` to `MovementQueue` to be executed
     * @param input the PlayerInput to be executed
     * @see xyz.wagyourtail.jsmacros.client.movement.MovementQueue
     * @since 1.4.0
     */
    function addInput(input: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput): void;

    /**
     * Adds multiple new `PlayerInput` to `MovementQueue` to be executed
     * @param inputs the PlayerInputs to be executed
     * @see xyz.wagyourtail.jsmacros.client.movement.MovementQueue
     * @since 1.4.0
     */
    function addInputs(inputs: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput[]): void;

    /**
     * Clears all inputs in the `MovementQueue`
     * @see xyz.wagyourtail.jsmacros.client.movement.MovementQueue
     * @since 1.4.0
     */
    function clearInputs(): void;
    function setDrawPredictions(val: boolean): void;

    /**
     * Predicts where one tick with a `PlayerInput` as input would lead to.
     * @param input the PlayerInput for the prediction
     * @return the position after the input
     * @see #predictInput(PlayerInput, boolean)
     * @since 1.4.0
     */
    function predictInput(input: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

    /**
     * Predicts where one tick with a `PlayerInput` as input would lead to.
     * @param input the PlayerInput for the prediction
     * @param draw whether to visualize the result or not
     * @return the position after the input
     * @since 1.4.0
     */
    function predictInput(input: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput, draw: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

    /**
     * Predicts where each `PlayerInput` executed in a row would lead
     *  without drawing it.
     * @param inputs the PlayerInputs for each tick for the prediction
     * @return the position after each input
     * @see #predictInputs(PlayerInput[], boolean)
     * @since 1.4.0
     */
    function predictInputs(inputs: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput[]): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.8.0
     * @return
     */
    function isBreakingBlock(): boolean;

    /**
     * Predicts where each `PlayerInput` executed in a row would lead
     * @param inputs the PlayerInputs for each tick for the prediction
     * @param draw whether to visualize the result or not
     * @return the position after each input
     * @since 1.4.0
     */
    function predictInputs(inputs: Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput[], draw: boolean): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * Adds a forward movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.0
     */
    function moveForward(yaw: double): void;

    /**
     * Adds a backward movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.0
     */
    function moveBackward(yaw: double): void;

    /**
     * Adds sideways movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.2
     */
    function moveStrafeLeft(yaw: double): void;

    /**
     * Adds sideways movement with a relative yaw value to the MovementQueue.
     * @param yaw the relative yaw for the player
     * @since 1.4.2
     */
    function moveStrafeRight(yaw: double): void;

}

/**
 * position helper classes
 * @since 1.6.3
 */
declare namespace PositionCommon {

    /**
     * create a new vector object
     * @since 1.6.3
     * @param x1
     * @param y1
     * @param z1
     * @param x2
     * @param y2
     * @param z2
     * @return
     */
    function createVec(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;

    /**
     * @since 1.8.4
     * @param entity
     * @return
     */
    function createLookingVector(entity: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;

    /**
     * @since 1.8.4
     * @param yaw
     * @param pitch
     * @return
     */
    function createLookingVector(yaw: double, pitch: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;

    /**
     * @since 1.6.3
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @return
     */
    function createVec(x1: double, y1: double, x2: double, y2: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec2D;

    /**
     * @since 1.6.3
     * @param x
     * @param y
     * @param z
     * @return
     */
    function createPos(x: double, y: double, z: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

    /**
     * @since 1.6.3
     * @param x
     * @param y
     * @return
     */
    function createPos(x: double, y: double): Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

    /**
     * @param x the x position of the block
     * @param y the y position of the block
     * @param z the z position of the block
     * @return a {@link BlockPosHelper} for the given coordinates.
     * @since 1.8.4
     */
    function createBlockPos(x: int, y: int, z: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

}

/**
 * @author Etheradon
 * @since 1.8.4
 */
declare namespace Utils {

    /**
     * @param url the url to open
     * @since 1.8.4
     */
    function openUrl(url: string): void;

    /**
     * @param path the path top open, relative the config folder
     * @since 1.8.4
     */
    function openFile(path: string): void;

    /**
     * Copies the text to the clipboard.
     * @param text the text to copy
     * @since 1.8.4
     */
    function copyToClipboard(text: string): void;

    /**
     * @return the text from the clipboard.
     * @since 1.8.4
     */
    function getClipboard(): string;

    /**
     * Tries to guess the name of the sender of a given message. This is not guaranteed to work and
     *  for specific servers it may be better to use regex instead.
     * @param text the text to check
     * @return the name of the sender or {@code null} if it couldn't be guessed.
     * @since 1.8.4
     */
    function guessName(text: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): string;

    /**
     * Tries to guess the name of the sender of a given message. This is not guaranteed to work and
     *  for specific servers it may be better to use regex instead.
     * @param text the text to check
     * @return the name of the sender or {@code null} if it couldn't be guessed.
     * @since 1.8.4
     */
    function guessName(text: string): string;

    /**
     * Tries to guess the name, as well as the titles and roles of the sender of the given message.  
     *  This is not guaranteed to work and for specific servers it may be better to use regex
     *  instead.
     * @param text the text to check
     * @return a list of names, titles and roles of the sender or an empty list if it couldn't be
     *          guessed.
     * @since 1.8.4
     */
    function guessNameAndRoles(text: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): JavaList<string>;

    /**
     * Tries to guess the name, as well as the titles and roles of the sender of the given message.  
     *  This is not guaranteed to work and for specific servers it may be better to use regex
     *  instead.
     * @param text the text to check
     * @return a list of names, titles and roles of the sender or an empty list if it couldn't be
     *          guessed.
     * @since 1.8.4
     */
    function guessNameAndRoles(text: string): JavaList<string>;

    /**
     * Hashes the given string with sha-256.
     * @param message the message to hash
     * @return the hashed message.
     * @since 1.8.4
     */
    function hashString(message: string): string;

    /**
     * Hashes the given string with sha-256 the selected algorithm.
     * @param message the message to hash
     * @param algorithm sha1 | sha256 | sha384 | sha512 | md2 | md5
     * @return the hashed message.
     * @since 1.8.4
     */
    function hashString(message: string, algorithm: string): string;

    /**
     * Encodes the given string with Base64.
     * @param message the message to encode
     * @return the encoded message.
     * @since 1.8.4
     */
    function encode(message: string): string;

    /**
     * Decodes the given string with Base64.
     * @param message the message to decode
     * @return the decoded message.
     * @since 1.8.4
     */
    function decode(message: string): string;

}

/**
 * Functions for getting and using world data.  
 *
 * @author Wagyourtail
 */
declare namespace World {

    /**
     * returns whether a world is currently loaded
     * @since 1.3.0
     * @return
     */
    function isWorldLoaded(): boolean;

    /**
     * @return players within render distance.
     */
    function getLoadedPlayers(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* minecraft class */ any>>;

    /**
     * @return players on the tablist.
     */
    function getPlayers(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper>;

    /**
     * @param name the name of the player to get the entry for
     * @return player entry for the given player's name or {@code null} if not found.
     * @since 1.8.4
     */
    function getPlayerEntry(name: string): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;

    /**
     * @param x
     * @param y
     * @param z
     * @return The block at that position.
     */
    function getBlock(x: int, y: int, z: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
    function getBlock(pos: Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
    function getBlock(pos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;

    /**
     * The x and z position of the chunk can be calculated by the following formula:  
     *  xChunk = x >> 4; zChunk = z >> 4;
     * @param x the x coordinate of the chunk, not the absolute position
     * @param z the z coordinate of the chunk, not the absolute position
     * @return ChunkHelper for the chunk coordinates {@link ChunkHelper}.
     * @since 1.8.4
     */
    function getChunk(x: int, z: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;

    /**
     * Usage: <br>  
     *  This will return all blocks that are facing south, don't require a tool to break,  
     *  have a hardness of 10 or less and whose name contains either chest or barrel.  
     *  ```  
     *  World.getWorldScanner()
     *      .withBlockFilter("getHardness").is("<=", 10)
     *      .andStringBlockFilter().contains("chest", "barrel")
     *      .withStringStateFilter().contains("facing=south")
     *      .andStateFilter("isToolRequired").is(false)
     *      .build()
     *  ```
     * @return a builder to create a WorldScanner.
     * @since 1.6.5
     */
    function getWorldScanner(): Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScannerBuilder;

    /**
     * @return a scanner for the current world.
     * @since 1.6.5
     */
    function getWorldScanner(blockFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean, any>, stateFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean, any>): Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScanner;

    /**
     * @since 1.6.4
     * @param id
     * @param chunkrange
     * @return
     */
    function findBlocksMatching(centerX: int, centerZ: int, id: BlockId, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.6.4
     * @param id
     * @param chunkrange
     * @return
     */
    function findBlocksMatching(id: BlockId, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.6.4
     * @param ids
     * @param chunkrange
     * @return
     */
    function findBlocksMatching(ids: BlockId[], chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.6.4
     * @param centerX
     * @param centerZ
     * @param ids
     * @param chunkrange
     * @return
     */
    function findBlocksMatching(centerX: int, centerZ: int, ids: BlockId[], chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.6.4
     * @param blockFilter
     * @param stateFilter
     * @param chunkrange
     * @return
     */
    function findBlocksMatching(blockFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean, any>, stateFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean, any>, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * @since 1.6.4
     * @param chunkX
     * @param chunkZ
     * @param blockFilter
     * @param stateFilter
     * @param chunkrange
     * @return
     */
    function findBlocksMatching(chunkX: int, chunkZ: int, blockFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, any, boolean, any>, stateFilter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, any, boolean, any>, chunkrange: int): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

    /**
     * By default, air blocks are ignored and the callback is only called for real blocks.
     * @param pos the center position
     * @param radius the radius to scan
     * @param callback the callback to call for each block
     * @since 1.8.4
     */
    function iterateSphere(pos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, radius: int, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @param pos the center position
     * @param radius the radius to scan
     * @param ignoreAir whether to ignore air blocks
     * @param callback the callback to call for each block
     * @since 1.8.4
     */
    function iterateSphere(pos: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, radius: int, ignoreAir: boolean, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @param pos1 the first position
     * @param pos2 the second position
     * @param callback the callback to call for each block
     * @since 1.8.4
     */
    function iterateBox(pos1: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @param pos1 the first position
     * @param pos2 the second position
     * @param callback the callback to call for each block
     * @param ignoreAir whether to ignore air blocks
     * @since 1.8.4
     */
    function iterateBox(pos1: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, ignoreAir: boolean, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper, any, any, any>): void;

    /**
     * @since 1.2.9
     * @return a helper for the scoreboards provided to the client.
     */
    function getScoreboards(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ScoreboardsHelper;

    /**
     * @return all entities in the render distance.
     */
    function getEntities(): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * @param types the entity types to consider
     * @return all entities in the render distance, that match the specified entity type.
     * @since 1.8.4
     */
    function getEntities(...types: EntityId[]): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * @param distance the maximum distance to search for entities
     * @return a list of entities within the specified distance to the player.
     * @since 1.8.4
     */
    function getEntities(distance: double): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * @param distance the maximum distance to search for entities
     * @param types the entity types to consider
     * @return a list of entities within the specified distance to the player, that match the specified entity type.
     * @since 1.8.4
     */
    function getEntities(distance: double, ...types: EntityId[]): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * @param filter the entity filter
     * @return a list of entities that match the specified filter.
     * @since 1.8.4
     */
    function getEntities(filter: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>, any, any, any>): JavaList<Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>>;

    /**
     * raytrace between two points returning the first block hit.
     * @since 1.6.5
     * @param x1
     * @param y1
     * @param z1
     * @param x2
     * @param y2
     * @param z2
     * @param fluid
     * @return
     */
    function rayTraceBlock(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int, fluid: boolean): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;

    /**
     * raytrace between two points returning the first entity hit.
     * @since 1.8.3
     * @param x1
     * @param y1
     * @param z1
     * @param x2
     * @param y2
     * @param z2
     * @return
     */
    function rayTraceEntity(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

    /**
     * @since 1.1.2
     * @return the current dimension.
     */
    function getDimension(): string;

    /**
     * @since 1.1.5
     * @return the current biome.
     */
    function getBiome(): string;

    /**
     * @since 1.1.5
     * @return the current world time.
     */
    function getTime(): number;

    /**
     * This is supposed to be time of day, but it appears to be the same as {@link FWorld#getTime} to me...
     * @since 1.1.5
     * @return the current world time of day.
     */
    function getTimeOfDay(): number;

    /**
     * @return {@code true} if it is daytime, {@code false} otherwise.
     * @since 1.8.4
     */
    function isDay(): boolean;

    /**
     * @return {@code true} if it is nighttime, {@code false} otherwise.
     * @since 1.8.4
     */
    function isNight(): boolean;

    /**
     * @return {@code true} if it is raining, {@code false} otherwise.
     * @since 1.8.4
     */
    function isRaining(): boolean;

    /**
     * @return {@code true} if it is thundering, {@code false} otherwise.
     * @since 1.8.4
     */
    function isThundering(): boolean;

    /**
     * @return an identifier for the loaded world that is based on the world's name or server ip and
     *          thus most likely unique enough to identify a specific world, or
     *          {@code "UNKNOWN_NAME"} if no world was found.
     * @since 1.8.4
     */
    function getWorldIdentifier(): string;

    /**
     * @since 1.2.6
     * @return respawn position.
     */
    function getRespawnPos(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

    /**
     * @since 1.2.6
     * @return world difficulty as an {@link java.lang.Integer Integer}.
     */
    function getDifficulty(): number;

    /**
     * @since 1.2.6
     * @return moon phase as an {@link java.lang.Integer Integer}.
     */
    function getMoonPhase(): number;

    /**
     * @since 1.1.2
     * @param x
     * @param y
     * @param z
     * @return sky light as an {@link java.lang.Integer Integer}.
     */
    function getSkyLight(x: int, y: int, z: int): number;

    /**
     * @since 1.1.2
     * @param x
     * @param y
     * @param z
     * @return block light as an {@link java.lang.Integer Integer}.
     */
    function getBlockLight(x: int, y: int, z: int): number;

    /**
     * plays a sound file using javax's sound stuff.
     * @since 1.1.7
     * @param file
     * @param volume
     * @return 
     * @throws LineUnavailableException
     * @throws IOException
     * @throws UnsupportedAudioFileException
     */
    function playSoundFile(file: string, volume: double): Packages.javax.sound.sampled.Clip;

    /**
     * @since 1.1.7
     * @see FWorld#playSound(String, double, double, double, double, double)
     * @param id
     */
    function playSound(id: string): void;

    /**
     * @since 1.1.7
     * @see FWorld#playSound(String, double, double, double, double, double)
     * @param id
     * @param volume
     */
    function playSound(id: string, volume: double): void;

    /**
     * @since 1.1.7
     * @see FWorld#playSound(String, double, double, double, double, double)
     * @param id
     * @param volume
     * @param pitch
     */
    function playSound(id: string, volume: double, pitch: double): void;

    /**
     * plays a minecraft sound using the internal system.
     * @since 1.1.7
     * @param id
     * @param volume
     * @param pitch
     * @param x
     * @param y
     * @param z
     */
    function playSound(id: string, volume: double, pitch: double, x: double, y: double, z: double): void;

    /**
     * @since 1.2.1
     * @return a map of boss bars by the boss bar's UUID.
     */
    function getBossBars(): JavaMap<string, Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.BossBarHelper>;

    /**
     * Check whether a chunk is within the render distance and loaded.
     * @since 1.2.2
     * @param chunkX
     * @param chunkZ
     * @return
     */
    function isChunkLoaded(chunkX: int, chunkZ: int): boolean;

    /**
     * @since 1.2.2
     * @return the current server address as a string ({@code server.address/server.ip:port}).
     */
    function getCurrentServerAddress(): string;

    /**
     * @since 1.2.2 [Citation Needed]
     * @param x
     * @param z
     * @return biome at specified location, only works if the block/chunk is loaded.
     */
    function getBiomeAt(x: int, z: int): string;

    /**
     * @since 1.8.4
     * @param x
     * @param y
     * @param z
     * @return biome at specified location, only works if the block/chunk is loaded.
     */
    function getBiomeAt(x: int, y: int, z: int): string;

    /**
     * @since 1.2.7
     * @return best attempt to measure and give the server tps with various timings.
     */
    function getServerTPS(): string;

    /**
     * @since 1.3.1
     * @return text helper for the top part of the tab list (above the players)
     */
    function getTabListHeader(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

    /**
     * @since 1.3.1
     * @return text helper for the bottom part of the tab list (below the players)
     */
    function getTabListFooter(): Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

    /**
     * Summons the amount of particles at the desired position.
     * @param id the particle id
     * @param x the x position to spawn the particle
     * @param y the y position to spawn the particle
     * @param z the z position to spawn the particle
     * @param count the amount of particles to spawn
     * @since 1.8.4
     */
    function spawnParticle(id: ParticleId, x: double, y: double, z: double, count: int): void;

    /**
     * Summons the amount of particles at the desired position with some variation of delta and the
     *  given speed.
     * @param id the particle id
     * @param x the x position to spawn the particle
     * @param y the y position to spawn the particle
     * @param z the z position to spawn the particle
     * @param deltaX the x variation of the particle
     * @param deltaY the y variation of the particle
     * @param deltaZ the z variation of the particle
     * @param speed the speed of the particle
     * @param count the amount of particles to spawn
     * @param force whether to show the particle if it's more than 32 blocks away
     * @since 1.8.4
     */
    function spawnParticle(id: ParticleId, x: double, y: double, z: double, deltaX: double, deltaY: double, deltaZ: double, speed: double, count: int, force: boolean): void;

    /**
     * @since 1.2.7
     * @return best attempt to measure and give the server tps.
     */
    function getServerInstantTPS(): number;

    /**
     * @since 1.2.7
     * @return best attempt to measure and give the server tps over the previous 1 minute average.
     */
    function getServer1MAverageTPS(): number;

    /**
     * @since 1.2.7
     * @return best attempt to measure and give the server tps over the previous 5 minute average.
     */
    function getServer5MAverageTPS(): number;

    /**
     * @since 1.2.7
     * @return best attempt to measure and give the server tps over the previous 15 minute average.
     */
    function getServer15MAverageTPS(): number;

}

/**
 * {@link FunctionalInterface} implementation for wrapping methods to match the language spec.  
 *  <br><br>    
 *  <br><br>  
 *  Javascript:  
 *  language spec requires that only one thread can hold an instance of the language at a time,  
 *  so this implementation uses a non-preemptive priority queue for the threads that call the resulting {@link MethodWrapper}.  
 *  <br><br>  
 *  JEP:  
 *  language spec requires everything to be on the same thread, on the java end, so all calls to {@link MethodWrapper}
 *  call back to JEP's starting thread and wait for the call to complete.  
 *  <br><br>  
 *  Jython:  
 *  no limitations
 *  <br><br>  
 *  LUA:  
 *  no limitations
 * @since 1.2.5, re-named from {@code consumer} in 1.3.2
 * @author Wagyourtail
 */
declare namespace JavaWrapper {

    /**
     * @since 1.4.0
     * @param c
     * @return a new {@link MethodWrapper MethodWrapper}
     */
    function methodToJava<A, B, R>(c: (arg0: A, arg1: B) => R | void): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<A, B, R, any>;

    /**
     * @since 1.4.0
     * @param c
     * @return a new {@link MethodWrapper MethodWrapper}
     */
    function methodToJavaAsync<A, B, R>(c: (arg0: A, arg1: B) => R | void): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<A, B, R, any>;

    /**
     * JS/JEP only, allows you to set the position of the thread in the queue. you can use this for return value one's too...
     * @since 1.8.0
     * @param priority
     * @param c
     * @return 
     */
    function methodToJavaAsync<A, B, R>(priority: int, c: (arg0: A, arg1: B) => R | void): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<A, B, R, any>;

    /**
     * JS/JEP only, puts current task at end of queue.  
     *  use with caution, don't accidentally cause circular waiting.
     * @throws InterruptedException
     * @since 1.4.0 [citation needed]
     */
    function deferCurrentTask(): void;

    /**
     * JS/JEP only, puts current task at end of queue.  
     *  use with caution, don't accidentally cause circular waiting.
     * @since 1.8.0
     * @throws InterruptedException
     * @param priorityAdjust the amount to adjust the priority by
     */
    function deferCurrentTask(priorityAdjust: int): void;

    /**
     * JS/JEP only, get priority of current task.
     * @throws InterruptedException
     * @since 1.8.0
     */
    function getCurrentPriority(): number;

    /**
     * Close the current context
     * @since 1.2.2
     */
    function stop(): void;

}

/**
 * Better File-System functions.  
 *
 * @since 1.1.8
 * @author Wagyourtail
 */
declare namespace FS {

    /**
     * List files in path.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @return An array of file names as {@link java.lang.String Strings}.
     */
    function list(path: string): JavaArray<string>;

    /**
     * Check if a file exists.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @return
     */
    function exists(path: string): boolean;

    /**
     * Check if a file is a directory.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @return
     */
    function isDir(path: string): boolean;

    /**
     * @param path the path relative to the script's folder
     * @return {@code true} if the path leads to a file, {@code false} otherwise.
     * @since 1.8.4
     */
    function isFile(path: string): boolean;

    /**
     * Get the last part (name) of a file.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @return a {@link java.lang.String String} of the file name.
     */
    function getName(path: string): string;

    /**
     * @param absolutePath the absolute path to the file
     * @return a path relative to the script's folder to the given absolute path.
     * @since 1.8.4
     */
    function toRelativePath(absolutePath: string): string;

    /**
     * Creates a new file in the specified path, relative to the script's folder. This will only
     *  work if the parent directory already exists. See {@link #createFile}
     *  to automatically create all parent directories.
     * @param path the path relative to the script's folder
     * @param name the name of the file
     * @return {@code true} if the file was created successfully, {@code false} otherwise.
     * @throws IOException if there occurs an error while creating the file.
     * @since 1.8.4
     */
    function createFile(path: string, name: string): boolean;

    /**
     * Creates a new file in the specified path, relative to the script's folder. Optionally parent
     *  directories can be created if they do not exist.
     * @param path the path relative to the script's folder
     * @param name the name of the file
     * @param createDirs whether to create parent directories if they do not exist or not
     * @return {@code true} if the file was created successfully, {@code false} otherwise.
     * @throws IOException if there occurs an error while creating the file.
     * @since 1.8.4
     */
    function createFile(path: string, name: string, createDirs: boolean): boolean;

    /**
     * Make a directory.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @return a {@link java.lang.Boolean boolean} for success.
     */
    function makeDir(path: string): boolean;

    /**
     * Move a file.
     * @since 1.1.8
     * @param from relative to the script's folder.
     * @param to relative to the script's folder.
     * @throws IOException
     */
    function move(from: string, to: string): void;

    /**
     * Copy a file.
     * @since 1.1.8
     * @param from relative to the script's folder.
     * @param to relative to the script's folder.
     * @throws IOException
     */
    function copy(from: string, to: string): void;

    /**
     * Delete a file.
     * @since 1.2.9
     * @param path relative to the script's folder.
     * @return a {@link java.lang.Boolean boolean} for success.
     */
    function unlink(path: string): boolean;

    /**
     * Combine 2 paths.
     * @since 1.1.8
     * @param patha path is relative to the script's folder.
     * @param pathb
     * @return a {@link java.lang.String String} of the combined path.
     * @throws IOException
     */
    function combine(patha: string, pathb: string): string;

    /**
     * Gets the directory part of a file path, or the parent directory of a folder.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @return a {@link java.lang.String String} of the combined path.
     * @throws IOException
     */
    function getDir(path: string): string;

    /**
     * Open a FileHandler for the file at the specified path.
     * @since 1.1.8
     * @see FileHandler
     * @param path relative to the script's folder.
     * @return a {@link FileHandler FileHandler} for the file path.
     */
    function open(path: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler;

    /**
     * Open a FileHandler for the file at the specified path.
     * @since 1.8.4
     * @see FileHandler
     * @param path relative to the script's folder.
     * @param charset the charset to use for reading/writing the file (default is UTF-8)
     * @return a {@link FileHandler FileHandler} for the file path.
     */
    function open(path: string, charset: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler;

    /**
     * An advanced method to walk a directory tree and get some information about the files, as well
     *  as their paths.
     * @param path the relative path of the directory to walk through
     * @param maxDepth the maximum depth to follow, can cause stack overflow if too high
     * @param followLinks whether to follow symbolic links
     * @param visitor the visitor that is called for each file with the path of the file and its
     *                     attributes
     * @throws IOException
     * @since 1.8.4
     */
    function walkFiles(path: string, maxDepth: int, followLinks: boolean, visitor: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<string, Packages.java.nio.file.attribute.BasicFileAttributes, any, any>): void;

    /**
     * @param path the relative path to get the file object for
     * @return the file object for the specified path.
     * @since 1.8.4
     */
    function toRawFile(path: string): Packages.java.io.File;

    /**
     * @param path the relative path to get the path object for
     * @return the path object for the specified path.
     * @since 1.8.4
     */
    function toRawPath(path: string): Packages.java.nio.file.Path;

    /**
     * @param path the path relative to the script's folder
     * @return the attributes of the file at the specified path.
     * @throws IOException
     * @since 1.8.4
     */
    function getRawAttributes(path: string): Packages.java.nio.file.attribute.BasicFileAttributes;

}

/**
 * "Global" variables for passing to other contexts.  
 *
 * @author Wagyourtail
 * @since 1.0.4
 */
declare namespace GlobalVars {

    /**
     * Put an Integer into the global variable space.
     * @param name
     * @param i
     * @return 
     * @since 1.0.4
     */
    function putInt(name: string, i: int): number;

    /**
     * put a String into the global variable space.
     * @param name
     * @param str
     * @return 
     * @since 1.0.4
     */
    function putString(name: string, str: string): string;

    /**
     * put a Double into the global variable space.
     * @param name
     * @param d
     * @return 
     * @since 1.0.8
     */
    function putDouble(name: string, d: double): number;

    /**
     * put a Boolean into the global variable space.
     * @param name
     * @param b
     * @return 
     * @since 1.1.7
     */
    function putBoolean(name: string, b: boolean): boolean;

    /**
     * put anything else into the global variable space.
     * @param name
     * @param o
     * @return 
     * @since 1.1.7
     */
    function putObject(name: string, o: any): any;

    /**
     * Returns the type of the defined item in the global variable space as a string.
     * @param name
     * @return 
     * @since 1.0.4
     */
    function getType(name: string): string;

    /**
     * Gets an Integer from the global variable space.
     * @param name
     * @return 
     * @since 1.0.4
     */
    function getInt(name: string): number;

    /**
     * Gets an Integer from the global variable space. and then increment it there.
     * @param name
     * @return 
     * @since 1.6.5
     */
    function getAndIncrementInt(name: string): number;

    /**
     * Gets an integer from the global variable pace. and then decrement it there.
     * @param name
     * @return 
     * @since 1.6.5
     */
    function getAndDecrementInt(name: string): number;

    /**
     * increment an Integer in the global variable space. then return it.
     * @param name
     * @return 
     * @since 1.6.5
     */
    function incrementAndGetInt(name: string): number;

    /**
     * decrement an Integer in the global variable space. then return it.
     * @param name
     * @return 
     * @since 1.6.5
     */
    function decrementAndGetInt(name: string): number;

    /**
     * Gets a String from the global variable space
     * @param name
     * @return 
     * @since 1.0.4
     */
    function getString(name: string): string;

    /**
     * Gets a Double from the global variable space.
     * @param name
     * @return 
     * @since 1.0.8
     */
    function getDouble(name: string): number;

    /**
     * Gets a Boolean from the global variable space.
     * @param name
     * @return 
     * @since 1.1.7
     */
    function getBoolean(name: string): boolean;

    /**
     * toggles a global boolean and returns its new value
     * @param name
     * @return 
     * @since 1.6.5
     */
    function toggleBoolean(name: string): boolean;

    /**
     * Gets an Object from the global variable space.
     * @param name
     * @return 
     * @since 1.1.7
     */
    function getObject(name: string): any;

    /**
     * removes a key from the global variable space.
     * @param key
     * @since 1.2.0
     */
    function remove(key: string): void;
    function getRaw(): JavaMap<string, any>;

}

/**
 * Functions that interact directly with JsMacros or Events.  
 *
 * @author Wagyourtail
 */
declare namespace JsMacros {

    /**
     * @return the JsMacros profile class.
     */
    function getProfile(): Packages.xyz.wagyourtail.jsmacros.core.config.BaseProfile;

    /**
     * @return the JsMacros config management class.
     */
    function getConfig(): Packages.xyz.wagyourtail.jsmacros.core.config.ConfigManager;

    /**
     * services are background scripts designed to run full time and are mainly noticed by their side effects.
     * @since 1.6.3
     * @return for managing services.
     */
    function getServiceManager(): Packages.xyz.wagyourtail.jsmacros.core.service.ServiceManager;

    /**
     * @return list of non-garbage-collected ScriptContext's
     * @since 1.4.0
     */
    function getOpenContexts(): JavaList<Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>>;

    /**
     * @see FJsMacros#runScript(String, String, MethodWrapper)
     * @since 1.1.5
     * @param file
     */
    function runScript(file: string): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @since 1.6.3
     * @param file
     * @param fakeEvent you probably actually want to pass an instance created by {@link #createCustomEvent(String)}
     * @return
     */
    function runScript(file: string, fakeEvent: Events.BaseEvent): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * runs a script with a eventCustom to be able to pass args
     * @since 1.6.3 (1.1.5 - 1.6.3 didn't have fakeEvent)
     * @param file
     * @param fakeEvent
     * @param callback
     * @return container the script is running on.
     */
    function runScript(file: string, fakeEvent: Events.BaseEvent, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any>): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @see FJsMacros#runScript(String, String, MethodWrapper)
     * @since 1.2.4
     * @param language
     * @param script
     * @return
     */
    function runScript(language: string, script: string): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * Runs a string as a script.
     * @since 1.2.4
     * @param language
     * @param script
     * @param callback calls your method as a {@link java.util.function.Consumer Consumer}<{@link String}>
     * @return the {@link EventContainer} the script is running on.
     */
    function runScript(language: string, script: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any>): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @since 1.6.0
     * @param language
     * @param script
     * @param file
     * @param callback
     * @return
     */
    function runScript(language: string, script: string, file: string, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any>): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @since 1.7.0
     * @param language
     * @param script
     * @param file
     * @param event
     * @param callback
     * @return
     */
    function runScript(language: string, script: string, file: string, event: Events.BaseEvent, callback: Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<Packages.java.lang.Throwable, any, any, any> | null): Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

    /**
     * @since 1.7.0
     * @param file
     * @return 
     */
    function wrapScriptRun<T, U, R>(file: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * @since 1.7.0
     * @param language
     * @param script
     * @return 
     */
    function wrapScriptRun<T, U, R>(language: string, script: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * @since 1.7.0
     * @param language
     * @param script
     * @param file
     * @return 
     */
    function wrapScriptRun<T, U, R>(language: string, script: string, file: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * @since 1.7.0
     * @param file
     * @return 
     */
    function wrapScriptRunAsync<T, U, R>(file: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * @since 1.7.0
     * @param language
     * @param script
     * @return 
     */
    function wrapScriptRunAsync<T, U, R>(language: string, script: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * @since 1.7.0
     * @param language
     * @param script
     * @param file
     * @return 
     */
    function wrapScriptRunAsync<T, U, R>(language: string, script: string, file: string): Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, any>;

    /**
     * Opens a file with the default system program.
     * @since 1.1.8
     * @param path relative to the script's folder.
     * @deprecated use the Utils library instead.
     */
    function open(path: string): void;

    /**
     * @since 1.6.0
     * @param url
     * @throws MalformedURLException
     * @deprecated use the Utils library instead.
     */
    function openUrl(url: string): void;

    /**
     * Creates a listener for an event, this function can be more efficient that running a script file when used properly.
     * @see IEventListener
     * @since 1.2.7
     * @param event
     * @param callback calls your method as a {@link java.util.function.BiConsumer BiConsumer}<{@link BaseEvent}, {@link EventContainer}>
     * @return
     */
    function on<E extends keyof Events>(event: E, callback: MethodWrapper<Events[E], EventContainer>): Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;

    /**
     * Creates a single-run listener for an event, this function can be more efficient that running a script file when used properly.
     * @see IEventListener
     * @since 1.2.7
     * @param event
     * @param callback calls your method as a {@link java.util.function.BiConsumer BiConsumer}<{@link BaseEvent}, {@link EventContainer}>
     * @return the listener.
     */
    function once<E extends keyof Events>(event: E, callback: MethodWrapper<Events[E], EventContainer>): Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;

    /**
     * @see FJsMacros#off(String, IEventListener)
     * @since 1.2.3
     * @param listener
     * @return
     */
    function off(listener: Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener): boolean;

    /**
     * Removes a {@link IEventListener} from an event.
     * @see IEventListener
     * @since 1.2.3
     * @param event
     * @param listener
     * @return
     */
    function off<E extends keyof Events>(event: E, listener: IEventListener): boolean;

    /**
     * Will also disable all listeners for the given event, including JsMacros own event listeners.
     * @param event the event to remove all listeners from
     * @since 1.8.4
     */
    function disableAllListeners(event: keyof Events): void;

    /**
     * Will also disable all listeners, including JsMacros own event listeners.
     * @since 1.8.4
     */
    function disableAllListeners(): void;

    /**
     * Will only disable user created event listeners for the given event. This includes listeners
     *  created from {@link #on}, {@link #once},  
     *  {@link #waitForEvent}, {@link #waitForEvent} and
     *  {@link #waitForEvent}.
     * @param event the event to remove all listeners from
     * @since 1.8.4
     */
    function disableScriptListeners(event: keyof Events): void;

    /**
     * Will only disable user created event listeners.  This includes listeners created from
     *  {@link #on}, {@link #once},  
     *  {@link #waitForEvent}, {@link #waitForEvent} and
     *  {@link #waitForEvent}.
     * @since 1.8.4
     */
    function disableScriptListeners(): void;

    /**
     * @param event event to wait for
     * @since 1.5.0
     * @return a event and a new context if the event you're waiting for was joined, to leave it early.
     * @throws InterruptedException
     */
    function waitForEvent<E extends keyof Events>(event: E): FJsMacros$EventAndContext & { readonly event: Events[E] };

    /**
     * @param event
     * @param filter
     * @return 
     * @throws InterruptedException
     */
    function waitForEvent<E extends keyof Events>(event: E, filter: MethodWrapper<Events[E], undefined, boolean>): FJsMacros$EventAndContext & { readonly event: Events[E] };

    /**
     * waits for an event. if this thread is bound to an event already, this will release current lock.
     * @param event event to wait for
     * @param filter filter the event until it has the proper values or whatever.
     * @param runBeforeWaiting runs as a {@link Runnable}, run before waiting, this is a thread-safety thing to prevent "interrupts" from going in between this and things like deferCurrentTask
     * @since 1.5.0
     * @return a event and a new context if the event you're waiting for was joined, to leave it early.
     * @throws InterruptedException
     */
    function waitForEvent<E extends keyof Events>(event: E, filter: MethodWrapper<Events[E], undefined, boolean>, runBeforeWaiting: MethodWrapper<JavaObject, JavaObject, JavaObject>): FJsMacros$EventAndContext & { readonly event: Events[E] };

    /**
     * @since 1.2.3
     * @param event
     * @return a list of script-added listeners.
     */
    function listeners(event: keyof Events): JavaList<Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener>;

    /**
     * create a custom event object that can trigger a event. It's recommended to use 
     *  {@link EventCustom#registerEvent} to set up the event to be visible in the GUI.
     * @see BaseEventRegistry#addEvent(String)
     * @param eventName name of the event. please don't use an existing one... your scripts might not like that.
     * @since 1.2.8
     * @return
     */
    function createCustomEvent(eventName: string): Packages.xyz.wagyourtail.jsmacros.core.event.impl.EventCustom;

}

/**
 * Functions for getting and using raw java classes, methods and functions.  
 *
 * @author Wagyourtail
 * @since 1.2.3
 */
declare namespace Reflection {

    /**
     * @param name name of class like {@code path.to.class}
     * @return resolved class
     * @throws ClassNotFoundException
     * @see FReflection#getClass(String, String)
     * @since 1.2.3
     */
    function getClass<C extends string>(name: C): GetJava.Type$Reflection<C>;
    function getClass<C extends JavaTypeList | keyof GetJava.Primitives>(name: C): GetJava.Type$Reflection<C>;

    /**
     * Use this to specify a class with intermediary and yarn names of classes for cleaner code. also has support for
     *  java primitives by using their name in lower case.
     * @param name first try
     * @param name2 second try
     * @return a {@link java.lang.Class Class} reference.
     * @throws ClassNotFoundException
     * @since 1.2.3
     */
    function getClass<C extends string>(name: C, name2: string): GetJava.Type$Reflection<C>;
    function getClass<C extends JavaTypeList | keyof GetJava.Primitives>(name: C, name2: JavaTypeList | keyof GetJava.Primitives): GetJava.Type$Reflection<C>;

    /**
     * @param c
     * @param name
     * @param parameterTypes
     * @return 
     * @throws NoSuchMethodException
     * @throws SecurityException
     * @see FReflection#getDeclaredMethod(Class, String, String, Class...)
     * @since 1.2.3
     */
    function getDeclaredMethod(c: JavaClassArg<any>, name: string, ...parameterTypes: JavaClassArg<any>[]): Packages.java.lang.reflect.Method;

    /**
     * Use this to specify a method with intermediary and yarn names of classes for cleaner code.
     * @param c
     * @param name
     * @param name2
     * @param parameterTypes
     * @return a {@link java.lang.reflect.Method Method} reference.
     * @throws NoSuchMethodException
     * @throws SecurityException
     * @since 1.2.3
     */
    function getDeclaredMethod(c: JavaClassArg<any>, name: string, name2: string, ...parameterTypes: JavaClassArg<any>[]): Packages.java.lang.reflect.Method;

    /**
     * @since 1.6.0
     * @param c
     * @param name
     * @param name2
     * @param parameterTypes
     * @return 
     * @throws NoSuchMethodException
     */
    function getMethod(c: JavaClassArg<any>, name: string, name2: string, ...parameterTypes: JavaClassArg<any>[]): Packages.java.lang.reflect.Method;

    /**
     * @since 1.6.0
     * @param c
     * @param name
     * @param parameterTypes
     * @return 
     * @throws NoSuchMethodException
     */
    function getMethod(c: JavaClassArg<any>, name: string, ...parameterTypes: JavaClassArg<any>[]): Packages.java.lang.reflect.Method;

    /**
     * @param c
     * @param name
     * @return 
     * @throws NoSuchFieldException
     * @throws SecurityException
     * @see FReflection#getDeclaredField(Class, String, String)
     * @since 1.2.3
     */
    function getDeclaredField(c: JavaClassArg<any>, name: string): Packages.java.lang.reflect.Field;

    /**
     * Use this to specify a field with intermediary and yarn names of classes for cleaner code.
     * @param c
     * @param name
     * @param name2
     * @return a {@link java.lang.reflect.Field Field} reference.
     * @throws NoSuchFieldException
     * @throws SecurityException
     * @since 1.2.3
     */
    function getDeclaredField(c: JavaClassArg<any>, name: string, name2: string): Packages.java.lang.reflect.Field;

    /**
     * @since 1.6.0
     * @param c
     * @param name
     * @return 
     * @throws NoSuchFieldException
     */
    function getField(c: JavaClassArg<any>, name: string): Packages.java.lang.reflect.Field;

    /**
     * @since 1.6.0
     * @param c
     * @param name
     * @param name2
     * @return 
     * @throws NoSuchFieldException
     */
    function getField(c: JavaClassArg<any>, name: string, name2: string): Packages.java.lang.reflect.Field;

    /**
     * Invoke a method on an object with auto type coercion for numbers.
     * @param m method
     * @param c object (can be {@code null} for statics)
     * @param objects
     * @return 
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     * @throws InvocationTargetException
     * @since 1.2.3
     */
    function invokeMethod(m: Packages.java.lang.reflect.Method, c: any, ...objects: any[]): any;

    /**
     * Attempts to create a new instance of a class. You probably don't have to use this one and can just call `
     *  new` on a {@link java.lang.Class} unless you're in LUA, but then you also have the (kinda poorly
     *  documented, can someone find a better docs link for me)
     *  [LuaJava Library](http://luaj.sourceforge.net/api/3.2/org/luaj/vm2/lib/jse/LuajavaLib.html).
     * @param c
     * @param objects
     * @return 
     * @since 1.2.7
     */
    function newInstance<T>(c: JavaClassArg<T>, ...objects: any[]): T;

    /**
     * proxy for extending java classes in the guest language with proper threading support.
     * @param clazz
     * @param interfaces
     * @since 1.6.0
     * @return
     */
    function createClassProxyBuilder<T>(clazz: JavaClassArg<T>, ...interfaces: JavaClassArg<any>[]): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder<T>;

    /**
     * @param cName
     * @param clazz
     * @param interfaces
     * @since 1.6.5
     * @return 
     * @throws NotFoundException
     * @throws CannotCompileException
     */
    function createClassBuilder<T>(cName: string, clazz: JavaClassArg<T>, ...interfaces: JavaClassArg<any>[]): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder<T>;

    /**
     * @param cName
     * @since 1.6.5
     * @return 
     * @throws ClassNotFoundException
     */
    function getClassFromClassBuilderResult(cName: string): JavaClass<any>;
    function createLibraryBuilder(name: string, perExec: boolean, ...acceptedLangs: string[]): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.LibraryBuilder;

    /**
     * A library class always has a {@link Library} annotation containing the name of the library,  
     *  which may differ from the actual class name. A library class must also extend
     *  {@link BaseLibrary} in some way, either directly or through
     *  {@link PerExecLibrary},  
     *  {@link xyz.wagyourtail.jsmacros.core.library.PerExecLanguageLibrary}
     *  or {@link xyz.wagyourtail.jsmacros.core.library.PerLanguageLibrary}.
     * @param className the fully qualified name of the class, including the package
     * @param javaCode the source code of the library
     * @since 1.8.4
     */
    function createLibrary(className: string, javaCode: string): void;

    /**
     * A Java Development Kit (JDK) must be installed (and potentially used to start Minecraft) in
     *  order to compile whole classes.  
     *
     *  Compiled classes can't be accessed from any guest language, but must be either stored through
     *  {@link FGlobalVars#putObject} or retrieved from this library. Unlike normal
     *  hot swapping, already created instances of the class will not be updated. Thus, it's
     *  important to know which version of the class you're using when instantiating it.
     * @param className the fully qualified name of the class, including the package
     * @param code the java code to compile
     * @return the compiled class.
     * @since 1.8.4
     */
    function compileJavaClass(className: string, code: string): JavaClass<any>;

    /**
     * @param className the fully qualified name of the class, including the package
     * @return the latest compiled class or {@code null} if it doesn't exist.
     * @since 1.8.4
     */
    function getCompiledJavaClass(className: string): JavaClass<any>;

    /**
     * @param className the fully qualified name of the class, including the package
     * @return all compiled versions of the class, in order of compilation.
     * @since 1.8.4
     */
    function getAllCompiledJavaClassVersions(className: string): JavaList<JavaClass<any>>;

    /**
     * See [jOOR Github](https://github.com/jOOQ/jOOR) for more information.
     * @param obj the object to wrap
     * @return a wrapper for the passed object to do help with java reflection.
     * @since 1.8.4
     */
    function getReflect(obj: any): Packages.org.joor.Reflect;

    /**
     * Loads a jar file to be accessible with this library.
     * @param file relative to the script's folder.
     * @return success value
     * @throws IOException
     * @since 1.2.6
     */
    function loadJarFile(file: string): boolean;

    /**
     * @since 1.3.1
     * @return the previous mapping helper generated with {@link #loadMappingHelper(String)}
     */
    function loadCurrentMappingHelper(): Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings;

    /**
     * @param o class you want the name of
     * @since 1.3.1
     * @return the fully qualified class name (with "."'s not "/"'s)
     */
    function getClassName(o: any): string;

    /**
     * @param urlorfile a url or file path the the yarn mappings {@code -v2.jar} file, or {@code .tiny} file. for example {@code https://maven.fabricmc.net/net/fabricmc/yarn/1.16.5%2Bbuild.3/yarn-1.16.5%2Bbuild.3-v2.jar}, if same url/path as previous this will load from cache.
     * @since 1.3.1
     * @return the associated mapping helper.
     */
    function loadMappingHelper(urlorfile: string): Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings;

    /**
     * @since 1.6.5
     * @param instance
     * @return
     */
    function wrapInstace<T>(instance: T): Packages.xyz.wagyourtail.jsmacros.core.classes.WrappedClassInstance<T>;

    /**
     * @since 1.6.5
     * @param className
     * @return 
     * @throws ClassNotFoundException
     */
    function getWrappedClass(className: string): Packages.xyz.wagyourtail.jsmacros.core.classes.WrappedClassInstance<any>;

}

/**
 * Functions for getting and using raw java classes, methods and functions.  
 *
 * @since 1.1.8
 * @author Wagyourtail
 */
declare namespace Request {

    /**
     * create a HTTPRequest handler to the specified URL
     * @since 1.1.8
     * @see HTTPRequest
     * @param url
     * @return Request Wrapper
     * @throws IOException
     */
    function create(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest;

    /**
     * @since 1.1.8
     * @see FRequest#get(String, Map)
     * @param url
     * @return 
     * @throws IOException
     */
    function get(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * send a GET request to the specified URL.
     * @since 1.1.8
     * @see HTTPRequest.Response
     * @param url
     * @param headers
     * @return Response Data
     * @throws IOException
     */
    function get(url: string, headers: JavaMap<string, string>): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * @see FRequest#post(String, String, Map)
     * @since 1.1.8
     * @param url
     * @param data
     * @return 
     * @throws IOException
     */
    function post(url: string, data: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * send a POST request to the specified URL.
     * @since 1.1.8
     * @param url
     * @param data
     * @param headers
     * @return Response Data
     * @throws IOException
     */
    function post(url: string, data: string, headers: JavaMap<string, string>): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;

    /**
     * Create a Websocket handler.
     * @since 1.2.7
     * @see Websocket
     * @param url
     * @return 
     * @throws IOException
     */
    function createWS(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket;

    /**
     * Create a Websocket handler.
     * @since 1.1.9
     * @deprecated 1.2.7
     * @param url
     * @return 
     * @throws IOException
     */
    function createWS2(url: string): Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket;

}

/**
 * Functions for getting and using raw java classes, methods and functions.  
 *
 * @author Wagyourtail
 */
declare namespace Time {

    /**
     * @return current time in MS.
     */
    function time(): number;

    /**
     * Sleeps the current thread for the specified time in MS.
     * @param millis
     * @throws InterruptedException
     */
    function sleep(millis: long): void;

}

declare namespace Packages {

    namespace xyz.wagyourtail {

        /**
         * Is this even faster than just iterating through a LinkedHashSet / HashSet at this point?
         *  also should the node-length just always be 1?
         * @author Wagyourtail
         */
        const StringHashTrie: JavaClassStatics<StringHashTrie, StringHashTrie$$constructor>;
        interface StringHashTrie$$constructor extends SuppressProperties {

            new (): StringHashTrie;

        }
        interface StringHashTrie extends JavaCollection<string> {

            size(): number;
            isEmpty(): boolean;
            contains(o: any): boolean;
            iterator(): java.util.Iterator<string>;
            toArray(): JavaArray<string>;
            toArray<T>(a: T[]): JavaArray<T>;
            toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
            add(s: string): boolean;

            /**
             * this can make the StringHashTrie sparse, this can cause extra steps in lookup that are no longer needed,  
             *  at some point it would be best to rebase the StringHashTrie with `new StringHashTrie().addAll(current.getAll())`
             * @param o
             * @return
             */
            remove(o: any): boolean;
            containsAll(c: JavaCollection<any>): boolean;
            containsAll(...o: string[]): boolean;
            addAll(c: JavaCollection<any>): boolean;
            addAll(...o: string[]): boolean;
            removeAll(c: JavaCollection<any>): boolean;
            removeAll(...o: string[]): boolean;
            retainAll(c: JavaCollection<any>): boolean;
            retainAll(...o: string[]): boolean;
            clear(): void;

            /**
             * @param prefix prefix to search with
             * @return all elements that start with the given prefix
             */
            getAllWithPrefix(prefix: string): JavaSet<string>;

            /**
             * @param prefix prefix to search with
             * @return all elements that start with the given prefix (case insensitive)
             */
            getAllWithPrefixCaseInsensitive(prefix: string): JavaSet<string>;

            /**
             * all contained elements as a {@link Set}
             * @return
             */
            getAll(): JavaSet<string>;

            /**
             * @return json representation, mainly for debugging.
             */
            toString(): string;

        }

        const Pair: JavaClassStatics<Pair<any, any>, Pair$$constructor>;
        interface Pair$$constructor extends SuppressProperties {

            new <T, U>(t: T, u: U): Pair<T, U>;

        }
        interface Pair<T, U> extends JavaObject {

            setU(u: U): void;
            setT(t: T): void;
            getU(): U;
            getT(): T;

        }

        export { StringHashTrie, Pair }

    }
    namespace xyz.wagyourtail {

        namespace jsmacros {

            namespace core {

                /**
                 * Wraps most of the important functional interfaces.
                 * @see xyz.wagyourtail.jsmacros.core.library.IFWrapper
                 * @author Wagyourtail
                 */
                const MethodWrapper: JavaClassStatics<MethodWrapper<any, any, any, any>, MethodWrapper$$constructor>;
                interface MethodWrapper$$constructor extends SuppressProperties {

                    new <T, U, R, C extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>>(containingContext: C): MethodWrapper<T, U, R, C>;

                }
                interface MethodWrapper<T, U, R, C extends xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>> extends java.util.function.Consumer<T>, java.util.function.BiConsumer<T, U>, java.util.function.Function<T, R>, java.util.function.BiFunction<T, U, R>, java.util.function.Predicate<T>, java.util.function.BiPredicate<T, U>, java.lang.Runnable, java.util.function.Supplier<R>, java.util.Comparator<T> {

                    getCtx(): C;
                    accept(t: T): void;
                    accept(t: T, u: U): void;
                    apply(t: T): R;
                    apply(t: T, u: U): R;
                    test(t: T): boolean;
                    test(t: T, u: U): boolean;

                    /**
                     * override to return true if the method can't join to the thread it was wrapped/created in, ie for languages that don't allow multithreading.
                     */
                    preventSameThreadJoin(): boolean;

                    /**
                     * make return something to override the thread set in {@link xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros#on}
                     *  (hi jep)
                     */
                    overrideThread(): java.lang.Thread;

                    /**
                     * Makes {@link Function} and {@link BiFunction} work together.  
                     *  Extended so it's called on every type not just those 2.
                     * @param after put a {@link MethodWrapper} here when using in scripts.
                     */
                    andThen<V>(after: java.util.function.Function<any, any>): MethodWrapper<T, U, V, C>;
                    andThen(arg0: java.util.function.Consumer<any>): java.util.function.Consumer<T>;
                    andThen(arg0: java.util.function.BiConsumer<any, any>): java.util.function.BiConsumer<T, U>;

                    /**
                     * Makes {@link Predicate} and {@link BiPredicate} work together
                     */
                    negate(): MethodWrapper<T, U, R, C>;

                }

                const Core: JavaClassStatics<Core<any, any>> & NoConstructor & {

                    /**
                     * static reference to instance created by {@link #createInstance}
                     */
                    getInstance(): Core<any, any>;

                    /**
                     * start by running this function, supplying implementations of {@link BaseEventRegistry} and {@link BaseProfile} and a {@link Supplier} for
                     *  creating the config manager with the folder paths it needs.
                     * @param eventRegistryFunction
                     * @param profileFunction
                     * @param configFolder
                     * @param macroFolder
                     * @param logger
                     * @return
                     */
                    createInstance<V extends xyz.wagyourtail.jsmacros.core.config.BaseProfile, R extends xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry>(eventRegistryFunction: java.util.function.Function<Core<V, R>, R>, profileFunction: java.util.function.BiFunction<Core<V, R>, org.slf4j.Logger, V>, configFolder: java.io.File, macroFolder: java.io.File, logger: org.slf4j.Logger): Core<V, R>;

                }
                interface Core<T extends xyz.wagyourtail.jsmacros.core.config.BaseProfile, U extends xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry> extends JavaObject {
                    readonly libraryRegistry: xyz.wagyourtail.jsmacros.core.library.LibraryRegistry;
                    readonly eventRegistry: xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry;
                    readonly extensions: xyz.wagyourtail.jsmacros.core.extensions.ExtensionLoader;
                    readonly profile: T;
                    readonly config: xyz.wagyourtail.jsmacros.core.config.ConfigManager;
                    readonly services: xyz.wagyourtail.jsmacros.core.service.ServiceManager;

                    deferredInit(): void;

                    /**
                     * @param container
                     */
                    addContext(container: xyz.wagyourtail.jsmacros.core.language.EventContainer<any>): void;

                    /**
                     * @return
                     */
                    getContexts(): JavaSet<xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>>;

                    /**
                     * executes an {@link BaseEvent} on a ${@link ScriptTrigger}
                     * @param macro
                     * @param event
                     * @return
                     */
                    exec(macro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger, event: Events.BaseEvent): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                    /**
                     * Executes an {@link BaseEvent} on a ${@link ScriptTrigger} with callback.
                     * @param macro
                     * @param event
                     * @param then
                     * @param catcher
                     * @return
                     */
                    exec(macro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger, event: Events.BaseEvent, then: java.lang.Runnable, catcher: java.util.function.Consumer<java.lang.Throwable>): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                    /**
                     * @since 1.7.0
                     * @param lang
                     * @param script
                     * @param fakeFile
                     * @param event
                     * @param then
                     * @param catcher
                     * @return
                     */
                    exec(lang: string, script: string, fakeFile: java.io.File, event: Events.BaseEvent, then: java.lang.Runnable, catcher: java.util.function.Consumer<java.lang.Throwable>): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                    /**
                     * wraps an exception for more uniform parsing between languages, also extracts useful info.
                     * @param ex exception to wrap.
                     * @return
                     */
                    wrapException(ex: java.lang.Throwable): xyz.wagyourtail.jsmacros.core.language.BaseWrappedException<any>;

                }

                export { MethodWrapper, Core }

            }
            namespace core {

                namespace language {

                    /** @since 1.4.0 */
                    const BaseScriptContext: JavaClassStatics<BaseScriptContext<any>, BaseScriptContext$$constructor>;
                    interface BaseScriptContext$$constructor extends SuppressProperties {

                        new <T>(event: Events.BaseEvent, file: java.io.File): BaseScriptContext<T>;

                    }
                    interface BaseScriptContext<T> extends JavaObject {
                        readonly startTime: number;
                        readonly syncObject: java.lang.ref.WeakReference<any>;
                        readonly triggeringEvent: Events.BaseEvent;
                        hasMethodWrapperBeenInvoked: boolean;

                        /**
                         * this object should only be weak referenced unless we want to prevent the context from closing when syncObject is cleared.
                         */
                        getSyncObject(): any;
                        clearSyncObject(): void;

                        /**
                         * @since 1.6.0
                         * @return
                         */
                        getBoundEvents(): JavaMap<java.lang.Thread, EventContainer<any>>;

                        /**
                         * @since 1.6.0
                         * @param th
                         * @param event
                         */
                        bindEvent(th: java.lang.Thread, event: EventContainer<BaseScriptContext<T>>): void;

                        /**
                         * @since 1.6.0
                         * @param thread
                         * @return
                         */
                        releaseBoundEventIfPresent(thread: java.lang.Thread): boolean;
                        getContext(): T;

                        /**
                         * @since 1.5.0
                         * @return
                         */
                        getMainThread(): java.lang.Thread;

                        /**
                         * @since 1.6.0
                         * @param t
                         * @return is a newly bound thread
                         */
                        bindThread(t: java.lang.Thread): boolean;

                        /**
                         * @since 1.6.0
                         * @param t
                         */
                        unbindThread(t: java.lang.Thread): void;

                        /**
                         * @since 1.6.0
                         * @return
                         */
                        getBoundThreads(): JavaSet<java.lang.Thread>;

                        /**
                         * @since 1.5.0
                         * @param t
                         */
                        setMainThread(t: java.lang.Thread): void;
                        /** @since 1.5.0 */
                        getTriggeringEvent(): Events.BaseEvent;
                        setContext(context: T): void;
                        isContextClosed(): boolean;
                        closeContext(): void;

                        /**
                         * @since 1.6.0
                         * @return
                         */
                        getFile(): java.io.File | null;

                        /**
                         * @since 1.6.0
                         * @return
                         */
                        getContainedFolder(): java.io.File;
                        isMultiThreaded(): boolean;
                        wrapSleep(sleep: BaseScriptContext$SleepRunnable): void;

                    }

                    /**
                     * @param <T>
                     * @since 1.4.0
                     */
                    const EventContainer: JavaClassStatics<EventContainer<any>, EventContainer$$constructor>;
                    interface EventContainer$$constructor extends SuppressProperties {

                        new <T extends BaseScriptContext<any>>(ctx: T): EventContainer<T>;

                    }
                    interface EventContainer<T extends BaseScriptContext<any>> extends JavaObject {

                        isLocked(): boolean;
                        setLockThread(lockThread: java.lang.Thread): void;
                        getCtx(): T;
                        getLockThread(): java.lang.Thread;

                        /**
                         * careful with this one it can cause deadlocks if used in scripts incorrectly.
                         * @param then must be a {@link MethodWrapper} when called from a script.
                         * @throws InterruptedException
                         * @since 1.4.0
                         */
                        awaitLock(then: java.lang.Runnable): void;

                        /**
                         * can be released earlier in a script or language impl.
                         * @since 1.4.0
                         */
                        releaseLock(): void;

                    }

                    const BaseScriptContext$SleepRunnable: JavaInterfaceStatics<BaseScriptContext$SleepRunnable>;
                    interface BaseScriptContext$SleepRunnable extends JavaObject {

                        run(): void;

                    }

                    /**
                     * Language class for languages to be implemented on top of.
                     * @since 1.1.3
                     */
                    const BaseLanguage: JavaClassStatics<BaseLanguage<any, any>, BaseLanguage$$constructor>;
                    interface BaseLanguage$$constructor extends SuppressProperties {

                        new <U, T extends BaseScriptContext<U>>(extension: xyz.wagyourtail.jsmacros.core.extensions.Extension, runner: xyz.wagyourtail.jsmacros.core.Core<any, any>): BaseLanguage<U, T>;

                    }
                    interface BaseLanguage<U, T extends BaseScriptContext<U>> extends JavaObject {
                        readonly extension: xyz.wagyourtail.jsmacros.core.extensions.Extension;
                        preThread: java.lang.Runnable;

                        trigger(macro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger, event: Events.BaseEvent, then: java.lang.Runnable, catcher: java.util.function.Consumer<java.lang.Throwable>): EventContainer<T>;
                        trigger(lang: string, script: string, fakeFile: java.io.File, event: Events.BaseEvent, then: java.lang.Runnable, catcher: java.util.function.Consumer<java.lang.Throwable>): EventContainer<T>;
                        retrieveLibs(context: T): JavaMap<string, xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;
                        retrieveOnceLibs(): JavaMap<string, xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;
                        retrievePerExecLibs(context: T): JavaMap<string, xyz.wagyourtail.jsmacros.core.library.BaseLibrary>;
                        createContext(event: Events.BaseEvent, file: java.io.File): T;

                    }

                    const BaseWrappedException: JavaClassStatics<BaseWrappedException<any>, BaseWrappedException$$constructor> & {

                        wrapHostElement(t: java.lang.StackTraceElement, next: BaseWrappedException<any>): BaseWrappedException<java.lang.StackTraceElement>;

                    }
                    interface BaseWrappedException$$constructor extends SuppressProperties {

                        new <T>(exception: T, message: string, location: BaseWrappedException$SourceLocation, next: BaseWrappedException<any>): BaseWrappedException<T>;

                    }
                    interface BaseWrappedException<T> extends JavaObject {
                        readonly stackFrame: T;
                        readonly location: BaseWrappedException$SourceLocation;
                        readonly message: string;
                        readonly next: BaseWrappedException<any>;
                    }

                    const BaseWrappedException$SourceLocation: JavaClassStatics<BaseWrappedException$SourceLocation, BaseWrappedException$SourceLocation$$constructor>;
                    interface BaseWrappedException$SourceLocation$$constructor extends SuppressProperties {

                        new (): BaseWrappedException$SourceLocation;

                    }
                    interface BaseWrappedException$SourceLocation extends JavaObject {}

                    export {
                        BaseScriptContext,
                        EventContainer,
                        BaseScriptContext$SleepRunnable,
                        BaseLanguage,
                        BaseWrappedException,
                        BaseWrappedException$SourceLocation
                    }

                }

                namespace helpers {

                    const BaseHelper: JavaClassStatics<BaseHelper<any>, BaseHelper$$constructor>;
                    interface BaseHelper$$constructor extends SuppressProperties {

                        new <T>(base: T): BaseHelper<T>;

                    }
                    interface BaseHelper<T> extends JavaObject {

                        getRaw(): T;

                    }

                    export { BaseHelper }

                }

                namespace library {

                    const BaseLibrary: JavaClassStatics<BaseLibrary, BaseLibrary$$constructor>;
                    interface BaseLibrary$$constructor extends SuppressProperties {

                        new (): BaseLibrary;

                    }
                    interface BaseLibrary extends JavaObject {}

                    const LibraryRegistry: JavaClassStatics<LibraryRegistry, LibraryRegistry$$constructor>;
                    interface LibraryRegistry$$constructor extends SuppressProperties {

                        new (): LibraryRegistry;

                    }
                    interface LibraryRegistry extends JavaObject {
                        readonly libraries: JavaMap<Library, BaseLibrary>;
                        readonly perExec: JavaMap<Library, JavaClass<any>>;
                        readonly perLanguage: JavaMap<JavaClass<any>, JavaMap<Library, PerLanguageLibrary>>;
                        readonly perExecLanguage: JavaMap<JavaClass<any>, JavaMap<Library, JavaClass<any>>>;

                        getLibraries(language: xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>, context: xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>): JavaMap<string, BaseLibrary>;
                        getOnceLibraries(language: xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>): JavaMap<string, BaseLibrary>;
                        getPerExecLibraries(language: xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>, context: xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any>): JavaMap<string, BaseLibrary>;
                        addLibrary(clazz: JavaClassArg<any>): void;

                    }

                    const PerLanguageLibrary: JavaClassStatics<PerLanguageLibrary, PerLanguageLibrary$$constructor>;
                    interface PerLanguageLibrary$$constructor extends SuppressProperties {

                        new (language: JavaClassArg<any>): PerLanguageLibrary;

                    }
                    interface PerLanguageLibrary extends BaseLibrary {}

                    /**
                     * Base Function interface.
                     * @author Wagyourtail
                     */
                    const Library: JavaInterfaceStatics<Library>;
                    interface Library extends java.lang.annotation.Annotation {

                        value(): string;
                        languages(): JavaArray<JavaClass<any>>;

                    }

                    export { BaseLibrary, LibraryRegistry, PerLanguageLibrary, Library }

                }
                namespace library {

                    namespace impl {

                        const FJsMacros$EventAndContext: JavaClassStatics<FJsMacros$EventAndContext, FJsMacros$EventAndContext$$constructor>;
                        interface FJsMacros$EventAndContext$$constructor extends SuppressProperties {

                            new (event: Events.BaseEvent, context: xyz.wagyourtail.jsmacros.core.language.EventContainer<any>): FJsMacros$EventAndContext;

                        }
                        interface FJsMacros$EventAndContext extends JavaObject {
                            readonly event: Events.BaseEvent;
                            readonly context: xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;
                        }

                        export { FJsMacros$EventAndContext }

                    }
                    namespace impl {

                        namespace classes {

                            /**
                             * @author Wagyourtail
                             * @since 1.1.8
                             */
                            const HTTPRequest: JavaClassStatics<HTTPRequest, HTTPRequest$$constructor>;
                            interface HTTPRequest$$constructor extends SuppressProperties {

                                new (url: string): HTTPRequest;

                            }
                            interface HTTPRequest extends JavaObject {
                                headers: JavaMap<string, string>;
                                conn: java.net.URL;

                                /**
                                 * @since 1.1.8
                                 * @param key
                                 * @param value
                                 * @return
                                 */
                                addHeader(key: string, value: string): HTTPRequest;

                                /**
                                 * @since 1.1.8
                                 * @return 
                                 * @throws IOException
                                 */
                                get(): HTTPRequest$Response;

                                /**
                                 * @since 1.1.8
                                 * @param data
                                 * @return 
                                 * @throws IOException
                                 */
                                post(data: string): HTTPRequest$Response;

                                /**
                                 * @since 1.8.4
                                 * @param data
                                 * @return 
                                 * @throws IOException
                                 */
                                post(data: byte[]): HTTPRequest$Response;

                                /**
                                 * @since 1.8.4
                                 * @param data
                                 * @return 
                                 * @throws IOException
                                 */
                                put(data: string): HTTPRequest$Response;

                                /**
                                 * @since 1.8.4
                                 * @param data
                                 * @return 
                                 * @throws IOException
                                 */
                                put(data: byte[]): HTTPRequest$Response;

                                /**
                                 * @since 1.8.4
                                 * @param method
                                 * @param data
                                 * @return 
                                 * @throws IOException
                                 */
                                send(method: string, data: string): HTTPRequest$Response;

                                /**
                                 * @since 1.8.4
                                 * @param method
                                 * @param data
                                 * @return 
                                 * @throws IOException
                                 */
                                send(method: string, data: byte[]): HTTPRequest$Response;

                            }

                            /**
                             * @param <T>
                             * @author Wagyourtail
                             * @since 1.6.0
                             */
                            const ProxyBuilder: JavaClassStatics<ProxyBuilder<any>, ProxyBuilder$$constructor>;
                            interface ProxyBuilder$$constructor extends SuppressProperties {

                                new <T>(clazz: JavaClassArg<T>, interfaces: JavaClassArg<any>[]): ProxyBuilder<T>;

                            }
                            interface ProxyBuilder<T> extends JavaObject {
                                readonly factory: javassist.util.proxy.ProxyFactory;
                                readonly proxiedMethods: JavaMap<ProxyBuilder$MethodSigParts, xyz.wagyourtail.jsmacros.core.MethodWrapper<ProxyBuilder$ProxyReference<T>, JavaArray<any>, any, any>>;
                                readonly proxiedMethodDefaults: JavaMap<string, xyz.wagyourtail.jsmacros.core.MethodWrapper<ProxyBuilder$ProxyReference<T>, JavaArray<any>, any, any>>;

                                /**
                                 * @param methodNameOrSig name of method or sig (the usual format)
                                 * @param proxyMethod
                                 * @since 1.6.0
                                 * @return self for chaining
                                 */
                                addMethod(methodNameOrSig: string, proxyMethod: xyz.wagyourtail.jsmacros.core.MethodWrapper<ProxyBuilder$ProxyReference<T>, any[], any, any>): ProxyBuilder<T>;

                                /**
                                 * @param constructorArgs args for the super constructor
                                 * @since 1.6.0
                                 * @return new instance of the constructor
                                 * @throws InvocationTargetException
                                 * @throws NoSuchMethodException
                                 * @throws InstantiationException
                                 * @throws IllegalAccessException
                                 */
                                buildInstance(constructorArgs: any[]): T;

                                /**
                                 * @param constructorSig string signature (you can skip the <init> part)
                                 * @param constructorArgs args for the super constructor
                                 * @since 1.6.0
                                 * @return new instance of the constructor
                                 * @throws InvocationTargetException
                                 * @throws NoSuchMethodException
                                 * @throws InstantiationException
                                 * @throws IllegalAccessException
                                 * @throws ClassNotFoundException
                                 */
                                buildInstance(constructorSig: string, constructorArgs: any[]): T;

                                /**
                                 * @param constructorSig string signature (you can skip the <init> part)
                                 * @param constructorArgs args for the super constructor
                                 * @since 1.6.0
                                 * @return new instance of the constructor
                                 * @throws InvocationTargetException
                                 * @throws NoSuchMethodException
                                 * @throws InstantiationException
                                 * @throws IllegalAccessException
                                 * @throws ClassNotFoundException
                                 */
                                buildInstance(constructorSig: JavaClassArg<any>[], constructorArgs: any[]): T;

                            }

                            /**
                             * @param <T>
                             * @since 1.6.5
                             */
                            const ClassBuilder: JavaClassStatics<ClassBuilder<any>, ClassBuilder$$constructor> & {
                                readonly methodWrappers: JavaMap<string, xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>>;
                            }
                            interface ClassBuilder$$constructor extends SuppressProperties {

                                new <T>(name: string, parent: JavaClassArg<T>, ...interfaces: JavaClassArg<any>[]): ClassBuilder<T>;

                            }
                            interface ClassBuilder<T> extends JavaObject {
                                readonly ctClass: javassist.CtClass;

                                addField(fieldType: JavaClassArg<any>, name: string): ClassBuilder$FieldBuilder;

                                /**
                                 * The code must define the full field, including visibility, type, name and an optional value.  
                                 *  Generic types are not supported and must be explicitly cast in the source code when used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `private String name;`
                                 *  `private java.lang.String name;`
                                 *  `public java.util.List list = new java.util.ArrayList();`
                                 *  `static int value = 10;`
                                 *  ```
                                 * @param code the code for the field
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addField(code: string): ClassBuilder<T>;
                                addMethod(returnType: JavaClassArg<any>, name: string, ...params: JavaClassArg<any>[]): ClassBuilder$MethodBuilder;

                                /**
                                 * The code must define the full method, including visibility, return type, name and parameters.  
                                 *  Generic types are not supported as return values or arguments, neither can varargs be used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `public Object id(Object obj) { return obj; }`
                                 *  `private void print(String text) { System.out.println(text); }`
                                 *  `private static java.util.Map toMap(Object[] keys, Object[] values) {
                                 *       java.util.Map map = new java.util.HashMap();  
                                 *       for (int i = 0; i < keys.length; i++) {
                                 *           map.put(keys[i], values[i]);  
                                 *       }
                                 *       return map;  
                                 *   }`
                                 *  `public String toString() {
                                 *       System.out.println(super.toString());  
                                 *       return "Hello World!";  
                                 *   }`
                                 *  ```
                                 * @param code the code for the method
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addMethod(code: string): ClassBuilder<T>;
                                addConstructor(...params: JavaClassArg<any>[]): ClassBuilder$ConstructorBuilder;

                                /**
                                 * The code must define the full constructor, including visibility and parameters.  
                                 *  Generic types are not supported as arguments, neither can varargs be used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  To make sure the class can be easily instantiated, the visibility of the constructor should be public.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `public MyClass() {}`
                                 *  `public MyClass(String text) { System.out.println(text); }`
                                 *  `protected MyClass(String text, int number) { super(text, number, ""); }`
                                 *  `public MyClass(String text, int number, String other) {
                                 *       this(text, number);  
                                 *       this.other = other;  
                                 *  }`
                                 *  ```
                                 * @param code the code for the constructor
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addConstructor(code: string): ClassBuilder<T>;
                                addClinit(): ClassBuilder$ConstructorBuilder;
                                addAnnotation(type: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder<T>>;
                                finishBuildAndFreeze(): JavaClass<any>;

                            }

                            /**
                             * @author Wagyourtail, R3alCl0ud
                             */
                            const Websocket: JavaClassStatics<Websocket, Websocket$$constructor>;
                            interface Websocket$$constructor extends SuppressProperties {

                                new (address: string): Websocket;
                                new (address: java.net.URL): Websocket;

                            }
                            interface Websocket extends JavaObject {

                                /**
                                 * calls your method as a {@link java.util.function.Consumer}<{@link WebSocket}, {@link List}<{@link String}>>
                                 */
                                onConnect: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, JavaMap<string, JavaList<string>>, any, any>;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link String}>
                                 */
                                onTextMessage: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, string, any, any>;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link Disconnected}>
                                 */
                                onDisconnect: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, Websocket$Disconnected, any, any>;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link WebSocketException}>
                                 */
                                onError: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, com.neovisionaries.ws.client.WebSocketException, any, any>;

                                /**
                                 * calls your method as a {@link java.util.function.BiConsumer}<{@link WebSocket}, {@link WebSocketFrame}>
                                 */
                                onFrame: xyz.wagyourtail.jsmacros.core.MethodWrapper<com.neovisionaries.ws.client.WebSocket, com.neovisionaries.ws.client.WebSocketFrame, any, any>;

                                /**
                                 * @since 1.1.9
                                 * @return 
                                 * @throws WebSocketException
                                 */
                                connect(): Websocket;

                                /**
                                 * @since 1.1.9
                                 * @return
                                 */
                                getWs(): com.neovisionaries.ws.client.WebSocket;

                                /**
                                 * @since 1.1.9
                                 * @param text
                                 * @return
                                 */
                                sendText(text: string): Websocket;

                                /**
                                 * @since 1.1.9
                                 * @return
                                 */
                                close(): Websocket;

                                /**
                                 * @since 1.1.9
                                 * @param closeCode
                                 * @return
                                 */
                                close(closeCode: int): Websocket;

                            }

                            /**
                             * @since 1.6.5
                             * @author Wagyourtail
                             */
                            const LibraryBuilder: JavaClassStatics<LibraryBuilder, LibraryBuilder$$constructor>;
                            interface LibraryBuilder$$constructor extends SuppressProperties {

                                new (name: string, perExec: boolean, ...allowedLangs: string[]): LibraryBuilder;

                            }
                            interface LibraryBuilder extends ClassBuilder<xyz.wagyourtail.jsmacros.core.library.BaseLibrary> {

                                /**
                                 * constructor, if perExec run every context, if per language run once for each lang;  
                                 *  params are context and language class.  
                                 *  if not per exec, param will be skipped.  
                                 *  ie:  
                                 *  BaseLibrary: no params  
                                 *  PerExecLibrary: context  
                                 *  PerExecLanguageLibrary: context, language  
                                 *  PerLanguageLibrary: language  
                                 *
                                 *  Don't do other constructors...
                                 * @return 
                                 * @throws NotFoundException
                                 */
                                addConstructor(): ClassBuilder$ConstructorBuilder;
                                addConstructor(...params: JavaClassArg<any>[]): ClassBuilder$ConstructorBuilder;

                                /**
                                 * The code must define the full constructor, including visibility and parameters.  
                                 *  Generic types are not supported as arguments, neither can varargs be used.  
                                 *  Annotations are also not supported.  
                                 *  Just like in java, classes from the `java.lang` package don't need a fully qualified name.  
                                 *  To make sure the class can be easily instantiated, the visibility of the constructor should be public.  
                                 *  Examples are:  
                                 *  ```  
                                 *  `public MyClass() {}`
                                 *  `public MyClass(String text) { System.out.println(text); }`
                                 *  `protected MyClass(String text, int number) { super(text, number, ""); }`
                                 *  `public MyClass(String text, int number, String other) {
                                 *       this(text, number);  
                                 *       this.other = other;  
                                 *  }`
                                 *  ```
                                 * @param code the code for the constructor
                                 * @return self for chaining.
                                 * @throws CannotCompileException
                                 * @since 1.8.4
                                 */
                                addConstructor(code: string): ClassBuilder<T>;
                                finishBuildAndFreeze(): JavaClass<any>;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.1.8
                             */
                            const HTTPRequest$Response: JavaClassStatics<HTTPRequest$Response, HTTPRequest$Response$$constructor>;
                            interface HTTPRequest$Response$$constructor extends SuppressProperties {

                                new (inputStream: java.io.InputStream, responseCode: int, headers: JavaMap<string, JavaList<string>>): HTTPRequest$Response;

                            }
                            interface HTTPRequest$Response extends JavaObject {
                                headers: JavaMap<string, JavaList<string>>;
                                responseCode: number;

                                /**
                                 * @since 1.1.8
                                 * @return
                                 */
                                text(): string;

                                /**
                                 * Don't use this. Parse {@link HTTPRequest.Response#text} in the guest language
                                 * @since 1.1.8
                                 * @deprecated
                                 * @return
                                 */
                                json(): any;

                                /**
                                 * @since 1.2.2
                                 * @return 
                                 * @throws IOException
                                 */
                                byteArray(): JavaArray<number>;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.1.8
                             */
                            const FileHandler: JavaClassStatics<FileHandler, FileHandler$$constructor>;
                            interface FileHandler$$constructor extends SuppressProperties {

                                new (path: string): FileHandler;
                                new (path: string, charset: string): FileHandler;
                                new (path: java.io.File, charset: string): FileHandler;
                                new (path: string, charset: java.nio.charset.Charset): FileHandler;
                                new (path: java.io.File): FileHandler;
                                new (path: java.io.File, charset: java.nio.charset.Charset): FileHandler;

                            }
                            interface FileHandler extends JavaObject {

                                /**
                                 * writes a string to the file. this is a destructive operation that replaces the file contents.
                                 * @since 1.1.8
                                 * @param s
                                 * @return 
                                 * @throws IOException
                                 */
                                write(s: string): FileHandler;

                                /**
                                 * writes a byte array to the file. this is a destructive operation that replaces the file contents.
                                 * @since 1.1.8
                                 * @param b
                                 * @return 
                                 * @throws IOException
                                 */
                                write(b: byte[]): FileHandler;

                                /**
                                 * @since 1.1.8
                                 * @return 
                                 * @throws IOException
                                 */
                                read(): string;

                                /**
                                 * @since 1.2.6
                                 * @return 
                                 * @throws IOException
                                 */
                                readBytes(): JavaArray<number>;

                                /**
                                 * @since 1.1.8
                                 * @param s
                                 * @return 
                                 * @throws IOException
                                 */
                                append(s: string): FileHandler;

                                /**
                                 * @since 1.2.6
                                 * @param b
                                 * @return 
                                 * @throws IOException
                                 */
                                append(b: byte[]): FileHandler;
                                getFile(): java.io.File;

                            }

                            const ClassBuilder$FieldBuilder: JavaClassStatics<ClassBuilder$FieldBuilder, ClassBuilder$FieldBuilder$$constructor>;
                            interface ClassBuilder$FieldBuilder$$constructor extends SuppressProperties {

                                new (fieldType: javassist.CtClass, name: string): ClassBuilder$FieldBuilder;

                            }
                            interface ClassBuilder$FieldBuilder extends JavaObject {
                                fieldInitializer: javassist.CtField$Initializer;

                                compile(code: string): ClassBuilder<T>;
                                rename(name: string): ClassBuilder$FieldBuilder;
                                makePrivate(): ClassBuilder$FieldBuilder;
                                makePublic(): ClassBuilder$FieldBuilder;
                                makeProtected(): ClassBuilder$FieldBuilder;
                                makePackagePrivate(): ClassBuilder$FieldBuilder;
                                toggleStatic(): ClassBuilder$FieldBuilder;
                                toggleFinal(): ClassBuilder$FieldBuilder;
                                getMods(): number;
                                getModString(): string;
                                addAnnotation(type: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$FieldBuilder>;
                                initializer(): ClassBuilder$FieldBuilder$FieldInitializerBuilder;
                                end(): ClassBuilder<T>;

                            }

                            const ClassBuilder$ConstructorBuilder: JavaClassStatics<ClassBuilder$ConstructorBuilder, ClassBuilder$ConstructorBuilder$$constructor>;
                            interface ClassBuilder$ConstructorBuilder$$constructor extends SuppressProperties {

                                new (params: javassist.CtClass[], clInit: boolean): ClassBuilder$ConstructorBuilder;

                            }
                            interface ClassBuilder$ConstructorBuilder extends ClassBuilder$MethodBuilder {

                                body(code_src: string): ClassBuilder<T>;
                                guestBody(methodBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): ClassBuilder<T>;
                                buildBody(): ClassBuilder$BodyBuilder;
                                body(buildBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<javassist.CtClass, javassist.CtBehavior, any, any>): ClassBuilder<T>;
                                endAbstract(): ClassBuilder<T>;

                            }

                            const ClassBuilder$AnnotationBuilder: JavaClassStatics<ClassBuilder$AnnotationBuilder<any>> & NoConstructor;
                            interface ClassBuilder$AnnotationBuilder<T> extends JavaObject {

                                putString(key: string, value: string): ClassBuilder$AnnotationBuilder<T>;
                                putBoolean(key: string, value: boolean): ClassBuilder$AnnotationBuilder<T>;
                                putByte(key: string, value: byte): ClassBuilder$AnnotationBuilder<T>;
                                putChar(key: string, value: char): ClassBuilder$AnnotationBuilder<T>;
                                putShort(key: string, value: short): ClassBuilder$AnnotationBuilder<T>;
                                putInt(key: string, value: int): ClassBuilder$AnnotationBuilder<T>;
                                putLong(key: string, value: long): ClassBuilder$AnnotationBuilder<T>;
                                putFloat(key: string, value: double): ClassBuilder$AnnotationBuilder<T>;
                                putDouble(key: string, value: double): ClassBuilder$AnnotationBuilder<T>;
                                putClass(key: string, value: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<T>;
                                putEnum(key: string, value: java.lang.Enum<any>): ClassBuilder$AnnotationBuilder<T>;
                                putAnnotation(key: string, annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$AnnotationBuilder<T>>;
                                putArray(key: string, annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<ClassBuilder$AnnotationBuilder<T>>;
                                finish(): T;

                            }

                            const ProxyBuilder$ProxyReference: JavaClassStatics<ProxyBuilder$ProxyReference<any>, ProxyBuilder$ProxyReference$$constructor>;
                            interface ProxyBuilder$ProxyReference$$constructor extends SuppressProperties {

                                new <T>(self: T, parent: java.util.function.Function<any[], any>): ProxyBuilder$ProxyReference<T>;

                            }
                            interface ProxyBuilder$ProxyReference<T> extends JavaObject {

                                /**
                                 * "this" value, but like python because "this" is a keyword in java...
                                 */
                                readonly self: T;

                                /**
                                 * "super" value, but that's also a keyword so...
                                 */
                                readonly parent: java.util.function.Function<JavaArray<any>, any>;
                            }

                            const ClassBuilder$MethodBuilder: JavaClassStatics<ClassBuilder$MethodBuilder, ClassBuilder$MethodBuilder$$constructor>;
                            interface ClassBuilder$MethodBuilder$$constructor extends SuppressProperties {

                                new (methodReturnType: javassist.CtClass, methodName: string, ...params: javassist.CtClass[]): ClassBuilder$MethodBuilder;

                            }
                            interface ClassBuilder$MethodBuilder extends JavaObject {

                                compile(code: string): ClassBuilder<T>;
                                makePrivate(): ClassBuilder$MethodBuilder;
                                makePublic(): ClassBuilder$MethodBuilder;
                                makeProtected(): ClassBuilder$MethodBuilder;
                                makePackagePrivate(): ClassBuilder$MethodBuilder;
                                toggleStatic(): ClassBuilder$MethodBuilder;
                                rename(newName: string): ClassBuilder$MethodBuilder;
                                exceptions(...exceptions: JavaClassArg<any>[]): ClassBuilder$MethodBuilder;
                                body(code_src: string): ClassBuilder<T>;
                                guestBody(methodBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): ClassBuilder<T>;
                                buildBody(): ClassBuilder$BodyBuilder;
                                body(buildBody: xyz.wagyourtail.jsmacros.core.MethodWrapper<javassist.CtClass, javassist.CtBehavior, any, any>): ClassBuilder<T>;
                                endAbstract(): ClassBuilder<T>;
                                addAnnotation(type: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$MethodBuilder>;

                            }

                            /**
                             * @author Perry "R3alCl0ud" Berman
                             */
                            const Websocket$Disconnected: JavaClassStatics<Websocket$Disconnected, Websocket$Disconnected$$constructor>;
                            interface Websocket$Disconnected$$constructor extends SuppressProperties {

                                /**
                                 * @param serverFrame
                                 * @param clientFrame
                                 * @param isServer
                                 */
                                new (serverFrame: com.neovisionaries.ws.client.WebSocketFrame, clientFrame: com.neovisionaries.ws.client.WebSocketFrame, isServer: boolean): Websocket$Disconnected;

                            }
                            interface Websocket$Disconnected extends JavaObject {
                                serverFrame: com.neovisionaries.ws.client.WebSocketFrame;
                                clientFrame: com.neovisionaries.ws.client.WebSocketFrame;
                                isServer: boolean;
                            }

                            const ProxyBuilder$MethodSigParts: JavaClassStatics<ProxyBuilder$MethodSigParts> & NoConstructor;
                            interface ProxyBuilder$MethodSigParts extends JavaObject {
                                readonly name: string;
                                readonly params: JavaArray<JavaClass<any>>;
                                readonly returnType: JavaClass<any>;
                            }

                            const ClassBuilder$FieldBuilder$FieldInitializerBuilder: JavaClassStatics<ClassBuilder$FieldBuilder$FieldInitializerBuilder, ClassBuilder$FieldBuilder$FieldInitializerBuilder$$constructor>;
                            interface ClassBuilder$FieldBuilder$FieldInitializerBuilder$$constructor extends SuppressProperties {

                                new (): ClassBuilder$FieldBuilder$FieldInitializerBuilder;

                            }
                            interface ClassBuilder$FieldBuilder$FieldInitializerBuilder extends JavaObject {

                                setInt(value: int): ClassBuilder$FieldBuilder;
                                setLong(value: long): ClassBuilder$FieldBuilder;
                                setFloat(value: double): ClassBuilder$FieldBuilder;
                                setDouble(value: double): ClassBuilder$FieldBuilder;
                                setChar(value: char): ClassBuilder$FieldBuilder;
                                setString(value: string): ClassBuilder$FieldBuilder;
                                setBoolean(value: boolean): ClassBuilder$FieldBuilder;
                                setByte(value: byte): ClassBuilder$FieldBuilder;
                                setShort(value: short): ClassBuilder$FieldBuilder;
                                compile(code: string): ClassBuilder$FieldBuilder;
                                initClass(clazz: JavaClassArg<any>, ...code_arg: string[]): ClassBuilder$FieldBuilder;
                                callStaticMethod(clazz: JavaClassArg<any>, methodName: string, ...code_arg: string[]): ClassBuilder$FieldBuilder;
                                callStaticMethodInThisClass(methodName: string, ...code_arg: string[]): ClassBuilder$FieldBuilder;

                            }

                            const ClassBuilder$BodyBuilder: JavaClassStatics<ClassBuilder$BodyBuilder> & NoConstructor;
                            interface ClassBuilder$BodyBuilder extends JavaObject {

                                appendJavaCode(code: string): ClassBuilder$BodyBuilder;

                                /**
                                 * @param code
                                 * @param argsAsObjects
                                 * @param tokenBefore ie, "return", "Object wasd = " etc
                                 * @return
                                 */
                                appendGuestCode(code: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>, argsAsObjects: string, tokenBefore: string): ClassBuilder$BodyBuilder;
                                finish(): ClassBuilder<T>;

                            }

                            const ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder: JavaClassStatics<ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<any>, ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder$$constructor>;
                            interface ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder$$constructor extends SuppressProperties {

                                new <U>(parent: U, constPool: javassist.bytecode.ConstPool): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;

                            }
                            interface ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U> extends JavaObject {

                                putString(value: string): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putBoolean(value: boolean): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putByte(value: byte): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putChar(value: char): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putShort(value: short): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putInt(value: int): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putLong(value: long): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putFloat(value: double): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putDouble(value: double): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putClass(value: JavaClassArg<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putEnum(value: java.lang.Enum<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
                                putAnnotation(annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder<ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>>;
                                putArray(annotationClass: JavaClassArg<any>): ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>>;
                                finish(): U;

                            }

                            export {
                                HTTPRequest,
                                ProxyBuilder,
                                ClassBuilder,
                                Websocket,
                                LibraryBuilder,
                                HTTPRequest$Response,
                                FileHandler,
                                ClassBuilder$FieldBuilder,
                                ClassBuilder$ConstructorBuilder,
                                ClassBuilder$AnnotationBuilder,
                                ProxyBuilder$ProxyReference,
                                ClassBuilder$MethodBuilder,
                                Websocket$Disconnected,
                                ProxyBuilder$MethodSigParts,
                                ClassBuilder$FieldBuilder$FieldInitializerBuilder,
                                ClassBuilder$BodyBuilder,
                                ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder
                            }

                        }

                    }

                }

                namespace config {

                    /**
                     * @author Wagyourtail
                     * @since 1.2.7
                     */
                    const BaseProfile: JavaClassStatics<BaseProfile, BaseProfile$$constructor>;
                    interface BaseProfile$$constructor extends SuppressProperties {

                        new (runner: xyz.wagyourtail.jsmacros.core.Core, logger: org.slf4j.Logger): BaseProfile;

                    }
                    interface BaseProfile extends JavaObject {
                        readonly LOGGER: org.slf4j.Logger;
                        readonly joinedThreadStack: JavaSet<java.lang.Thread>;
                        profileName: string;

                        logError(ex: java.lang.Throwable): void;

                        /**
                         * @since 1.1.2 [citation needed]
                         * @return
                         * @deprecated
                         */
                        getRegistry(): xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry;
                        /** @since 1.6.0 */
                        checkJoinedThreadStack(): boolean;

                        /**
                         * @since 1.1.2 [citation needed]
                         * @param profileName
                         */
                        loadOrCreateProfile(profileName: string): void;
                        /** @since 1.0.8 [citation needed] */
                        saveProfile(): void;

                        /**
                         * @since 1.2.7
                         * @param event
                         */
                        triggerEvent(event: Events.BaseEvent): void;

                        /**
                         * @since 1.2.7
                         * @param event
                         */
                        triggerEventJoin(event: Events.BaseEvent): void;

                        /**
                         * @since 1.2.7
                         * @param event
                         */
                        triggerEventNoAnything(event: Events.BaseEvent): void;

                        /**
                         * @since 1.2.7
                         * @param event
                         */
                        triggerEventJoinNoAnything(event: Events.BaseEvent): void;
                        init(defaultProfile: string): void;
                        getCurrentProfileName(): string;
                        renameCurrentProfile(profile: string): void;

                    }

                    const ConfigManager: JavaClassStatics<ConfigManager, ConfigManager$$constructor>;
                    interface ConfigManager$$constructor extends SuppressProperties {

                        new (configFolder: java.io.File, macroFolder: java.io.File, logger: org.slf4j.Logger): ConfigManager;

                    }
                    interface ConfigManager extends JavaObject {
                        readonly optionClasses: JavaMap<string, JavaClass<any>>;
                        readonly options: JavaMap<JavaClass<any>, any>;
                        readonly configFolder: java.io.File;
                        readonly macroFolder: java.io.File;
                        readonly configFile: java.io.File;
                        readonly LOGGER: org.slf4j.Logger;
                        rawOptions: com.google.gson.JsonObject;

                        reloadRawConfigFromFile(): void;
                        convertConfigFormat(): void;
                        convertConfigFormat(clazz: JavaClassArg<any>): void;
                        getOptions<T>(optionClass: JavaClassArg<T>): T;
                        addOptions(key: string, optionClass: JavaClassArg<any>): void;
                        loadConfig(): void;
                        loadDefaults(): void;
                        saveConfig(): void;

                    }

                    const ScriptTrigger: JavaClassStatics<ScriptTrigger, ScriptTrigger$$constructor> & {

                        copy(m: ScriptTrigger): ScriptTrigger;

                    }
                    interface ScriptTrigger$$constructor extends SuppressProperties {

                        new (triggerType: ScriptTrigger$TriggerType, event: string, scriptFile: java.io.File, enabled: boolean): ScriptTrigger;
                        /** @deprecated */
                        new (triggerType: ScriptTrigger$TriggerType, event: string, scriptFile: string, enabled: boolean): ScriptTrigger;

                    }
                    interface ScriptTrigger extends JavaObject {
                        triggerType: ScriptTrigger$TriggerType;
                        event: string;
                        scriptFile: string;
                        enabled: boolean;

                        equals(macro: ScriptTrigger): boolean;
                        equals(arg0: any): boolean;
                        copy(): ScriptTrigger;

                        /**
                         * @since 1.2.7
                         * @return
                         */
                        getTriggerType(): ScriptTrigger$TriggerType;

                        /**
                         * @since 1.2.7
                         * @return
                         */
                        getEvent(): string;

                        /**
                         * @since 1.2.7
                         * @return
                         */
                        getScriptFile(): string;

                        /**
                         * @since 1.2.7
                         * @return
                         */
                        getEnabled(): boolean;

                    }

                    /**
                     * @since 1.0.0 [citation needed]
                     * @author Wagyourtail
                     */
                    const ScriptTrigger$TriggerType: JavaClassStatics<ScriptTrigger$TriggerType> & NoConstructor & {
                        readonly KEY_FALLING: ScriptTrigger$TriggerType;
                        readonly KEY_RISING: ScriptTrigger$TriggerType;
                        readonly KEY_BOTH: ScriptTrigger$TriggerType;
                        readonly EVENT: ScriptTrigger$TriggerType;

                        values(): JavaArray<ScriptTrigger$TriggerType>;
                        valueOf(name: string): ScriptTrigger$TriggerType;

                    }
                    interface ScriptTrigger$TriggerType extends java.lang.Enum<ScriptTrigger$TriggerType> {}

                    export {
                        BaseProfile,
                        ConfigManager,
                        ScriptTrigger,
                        ScriptTrigger$TriggerType
                    }

                }

                namespace service {

                    /**
                     * @author Wagyourtail
                     * @since 1.6.3
                     */
                    const ServiceManager: JavaClassStatics<ServiceManager, ServiceManager$$constructor>;
                    interface ServiceManager$$constructor extends SuppressProperties {

                        new (runner: xyz.wagyourtail.jsmacros.core.Core<any, any>): ServiceManager;

                    }
                    interface ServiceManager extends JavaObject {

                        /**
                         * @param name
                         * @param pathToFile relative to macro folder
                         * @return false if service with that name is already registered
                         */
                        registerService(name: string, pathToFile: string): boolean;

                        /**
                         * @param name
                         * @param pathToFile relative to macro folder
                         * @param enabled
                         * @return false if service with that name is already registered
                         */
                        registerService(name: string, pathToFile: string, enabled: boolean): boolean;

                        /**
                         * @param name
                         * @param trigger
                         * @return false if service with that name already registered
                         */
                        registerService(name: string, trigger: ServiceTrigger): boolean;

                        /**
                         * @param name
                         * @return
                         */
                        unregisterService(name: string): boolean;

                        /**
                         * @param serviceName the name of the service to disable the reload feature for
                         * @since 1.8.4
                         */
                        disableReload(serviceName: string): void;

                        /**
                         * @param oldName
                         * @param newName
                         * @return false if service with new name already registered or old name doesn't exist
                         */
                        renameService(oldName: string, newName: string): boolean;

                        /**
                         * @return registered service names
                         */
                        getServices(): JavaSet<string>;

                        /**
                         * starts service once
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus#UNKNOWN} if unknown service)
                         */
                        startService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus#UNKNOWN} if unknown service)
                         */
                        stopService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return state before "restarting" (or {@link ServiceStatus#UNKNOWN} if unknown service)
                         */
                        restartService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus#UNKNOWN} if unknown service)
                         */
                        enableService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name service name
                         * @return previous state (or {@link ServiceStatus#UNKNOWN} if unknown service)
                         */
                        disableService(name: string): ServiceManager$ServiceStatus;

                        /**
                         * @param name the name of the service to check
                         * @return {@code true} if the service is running, {@code false} otherwise.
                         * @since 1.8.4
                         */
                        isRunning(name: string): boolean;

                        /**
                         * @param name the name of the service to check
                         * @return {@code true} if the service is enabled, {@code false} otherwise.
                         * @since 1.8.4
                         */
                        isEnabled(name: string): boolean;

                        /**
                         * @param name service name
                         * @return {@link ServiceStatus#UNKNOWN} if unknown service, {@link ServiceStatus#RUNNING} if disabled and running, {@link ServiceStatus#DISABLED} if disabled and stopped, {@link ServiceStatus#STOPPED} if enabled and stopped, {@link ServiceStatus#ENABLED} if enabled and running.
                         */
                        status(name: string): ServiceManager$ServiceStatus;

                        /**
                         * this might throw if the service is not running...
                         * @param name
                         * @since 1.6.5
                         * @return the event that is current for the service
                         */
                        getServiceData(name: string): EventService;

                        /**
                         * @param name
                         * @since 1.6.5 [named getServiceData previously]
                         * @return
                         */
                        getTrigger(name: string): ServiceTrigger;

                        /**
                         * load services from config
                         */
                        load(): void;

                        /**
                         * save current registered services & enabled/disabled status to config
                         */
                        save(): void;

                        /**
                         * Stops the service manager from reloading scrips on file changes.
                         * @since 1.8.4
                         */
                        stopReloadListener(): void;

                        /**
                         * Will make the service manager reload scripts on file changes.
                         * @since 1.8.4
                         */
                        startReloadListener(): void;

                        /**
                         * Mark a service as crashed so that it can be reloaded when its file changes. Crashed services
                         *  must be marked so that file change listener knows to restart them even if they are not
                         *  running because they crashed.
                         * @param serviceName the name of the service to mark as crashed
                         * @since 1.8.4
                         */
                        markCrashed(serviceName: string): void;

                        /**
                         * @param serviceName the name of the service to check
                         * @return {@code true} if the service previously crashed, {@code false} otherwise.
                         * @since 1.8.4
                         */
                        isCrashed(serviceName: string): boolean;

                        /**
                         * Ticks the service manager. This will check if any services need to be reloaded and reloads
                         *  them if necessary.
                         * @since 1.8.4
                         */
                        tickReloadListener(): void;

                    }

                    const ServiceManager$ServiceStatus: JavaClassStatics<ServiceManager$ServiceStatus> & NoConstructor & {
                        readonly ENABLED: ServiceManager$ServiceStatus;
                        readonly DISABLED: ServiceManager$ServiceStatus;
                        readonly RUNNING: ServiceManager$ServiceStatus;
                        readonly STOPPED: ServiceManager$ServiceStatus;
                        readonly UNKNOWN: ServiceManager$ServiceStatus;

                        values(): JavaArray<ServiceManager$ServiceStatus>;
                        valueOf(name: string): ServiceManager$ServiceStatus;

                    }
                    interface ServiceManager$ServiceStatus extends java.lang.Enum<ServiceManager$ServiceStatus> {}

                    const ServiceTrigger: JavaClassStatics<ServiceTrigger, ServiceTrigger$$constructor>;
                    interface ServiceTrigger$$constructor extends SuppressProperties {

                        new (file: java.io.File, enabled: boolean): ServiceTrigger;

                    }
                    interface ServiceTrigger extends JavaObject {
                        file: string;
                        enabled: boolean;

                        toScriptTrigger(): xyz.wagyourtail.jsmacros.core.config.ScriptTrigger;

                    }

                    /** @since 1.6.4 */
                    const EventService: JavaClassStatics<EventService, EventService$$constructor>;
                    interface EventService$$constructor extends SuppressProperties {

                        new (name: string): EventService;

                    }
                    interface EventService extends Events.BaseEvent {
                        readonly serviceName: string;

                        /**
                         * when this service is stopped, this is run...
                         */
                        stopListener: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>;

                        /**
                         * Put an Integer into the global variable space.
                         * @param name
                         * @param i
                         * @return 
                         * @since 1.6.5
                         */
                        putInt(name: string, i: int): number;

                        /**
                         * put a String into the global variable space.
                         * @param name
                         * @param str
                         * @return 
                         * @since 1.6.5
                         */
                        putString(name: string, str: string): string;

                        /**
                         * put a Double into the global variable space.
                         * @param name
                         * @param d
                         * @return 
                         * @since 1.6.5
                         */
                        putDouble(name: string, d: double): number;

                        /**
                         * put a Boolean into the global variable space.
                         * @param name
                         * @param b
                         * @return 
                         * @since 1.6.5
                         */
                        putBoolean(name: string, b: boolean): boolean;

                        /**
                         * put anything else into the global variable space.
                         * @param name
                         * @param o
                         * @return 
                         * @since 1.6.5
                         */
                        putObject(name: string, o: any): any;

                        /**
                         * Returns the type of the defined item in the global variable space as a string.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getType(name: string): string;

                        /**
                         * Gets an Integer from the global variable space.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getInt(name: string): number;

                        /**
                         * Gets an Integer from the global variable space. and then increment it there.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getAndIncrementInt(name: string): number;

                        /**
                         * Gets an integer from the global variable pace. and then decrement it there.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getAndDecrementInt(name: string): number;

                        /**
                         * increment an Integer in the global variable space. then return it.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        incrementAndGetInt(name: string): number;

                        /**
                         * decrement an Integer in the global variable space. then return it.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        decrementAndGetInt(name: string): number;

                        /**
                         * Gets a String from the global variable space
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getString(name: string): string;

                        /**
                         * Gets a Double from the global variable space.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getDouble(name: string): number;

                        /**
                         * Gets a Boolean from the global variable space.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getBoolean(name: string): boolean;

                        /**
                         * toggles a global boolean and returns its new value
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        toggleBoolean(name: string): boolean;

                        /**
                         * Gets an Object from the global variable space.
                         * @param name
                         * @return 
                         * @since 1.6.5
                         */
                        getObject(name: string): any;

                        /**
                         * removes a key from the global variable space.
                         * @param key
                         * @since 1.6.5
                         */
                        remove(key: string): void;
                        getRaw(): JavaMap<string, any>;

                    }

                    export {
                        ServiceManager,
                        ServiceManager$ServiceStatus,
                        ServiceTrigger,
                        EventService
                    }

                }

                namespace event {

                    /**
                     * @author Wagyourtail
                     * @since 1.2.7
                     */
                    const BaseEventRegistry: JavaClassStatics<BaseEventRegistry, BaseEventRegistry$$constructor>;
                    interface BaseEventRegistry$$constructor extends SuppressProperties {

                        new (runner: xyz.wagyourtail.jsmacros.core.Core): BaseEventRegistry;

                    }
                    interface BaseEventRegistry extends JavaObject {
                        readonly oldEvents: JavaMap<string, string>;
                        readonly events: JavaSet<string>;

                        clearMacros(): void;

                        /**
                         * @since 1.1.2 [citation needed]
                         * @param rawmacro
                         */
                        addScriptTrigger(rawmacro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger): void;

                        /**
                         * @since 1.2.3
                         * @param event
                         * @param listener
                         */
                        addListener(event: string, listener: IEventListener): void;

                        /**
                         * @since 1.2.3
                         * @param event
                         * @param listener
                         * @return
                         */
                        removeListener(event: string, listener: IEventListener): boolean;

                        /**
                         * @since 1.2.3
                         * @param listener
                         * @return
                         * @deprecated
                         */
                        removeListener(listener: IEventListener): boolean;

                        /**
                         * @since 1.1.2 [citation needed]
                         * @param rawmacro
                         * @return
                         */
                        removeScriptTrigger(rawmacro: xyz.wagyourtail.jsmacros.core.config.ScriptTrigger): boolean;

                        /**
                         * @since 1.2.3
                         * @return
                         */
                        getListeners(): JavaMap<string, JavaSet<IEventListener>>;

                        /**
                         * @since 1.2.3
                         * @param key
                         * @return
                         */
                        getListeners(key: string): JavaSet<IEventListener>;

                        /**
                         * @see ScriptTrigger
                         * @since 1.1.2 [citation needed]
                         * @return
                         */
                        getScriptTriggers(): JavaList<xyz.wagyourtail.jsmacros.core.config.ScriptTrigger>;

                        /**
                         * @since 1.1.2 [citation needed]
                         * @param eventName
                         */
                        addEvent(eventName: string): void;
                        addEvent(clazz: JavaClassArg<any>): void;

                    }

                    const IEventListener: JavaInterfaceStatics<IEventListener>;
                    interface IEventListener extends JavaObject {

                        trigger(event: BaseEvent): xyz.wagyourtail.jsmacros.core.language.EventContainer<any>;

                        /**
                         * Used for self unregistering events.
                         * @since 1.8.4
                         */
                        off(): void;

                    }

                    const BaseEvent: JavaInterfaceStatics<BaseEvent> & {
                        readonly profile: xyz.wagyourtail.jsmacros.core.config.BaseProfile;
                    }
                    interface BaseEvent extends JavaObject {

                        getEventName(): string;

                    }

                    export { BaseEventRegistry, IEventListener, BaseEvent }

                }
                namespace event {

                    namespace impl {

                        /**
                         * Custom Events
                         * @author Wagyourtail
                         * @since 1.2.8
                         */
                        const EventCustom: JavaClassStatics<EventCustom, EventCustom$$constructor>;
                        interface EventCustom$$constructor extends SuppressProperties {

                            /**
                             * @param eventName name of the event. please don't use an existing one... your scripts might not like that.
                             */
                            new (eventName: string): EventCustom;

                        }
                        interface EventCustom extends Events.BaseEvent {
                            eventName: string;

                            /**
                             * Triggers the event.  
                             *  Try not to cause infinite looping by triggering the same {@link EventCustom} from its own listeners.
                             * @since 1.2.8
                             */
                            trigger(): void;

                            /**
                             * trigger the event listeners, then run `callback` when they finish.
                             * @since 1.3.1
                             * @param callback used as a {@link Runnable}, so no args, no return value.
                             */
                            trigger(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): void;

                            /**
                             * Triggers the event and waits for it to complete.  
                             *  In languages with threading issues (js/jep) this may cause circular waiting when triggered from the same thread as
                             *  the `jsmacros.on` registration for the event
                             * @since 1.2.8
                             */
                            triggerJoin(): void;

                            /**
                             * Put an Integer into the event.
                             * @param name
                             * @param i
                             * @return 
                             * @since 1.2.8
                             */
                            putInt(name: string, i: int): number;

                            /**
                             * put a String into the event.
                             * @param name
                             * @param str
                             * @return 
                             * @since 1.2.8
                             */
                            putString(name: string, str: string): string;

                            /**
                             * put a Double into the event.
                             * @param name
                             * @param d
                             * @return 
                             * @since 1.2.8
                             */
                            putDouble(name: string, d: double): number;

                            /**
                             * put a Boolean into the event.
                             * @param name
                             * @param b
                             * @return 
                             * @since 1.2.8
                             */
                            putBoolean(name: string, b: boolean): boolean;

                            /**
                             * put anything else into the event.
                             * @param name
                             * @param o
                             * @return 
                             * @since 1.2.8
                             */
                            putObject(name: string, o: any): any;

                            /**
                             * Returns the type of the defined item in the event as a string.
                             * @param name
                             * @return 
                             * @since 1.2.8
                             */
                            getType(name: string): string;

                            /**
                             * Gets an Integer from the event.
                             * @param name
                             * @return 
                             * @since 1.2.8
                             */
                            getInt(name: string): number;

                            /**
                             * Gets a String from the event
                             * @param name
                             * @return 
                             * @since 1.2.8
                             */
                            getString(name: string): string;

                            /**
                             * Gets a Double from the event.
                             * @param name
                             * @return 
                             * @since 1.2.8
                             */
                            getDouble(name: string): number;

                            /**
                             * Gets a Boolean from the event.
                             * @param name
                             * @return 
                             * @since 1.2.8
                             */
                            getBoolean(name: string): boolean;

                            /**
                             * Gets an Object from the event.
                             * @param name
                             * @return 
                             * @since 1.2.8
                             */
                            getObject(name: string): any;

                            /**
                             * @since 1.6.4
                             * @return map backing the event
                             */
                            getUnderlyingMap(): JavaMap<string, any>;

                            /**
                             * registers event so you can see it in the gui
                             * @since 1.3.0
                             */
                            registerEvent(): void;

                        }

                        export { EventCustom }

                    }

                }

                namespace classes {

                    /**
                     * @author Wagyourtail
                     * @since 1.3.1
                     */
                    const Mappings: JavaClassStatics<Mappings, Mappings$$constructor>;
                    interface Mappings$$constructor extends SuppressProperties {

                        new (mappingsource: string): Mappings;

                    }
                    interface Mappings extends JavaObject {
                        readonly mappingsource: string;

                        /**
                         * @return mappings from Intermediary to Named
                         * @since 1.3.1
                         * @throws IOException will throw if malformed url/path
                         */
                        getMappings(): JavaMap<string, Mappings$ClassData>;

                        /**
                         * @return mappings from Named to Intermediary
                         * @since 1.3.1
                         * @throws IOException will throw if malformed url/path
                         */
                        getReversedMappings(): JavaMap<string, Mappings$ClassData>;

                        /**
                         * @since 1.6.0
                         * @return
                         */
                        remapClass<T>(instance: T): Mappings$MappedClass<T>;

                        /**
                         * gets the class without instance, so can only access static methods/fields
                         * @param className
                         * @return 
                         * @throws IOException
                         * @throws ClassNotFoundException
                         */
                        getClass(className: string): Mappings$MappedClass<any>;

                    }

                    /**
                     * @since 1.6.5
                     * @param <T> the type of the wrapped class
                     */
                    const WrappedClassInstance: JavaClassStatics<WrappedClassInstance<any>, WrappedClassInstance$$constructor>;
                    interface WrappedClassInstance$$constructor extends SuppressProperties {

                        new <T>(instance: T): WrappedClassInstance<T>;
                        new <T>(instanceNullable: T, tClass: JavaClassArg<T>): WrappedClassInstance<T>;

                    }
                    interface WrappedClassInstance<T> extends JavaObject {

                        getFieldValue(fieldName: string): any;
                        getFieldValueAsClass(asClass: string, fieldName: string): any;
                        setFieldValue(fieldName: string, fieldValue: any): void;
                        setFieldValueAsClass(asClass: string, fieldName: string, fieldValue: any): void;
                        invokeMethod(methodNameOrSig: string, ...params: any[]): any;
                        invokeMethodAsClass(asClass: string, methodNameOrSig: string, ...params: any[]): any;

                        /**
                         * @since 1.6.5
                         * @return
                         */
                        getRawInstance(): T;

                        /**
                         * @since 1.6.5
                         * @return
                         */
                        getRawClass(): JavaClass<T>;

                    }

                    /** @since 1.6.0 */
                    const Mappings$MappedClass: JavaClassStatics<Mappings$MappedClass<any>, Mappings$MappedClass$$constructor>;
                    interface Mappings$MappedClass$$constructor extends SuppressProperties {

                        new <T>(instance: T): Mappings$MappedClass<T>;
                        new <T>(instance: T, type: JavaClassArg<T>): Mappings$MappedClass<T>;

                    }
                    interface Mappings$MappedClass<T> extends WrappedClassInstance<T> {}

                    const Mappings$ClassData: JavaClassStatics<Mappings$ClassData, Mappings$ClassData$$constructor>;
                    interface Mappings$ClassData$$constructor extends SuppressProperties {

                        new (name: string): Mappings$ClassData;

                    }
                    interface Mappings$ClassData extends JavaObject {
                        readonly methods: JavaMap<string, Mappings$MethodData>;
                        readonly fields: JavaMap<string, string>;
                        readonly name: string;
                    }

                    const Mappings$MethodData: JavaClassStatics<Mappings$MethodData, Mappings$MethodData$$constructor>;
                    interface Mappings$MethodData$$constructor extends SuppressProperties {

                        new (name: string, sig: java.util.function.Supplier<string>): Mappings$MethodData;

                    }
                    interface Mappings$MethodData extends JavaObject {
                        readonly name: string;
                        readonly sig: java.util.function.Supplier<string>;
                    }

                    export {
                        Mappings,
                        WrappedClassInstance,
                        Mappings$MappedClass,
                        Mappings$ClassData,
                        Mappings$MethodData
                    }

                }

                namespace extensions {

                    const ExtensionLoader: JavaClassStatics<ExtensionLoader, ExtensionLoader$$constructor>;
                    interface ExtensionLoader$$constructor extends SuppressProperties {

                        new (core: xyz.wagyourtail.jsmacros.core.Core<any, any>): ExtensionLoader;

                    }
                    interface ExtensionLoader extends JavaObject {

                        isExtensionLoaded(name: string): boolean;
                        notLoaded(): boolean;
                        getHighestPriorityExtension(): Extension;
                        getAllExtensions(): JavaSet<Extension>;
                        getExtensionForFile(file: java.io.File): Extension | null;
                        getExtensionForName(lang: string): Extension;
                        loadExtensions(): void;
                        isGuestObject(obj: any): boolean;

                    }

                    const Extension: JavaInterfaceStatics<Extension> & {

                        getDependenciesInternal(clazz: JavaClassArg<any>, fname: string): JavaSet<java.net.URL>;
                        getTranslationsInternal(clazz: JavaClassArg<any>, fname: string): JavaMap<string, string>;

                    }
                    interface Extension extends JavaObject {

                        init(): void;
                        getPriority(): number;
                        getLanguageImplName(): string;
                        extensionMatch(file: java.io.File): Extension$ExtMatch;
                        defaultFileExtension(): string;

                        /**
                         * @return a single static instance of the language definition
                         */
                        getLanguage(runner: xyz.wagyourtail.jsmacros.core.Core<any, any>): xyz.wagyourtail.jsmacros.core.language.BaseLanguage<any, any>;
                        getLibraries(): JavaSet<JavaClass<any>>;
                        getDependencies(): JavaSet<java.net.URL>;
                        wrapException(t: java.lang.Throwable): xyz.wagyourtail.jsmacros.core.language.BaseWrappedException<any>;
                        getTranslations(lang: string): JavaMap<string, string>;
                        isGuestObject(o: any): boolean;

                    }

                    const Extension$ExtMatch: JavaClassStatics<Extension$ExtMatch> & NoConstructor & {
                        readonly NOT_MATCH: Extension$ExtMatch;
                        readonly MATCH: Extension$ExtMatch;
                        readonly MATCH_WITH_NAME: Extension$ExtMatch;

                        values(): JavaArray<Extension$ExtMatch>;
                        valueOf(name: string): Extension$ExtMatch;

                    }
                    interface Extension$ExtMatch extends java.lang.Enum<Extension$ExtMatch> {

                        isMatch(): boolean;

                    }

                    export { ExtensionLoader, Extension, Extension$ExtMatch }

                }

            }

            namespace client {

                namespace api {

                    namespace helpers {

                        /** @since 1.6.5 */
                        const SuggestionsBuilderHelper: JavaClassStatics<SuggestionsBuilderHelper, SuggestionsBuilderHelper$$constructor>;
                        interface SuggestionsBuilderHelper$$constructor extends SuppressProperties {

                            new (base: com.mojang.brigadier.suggestion.SuggestionsBuilder): SuggestionsBuilderHelper;

                        }
                        interface SuggestionsBuilderHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<com.mojang.brigadier.suggestion.SuggestionsBuilder> {

                            getInput(): string;
                            getStart(): number;
                            getRemaining(): string;
                            getRemainingLowerCase(): string;
                            suggest(suggestion: string): SuggestionsBuilderHelper;
                            suggest(value: int): SuggestionsBuilderHelper;
                            suggestWithTooltip(suggestion: string, tooltip: TextHelper): SuggestionsBuilderHelper;
                            suggestWithTooltip(value: int, tooltip: TextHelper): SuggestionsBuilderHelper;

                            /**
                             * @param suggestions the strings to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestMatching(...suggestions: string[]): SuggestionsBuilderHelper;

                            /**
                             * @param suggestions the strings to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestMatching(suggestions: JavaCollection<string>): SuggestionsBuilderHelper;

                            /**
                             * @param identifiers the identifiers to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestIdentifier(...identifiers: string[]): SuggestionsBuilderHelper;

                            /**
                             * @param identifiers the identifiers to match
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestIdentifier(identifiers: JavaCollection<string>): SuggestionsBuilderHelper;

                            /**
                             * @param positions the positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestBlockPositions(...positions: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper[]): SuggestionsBuilderHelper;

                            /**
                             * @param positions the positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestBlockPositions(positions: JavaCollection<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>): SuggestionsBuilderHelper;

                            /**
                             * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                             *  minecraft selectors "~" and "^" followed by a number.
                             * @param positions the positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestPositions(...positions: string[]): SuggestionsBuilderHelper;

                            /**
                             * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                             *  minecraft selectors "~" and "^" followed by a number.
                             * @param positions the relative positions to suggest
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            suggestPositions(positions: JavaCollection<string>): SuggestionsBuilderHelper;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const OptionsHelper: JavaClassStatics<OptionsHelper, OptionsHelper$$constructor>;
                        interface OptionsHelper$$constructor extends SuppressProperties {

                            new (options: /* minecraft class */ any): OptionsHelper;

                        }
                        interface OptionsHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {
                            readonly skin: OptionsHelper$SkinOptionsHelper;
                            readonly video: OptionsHelper$VideoOptionsHelper;
                            readonly music: OptionsHelper$MusicOptionsHelper;
                            readonly control: OptionsHelper$ControlOptionsHelper;
                            readonly chat: OptionsHelper$ChatOptionsHelper;
                            readonly accessibility: OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return a helper for the skin options.
                             * @since 1.8.4
                             */
                            getSkinOptions(): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @return a helper for the video options.
                             * @since 1.8.4
                             */
                            getVideoOptions(): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return a helper for the music options.
                             * @since 1.8.4
                             */
                            getMusicOptions(): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return a helper for the control options.
                             * @since 1.8.4
                             */
                            getControlOptions(): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return a helper for the chat options.
                             * @since 1.8.4
                             */
                            getChatOptions(): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return a helper for the accessibility options.
                             * @since 1.8.4
                             */
                            getAccessibilityOptions(): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            saveOptions(): OptionsHelper;

                            /**
                             * @return list of names of resource packs.
                             * @since 1.1.7
                             */
                            getResourcePacks(): JavaList<string>;

                            /**
                             * @return list of names of enabled resource packs.
                             * @since 1.2.0
                             */
                            getEnabledResourcePacks(): JavaList<string>;

                            /**
                             * Set the enabled resource packs to the provided list.
                             * @param enabled
                             * @return self for chaining.
                             * @since 1.2.0
                             */
                            setEnabledResourcePacks(enabled: string[]): OptionsHelper;

                            /**
                             * @param state false to put it back
                             * @since 1.8.3
                             */
                            removeServerResourcePack(state: boolean): OptionsHelper;

                            /**
                             * @return the active language.
                             * @since 1.8.4
                             */
                            getLanguage(): Locale;

                            /**
                             * @param languageCode the language to change to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setLanguage(languageCode: Locale): OptionsHelper;

                            /**
                             * @return the active difficulty.
                             * @since 1.8.4
                             */
                            getDifficulty(): Difficulty;

                            /**
                             * The name be either "peaceful", "easy", "normal", or "hard".
                             * @param name the name of the difficulty to change to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDifficulty(name: Difficulty): OptionsHelper;

                            /**
                             * @return {@code true} if the difficulty is locked, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isDifficultyLocked(): boolean;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            lockDifficulty(): OptionsHelper;

                            /**
                             * Unlocks the difficulty of the world. This can't be done in an unmodified client.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            unlockDifficulty(): OptionsHelper;

                            /**
                             * @return the current fov value.
                             * @since 1.1.7
                             */
                            getFov(): number;

                            /**
                             * @param fov the new fov value
                             * @return self for chaining.
                             * @since 1.1.7
                             */
                            setFov(fov: int): OptionsHelper;

                            /**
                             * @return 0 for 1st person, 2 for in front.
                             * @since 1.5.0
                             */
                            getCameraMode(): Trit;

                            /**
                             * @param mode 0: first, 2: front
                             * @since 1.5.0
                             */
                            setCameraMode(mode: Trit): OptionsHelper;

                            /**
                             * @return 
                             * @since 1.5.0
                             */
                            getSmoothCamera(): boolean;

                            /**
                             * @param val
                             * @since 1.5.0
                             */
                            setSmoothCamera(val: boolean): OptionsHelper;

                            /**
                             * @return 
                             * @since 1.2.6
                             */
                            getWidth(): number;

                            /**
                             * @return 
                             * @since 1.2.6
                             */
                            getHeight(): number;

                            /**
                             * @param w
                             * @since 1.2.6
                             */
                            setWidth(w: int): OptionsHelper;

                            /**
                             * @param h
                             * @since 1.2.6
                             */
                            setHeight(h: int): OptionsHelper;

                            /**
                             * @param w
                             * @param h
                             * @since 1.2.6
                             */
                            setSize(w: int, h: int): OptionsHelper;

                            /**
                             * @return 0: off, 2: fancy
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper#getCloudsMode()} instead.
                             */
                            getCloudMode(): Trit;

                            /**
                             * @param mode 0: off, 2: fancy
                             * @return 
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper#setCloudsMode(String)} instead.
                             */
                            setCloudMode(mode: Trit): OptionsHelper;

                            /**
                             * @return 
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper#getGraphicsMode()} instead.
                             */
                            getGraphicsMode(): number;

                            /**
                             * @param mode 0: fast, 2: fabulous
                             * @return 
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper#setGraphicsMode(String)} instead.
                             */
                            setGraphicsMode(mode: int): OptionsHelper;

                            /**
                             * @return 
                             * @since 1.1.7
                             * @deprecated use {@link SkinOptionsHelper#isRightHanded()} instead.
                             */
                            isRightHanded(): boolean;

                            /**
                             * @param val
                             * @since 1.1.7
                             * @deprecated use {@link SkinOptionsHelper#toggleMainHand(String)} instead.
                             */
                            setRightHanded(val: boolean): OptionsHelper;

                            /**
                             * @return 
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper#getRenderDistance()} instead.
                             */
                            getRenderDistance(): number;

                            /**
                             * @param d
                             * @since 1.1.7
                             * @deprecated use {@link VideoOptionsHelper#setRenderDistance(int)} instead.
                             */
                            setRenderDistance(d: int): OptionsHelper;

                            /**
                             * @since 1.3.0 normal values for gamma are between {@code 0} and {@code 1}
                             * @deprecated use {@link VideoOptionsHelper#getGamma()} instead.
                             */
                            getGamma(): number;

                            /**
                             * @since 1.3.0 normal values for gamma are between {@code 0} and {@code 1}
                             * @deprecated use {@link VideoOptionsHelper#setGamma(double)} instead.
                             */
                            setGamma(gamma: double): OptionsHelper;

                            /**
                             * @param vol
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper#setMasterVolume(double)} instead.
                             */
                            setVolume(vol: double): OptionsHelper;

                            /**
                             * set volume by category.
                             * @param category
                             * @param volume
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper#setVolume(String, double)} instead.
                             */
                            setVolume(category: SoundCategory, volume: double): OptionsHelper;

                            /**
                             * @return 
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper#getVolumes()} instead.
                             */
                            getVolumes(): JavaMap<string, number>;

                            /**
                             * sets gui scale, `0` for auto.
                             * @param scale
                             * @since 1.3.1
                             * @deprecated use {@link VideoOptionsHelper#setGuiScale(int)} instead.
                             */
                            setGuiScale(scale: int): OptionsHelper;

                            /**
                             * @return gui scale, {@code 0} for auto.
                             * @since 1.3.1
                             * @deprecated use {@link VideoOptionsHelper#getGuiScale()} instead.
                             */
                            getGuiScale(): number;

                            /**
                             * @param category
                             * @return 
                             * @since 1.3.1
                             * @deprecated use {@link MusicOptionsHelper#getVolume(String)} instead.
                             */
                            getVolume(category: SoundCategory): number;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const ModContainerHelper: JavaClassStatics<ModContainerHelper<any>> & NoConstructor;
                        interface ModContainerHelper<T> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {

                            /**
                             * @return the mod's id.
                             * @since 1.8.4
                             */
                            getId(): string;

                            /**
                             * @return the mod's name.
                             * @since 1.8.4
                             */
                            getName(): string;

                            /**
                             * @return the mod's description.
                             * @since 1.8.4
                             */
                            getDescription(): string;

                            /**
                             * @return the mod's version.
                             * @since 1.8.4
                             */
                            getVersion(): string;

                            /**
                             * @return the environment this mod is intended for.
                             * @since 1.8.4
                             */
                            getEnv(): string;

                            /**
                             * @return a list of all authors.
                             * @since 1.8.4
                             */
                            getAuthors(): JavaList<string>;

                            /**
                             * @return a list of all dependencies.
                             * @since 1.8.4
                             */
                            getDependencies(): JavaList<string>;

                        }

                        /**
                         * @author Wagyourtail
                         * @since 1.6.5
                         */
                        const StyleHelper: JavaClassStatics<StyleHelper, StyleHelper$$constructor>;
                        interface StyleHelper$$constructor extends SuppressProperties {

                            new (base: /* minecraft class */ any): StyleHelper;

                        }
                        interface StyleHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            hasColor(): boolean;

                            /**
                             * @return the color index of this style or {@code -1} if no color is set.
                             * @deprecated use {@link #getColorIndex()} instead.
                             */
                            getColor(): number;

                            /**
                             * @return the formatting of this style, or {@code null} if no formatting was found.
                             * @since 1.8.4
                             */
                            getFormatting(): FormattingHelper;

                            /**
                             * @return the color index of this style or {@code -1} if no color is set.
                             * @since 1.8.4
                             */
                            getColorIndex(): number;

                            /**
                             * @return the color value of this style or {@code -1} if it doesn't have one.
                             * @since 1.8.4
                             */
                            getColorValue(): number;

                            /**
                             * @return the color name of this style or {@code null} if it has no color.
                             * @since 1.8.4
                             */
                            getColorName(): string;
                            hasCustomColor(): boolean;
                            getCustomColor(): number;
                            bold(): boolean;
                            italic(): boolean;
                            underlined(): boolean;
                            strikethrough(): boolean;
                            obfuscated(): boolean;
                            getClickAction(): TextClickAction;
                            getClickValue(): string;
                            getCustomClickValue(): java.lang.Runnable;
                            getHoverAction(): TextHoverAction;
                            getHoverValue(): any;
                            getInsertion(): string;

                        }

                        /** @since 1.4.2 */
                        const CommandContextHelper: JavaClassStatics<CommandContextHelper, CommandContextHelper$$constructor>;
                        interface CommandContextHelper$$constructor extends SuppressProperties {

                            new (base: com.mojang.brigadier.context.CommandContext<any>): CommandContextHelper;

                        }
                        interface CommandContextHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<com.mojang.brigadier.context.CommandContext<any>>, Events.BaseEvent {

                            /**
                             * @param name
                             * @return 
                             * @since 1.4.2
                             * @throws CommandSyntaxException
                             */
                            getArg(name: string): any;
                            getChild(): CommandContextHelper;
                            getRange(): com.mojang.brigadier.context.StringRange;
                            getInput(): string;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const PacketByteBufferHelper: JavaClassStatics<PacketByteBufferHelper, PacketByteBufferHelper$$constructor> & {

                            /**
                             * Don't touch this here!
                             */
                            readonly BUFFER_TO_PACKET: JavaMap<JavaClass<any>, java.util.function.Function</* minecraft class */ any, any>>;

                            getPacketName(packet: /* minecraft class */ any): string;
                            init(): void;
                            main(args: string[]): void;

                        }
                        interface PacketByteBufferHelper$$constructor extends SuppressProperties {

                            new (): PacketByteBufferHelper;
                            new (base: /* minecraft class */ any): PacketByteBufferHelper;
                            new (packet: /* minecraft class */ any): PacketByteBufferHelper;

                        }
                        interface PacketByteBufferHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * @return the packet for this buffer or {@code null} if no packet was used to create this
                             *          helper.
                             * @since 1.8.4
                             */
                            toPacket(): /* minecraft class */ any;

                            /**
                             * @param packetName the name of the packet's class that should be returned
                             * @return the packet for this buffer.
                             * @see #getPacketNames()
                             * @since 1.8.4
                             */
                            toPacket(packetName: PacketName): /* minecraft class */ any;

                            /**
                             * @param clazz the class of the packet to return
                             * @return the packet for this buffer.
                             * @since 1.8.4
                             */
                            toPacket(clazz: JavaClassArg<any>): /* minecraft class */ any;

                            /**
                             * @param clientbound whether the packet is clientbound or serverbound
                             * @param packetId the id of the packet
                             * @return the packet for this buffer.
                             * @see #getPacketId(Class)
                             * @see #getNetworkStateId(Class)
                             * @see #isClientbound(Class)
                             * @see #isServerbound(Class)
                             * @since 1.8.4
                             */
                            toPacket(clientbound: boolean, packetId: int): /* minecraft class */ any;

                            /**
                             * @param packetClass the class of the packet to get the id for
                             * @return the id of the packet.
                             * @since 1.8.4
                             */
                            getPacketId(packetClass: JavaClassArg<any>): number;

                            /**
                             * @param packetClass the class of the packet to get the id for
                             * @return the id of the network state the packet belongs to.
                             * @since 1.8.4
                             */
                            getNetworkStateId(packetClass: JavaClassArg<any>): number;

                            /**
                             * @param packetClass the class to get the side for
                             * @return {@code true} if the packet is clientbound, {@code false} if it is serverbound.
                             * @since 1.8.4
                             */
                            isClientbound(packetClass: JavaClassArg<any>): boolean;

                            /**
                             * @param packetClass the class to get the id for
                             * @return {@code true} if the packet is serverbound, {@code false} if it is clientbound.
                             * @since 1.8.4
                             */
                            isServerbound(packetClass: JavaClassArg<any>): boolean;

                            /**
                             * Send a packet of the given type, created from this buffer, to the server.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendPacket(): PacketByteBufferHelper;

                            /**
                             * @param packetName the name of the packet's class that should be sent
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendPacket(packetName: string): PacketByteBufferHelper;

                            /**
                             * Send a packet of the given type, created from this buffer, to the server.
                             * @param clazz the class of the packet to send
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendPacket(clazz: JavaClassArg<any>): PacketByteBufferHelper;

                            /**
                             * @param channel the channel to send the packet on
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            sendCustomPacket(channel: string): PacketByteBufferHelper;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            receivePacket(): PacketByteBufferHelper;

                            /**
                             * @param packetName the name of the packet's class that should be received
                             * @return self for chaining.
                             * @see #getPacketNames()
                             * @since 1.8.4
                             */
                            receivePacket(packetName: string): PacketByteBufferHelper;

                            /**
                             * @param clazz the class of the packet to receive
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            receivePacket(clazz: JavaClassArg<any>): PacketByteBufferHelper;

                            /**
                             * @param channel the channel to receive the packet on
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            receiveCustomPacket(channel: string): PacketByteBufferHelper;

                            /**
                             * These names are subject to change and are only for an easier access. They will probably not
                             *  change in the future, but it is not guaranteed.
                             * @return a list of all packet names.
                             * @since 1.8.4
                             */
                            getPacketNames(): JavaList<PacketName>;

                            /**
                             * Resets the buffer to the state it was in when this helper was created.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            reset(): PacketByteBufferHelper;

                            /**
                             * @param registry the registry the value is from
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeRegistryValue<T>(registry: /* minecraft class */ any, value: T): PacketByteBufferHelper;

                            /**
                             * @param registry the registry the read value is from
                             * @return the registry value.
                             * @since 1.8.4
                             */
                            readRegistryValue<T>(registry: /* minecraft class */ any): T;

                            /**
                             * @param key the registry key to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeRegistryKey(key: /* minecraft class */ any): PacketByteBufferHelper;

                            /**
                             * @param registry the registry the read key is from
                             * @return the registry key.
                             * @since 1.8.4
                             */
                            readRegistryKey<T>(registry: /* minecraft class */ any): /* minecraft class */ any;

                            /**
                             * @param collection the collection to store
                             * @param writer the function that writes the collection's elements to the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeCollection<T>(collection: JavaCollection<T>, writer: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, T, any, any>): PacketByteBufferHelper;

                            /**
                             * @param reader the function that reads the collection's elements from the buffer
                             * @return the read list.
                             * @since 1.8.4
                             */
                            readList<T>(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, T, any>): JavaList<T>;

                            /**
                             * @param list the integer list to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeIntList(list: JavaCollection<int>): PacketByteBufferHelper;

                            /**
                             * @return the read integer list.
                             * @since 1.8.4
                             */
                            readIntList(): it.unimi.dsi.fastutil.ints.IntList;

                            /**
                             * @param map the map to store
                             * @param keyWriter the function to write the map's keys to the buffer
                             * @param valueWriter the function to write the map's values to the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeMap<K, V>(map: JavaMap<K, V>, keyWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, K, any, any>, valueWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, V, any, any>): PacketByteBufferHelper;

                            /**
                             * @param keyReader the function to read the map's keys from the buffer
                             * @param valueReader the function to read the map's values from the buffer
                             * @return the read map.
                             * @since 1.8.4
                             */
                            readMap<K, V>(keyReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, K, any>, valueReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, V, any>): JavaMap<K, V>;

                            /**
                             * @param reader the function to read the collection's elements from the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            forEachInCollection(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, any, any>): PacketByteBufferHelper;

                            /**
                             * @param value the optional value to store
                             * @param writer the function to write the optional value if present to the buffer
                             * @return self for chaining.
                             * @see #writeNullable(Object, MethodWrapper)
                             * @since 1.8.4
                             */
                            writeOptional<T>(value: T, writer: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, T, any, any>): PacketByteBufferHelper;

                            /**
                             * @param reader the function to read the optional value from the buffer if present
                             * @return the optional value.
                             * @see #readNullable(MethodWrapper)
                             * @since 1.8.4
                             */
                            readOptional<T>(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, T, any>): java.util.Optional<T>;

                            /**
                             * @param value the optional value to store
                             * @param writer the function to write the optional value if it's not null to the buffer
                             * @return self for chaining.
                             * @see #writeOptional(Object, MethodWrapper)
                             * @since 1.8.4
                             */
                            writeNullable(value: any, writer: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, any, any>): PacketByteBufferHelper;

                            /**
                             * @param reader the function to read the value from the buffer if it's not null
                             * @return the read value or {@code null} if it was null.
                             * @see #readOptional(MethodWrapper)
                             * @since 1.8.4
                             */
                            readNullable<T>(reader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, T, any>): T;

                            /**
                             * This method chooses the left value if it's not null, otherwise it chooses the right value.
                             * @param left the left value to store
                             * @param right the right value to store
                             * @param leftWriter the function to write the left value to the buffer
                             * @param rightWriter the function to write the right value to the buffer
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeEither<L, R>(left: L, right: R, leftWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, L, any, any>, rightWriter: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, R, any, any>): PacketByteBufferHelper;

                            /**
                             * @param leftReader the function to read the left value from the buffer
                             * @param rightReader the function to read the right value from the buffer
                             * @return the read object.
                             * @since 1.8.4
                             */
                            readEither(leftReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, any, any>, rightReader: xyz.wagyourtail.jsmacros.core.MethodWrapper</* minecraft class */ any, any, any, any>): any;

                            /**
                             * @param bytes the bytes to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeByteArray(bytes: byte[]): PacketByteBufferHelper;

                            /**
                             * @return the read byte array.
                             * @since 1.8.4
                             */
                            readByteArray(): JavaArray<number>;

                            /**
                             * Will throw an exception if the byte array is bigger than the given maximum size.
                             * @param maxSize the maximum size of the byte array to read
                             * @return the read byte array.
                             * @since 1.8.4
                             */
                            readByteArray(maxSize: int): JavaArray<number>;

                            /**
                             * @param ints the int array to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeIntArray(ints: int[]): PacketByteBufferHelper;

                            /**
                             * @return the read int array.
                             * @since 1.8.4
                             */
                            readIntArray(): JavaArray<number>;

                            /**
                             * Will throw an exception if the int array is bigger than the given maximum size.
                             * @param maxSize the maximum size of the int array to read
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            readIntArray(maxSize: int): PacketByteBufferHelper;

                            /**
                             * @param longs the long array to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeLongArray(longs: long[]): PacketByteBufferHelper;

                            /**
                             * @return the read long array.
                             * @since 1.8.4
                             */
                            readLongArray(): JavaArray<number>;

                            /**
                             * Will throw an exception if the long array is bigger than the given maximum size.
                             * @param maxSize the maximum size of the long array to read
                             * @return the read long array.
                             * @since 1.8.4
                             */
                            readLongArray(maxSize: int): JavaArray<number>;

                            /**
                             * @param pos the block position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockPos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): PacketByteBufferHelper;

                            /**
                             * @param x the x coordinate of the block position to store
                             * @param y the y coordinate of the block position to store
                             * @param z the z coordinate of the block position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockPos(x: int, y: int, z: int): PacketByteBufferHelper;

                            /**
                             * @return the read block position.
                             * @since 1.8.4
                             */
                            readBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                            /**
                             * @param x the x coordinate of the chunk to store
                             * @param z the z coordinate of the chunk to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkPos(x: int, z: int): PacketByteBufferHelper;

                            /**
                             * @param chunk the chunk to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkPos(chunk: xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper): PacketByteBufferHelper;

                            /**
                             * @return the position of the read chunk, x at index 0, z at index 1.
                             * @since 1.8.4
                             */
                            readChunkPos(): JavaArray<number>;

                            /**
                             * @return a {@link ChunkHelper} for the read chunk position.
                             * @since 1.8.4
                             */
                            readChunkHelper(): xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;

                            /**
                             * @param chunkX the x coordinate of the chunk to store
                             * @param y the y coordinate to store
                             * @param chunkZ the z coordinate of the chunk to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkSectionPos(chunkX: int, y: int, chunkZ: int): PacketByteBufferHelper;

                            /**
                             * @param chunk the chunk whose position should be stored
                             * @param y the y to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChunkSectionPos(chunk: xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper, y: int): PacketByteBufferHelper;

                            /**
                             * @return the read chunk section pos, as a {@link BlockPosHelper}.
                             * @since 1.8.4
                             */
                            readChunkSectionPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                            /**
                             * @param dimension the dimension, vanilla default are {@code overworld}, {@code the_nether},
                             *                   {@code the_end}
                             * @param pos the position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeGlobalPos(dimension: string, pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): PacketByteBufferHelper;

                            /**
                             * @param dimension the dimension, vanilla default are {@code overworld}, {@code the_nether},
                             *                   {@code the_end}
                             * @param x the x coordinate of the position to store
                             * @param y the y coordinate of the position to store
                             * @param z the z coordinate of the position to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeGlobalPos(dimension: string, x: int, y: int, z: int): PacketByteBufferHelper;

                            /**
                             * @return the read global pos, the first element is the dimension, the second is the position.
                             * @since 1.8.4
                             */
                            readGlobalPos(): xyz.wagyourtail.Pair<string, xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>;

                            /**
                             * @param text the string to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeText(text: string): PacketByteBufferHelper;

                            /**
                             * @param builder the text builder whose text should be stored
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeText(builder: xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder): PacketByteBufferHelper;

                            /**
                             * @param text the text to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeText(text: TextHelper): PacketByteBufferHelper;

                            /**
                             * @return the read text.
                             * @since 1.8.4
                             */
                            readText(): TextHelper;

                            /**
                             * @param constant the enum constant to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeEnumConstant(constant: java.lang.Enum<any>): PacketByteBufferHelper;

                            /**
                             * @param enumClass the class of the enum to read from
                             * @return the read enum constant.
                             * @since 1.8.4
                             */
                            readEnumConstant<T extends java.lang.Enum<T>>(enumClass: JavaClassArg<T>): T;

                            /**
                             * @param i the int to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeVarInt(i: int): PacketByteBufferHelper;

                            /**
                             * @return the read int.
                             * @since 1.8.4
                             */
                            readVarInt(): number;

                            /**
                             * @param l the long to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeVarLong(l: long): PacketByteBufferHelper;

                            /**
                             * @return the read long.
                             * @since 1.8.4
                             */
                            readVarLong(): number;

                            /**
                             * @param uuid the UUID to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeUuid(uuid: string): PacketByteBufferHelper;

                            /**
                             * @return the read UUID.
                             * @since 1.8.4
                             */
                            readUuid(): java.util.UUID;

                            /**
                             * @param nbt the nbt
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeNbt(nbt: NBTElementHelper$NBTCompoundHelper): PacketByteBufferHelper;

                            /**
                             * @return the read nbt data.
                             * @since 1.8.4
                             */
                            readNbt(): NBTElementHelper<any>;

                            /**
                             * @param stack the item stack to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeItemStack(stack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): PacketByteBufferHelper;

                            /**
                             * @return the read item stack.
                             * @since 1.8.4
                             */
                            readItemStack(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            /**
                             * @param string the string to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeString(string: string): PacketByteBufferHelper;

                            /**
                             * Throws an exception if the string is longer than the given length.
                             * @param string the string to store
                             * @param maxLength the maximum length of the string
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeString(string: string, maxLength: int): PacketByteBufferHelper;

                            /**
                             * @return the read string.
                             * @since 1.8.4
                             */
                            readString(): string;

                            /**
                             * Throws an exception if the read string is longer than the given length.
                             * @param maxLength the maximum length of the string to read
                             * @return the read string.
                             * @since 1.8.4
                             */
                            readString(maxLength: int): string;

                            /**
                             * @param id the identifier to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeIdentifier(id: string): PacketByteBufferHelper;

                            /**
                             * @return the read identifier.
                             * @since 1.8.4
                             */
                            readIdentifier(): string;

                            /**
                             * @param date the date to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeDate(date: java.util.Date): PacketByteBufferHelper;

                            /**
                             * @return the read date.
                             * @since 1.8.4
                             */
                            readDate(): java.util.Date;

                            /**
                             * @param instant the instant to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeInstant(instant: java.time.Instant): PacketByteBufferHelper;

                            /**
                             * @return the read instant.
                             * @since 1.8.4
                             */
                            readInstant(): java.time.Instant;

                            /**
                             * @param key the public key to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writePublicKey(key: java.security.PublicKey): PacketByteBufferHelper;

                            /**
                             * @return the read public key.
                             * @since 1.8.4
                             */
                            readPublicKey(): java.security.PublicKey;

                            /**
                             * @param hitResult the hit result to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockHitResult(hitResult: /* minecraft class */ any): PacketByteBufferHelper;

                            /**
                             * @param pos the position of the BlockHitResult
                             * @param direction the direction of the BlockHitResult
                             * @param blockPos the block pos of the BlockHitResult
                             * @param missed whether the BlockHitResult missed
                             * @param insideBlock whether the BlockHitResult is inside a block
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBlockHitResult(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, direction: string, blockPos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, missed: boolean, insideBlock: boolean): PacketByteBufferHelper;

                            /**
                             * @return the read block hit result.
                             * @since 1.8.4
                             */
                            readBlockHitResult(): /* minecraft class */ any;

                            /**
                             * @return a map of the block hit result's data and their values.
                             * @since 1.8.4
                             */
                            readBlockHitResultMap(): JavaMap<string, any>;

                            /**
                             * @param bitSet the bit set to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBitSet(bitSet: java.util.BitSet): PacketByteBufferHelper;

                            /**
                             * @return the read bit set.
                             * @since 1.8.4
                             */
                            readBitSet(): java.util.BitSet;

                            /**
                             * @param profile the profile to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeGameProfile(profile: com.mojang.authlib.GameProfile): PacketByteBufferHelper;

                            /**
                             * @return the read game profile.
                             * @since 1.8.4
                             */
                            readGameProfile(): com.mojang.authlib.GameProfile;

                            /**
                             * @return the read profile's name.
                             * @since 1.8.4
                             */
                            readGameProfileName(): string;

                            /**
                             * @return the read profile's UUID.
                             * @since 1.8.4
                             */
                            readGameProfileUuid(): java.util.UUID;

                            /**
                             * @return the readers current position.
                             * @since 1.8.4
                             */
                            readerIndex(): number;

                            /**
                             * @param index the readers new index
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setReaderIndex(index: int): PacketByteBufferHelper;

                            /**
                             * @return the writers current position.
                             * @since 1.8.4
                             */
                            writerIndex(): number;

                            /**
                             * @param index the writers new index
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setWriterIndex(index: int): PacketByteBufferHelper;

                            /**
                             * @param readerIndex the readers new index
                             * @param writerIndex the writers new index
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setIndices(readerIndex: int, writerIndex: int): PacketByteBufferHelper;

                            /**
                             * Resets the readers and writers index to their respective last marked indices.
                             * @return self for chaining.
                             * @see #markReaderIndex()
                             * @see #markWriterIndex()
                             * @since 1.8.4
                             */
                            resetIndices(): PacketByteBufferHelper;

                            /**
                             * Marks the readers current index for later use.
                             * @return self for chaining.
                             * @see #resetReaderIndex()
                             * @since 1.8.4
                             */
                            markReaderIndex(): PacketByteBufferHelper;

                            /**
                             * Resets the readers index to the last marked index.
                             * @return self for chaining.
                             * @see #markReaderIndex()
                             * @since 1.8.4
                             */
                            resetReaderIndex(): PacketByteBufferHelper;

                            /**
                             * Marks the writers current index for later use.
                             * @return self for chaining.
                             * @see #resetWriterIndex()
                             * @see ()
                             * @since 1.8.4
                             */
                            markWriterIndex(): PacketByteBufferHelper;

                            /**
                             * Resets the writers index to the last marked index.
                             * @return self for chaining.
                             * @see #markWriterIndex()
                             * @since 1.8.4
                             */
                            resetWriterIndex(): PacketByteBufferHelper;

                            /**
                             * Resets the writers and readers index to 0. This technically doesn't clear the buffer, but
                             *  rather makes it so that new operations will overwrite the old data.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            clear(): PacketByteBufferHelper;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBoolean(value: boolean): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBoolean(index: int, value: boolean): PacketByteBufferHelper;

                            /**
                             * @return the read boolean value.
                             * @since 1.8.4
                             */
                            readBoolean(): boolean;

                            /**
                             * @param index the index to read from
                             * @return the boolean value at the given index.
                             * @since 1.8.4
                             */
                            getBoolean(index: int): boolean;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeChar(value: int): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChar(index: int, value: char): PacketByteBufferHelper;

                            /**
                             * @return the read char value.
                             * @since 1.8.4
                             */
                            readChar(): number;

                            /**
                             * @param index the index to read from
                             * @return the char at the given index.
                             * @since 1.8.4
                             */
                            getChar(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeByte(value: int): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setByte(index: int, value: int): PacketByteBufferHelper;

                            /**
                             * @return the read byte value.
                             * @since 1.8.4
                             */
                            readByte(): number;

                            /**
                             * @return the read unsigned byte value, represented as a short.
                             * @since 1.8.4
                             */
                            readUnsignedByte(): number;

                            /**
                             * @param index the index to read from
                             * @return the byte at the given index.
                             * @since 1.8.4
                             */
                            getByte(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned byte at the given index, represented as a short.
                             * @since 1.8.4
                             */
                            getUnsignedByte(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeShort(value: int): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setShort(index: int, value: int): PacketByteBufferHelper;

                            /**
                             * @return the read short value.
                             * @since 1.8.4
                             */
                            readShort(): number;

                            /**
                             * @return the read unsigned short value, represented as an int.
                             * @since 1.8.4
                             */
                            readUnsignedShort(): number;

                            /**
                             * @param index the index to read from
                             * @return the short at the given index.
                             * @since 1.8.4
                             */
                            getShort(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned short at the given index, represented as an int.
                             * @since 1.8.4
                             */
                            getUnsignedShort(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeMedium(value: int): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMedium(index: int, value: int): PacketByteBufferHelper;

                            /**
                             * @return the read medium value.
                             * @since 1.8.4
                             */
                            readMedium(): number;

                            /**
                             * @return the read unsigned medium value.
                             * @since 1.8.4
                             */
                            readUnsignedMedium(): number;

                            /**
                             * @param index the index to read from
                             * @return the medium at the given index.
                             * @since 1.8.4
                             */
                            getMedium(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned medium at the given index.
                             * @since 1.8.4
                             */
                            getUnsignedMedium(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeInt(value: int): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setInt(index: int, value: int): PacketByteBufferHelper;

                            /**
                             * @return the read int value.
                             * @since 1.8.4
                             */
                            readInt(): number;

                            /**
                             * @return the read unsigned int value, represented as a long.
                             * @since 1.8.4
                             */
                            readUnsignedInt(): number;

                            /**
                             * @param index the index to read from
                             * @return the int at the given index.
                             * @since 1.8.4
                             */
                            getInt(index: int): number;

                            /**
                             * @param index the index to read from
                             * @return the unsigned int at the given index, represented as a long.
                             * @since 1.8.4
                             */
                            getUnsignedInt(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeLong(value: long): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setLong(index: int, value: long): PacketByteBufferHelper;

                            /**
                             * @return the read long value.
                             * @since 1.8.4
                             */
                            readLong(): number;

                            /**
                             * @param index the index to read from
                             * @return the long at the given index.
                             * @since 1.8.4
                             */
                            getLong(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeFloat(value: double): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFloat(index: int, value: double): PacketByteBufferHelper;

                            /**
                             * @return the read float value.
                             * @since 1.8.4
                             */
                            readFloat(): number;

                            /**
                             * @param index the index to read from
                             * @return the float at the given index.
                             * @since 1.8.4
                             */
                            getFloat(index: int): number;

                            /**
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeDouble(value: double): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param value the value to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDouble(index: int, value: double): PacketByteBufferHelper;

                            /**
                             * @return the read double value.
                             * @since 1.8.4
                             */
                            readDouble(): number;

                            /**
                             * @param index the index to read from
                             * @return the double at the given index.
                             * @since 1.8.4
                             */
                            getDouble(index: int): number;

                            /**
                             * @param length the amount of zeros to write
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeZero(length: int): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param length the amount of zeros to write
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setZero(index: int, length: int): PacketByteBufferHelper;

                            /**
                             * @param bytes the bytes to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            writeBytes(bytes: byte[]): PacketByteBufferHelper;

                            /**
                             * @param index the index to write to
                             * @param bytes the bytes to store
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBytes(index: int, bytes: byte[]): PacketByteBufferHelper;

                            /**
                             * Starts reading from this buffer's readerIndex.
                             * @param length the length of the array to read
                             * @return the read byte array.
                             * @since 1.8.4
                             */
                            readBytes(length: int): JavaArray<number>;

                            /**
                             * @param index the index to start reading from
                             * @param length the length of the array to read
                             * @return the read byte array .
                             * @since 1.8.4
                             */
                            getBytes(index: int, length: int): JavaArray<number>;

                            /**
                             * Moves the readerIndex of this buffer by the specified amount.
                             * @param length the amount of bytes to skip
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            skipBytes(length: int): PacketByteBufferHelper;

                        }

                        /**
                         * @author Wagyourtail
                         * @since 1.2.4
                         */
                        const StatusEffectHelper: JavaClassStatics<StatusEffectHelper, StatusEffectHelper$$constructor>;
                        interface StatusEffectHelper$$constructor extends SuppressProperties {

                            new (s: /* minecraft class */ any): StatusEffectHelper;

                        }
                        interface StatusEffectHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * @since 1.2.4
                             * @return
                             */
                            getId(): StatusEffectId;

                            /**
                             * @since 1.2.4
                             * @return
                             */
                            getStrength(): number;

                            /**
                             * @since 1.2.4
                             * @return
                             */
                            getTime(): number;

                            /**
                             * @return {@code true} if this effect is applied permanently, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isPermanent(): boolean;

                            /**
                             * Ambient effects are usually applied through beacons and they make the particles more
                             *  translucent.
                             * @return {@code true} if this effect is an ambient one, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isAmbient(): boolean;

                            /**
                             * @return {@code true} if this effect has an icon it should render, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            hasIcon(): boolean;

                            /**
                             * @return {@code true} if this effect affects the particle color and gets rendered in game,
                             *          {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isVisible(): boolean;

                            /**
                             * An effect which is instant can still have a duration, but only if it's set through a
                             *  command.
                             * @return {@code true} if this effect should be applied instantly, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isInstant(): boolean;

                            /**
                             * @return {@code true} if this effect is considered beneficial, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isBeneficial(): boolean;

                            /**
                             * @return {@code true} if this effect is considered neutral, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isNeutral(): boolean;

                            /**
                             * @return {@code true} if this effect is considered harmful, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isHarmful(): boolean;

                        }

                        const CommandNodeHelper: JavaClassStatics<CommandNodeHelper, CommandNodeHelper$$constructor>;
                        interface CommandNodeHelper$$constructor extends SuppressProperties {

                            new (base: com.mojang.brigadier.tree.CommandNode, fabric: com.mojang.brigadier.tree.CommandNode): CommandNodeHelper;

                        }
                        interface CommandNodeHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<com.mojang.brigadier.tree.CommandNode<any>> {
                            readonly fabric: com.mojang.brigadier.tree.CommandNode;
                        }

                        /**
                         * @author Wagyourtail
                         * @since 1.0.8
                         */
                        const TextHelper: JavaClassStatics<TextHelper, TextHelper$$constructor> & {
                            readonly STRIP_FORMATTING_PATTERN: java.util.regex.Pattern;
                        }
                        interface TextHelper$$constructor extends SuppressProperties {

                            new (t: /* minecraft class */ any): TextHelper;

                        }
                        interface TextHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * replace the text in this class with JSON data.
                             * @since 1.0.8
                             * @param json
                             * @deprecated use {@link xyz.wagyourtail.jsmacros.client.api.library.impl.FChat#createTextHelperFromJSON(String)} instead.
                             * @return
                             */
                            replaceFromJson(json: string): TextHelper;

                            /**
                             * replace the text in this class with {@link java.lang.String} data.
                             * @since 1.0.8
                             * @param content
                             * @deprecated use {@link xyz.wagyourtail.jsmacros.client.api.library.impl.FChat#createTextHelperFromString(String)} instead.
                             * @return
                             */
                            replaceFromString(content: string): TextHelper;

                            /**
                             * @since 1.2.7
                             * @return JSON data representation.
                             */
                            getJson(): string;

                            /**
                             * @since 1.2.7
                             * @return the text content.
                             */
                            getString(): string;

                            /**
                             * @since 1.6.5
                             * @return the text content. stripped formatting when servers send it the (super) old way due to shitty coders.
                             */
                            getStringStripFormatting(): string;

                            /**
                             * @return the text helper without the formatting applied.
                             * @since 1.8.4
                             */
                            withoutFormatting(): TextHelper;

                            /**
                             * @param visitor function with 2 args, no return.
                             * @since 1.6.5
                             */
                            visit(visitor: xyz.wagyourtail.jsmacros.core.MethodWrapper<StyleHelper, string, any, any>): TextHelper;

                            /**
                             * @return the width of this text.
                             * @since 1.8.4
                             */
                            getWidth(): number;

                            /**
                             * @since 1.0.8
                             * @deprecated confusing name, use {@link #getJson()} instead.
                             * @return
                             */
                            toJson(): string;

                            /**
                             * @since 1.0.8, this used to do the same as {@link #getString}
                             * @return String representation of text helper.
                             */
                            toString(): string;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const FormattingHelper: JavaClassStatics<FormattingHelper, FormattingHelper$$constructor>;
                        interface FormattingHelper$$constructor extends SuppressProperties {

                            new (base: /* minecraft class */ any): FormattingHelper;

                        }
                        interface FormattingHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * @return the color value of this formatting.
                             * @since 1.8.4
                             */
                            getColorValue(): number;

                            /**
                             * @return the index of this formatting or {@code -1} if this formatting is a modifier.
                             * @since 1.8.4
                             */
                            getColorIndex(): number;

                            /**
                             * @return the name of this formatting.
                             * @since 1.8.4
                             */
                            getName(): string;

                            /**
                             * The color code can be used with the paragraph to color text.
                             * @return the color code of this formatting.
                             * @since 1.8.4
                             */
                            getCode(): number;

                            /**
                             * @return {@code true} if this formatting is a color, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isColor(): boolean;

                            /**
                             * @return {@code true} if this formatting is a modifier, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isModifier(): boolean;

                        }

                        const StatsHelper: JavaClassStatics<StatsHelper, StatsHelper$$constructor>;
                        interface StatsHelper$$constructor extends SuppressProperties {

                            new (base: /* minecraft class */ any): StatsHelper;

                        }
                        interface StatsHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            getStatList(): JavaList<string>;
                            getStatText(statKey: string): /* minecraft class */ any;
                            getRawStatValue(statKey: string): number;
                            getFormattedStatValue(statKey: string): string;
                            getFormattedStatMap(): JavaMap<string, string>;
                            getRawStatMap(): JavaMap<string, number>;

                            /**
                             * @param id the identifier of the entity
                             * @return how many times the player has killed the entity.
                             * @since 1.8.4
                             */
                            getEntityKilled(id: EntityId): number;

                            /**
                             * @param id the identifier of the entity
                             * @return how many times the player has killed the specified entity.
                             * @since 1.8.4
                             */
                            getKilledByEntity(id: EntityId): number;

                            /**
                             * @param id the identifier of the block
                             * @return how many times the player has mined the block.
                             * @since 1.8.4
                             */
                            getBlockMined(id: BlockId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has broken the item.
                             * @since 1.8.4
                             */
                            getItemBroken(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has crafted the item.
                             * @since 1.8.4
                             */
                            getItemCrafted(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has used the item.
                             * @since 1.8.4
                             */
                            getItemUsed(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has picked up the item.
                             * @since 1.8.4
                             */
                            getItemPickedUp(id: ItemId): number;

                            /**
                             * @param id the identifier of the item
                             * @return how many times the player has dropped the item.
                             * @since 1.8.4
                             */
                            getItemDropped(id: ItemId): number;

                            /**
                             * @param id the identifier of the custom stat
                             * @return the value of the custom stat.
                             * @since 1.8.4
                             */
                            getCustomStat(id: string): number;

                            /**
                             * @param id the identifier of the custom stat
                             * @return the formatted value of the custom stat.
                             * @since 1.8.4
                             */
                            getCustomFormattedStat(id: string): string;

                            /**
                             * Used to request an update of the statistics from the server.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            updateStatistics(): StatsHelper;

                        }

                        const OptionsHelper$ControlOptionsHelper: JavaClassStatics<OptionsHelper$ControlOptionsHelper, OptionsHelper$ControlOptionsHelper$$constructor>;
                        interface OptionsHelper$ControlOptionsHelper$$constructor extends SuppressProperties {

                            new (OptionsHelper: OptionsHelper): OptionsHelper$ControlOptionsHelper;

                        }
                        interface OptionsHelper$ControlOptionsHelper extends JavaObject {
                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current mouse sensitivity.
                             * @since 1.8.4
                             */
                            getMouseSensitivity(): number;

                            /**
                             * @param val the new mouse sensitivity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMouseSensitivity(val: double): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return {@code true} if the mouse direction should be inverted.
                             * @since 1.8.4
                             */
                            isMouseInverted(): boolean;

                            /**
                             * @param val whether to invert the mouse direction or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            invertMouse(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return the current mouse wheel sensitivity.
                             * @since 1.8.4
                             */
                            getMouseWheelSensitivity(): number;

                            /**
                             * @param val the new mouse wheel sensitivity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMouseWheelSensitivity(val: double): OptionsHelper$ControlOptionsHelper;

                            /**
                             * This option was introduced due to a bug on some systems where the mouse wheel would
                             *  scroll too fast.
                             * @return {@code true} if discrete scrolling is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isDiscreteScrollingEnabled(): boolean;

                            /**
                             * @param val whether to enable discrete scrolling or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableDiscreteScrolling(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return {@code true} if touchscreen mode is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isTouchscreenEnabled(): boolean;

                            /**
                             * @param val whether to enable touchscreen mode or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableTouchscreen(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * Raw input is directly reading the mouse data, without any adjustments due to other
                             *  programs or the operating system.
                             * @return {@code true} if raw mouse input is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isRawMouseInputEnabled(): boolean;

                            /**
                             * @param val whether to enable raw mouse input or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableRawMouseInput(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return {@code true} if auto jump is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isAutoJumpEnabled(): boolean;

                            /**
                             * @param val whether to enable auto jump or not or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableAutoJump(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return {@code true} if the toggle functionality for sneaking is enabled, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isSneakTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sneaking
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSneak(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return {@code true} if the toggle functionality for sprinting is enabled, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isSprintTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sprinting
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSprint(val: boolean): OptionsHelper$ControlOptionsHelper;

                            /**
                             * @return an array of all raw minecraft keybindings.
                             * @since 1.8.4
                             */
                            getRawKeys(): JavaArray</* minecraft class */ any>;

                            /**
                             * @return a list of all keybinding catehories.
                             * @since 1.8.4
                             */
                            getCategories(): JavaList<KeyCategory>;

                            /**
                             * @return a list of all key names.
                             * @since 1.8.4
                             */
                            getKeys(): JavaList<Key>;

                            /**
                             * @return a map of all keybindings and their bound key.
                             * @since 1.8.4
                             */
                            getKeyBinds(): JavaMap<Bind, Key>;

                            /**
                             * @param category the category to get keybindings from
                             * @return a map of all keybindings and their bound key in the specified category.
                             * @since 1.8.4
                             */
                            getKeyBindsByCategory(category: KeyCategory): JavaMap<string, string>;

                            /**
                             * @return a map of all keybinding categories, containing a map of all keybindings in that
                             *          category and their bound key.
                             * @since 1.8.4
                             */
                            getKeyBindsByCategory(): JavaMap<string, JavaMap<string, string>>;

                        }

                        const OptionsHelper$MusicOptionsHelper: JavaClassStatics<OptionsHelper$MusicOptionsHelper, OptionsHelper$MusicOptionsHelper$$constructor>;
                        interface OptionsHelper$MusicOptionsHelper$$constructor extends SuppressProperties {

                            new (OptionsHelper: OptionsHelper): OptionsHelper$MusicOptionsHelper;

                        }
                        interface OptionsHelper$MusicOptionsHelper extends JavaObject {
                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current master volume.
                             * @since 1.8.4
                             */
                            getMasterVolume(): number;

                            /**
                             * @param volume the new master volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMasterVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current music volume.
                             * @since 1.8.4
                             */
                            getMusicVolume(): number;

                            /**
                             * @param volume the new music volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMusicVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current value of played recods.
                             * @since 1.8.4
                             */
                            getRecordsVolume(): number;

                            /**
                             * @param volume the new volume for playing records
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setRecordsVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current volume of the weather.
                             * @since 1.8.4
                             */
                            getWeatherVolume(): number;

                            /**
                             * @param volume the new volume for the weather
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setWeatherVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current volume of block related sounds.
                             * @since 1.8.4
                             */
                            getBlocksVolume(): number;

                            /**
                             * @param volume the new volume for block sounds
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBlocksVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current volume of hostile mobs.
                             * @since 1.8.4
                             */
                            getHostileVolume(): number;

                            /**
                             * @param volume the new volume for hostile mobs
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setHostileVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current volume of neutral mobs.
                             * @since 1.8.4
                             */
                            getNeutralVolume(): number;

                            /**
                             * @param volume the new volume for neutral mobs
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setNeutralVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current player volume.
                             * @since 1.8.4
                             */
                            getPlayerVolume(): number;

                            /**
                             * @param volume the new player volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setPlayerVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current ambient volume.
                             * @since 1.8.4
                             */
                            getAmbientVolume(): number;

                            /**
                             * @param volume the new ambient volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setAmbientVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the current voice volume.
                             * @since 1.8.4
                             */
                            getVoiceVolume(): number;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setVoiceVolume(volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @param category the category to get the volume of
                             * @return the volume of the given sound category.
                             * @since 1.8.4
                             */
                            getVolume(category: SoundCategory): number;

                            /**
                             * @return a map of all sound categories and their volumes.
                             * @since 1.8.4
                             */
                            getVolumes(): JavaMap<string, number>;

                            /**
                             * @param category the category to set the volume for
                             * @param volume the new volume
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setVolume(category: SoundCategory, volume: double): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return the currently selected sound device.
                             * @since 1.8.4
                             */
                            getSoundDevice(): string;

                            /**
                             * @param audioDevice the audio device to use
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setSoundDevice(audioDevice: string): OptionsHelper$MusicOptionsHelper;

                            /**
                             * @return a list of all connected audio devices.
                             * @since 1.8.4
                             */
                            getAudioDevices(): JavaList<string>;

                            /**
                             * @return {@code true} if subtitles should be shown, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            areSubtitlesShown(): boolean;

                            /**
                             * @param val whether subtitles should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            showSubtitles(val: boolean): OptionsHelper$MusicOptionsHelper;

                        }

                        const OptionsHelper$ChatOptionsHelper: JavaClassStatics<OptionsHelper$ChatOptionsHelper, OptionsHelper$ChatOptionsHelper$$constructor>;
                        interface OptionsHelper$ChatOptionsHelper$$constructor extends SuppressProperties {

                            new (OptionsHelper: OptionsHelper): OptionsHelper$ChatOptionsHelper;

                        }
                        interface OptionsHelper$ChatOptionsHelper extends JavaObject {
                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current chat visibility mode.
                             * @since 1.8.4
                             */
                            getChatVisibility(): ChatVisibility;

                            /**
                             * @param mode the new chat visibility mode. Must be "FULL", "SYSTEM" or "HIDDEN"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatVisibility(mode: ChatVisibility): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return {@code true} if messages can use color codes, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            areColorsShown(): boolean;

                            /**
                             * @param val whether to allow color codes in messages or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setShowColors(val: boolean): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return {@code true} if it's allowed to open web links from chat, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            areWebLinksEnabled(): boolean;

                            /**
                             * @param val whether to allow opening web links from chat or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableWebLinks(val: boolean): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return {@code true} if a warning prompt before opening links should be shown,
                             *          {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isWebLinkPromptEnabled(): boolean;

                            /**
                             * @param val whether to show warning prompts before opening links or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableWebLinkPrompt(val: boolean): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the current chat opacity.
                             * @since 1.8.4
                             */
                            getChatOpacity(): number;

                            /**
                             * @param val the new chat opacity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatOpacity(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @param val the new background opacity for text
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setTextBackgroundOpacity(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the current background opacity of text.
                             * @since 1.8.4
                             */
                            getTextBackgroundOpacity(): number;

                            /**
                             * @return the current text size.
                             * @since 1.8.4
                             */
                            getTextSize(): number;

                            /**
                             * @param val the new text size
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setTextSize(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the current chat line spacing.
                             * @since 1.8.4
                             */
                            getChatLineSpacing(): number;

                            /**
                             * @param val the new chat line spacing
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatLineSpacing(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the current chat delay in seconds.
                             * @since 1.8.4
                             */
                            getChatDelay(): number;

                            /**
                             * @param val the new chat delay in seconds
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatDelay(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the current chat width.
                             * @since 1.8.4
                             */
                            getChatWidth(): number;

                            /**
                             * @param val the new chat width
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatWidth(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the focused chat height.
                             * @since 1.8.4
                             */
                            getChatFocusedHeight(): number;

                            /**
                             * @param val the new focused chat height
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatFocusedHeight(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the unfocused chat height.
                             * @since 1.8.4
                             */
                            getChatUnfocusedHeight(): number;

                            /**
                             * @param val the new unfocused chat height
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatUnfocusedHeight(val: double): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return the current narrator mode.
                             * @since 1.8.4
                             */
                            getNarratorMode(): NarratorMode;

                            /**
                             * @param mode the mode to set the narrator to. Must be either "OFF", "ALL", "CHAT", or
                             *              "SYSTEM"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setNarratorMode(mode: NarratorMode): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return {@code true} if command suggestions are enabled
                             * @since 1.8.4
                             */
                            areCommandSuggestionsEnabled(): boolean;

                            /**
                             * @param val whether to enable command suggestions or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableCommandSuggestions(val: boolean): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return {@code true} if messages from blocked users are hidden.
                             * @since 1.8.4
                             */
                            areMatchedNamesHidden(): boolean;

                            /**
                             * @param val whether to hide messages of blocked users or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableHideMatchedNames(val: boolean): OptionsHelper$ChatOptionsHelper;

                            /**
                             * @return {@code true} if reduced debug info is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isDebugInfoReduced(): boolean;

                            /**
                             * @param val whether to enable reduced debug info or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            reduceDebugInfo(val: boolean): OptionsHelper$ChatOptionsHelper;

                        }

                        const OptionsHelper$VideoOptionsHelper: JavaClassStatics<OptionsHelper$VideoOptionsHelper, OptionsHelper$VideoOptionsHelper$$constructor>;
                        interface OptionsHelper$VideoOptionsHelper$$constructor extends SuppressProperties {

                            new (OptionsHelper: OptionsHelper): OptionsHelper$VideoOptionsHelper;

                        }
                        interface OptionsHelper$VideoOptionsHelper extends JavaObject {
                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the full screen resolution as a string.
                             * @since 1.8.4
                             */
                            getFullscreenResolution(): string;

                            /**
                             * @return the current biome blend radius.
                             * @since 1.8.4
                             */
                            getBiomeBlendRadius(): number;

                            /**
                             * @param radius the new biome blend radius
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBiomeBlendRadius(radius: int): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the selected graphics mode.
                             * @since 1.8.4
                             */
                            getGraphicsMode(): GraphicsMode;

                            /**
                             * @param mode the graphics mode to select. Must be either "fast", "fancy" or "fabulous"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGraphicsMode(mode: GraphicsMode): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the selected chunk builder mode.
                             * @since 1.8.4
                             */
                            getChunkBuilderMode(): ChunkBuilderMode;

                            /**
                             * @param mode the chunk builder mode to select. Must be either "none", "nearby" or
                             *              "player_affected"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChunkBuilderMode(mode: ChunkBuilderMode): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the selected smooth lightning mode.
                             * @since 1.8.4
                             */
                            getSmoothLightningMode(): boolean;

                            /**
                             * @param mode the smooth lightning mode to select. boolean value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setSmoothLightningMode(mode: boolean): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current render distance in chunks.
                             * @since 1.8.4
                             */
                            getRenderDistance(): number;

                            /**
                             * @param radius the new render distance in chunks
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setRenderDistance(radius: int): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current simulation distance in chunks.
                             * @since 1.8.4
                             */
                            getSimulationDistance(): number;

                            /**
                             * @param radius the new simulation distance in chunks
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setSimulationDistance(radius: int): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current upper fps limit.
                             * @since 1.8.4
                             */
                            getMaxFps(): number;

                            /**
                             * @param maxFps the new maximum fps limit
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMaxFps(maxFps: int): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return {@code true} if vsync is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isVsyncEnabled(): boolean;

                            /**
                             * @param val whether to enable vsync or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableVsync(val: boolean): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return {@code true} if view bobbing is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isViewBobbingEnabled(): boolean;

                            /**
                             * @param val whether to enable view bobbing or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableViewBobbing(val: boolean): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current gui scale.
                             * @since 1.8.4
                             */
                            getGuiScale(): number;

                            /**
                             * @param scale the gui scale to set. Must be 1, 2, 3 or 4
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGuiScale(scale: int): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current attack indicator type.
                             * @since 1.8.4
                             */
                            getAttackIndicatorType(): AttackIndicatorType;

                            /**
                             * @param type the attack indicator type. Must be either "off", "crosshair", or "hotbar"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setAttackIndicatorType(type: AttackIndicatorType): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current gamma value.
                             * @since 1.8.4
                             */
                            getGamma(): number;

                            /**
                             * @param gamma the new gamma value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGamma(gamma: double): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current brightness value.
                             * @since 1.8.4
                             */
                            getBrightness(): number;

                            /**
                             * @param gamma the new brightness value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setBrightness(gamma: double): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current cloud rendering mode.
                             * @since 1.8.4
                             */
                            getCloudsMode(): CloudsMode;

                            /**
                             * @param mode the cloud rendering mode to select. Must be either "off", "fast" or "fancy"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setCloudsMode(mode: CloudsMode): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return {@code true} if the game is running in fullscreen mode, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isFullscreen(): boolean;

                            /**
                             * @param fullscreen whether to enable fullscreen mode or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFullScreen(fullscreen: boolean): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current particle rendering mode.
                             * @since 1.8.4
                             */
                            getParticleMode(): ParticleMode;

                            /**
                             * @param mode the particle rendering mode to select. Must be either "minimal", "decreased"
                             *              or "all"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setParticleMode(mode: ParticleMode): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current mip map level.
                             * @since 1.8.4
                             */
                            getMipMapLevels(): number;

                            /**
                             * @param val the new mip map level
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setMipMapLevels(val: int): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return {@code true} if entity shadows should be rendered, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            areEntityShadowsEnabled(): boolean;

                            /**
                             * @param val whether to enable entity shadows or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableEntityShadows(val: boolean): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current distortion effect scale.
                             * @since 1.8.4
                             */
                            getDistortionEffect(): number;

                            /**
                             * @param val the new distortion effect scale
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDistortionEffects(val: double): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current entity render distance.
                             * @since 1.8.4
                             */
                            getEntityDistance(): number;

                            /**
                             * @param val the new entity render distance
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setEntityDistance(val: double): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return the current fov value.
                             * @since 1.8.4
                             */
                            getFovEffects(): number;

                            /**
                             * @param val the new fov value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFovEffects(val: double): OptionsHelper$VideoOptionsHelper;

                            /**
                             * @return {@code true} if the autosave indicator is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isAutosaveIndicatorEnabled(): boolean;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableAutosaveIndicator(val: boolean): OptionsHelper$VideoOptionsHelper;

                        }

                        /** @since 1.5.1 */
                        const NBTElementHelper: JavaClassStatics<NBTElementHelper<any>> & NoConstructor & {

                            /** @since 1.5.1 */
                            resolve(element: /* minecraft class */ any): NBTElementHelper<any>;

                        }
                        interface NBTElementHelper<T = /* minecraft class */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {

                            /** @since 1.5.1 */
                            getType(): number;
                            /** @since 1.5.1 */
                            isNull(): boolean;
                            /** @since 1.5.1 */
                            isNumber(): boolean;
                            /** @since 1.5.1 */
                            isString(): boolean;
                            /** @since 1.5.1 */
                            isList(): boolean;
                            /** @since 1.5.1 */
                            isCompound(): boolean;

                            /**
                             * if element is a string, returns value.  
                             *  otherwise returns toString representation.
                             * @since 1.5.1
                             */
                            asString(): string;

                            /**
                             * check with {@link #isNumber} first
                             * @since 1.5.1
                             */
                            asNumberHelper(): NBTElementHelper$NBTNumberHelper;

                            /**
                             * check with {@link #isList} first
                             * @since 1.5.1
                             */
                            asListHelper(): NBTElementHelper$NBTListHelper;

                            /**
                             * check with {@link #isCompound} first
                             * @since 1.5.1
                             */
                            asCompoundHelper(): NBTElementHelper$NBTCompoundHelper;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const AdvancementManagerHelper: JavaClassStatics<AdvancementManagerHelper, AdvancementManagerHelper$$constructor>;
                        interface AdvancementManagerHelper$$constructor extends SuppressProperties {

                            new (advancementManager: /* minecraft class */ any): AdvancementManagerHelper;

                        }
                        interface AdvancementManagerHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * @return a map of all advancement ids and their advancement.
                             * @since 1.8.4
                             */
                            getAdvancementsForIdentifiers(): JavaMap<AdvancementId, $AdvancementHelper>;

                            /**
                             * @return a list of all advancements.
                             * @since 1.8.4
                             */
                            getAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * Started advancements are advancements that have been started, so at least one task has been
                             *  completed so far, but not fully completed.
                             * @return a list of all started advancements.
                             * @since 1.8.4
                             */
                            getStartedAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all missing advancements.
                             * @since 1.8.4
                             */
                            getMissingAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all completed advancements.
                             * @since 1.8.4
                             */
                            getCompletedAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all the root advancements.
                             * @since 1.8.4
                             */
                            getRootAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @return a list of all advancements that are not a root.
                             * @since 1.8.4
                             */
                            getSubAdvancements(): JavaList<AdvancementHelper>;

                            /**
                             * @param identifier the identifier of the advancement
                             * @return the advancement for the given identifier.
                             * @since 1.8.4
                             */
                            getAdvancement(identifier: AdvancementId): AdvancementHelper;

                            /**
                             * @return a map of all advancements and their progress.
                             * @since 1.8.4
                             */
                            getAdvancementsProgress(): JavaMap<AdvancementHelper, AdvancementProgressHelper>;

                            /**
                             * @param identifier
                             * @return the progress of the given advancement.
                             * @since 1.8.4
                             */
                            getAdvancementProgress(identifier: AdvancementId): AdvancementProgressHelper;

                        }

                        /** @since 1.5.1 */
                        const NBTElementHelper$NBTCompoundHelper: JavaClassStatics<NBTElementHelper$NBTCompoundHelper> & NoConstructor;
                        interface NBTElementHelper$NBTCompoundHelper extends NBTElementHelper</* minecraft class */ any> {

                            /**
                             * @since 1.6.0
                             * @return
                             */
                            getKeys(): JavaSet<string>;
                            /** @since 1.5.1 */
                            getType(key: string): number;
                            /** @since 1.5.1 */
                            getType(): number;
                            /** @since 1.5.1 */
                            has(key: string): boolean;
                            /** @since 1.5.1 */
                            get(key: string): NBTElementHelper<any>;
                            /** @since 1.5.1 */
                            asString(key: string): string;

                        }

                        const OptionsHelper$SkinOptionsHelper: JavaClassStatics<OptionsHelper$SkinOptionsHelper, OptionsHelper$SkinOptionsHelper$$constructor>;
                        interface OptionsHelper$SkinOptionsHelper$$constructor extends SuppressProperties {

                            new (OptionsHelper: OptionsHelper): OptionsHelper$SkinOptionsHelper;

                        }
                        interface OptionsHelper$SkinOptionsHelper extends JavaObject {
                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return {@code true} if the player's cape should be shown, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isCapeActivated(): boolean;

                            /**
                             * @return {@code true} if the player's jacket should be shown, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isJacketActivated(): boolean;

                            /**
                             * @return {@code true} if the player's left sleeve should be shown, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isLeftSleeveActivated(): boolean;

                            /**
                             * @return {@code true} if the player's right sleeve should be shown, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isRightSleeveActivated(): boolean;

                            /**
                             * @return {@code true} if the player's left pants should be shown, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isLeftPantsActivated(): boolean;

                            /**
                             * @return {@code true} if the player's right pants should be shown, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isRightPantsActivated(): boolean;

                            /**
                             * @return {@code true} if the player's hat should be shown, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isHatActivated(): boolean;

                            /**
                             * @return {@code true} if the player's main hand is the right one, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isRightHanded(): boolean;

                            /**
                             * @return {@code true} if the player's main hand is the left one, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isLeftHanded(): boolean;

                            /**
                             * @param val whether the cape should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleCape(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @param val whether the jacket should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleJacket(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @param val whether the left sleeve should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleLeftSleeve(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @param val whether the right sleeve should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleRightSleeve(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @param val whether the left pants should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleLeftPants(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @param val whether the right pants should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleRightPants(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * @param val whether the hat should be shown or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleHat(val: boolean): OptionsHelper$SkinOptionsHelper;

                            /**
                             * The hand must be either `"left"` or `"right"`.
                             * @param hand the hand to set as main hand
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleMainHand(hand: string): OptionsHelper$SkinOptionsHelper;

                        }

                        const OptionsHelper$AccessibilityOptionsHelper: JavaClassStatics<OptionsHelper$AccessibilityOptionsHelper, OptionsHelper$AccessibilityOptionsHelper$$constructor>;
                        interface OptionsHelper$AccessibilityOptionsHelper$$constructor extends SuppressProperties {

                            new (OptionsHelper: OptionsHelper): OptionsHelper$AccessibilityOptionsHelper;

                        }
                        interface OptionsHelper$AccessibilityOptionsHelper extends JavaObject {
                            readonly parent: OptionsHelper;

                            /**
                             * @return the parent options helper.
                             * @since 1.8.4
                             */
                            getParent(): OptionsHelper;

                            /**
                             * @return the current narrator mode.
                             * @since 1.8.4
                             */
                            getNarratorMode(): string;

                            /**
                             * @param mode the mode to set the narrator to. Must be either "OFF", "ALL", "CHAT", or
                             *              "SYSTEM"
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setNarratorMode(mode: string): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return {@code true} if subtitles are enabled.
                             * @since 1.8.4
                             */
                            areSubtitlesShown(): boolean;

                            /**
                             * @param val whether to show subtitles or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            showSubtitles(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @param val the new opacity for the text background
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setTextBackgroundOpacity(val: double): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return the opacity of the text background.
                             * @since 1.8.4
                             */
                            getTextBackgroundOpacity(): number;

                            /**
                             * @return 
                             * @since 1.8.4
                             */
                            isBackgroundForChatOnly(): boolean;

                            /**
                             * @param val
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableBackgroundForChatOnly(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return the current chat opacity.
                             * @since 1.8.4
                             */
                            getChatOpacity(): number;

                            /**
                             * @param val the new chat opacity
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatOpacity(val: double): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return the current chat line spacing.
                             * @since 1.8.4
                             */
                            getChatLineSpacing(): number;

                            /**
                             * @param val the new chat line spacing
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatLineSpacing(val: double): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return the current chat delay in seconds.
                             * @since 1.8.4
                             */
                            getChatDelay(): number;

                            /**
                             * @param val the new chat delay in seconds
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setChatDelay(val: double): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return {@code true} if auto jump is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isAutoJumpEnabled(): boolean;

                            /**
                             * @param val whether to enable auto jump or not or not
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            enableAutoJump(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return {@code true} if the toggle functionality for sneaking is enabled, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isSneakTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sneaking
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSneak(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return {@code true} if the toggle functionality for sprinting is enabled, {@code false}
                             *          otherwise.
                             * @since 1.8.4
                             */
                            isSprintTogglingEnabled(): boolean;

                            /**
                             * @param val whether to enable or disable the toggle functionality for sprinting
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            toggleSprint(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return the current distortion effect scale.
                             * @since 1.8.4
                             */
                            getDistortionEffect(): number;

                            /**
                             * @param val the new distortion effect scale
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setDistortionEffect(val: double): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return the current fov effect scale.
                             * @since 1.8.4
                             */
                            getFovEffect(): number;

                            /**
                             * @param val the new fov effect scale
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFovEffect(val: double): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return {@code true} if the monochrome logo is enabled, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isMonochromeLogoEnabled(): boolean;

                            /**
                             * @param val whether to enable the monochrome logo or not
                             * @return the current helper instance for chaining.
                             * @since 1.8.4
                             */
                            enableMonochromeLogo(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                            /**
                             * @return {@code true} if lighting flashes are hidden, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            areLightningFlashesHidden(): boolean;

                            /**
                             * @param val the new fov value
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setFovEffect(val: boolean): OptionsHelper$AccessibilityOptionsHelper;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const AdvancementProgressHelper: JavaClassStatics<AdvancementProgressHelper, AdvancementProgressHelper$$constructor>;
                        interface AdvancementProgressHelper$$constructor extends SuppressProperties {

                            new (base: /* minecraft class */ any): AdvancementProgressHelper;

                        }
                        interface AdvancementProgressHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * @return {@code true} if the advancement is finished, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isDone(): boolean;

                            /**
                             * @return {@code true} if any criteria has already been met, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isAnyObtained(): boolean;

                            /**
                             * @return a map of all criteria and their completion date.
                             * @since 1.8.4
                             */
                            getCriteria(): JavaMap<string, java.util.Date>;

                            /**
                             * @return all requirements of this advancement.
                             * @since 1.8.4
                             */
                            getRequirements(): JavaArray<JavaArray<string>>;

                            /**
                             * @return the percentage of finished requirements.
                             * @since 1.8.4
                             */
                            getPercentage(): number;

                            /**
                             * @return the fraction of finished requirements to total requirements.
                             * @since 1.8.4
                             */
                            getFraction(): string;

                            /**
                             * @return the amount of requirements criteria.
                             * @since 1.8.4
                             */
                            countObtainedRequirements(): number;

                            /**
                             * @return the amount of missing criteria.
                             * @since 1.8.4
                             */
                            getUnobtainedCriteria(): JavaArray<string>;

                            /**
                             * @return the ids of the finished requirements.
                             * @since 1.8.4
                             */
                            getObtainedCriteria(): JavaArray<string>;

                            /**
                             * @return the earliest completion date of all criteria.
                             * @since 1.8.4
                             */
                            getEarliestProgressObtainDate(): java.util.Date;

                            /**
                             * @param criteria the criteria
                             * @return the completion date of the given criteria or {@code null} if the criteria is not met
                             *          yet.
                             * @since 1.8.4
                             */
                            getCriterionProgress(criteria: string): java.util.Date;

                            /**
                             * @param criteria the criteria
                             * @return {@code true} if the given criteria is met, {@code false} otherwise.
                             * @since 1.8.4
                             */
                            isCriteriaObtained(criteria: string): boolean;

                        }

                        /** @since 1.5.1 */
                        const NBTElementHelper$NBTNumberHelper: JavaClassStatics<NBTElementHelper$NBTNumberHelper> & NoConstructor;
                        interface NBTElementHelper$NBTNumberHelper extends NBTElementHelper</* minecraft class */ any> {

                            /** @since 1.5.1 */
                            asLong(): number;
                            /** @since 1.5.1 */
                            asInt(): number;
                            /** @since 1.5.1 */
                            asShort(): number;
                            /** @since 1.5.1 */
                            asByte(): number;
                            /** @since 1.5.1 */
                            asFloat(): number;
                            /** @since 1.5.1 */
                            asDouble(): number;
                            /** @since 1.5.1 */
                            asNumber(): java.lang.Number;

                        }

                        /** @since 1.5.1 */
                        const NBTElementHelper$NBTListHelper: JavaClassStatics<NBTElementHelper$NBTListHelper> & NoConstructor;
                        interface NBTElementHelper$NBTListHelper extends NBTElementHelper</* minecraft class */ any> {

                            /**
                             * @since 1.8.3
                             * @return
                             */
                            isPossiblyUUID(): boolean;

                            /**
                             * @since 1.8.3
                             * @return
                             */
                            asUUID(): java.util.UUID;

                            /**
                             * @since 1.5.1
                             * @return
                             */
                            length(): number;
                            /** @since 1.5.1 */
                            get(index: int): NBTElementHelper<any>;
                            /** @since 1.5.1 */
                            getHeldType(): number;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const AdvancementHelper: JavaClassStatics<AdvancementHelper, AdvancementHelper$$constructor>;
                        interface AdvancementHelper$$constructor extends SuppressProperties {

                            new (base: /* minecraft class */ any): AdvancementHelper;

                        }
                        interface AdvancementHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                            /**
                             * @return the parent advancement or {@code null} if there is none.
                             * @since 1.8.4
                             */
                            getParent(): AdvancementHelper;

                            /**
                             * @return a list of all child advancements.
                             * @since 1.8.4
                             */
                            getChildren(): JavaList<AdvancementHelper>;

                            /**
                             * @return the requirements of this advancement.
                             * @since 1.8.4
                             */
                            getRequirements(): JavaArray<JavaArray<string>>;

                            /**
                             * @return the amount of requirements.
                             * @since 1.8.4
                             */
                            getRequirementCount(): number;

                            /**
                             * @return the identifier of this advancement.
                             * @since 1.8.4
                             */
                            getId(): AdvancementId;

                            /**
                             * @return a map of all criteria and their criterion of this advancement.
                             * @since 1.8.4
                             */
                            getCriteria(): JavaMap<string, string>;

                            /**
                             * @return the experience awarded by this advancement.
                             * @since 1.8.4
                             */
                            getExperience(): number;

                            /**
                             * @return the loot table ids for this advancement's rewards.
                             * @since 1.8.4
                             */
                            getLoot(): JavaArray<string>;

                            /**
                             * @return the recipes unlocked through this advancement.
                             * @since 1.8.4
                             */
                            getRecipes(): JavaArray<RecipeId>;

                            /**
                             * @return the progress.
                             * @since 1.8.4
                             */
                            getProgress(): AdvancementProgressHelper;

                        }

                        export {
                            SuggestionsBuilderHelper,
                            OptionsHelper,
                            ModContainerHelper,
                            StyleHelper,
                            CommandContextHelper,
                            PacketByteBufferHelper,
                            StatusEffectHelper,
                            CommandNodeHelper,
                            TextHelper,
                            FormattingHelper,
                            StatsHelper,
                            OptionsHelper$ControlOptionsHelper,
                            OptionsHelper$MusicOptionsHelper,
                            OptionsHelper$ChatOptionsHelper,
                            OptionsHelper$VideoOptionsHelper,
                            NBTElementHelper,
                            AdvancementManagerHelper,
                            NBTElementHelper$NBTCompoundHelper,
                            OptionsHelper$SkinOptionsHelper,
                            OptionsHelper$AccessibilityOptionsHelper,
                            AdvancementProgressHelper,
                            NBTElementHelper$NBTNumberHelper,
                            NBTElementHelper$NBTListHelper,
                            AdvancementHelper
                        }

                    }
                    namespace helpers {

                        namespace inventory {

                            /**
                             * @author Wagyourtail
                             */
                            const ItemStackHelper: JavaClassStatics<ItemStackHelper, ItemStackHelper$$constructor>;
                            interface ItemStackHelper$$constructor extends SuppressProperties {

                                new (id: ItemId, count: int): ItemStackHelper;
                                new (i: /* minecraft class */ any): ItemStackHelper;

                            }
                            interface ItemStackHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * Sets the item damage value.  
                                 *  You should use {@link CreativeItemStackHelper#setDamage} instead.  
                                 *  You may want to use {@link ItemStackHelper#copy} first.
                                 * @since 1.2.0
                                 * @param damage
                                 * @return
                                 * @deprecated
                                 */
                                setDamage(damage: int): ItemStackHelper;

                                /**
                                 * @since 1.2.0
                                 * @return
                                 */
                                isDamageable(): boolean;

                                /**
                                 * @return {@code true} if this item is unbreakable, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isUnbreakable(): boolean;

                                /**
                                 * @since 1.2.0
                                 * @return
                                 */
                                isEnchantable(): boolean;

                                /**
                                 * @return {@code true} if the item is enchanted, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isEnchanted(): boolean;

                                /**
                                 * @return a list of all enchantments on this item.
                                 * @since 1.8.4
                                 */
                                getEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @param id the id of the enchantment to check for
                                 * @return the enchantment instance, containing the level, or {@code null} if the item is not
                                 *          enchanted with the specified enchantment.
                                 * @since 1.8.4
                                 */
                                getEnchantment(id: EnchantmentId): EnchantmentHelper;

                                /**
                                 * @param enchantment the enchantment to check for
                                 * @return {@code true} if the specified enchantment can be applied to this item, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                canBeApplied(enchantment: EnchantmentHelper): boolean;

                                /**
                                 * @param enchantment the enchantment to check for
                                 * @return {@code true} if the item is enchanted with the specified enchantment of the same
                                 *          level, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                hasEnchantment(enchantment: EnchantmentHelper): boolean;

                                /**
                                 * @param enchantment the id of the enchantment to check for
                                 * @return {@code true} if the item is enchanted with the specified enchantment, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                hasEnchantment(id: EnchantmentId): boolean;

                                /**
                                 * @return a list of all enchantments that can be applied to this item.
                                 * @since 1.8.4
                                 */
                                getPossibleEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @return a list of all enchantments that can be applied to this item through an enchanting table.
                                 * @since 1.8.4
                                 */
                                getPossibleEnchantmentsFromTable(): JavaList<EnchantmentHelper>;

                                /**
                                 * The returned list is a copy of the original list and can be modified without affecting the
                                 *  original item. For editing the actual lore see
                                 *  {@link CreativeItemStackHelper#addLore}.
                                 * @return a list of all lines of lore on this item.
                                 * @since 1.8.4
                                 */
                                getLore(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return the maximum durability of this item.
                                 * @since 1.8.4
                                 */
                                getMaxDurability(): number;

                                /**
                                 * @return the current durability of this item.
                                 * @since 1.8.4
                                 */
                                getDurability(): number;

                                /**
                                 * @return the current repair cost of this item.
                                 * @since 1.8.4
                                 */
                                getRepairCost(): number;

                                /**
                                 * @return the damage taken by this item.
                                 * @see #getDurability()
                                 */
                                getDamage(): number;

                                /**
                                 * @return the maximum damage this item can take.
                                 * @see #getMaxDurability()
                                 */
                                getMaxDamage(): number;

                                /**
                                 * @return the default attack damage of this item.
                                 * @since 1.8.4
                                 */
                                getAttackDamage(): number;

                                /**
                                 * @since 1.2.0
                                 * @return was string before 1.6.5
                                 */
                                getDefaultName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return was string before 1.6.5
                                 */
                                getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return the item count this stack is holding.
                                 */
                                getCount(): number;

                                /**
                                 * @return the maximum amount of items this stack can hold.
                                 */
                                getMaxCount(): number;

                                /**
                                 * @since 1.1.6, was a {@link String} until 1.5.1
                                 * @return
                                 */
                                getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<any>;

                                /**
                                 * @since 1.1.3
                                 * @return
                                 */
                                getCreativeTab(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                /** @deprecated */
                                getItemID(): ItemId;

                                /**
                                 * @since 1.6.4
                                 * @return
                                 */
                                getItemId(): ItemId;

                                /**
                                 * @since 1.8.2
                                 * @return
                                 */
                                getTags(): JavaList<ItemTag>;

                                /**
                                 * @since 1.8.2
                                 * @return
                                 */
                                isFood(): boolean;

                                /**
                                 * @since 1.8.2
                                 * @return
                                 */
                                isTool(): boolean;

                                /**
                                 * @since 1.8.2
                                 * @return
                                 */
                                isWearable(): boolean;

                                /**
                                 * @since 1.8.2
                                 * @return
                                 */
                                getMiningLevel(): number;

                                /**
                                 * @return
                                 */
                                isEmpty(): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param ish
                                 * @return
                                 */
                                equals(ish: ItemStackHelper): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param is
                                 * @return
                                 */
                                equals(is: /* minecraft class */ any): boolean;
                                equals(obj: any): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param ish
                                 * @return
                                 */
                                isItemEqual(ish: ItemStackHelper): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param is
                                 * @return
                                 */
                                isItemEqual(is: /* minecraft class */ any): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param ish
                                 * @return
                                 */
                                isItemEqualIgnoreDamage(ish: ItemStackHelper): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param is
                                 * @return
                                 */
                                isItemEqualIgnoreDamage(is: /* minecraft class */ any): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param ish
                                 * @return
                                 */
                                isNBTEqual(ish: ItemStackHelper): boolean;

                                /**
                                 * @since 1.1.3 [citation needed]
                                 * @param is
                                 * @return
                                 */
                                isNBTEqual(is: /* minecraft class */ any): boolean;

                                /**
                                 * @since 1.6.5
                                 * @return
                                 */
                                isOnCooldown(): boolean;

                                /**
                                 * @since 1.6.5
                                 * @return
                                 */
                                getCooldownProgress(): number;

                                /**
                                 * @param block the block to check
                                 * @return {@code true} if the given block can be mined and drops when broken with this item,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper): boolean;

                                /**
                                 * @param block the block to check
                                 * @return {@code true} if the given block can be mined and drops when broken with this item,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): boolean;

                                /**
                                 * {@link CreativeItemStackHelper} adds methods for manipulating the item's nbt data.
                                 * @return a {@link CreativeItemStackHelper} instance for this item.
                                 * @since 1.8.4
                                 */
                                getCreative(): CreativeItemStackHelper;

                                /**
                                 * @return the item this stack is made of.
                                 * @since 1.8.4
                                 */
                                getItem(): ItemHelper;

                                /**
                                 * @since 1.2.0
                                 * @return
                                 */
                                copy(): ItemStackHelper;

                                /**
                                 * This flag only affects players in adventure mode and makes sure only specified blocks can be
                                 *  destroyed by this item.
                                 * @return {@code true} if the can destroy flag is set, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                hasDestroyRestrictions(): boolean;

                                /**
                                 * This flag only affects players in adventure mode and makes sure this item can only be placed
                                 *  on specified blocks.
                                 * @return {@code true} if the can place on flag is set, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                hasPlaceRestrictions(): boolean;

                                /**
                                 * @return a list of all filters set for the can destroy flag.
                                 * @since 1.8.4
                                 */
                                getDestroyRestrictions(): JavaList<string>;

                                /**
                                 * @return a list of all filters set for the can place on flag.
                                 * @since 1.8.4
                                 */
                                getPlaceRestrictions(): JavaList<string>;

                                /**
                                 * @return {@code true} if enchantments are hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                areEnchantmentsHidden(): boolean;

                                /**
                                 * @return {@code true} if modifiers are hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                areModifiersHidden(): boolean;

                                /**
                                 * @return {@code true} if the unbreakable flag is hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isUnbreakableHidden(): boolean;

                                /**
                                 * @return {@code true} if the can destroy flag is hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isCanDestroyHidden(): boolean;

                                /**
                                 * @return {@code true} if the can place flag is hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isCanPlaceHidden(): boolean;

                                /**
                                 * @return {@code true} if additional attributes are hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                areAdditionalsHidden(): boolean;

                                /**
                                 * @return {@code true} if dye of colored leather armor is hidden, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isDyeHidden(): boolean;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const EnchantmentHelper: JavaClassStatics<EnchantmentHelper, EnchantmentHelper$$constructor>;
                            interface EnchantmentHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): EnchantmentHelper;
                                new (base: /* minecraft class */ any, level: int): EnchantmentHelper;
                                new (enchantment: EnchantmentId): EnchantmentHelper;

                            }
                            interface EnchantmentHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return the level of this enchantment.
                                 * @since 1.8.4
                                 */
                                getLevel(): number;

                                /**
                                 * @return the minimum possible level of this enchantment that one can get in vanilla.
                                 * @since 1.8.4
                                 */
                                getMinLevel(): number;

                                /**
                                 * @return the maximum possible level of this enchantment that one can get in vanilla.
                                 * @since 1.8.4
                                 */
                                getMaxLevel(): number;

                                /**
                                 * @param level the level for the name
                                 * @return the translated name of this enchantment for the given level.
                                 * @since 1.8.4
                                 */
                                getLevelName(level: int): string;

                                /**
                                 * Because roman numerals only support positive integers in the range of 1 to 3999, this method
                                 *  will return the arabic numeral for any given level outside that range.
                                 * @return the translated name of this enchantment for the given level in roman numerals.
                                 * @since 1.8.4
                                 */
                                getRomanLevelName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * Because roman numerals only support positive integers in the range of 1 to 3999, this method
                                 *  will return the arabic numeral for any given level outside that range.
                                 * @param level the level for the name
                                 * @return the translated name of this enchantment for the given level in roman numerals.
                                 * @since 1.8.4
                                 */
                                getRomanLevelName(level: int): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return the name of this enchantment.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * @return the id of this enchantment.
                                 * @since 1.8.4
                                 */
                                getId(): EnchantmentId;

                                /**
                                 * @return the rarity of this enchantment.
                                 * @since 1.8.4
                                 */
                                getRarity(): EnchantmentRarity;

                                /**
                                 * Only accounts for enchantments of the same target type.
                                 * @return a list of all enchantments that conflict with this one.
                                 * @since 1.8.4
                                 */
                                getConflictingEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @param ignoreType whether to check only enchantments that can be applied to the same target
                                 *                    type.
                                 * @return a list of all enchantments that conflict with this one.
                                 * @since 1.8.4
                                 */
                                getConflictingEnchantments(ignoreType: boolean): JavaList<EnchantmentHelper>;

                                /**
                                 * Only accounts for enchantments of the same target type.
                                 * @return a list of all enchantments that can be combined with this one.
                                 * @since 1.8.4
                                 */
                                getCompatibleEnchantments(): JavaList<EnchantmentHelper>;

                                /**
                                 * @param ignoreType whether to check only enchantments that can be applied to the same target
                                 *                    type.
                                 * @return a list of all enchantments that can be combined with this one.
                                 * @since 1.8.4
                                 */
                                getCompatibleEnchantments(ignoreType: boolean): JavaList<EnchantmentHelper>;

                                /**
                                 * @return the type of item this enchantment is compatible with.
                                 * @since 1.8.4
                                 */
                                getTargetType(): EnchantmentTargetType;

                                /**
                                 * The weight of an enchantment is bound to its rarity. The higher the weight, the more likely
                                 *  it is to be chosen.
                                 * @return the relative probability of this enchantment being applied to an enchanted item
                                 *          through the enchanting table or a loot table.
                                 * @since 1.8.4
                                 */
                                getWeight(): number;

                                /**
                                 * Curses are enchantments that can't be removed from the item they were applied to. They
                                 *  usually only have one possible level and can't be upgraded. When combining items with curses
                                 *  on them, they are transferred like any other enchantment. They can't be obtained through
                                 *  enchantment tables, but rather from loot chests, fishing or trading with villagers.
                                 * @return {@code true} if this enchantment is a curse, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isCursed(): boolean;

                                /**
                                 * Treasures are enchantments that can't be obtained through enchantment tables, but rather from
                                 *  loot chests, fishing or trading with villagers.
                                 * @return {@code true} if this enchantment is a treasure, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isTreasure(): boolean;

                                /**
                                 * @param item the item to check
                                 * @return {@code true} if this enchantment can be applied to the given item type, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                canBeApplied(item: ItemHelper): boolean;

                                /**
                                 * @param item the item to check
                                 * @return {@code true} if this enchantment can be applied to the given item, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                canBeApplied(item: ItemStackHelper): boolean;

                                /**
                                 * @return a list of all acceptable item ids for this enchantment.
                                 * @since 1.8.4
                                 */
                                getAcceptableItems(): JavaList<ItemHelper>;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return {@code true} if this enchantment is compatible with the given enchantment,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isCompatible(enchantment: EnchantmentId): boolean;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return {@code true} if this enchantment is compatible with the given enchantment,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isCompatible(enchantment: EnchantmentHelper): boolean;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return {@code true} if this enchantment conflicts with the given enchantment, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                conflictsWith(enchantment: EnchantmentId): boolean;

                                /**
                                 * @param enchantment the enchantment to check
                                 * @return {@code true} if this enchantment conflicts with the given enchantment, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                conflictsWith(enchantment: EnchantmentHelper): boolean;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const ItemHelper: JavaClassStatics<ItemHelper, ItemHelper$$constructor>;
                            interface ItemHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): ItemHelper;

                            }
                            interface ItemHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return the name of this item's group or {@code "UNKNOWN"} if this item is not in a group.
                                 * @since 1.8.4
                                 */
                                getCreativeTab(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return the item stack representing the group of this item or {@code null} if this item is
                                 *          not in a group.
                                 * @since 1.8.4
                                 */
                                getGroupIcon(): JavaList<ItemStackHelper>;

                                /**
                                 * @param stack the possible repair material
                                 * @return {@code true} if the given item stack can be used to repair item stacks of this item,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                canBeRepairedWith(stack: ItemStackHelper): boolean;

                                /**
                                 * @param block the block to check
                                 * @return {@code true} if the given block can be mined and drops when broken with this item,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper): boolean;

                                /**
                                 * @param block the block to check
                                 * @return {@code true} if the given block can be mined and drops when broken with this item,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isSuitableFor(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): boolean;

                                /**
                                 * @return {@code true} if the item has a block representation, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isBlockItem(): boolean;

                                /**
                                 * @return the block representation of this item or {@code null} if this item has no
                                 *          corresponding block.
                                 * @since 1.8.4
                                 */
                                getBlock(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper;

                                /**
                                 * @param state the block state to check
                                 * @return the mining speed of this item against the given block state, returns {@code 1} by
                                 *          default.
                                 * @since 1.8.4
                                 */
                                getMiningSpeedMultiplier(state: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): number;

                                /**
                                 * @return {@code true} if the item has durability, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isDamageable(): boolean;

                                /**
                                 * @return {@code true} if when crafter the item stack has a remainder, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                hasRecipeRemainder(): boolean;

                                /**
                                 * @return the recipe remainder if it exists and {@code null} otherwise.
                                 * @since 1.8.4
                                 */
                                getRecipeRemainder(): ItemHelper;

                                /**
                                 * With increased enchantability the change to get more and better enchantments increases.
                                 * @return the enchantability of this item, returns {@code 0} by default.
                                 * @since 1.8.4
                                 */
                                getEnchantability(): number;

                                /**
                                 * @return the name of this item, translated to the current language.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * @return the identifier of this item.
                                 * @since 1.8.4
                                 */
                                getId(): ItemId;

                                /**
                                 * @return the maximum amount of items in a stack of this item.
                                 * @since 1.8.4
                                 */
                                getMaxCount(): number;

                                /**
                                 * The damage an item has taken is the opposite of the durability still left.
                                 * @return the maximum amount of damage this item can take.
                                 * @since 1.8.4
                                 */
                                getMaxDurability(): number;

                                /**
                                 * @return {@code true} if this item is fireproof, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isFireproof(): boolean;

                                /**
                                 * @return {@code true} if this item is a tool, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isTool(): boolean;

                                /**
                                 * @return {@code true} if this item can be worn in the armor slot, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isWearable(): boolean;

                                /**
                                 * @return {@code true} if this item is food, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isFood(): boolean;

                                /**
                                 * @return the food component of this item or {@code null} if this item is not food.
                                 * @since 1.8.4
                                 */
                                getFood(): FoodComponentHelper;

                                /**
                                 * @return {@code true} if this item can be nested, i.e. put into a bundle or shulker box,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                canBeNested(): boolean;

                                /**
                                 * @return the default item stack of this item with a stack size of {@code 1}.
                                 * @since 1.8.4
                                 */
                                getDefaultStack(): ItemStackHelper;

                                /**
                                 * @param nbt the nbt data of the item stack
                                 * @return the item stack of this item with a stack size of {@code 1} and the given nbt.
                                 * @throws CommandSyntaxException if the nbt data is invalid.
                                 * @since 1.8.4
                                 */
                                getStackWithNbt(nbt: string): ItemStackHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const FoodComponentHelper: JavaClassStatics<FoodComponentHelper, FoodComponentHelper$$constructor>;
                            interface FoodComponentHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): FoodComponentHelper;

                            }
                            interface FoodComponentHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return the amount of hunger this food restores.
                                 * @since 1.8.4
                                 */
                                getHunger(): number;

                                /**
                                 * @return the amount of saturation this food restores.
                                 * @since 1.8.4
                                 */
                                getSaturation(): number;

                                /**
                                 * @return {@code true} if this food can be eaten by wolves, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isMeat(): boolean;

                                /**
                                 * @return {@code true} if this food can be eaten even when the player is not hungry,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isAlwaysEdible(): boolean;

                                /**
                                 * @return {@code true} if the food can be eaten faster than usual, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isFastFood(): boolean;

                                /**
                                 * @return a map of status effects and their respective probabilities.
                                 * @since 1.8.4
                                 */
                                getStatusEffects(): JavaMap<xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper, number>;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const CreativeItemStackHelper: JavaClassStatics<CreativeItemStackHelper, CreativeItemStackHelper$$constructor>;
                            interface CreativeItemStackHelper$$constructor extends SuppressProperties {

                                new (itemStack: /* minecraft class */ any): CreativeItemStackHelper;

                            }
                            interface CreativeItemStackHelper extends ItemStackHelper {

                                /**
                                 * @param damage the damage the item should take
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setDamage(damage: int): CreativeItemStackHelper;

                                /**
                                 * @param durability the new durability of this item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setDurability(durability: int): CreativeItemStackHelper;

                                /**
                                 * @param count the new count of the item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCount(count: int): CreativeItemStackHelper;

                                /**
                                 * @param name the new name of the item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setName(name: string): CreativeItemStackHelper;

                                /**
                                 * @param name the new name of the item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setName(name: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): CreativeItemStackHelper;

                                /**
                                 * @param id the id of the enchantment
                                 * @param level the level of the enchantment
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addEnchantment(id: EnchantmentId, level: int): CreativeItemStackHelper;

                                /**
                                 * @param enchantment the enchantment to add
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addEnchantment(enchantment: EnchantmentHelper): CreativeItemStackHelper;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                clearEnchantments(): CreativeItemStackHelper;

                                /**
                                 * @param enchantment the enchantment to remove
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                removeEnchantment(enchantment: EnchantmentHelper): CreativeItemStackHelper;

                                /**
                                 * @param id the id of the enchantment to remove
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                removeEnchantment(id: EnchantmentId): CreativeItemStackHelper;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                clearLore(): CreativeItemStackHelper;

                                /**
                                 * @param lore the new lore
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setLore(...lore: any[]): CreativeItemStackHelper;

                                /**
                                 * @param lore the lore to add
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addLore(...lore: any[]): CreativeItemStackHelper;

                                /**
                                 * @param unbreakable whether the item should be unbreakable or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setUnbreakable(unbreakable: boolean): CreativeItemStackHelper;

                                /**
                                 * @param hide whether to hide the enchantments or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideEnchantments(hide: boolean): CreativeItemStackHelper;

                                /**
                                 * @param hide whether to hide attributes and modifiers or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideModifiers(hide: boolean): CreativeItemStackHelper;

                                /**
                                 * @param hide whether to hide the unbreakable flag or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideUnbreakable(hide: boolean): CreativeItemStackHelper;

                                /**
                                 * @param hide whether to hide the blocks this item can destroy or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideCanDestroy(hide: boolean): CreativeItemStackHelper;

                                /**
                                 * @param hide whether to hide the blocks this item can be placed on or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideCanPlace(hide: boolean): CreativeItemStackHelper;

                                /**
                                 * These flags are for banner patterns, potion effects, book information and other special
                                 *  flags.
                                 * @param hide whether to hide additional flags or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideAdditional(hide: boolean): CreativeItemStackHelper;

                                /**
                                 * @param hide whether to hide the color of colored leather armor or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hideDye(hide: boolean): CreativeItemStackHelper;

                            }

                            export {
                                ItemStackHelper,
                                EnchantmentHelper,
                                ItemHelper,
                                FoodComponentHelper,
                                CreativeItemStackHelper
                            }

                        }

                        namespace world {

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const FluidStateHelper: JavaClassStatics<FluidStateHelper, FluidStateHelper$$constructor>;
                            interface FluidStateHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): FluidStateHelper;

                            }
                            interface FluidStateHelper extends StateHelper</* minecraft class */ any> {

                                /**
                                 * @return the block's id.
                                 * @since 1.8.4
                                 */
                                getId(): BlockId;

                                /**
                                 * @return {@code true} if this fluid is still, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isStill(): boolean;

                                /**
                                 * @return {@code true} if this fluid is empty (the default fluid state for non fluid blocks),
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isEmpty(): boolean;

                                /**
                                 * @return the height of this state.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * @return the level of this state.
                                 * @since 1.8.4
                                 */
                                getLevel(): number;

                                /**
                                 * @return {@code true} if the fluid has some random tick logic (only used by lava to do the
                                 *          fire spread), {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                hasRandomTicks(): boolean;

                                /**
                                 * @param pos the position in the world
                                 * @return the velocity that will be applied to entities at the given position.
                                 * @since 1.8.4
                                 */
                                getVelocity(pos: BlockPosHelper): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                /**
                                 * @return the block state of this fluid.
                                 * @since 1.8.4
                                 */
                                getBlockState(): BlockStateHelper;

                                /**
                                 * @return the blast resistance of this fluid.
                                 * @since 1.8.4
                                 */
                                getBlastResistance(): number;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.0.2
                             */
                            const PlayerListEntryHelper: JavaClassStatics<PlayerListEntryHelper, PlayerListEntryHelper$$constructor>;
                            interface PlayerListEntryHelper$$constructor extends SuppressProperties {

                                new (p: /* minecraft class */ any): PlayerListEntryHelper;

                            }
                            interface PlayerListEntryHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @since 1.1.9
                                 * @return
                                 */
                                getUUID(): string;

                                /**
                                 * @since 1.0.2
                                 * @return
                                 */
                                getName(): string;

                                /**
                                 * @since 1.6.5
                                 * @return
                                 */
                                getPing(): number;

                                /**
                                 * @since 1.6.5
                                 * @return null if unknown
                                 */
                                getGamemode(): Gamemode;

                                /**
                                 * @since 1.1.9
                                 * @return
                                 */
                                getDisplayText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @since 1.8.2
                                 * @return
                                 */
                                getPublicKey(): JavaArray<number>;

                                /**
                                 * @return {@code true} if the player has a cape enabled, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                hasCape(): boolean;

                                /**
                                 * A slim skin is an Alex skin, while the default one is Steve.
                                 * @return {@code true} if the player has a slim skin, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                hasSlimModel(): boolean;

                                /**
                                 * @return the identifier of the player's skin texture or {@code null} if it's unknown.
                                 * @since 1.8.4
                                 */
                                getSkinTexture(): string;

                                /**
                                 * @return the identifier of the player's cape texture or {@code null} if it's unknown.
                                 * @since 1.8.4
                                 */
                                getCapeTexture(): string;

                                /**
                                 * @return the identifier of the player's elytra texture or {@code null} if it's unknown.
                                 * @since 1.8.4
                                 */
                                getElytraTexture(): string;

                                /**
                                 * @return the team of the player or {@code null} if the player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeam(): TeamHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            const BlockStateHelper: JavaClassStatics<BlockStateHelper, BlockStateHelper$$constructor>;
                            interface BlockStateHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): BlockStateHelper;

                            }
                            interface BlockStateHelper extends StateHelper</* minecraft class */ any> {

                                /**
                                 * @return the block the state belongs to.
                                 * @since 1.6.5
                                 */
                                getBlock(): BlockHelper;

                                /**
                                 * @return the block's id.
                                 * @since 1.8.4
                                 */
                                getId(): BlockId;

                                /**
                                 * @return the fluid state of this block state.
                                 * @since 1.8.4
                                 */
                                getFluidState(): FluidStateHelper;

                                /**
                                 * @return the hardness.
                                 * @since 1.6.5
                                 */
                                getHardness(): number;

                                /**
                                 * @return the luminance.
                                 * @since 1.6.5
                                 */
                                getLuminance(): number;

                                /**
                                 * @return {@code true} if the state emits redstone power.
                                 * @since 1.6.5
                                 */
                                emitsRedstonePower(): boolean;

                                /**
                                 * @return {@code true} if the shape of the state is a cube.
                                 * @since 1.6.5
                                 */
                                exceedsCube(): boolean;

                                /**
                                 * @return {@code true} if the state is air.
                                 * @since 1.6.5
                                 */
                                isAir(): boolean;

                                /**
                                 * @return {@code true} if the state is opaque.
                                 * @since 1.6.5
                                 */
                                isOpaque(): boolean;

                                /**
                                 * @return {@code true} if a tool is required to mine the block.
                                 * @since 1.6.5
                                 */
                                isToolRequired(): boolean;

                                /**
                                 * @return {@code true} if the state has a block entity.
                                 * @since 1.6.5
                                 */
                                hasBlockEntity(): boolean;

                                /**
                                 * @return {@code true} if the state can be random ticked.
                                 * @since 1.6.5
                                 */
                                hasRandomTicks(): boolean;

                                /**
                                 * @return {@code true} if the state has a comparator output.
                                 * @since 1.6.5
                                 */
                                hasComparatorOutput(): boolean;

                                /**
                                 * @return the piston behaviour of the state.
                                 * @since 1.6.5
                                 */
                                getPistonBehaviour(): PistonBehaviour;

                                /**
                                 * @return {@code true} if the state blocks light.
                                 * @since 1.6.5
                                 */
                                blocksLight(): boolean;

                                /**
                                 * @return {@code true} if the state blocks the movement of entities.
                                 * @since 1.6.5
                                 */
                                blocksMovement(): boolean;

                                /**
                                 * @return {@code true} if the state is burnable.
                                 * @since 1.6.5
                                 */
                                isBurnable(): boolean;

                                /**
                                 * @return {@code true} if the state is a liquid.
                                 * @since 1.6.5
                                 */
                                isLiquid(): boolean;

                                /**
                                 * @return {@code true} if the state is solid.
                                 * @since 1.6.5
                                 */
                                isSolid(): boolean;

                                /**
                                 * This will return true for blocks like air and grass, that can be replaced without breaking
                                 *  them first.
                                 * @return {@code true} if the state can be replaced.
                                 * @since 1.6.5
                                 */
                                isReplaceable(): boolean;

                                /**
                                 * @param pos the position of the block to check
                                 * @param entity the entity type to check
                                 * @return {@code true} if the entity can spawn on this block state at the given position in the
                                 *          current world.
                                 * @since 1.6.5
                                 */
                                allowsSpawning(pos: BlockPosHelper, entity: string): boolean;

                                /**
                                 * @param pos the position of the block to check
                                 * @return {@code true} if an entity can suffocate in this block state at the given position in
                                 *          the current world.
                                 * @since 1.6.5
                                 */
                                shouldSuffocate(pos: BlockPosHelper): boolean;

                                /**
                                 * @return an {@link UniversalBlockStateHelper} to access all properties of this block state.
                                 * @since 1.8.4
                                 */
                                getUniversal(): UniversalBlockStateHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            const BlockHelper: JavaClassStatics<BlockHelper, BlockHelper$$constructor>;
                            interface BlockHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): BlockHelper;

                            }
                            interface BlockHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return the default state of the block.
                                 * @since 1.6.5
                                 */
                                getDefaultState(): BlockStateHelper;

                                /**
                                 * @return the default item stack of the block.
                                 * @since 1.6.5
                                 */
                                getDefaultItemStack(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                canMobSpawnInside(): boolean;

                                /**
                                 * @return {@code true} if the block has dynamic bounds.
                                 * @since 1.6.5
                                 */
                                hasDynamicBounds(): boolean;

                                /**
                                 * @return the blast resistance.
                                 * @since 1.6.5
                                 */
                                getBlastResistance(): number;

                                /**
                                 * @return the jump velocity multiplier.
                                 * @since 1.6.5
                                 */
                                getJumpVelocityMultiplier(): number;

                                /**
                                 * @return the slipperiness.
                                 * @since 1.6.5
                                 */
                                getSlipperiness(): number;

                                /**
                                 * @return the hardness.
                                 * @since 1.6.5
                                 */
                                getHardness(): number;

                                /**
                                 * @return the velocity multiplier.
                                 * @since 1.6.5
                                 */
                                getVelocityMultiplier(): number;

                                /**
                                 * @return all tags of the block as an {@link java.util.ArrayList ArrayList}.
                                 * @since 1.6.5
                                 */
                                getTags(): JavaList<BlockTag>;

                                /**
                                 * @return all possible block states of the block.
                                 * @since 1.6.5
                                 */
                                getStates(): JavaList<BlockStateHelper>;

                                /**
                                 * @return the identifier of the block.
                                 * @since 1.6.5
                                 */
                                getId(): BlockId;

                                /**
                                 * @return the name of the block.
                                 * @since 1.8.4
                                 */
                                getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.2.6
                             */
                            const BlockPosHelper: JavaClassStatics<BlockPosHelper, BlockPosHelper$$constructor>;
                            interface BlockPosHelper$$constructor extends SuppressProperties {

                                new (b: /* minecraft class */ any): BlockPosHelper;
                                new (x: int, y: int, z: int): BlockPosHelper;

                            }
                            interface BlockPosHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @since 1.2.6
                                 * @return the {@code x} value of the block.
                                 */
                                getX(): number;

                                /**
                                 * @since 1.2.6
                                 * @return the {@code y} value of the block.
                                 */
                                getY(): number;

                                /**
                                 * @since 1.2.6
                                 * @return the {@code z} value of the block.
                                 */
                                getZ(): number;

                                /**
                                 * @return the block above.
                                 * @since 1.6.5
                                 */
                                up(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move up
                                 * @return the block n-th block above.
                                 * @since 1.6.5
                                 */
                                up(distance: int): BlockPosHelper;

                                /**
                                 * @return the block below.
                                 * @since 1.6.5
                                 */
                                down(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move down
                                 * @return the block n-th block below.
                                 * @since 1.6.5
                                 */
                                down(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the north.
                                 * @since 1.6.5
                                 */
                                north(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move north
                                 * @return the n-th block to the north.
                                 * @since 1.6.5
                                 */
                                north(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the south.
                                 * @since 1.6.5
                                 */
                                south(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move south
                                 * @return the n-th block to the south.
                                 * @since 1.6.5
                                 */
                                south(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the east.
                                 * @since 1.6.5
                                 */
                                east(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move east
                                 * @return the n-th block to the east.
                                 * @since 1.6.5
                                 */
                                east(distance: int): BlockPosHelper;

                                /**
                                 * @return the block to the west.
                                 * @since 1.6.5
                                 */
                                west(): BlockPosHelper;

                                /**
                                 * @param distance the distance to move west
                                 * @return the n-th block to the west.
                                 * @since 1.6.5
                                 */
                                west(distance: int): BlockPosHelper;

                                /**
                                 * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                 * @return the block offset by the given direction.
                                 * @since 1.6.5
                                 */
                                offset(direction: string): BlockPosHelper;

                                /**
                                 * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                 * @param distance the distance to move in the given direction
                                 * @return the n-th block offset by the given direction.
                                 * @since 1.6.5
                                 */
                                offset(direction: string, distance: int): BlockPosHelper;

                                /**
                                 * @param x the x offset
                                 * @param y the y offset
                                 * @param z the y offset
                                 * @return the block offset by the given values.
                                 * @since 1.8.4
                                 */
                                offset(x: int, y: int, z: int): BlockPosHelper;

                                /**
                                 * @return the block position converted to the respective nether coordinates.
                                 * @since 1.8.4
                                 */
                                toNetherCoords(): BlockPosHelper;

                                /**
                                 * @return the block position converted to the respective overworld coordinates.
                                 * @since 1.8.4
                                 */
                                toOverworldCoords(): BlockPosHelper;

                                /**
                                 * @param entity the entity to get the distance to
                                 * @return the distance of this position to the given entity.
                                 * @since 1.8.4
                                 */
                                distanceTo(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): number;

                                /**
                                 * @param pos the position to get the distance to
                                 * @return the distance of this position to the given position.
                                 * @since 1.8.4
                                 */
                                distanceTo(pos: BlockPosHelper): number;

                                /**
                                 * @param pos the position to get the distance to
                                 * @return the distance of this position to the given position.
                                 * @since 1.8.4
                                 */
                                distanceTo(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): number;

                                /**
                                 * @param x the x coordinate to get the distance to
                                 * @param y the y coordinate to get the distance to
                                 * @param z the z coordinate to get the distance to
                                 * @return the distance of this position to the given position.
                                 * @since 1.8.4
                                 */
                                distanceTo(x: double, y: double, z: double): number;

                                /**
                                 * @return the {@link Pos3D} representation of this position.
                                 * @since 1.8.4
                                 */
                                toPos3D(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                            }

                            /** @since 1.6.5 */
                            const ServerInfoHelper: JavaClassStatics<ServerInfoHelper, ServerInfoHelper$$constructor>;
                            interface ServerInfoHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): ServerInfoHelper;

                            }
                            interface ServerInfoHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                getName(): string;
                                getAddress(): string;
                                getPlayerCountLabel(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getLabel(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getPing(): number;
                                getProtocolVersion(): number;
                                getVersion(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getPlayerListSummary(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                resourcePackPolicy(): string;
                                getIcon(): string;
                                isOnline(): boolean;
                                isLocal(): boolean;
                                getNbt(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<any>;

                                /**
                                 * @return {@code true} if the server enforces secure chat, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isSecureChatEnforced(): boolean;

                            }

                            /**
                             * @since 1.2.9
                             * @author Wagyourtail
                             */
                            const ScoreboardsHelper: JavaClassStatics<ScoreboardsHelper, ScoreboardsHelper$$constructor>;
                            interface ScoreboardsHelper$$constructor extends SuppressProperties {

                                new (board: /* minecraft class */ any): ScoreboardsHelper;

                            }
                            interface ScoreboardsHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @param index
                                 * @since 1.2.9
                                 * @return
                                 */
                                getObjectiveForTeamColorIndex(index: int): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper;

                                /**
                                 * `0` is tab list, `1` or `3 + getPlayerTeamColorIndex()` is sidebar, `2` should be below name.  
                                 *  therefore max slot number is 18.
                                 * @param slot
                                 * @since 1.2.9
                                 * @return
                                 */
                                getObjectiveSlot(slot: int): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper;

                                /**
                                 * @param entity
                                 * @since 1.2.9
                                 * @return
                                 */
                                getPlayerTeamColorIndex(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* minecraft class */ any>): number;

                                /**
                                 * @since 1.6.5
                                 * @return team index for client player
                                 */
                                getPlayerTeamColorIndex(): number;

                                /**
                                 * @return the formatting for the client player's team, {@code null} if the player is not in a
                                 *          team.
                                 * @since 1.8.4
                                 */
                                getTeamColorFormatting(): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;

                                /**
                                 * @param player the player to get the team color's formatting for.
                                 * @return the formatting for the client player's team, {@code null} if the player is not in a
                                 *          team.
                                 * @since 1.8.4
                                 */
                                getTeamColorFormatting(player: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* minecraft class */ any>): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;

                                /**
                                 * @param player the player to get the team color for
                                 * @return the color of the speicifed player's team or {@code -1} if the player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeamColor(player: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* minecraft class */ any>): number;

                                /**
                                 * @return the color of this player's team or {@code -1} if this player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeamColor(): number;

                                /**
                                 * @param player the player to get the team color's name for
                                 * @return the name of the speicifed player's team color or {@code null} if the player is not in
                                 *          a team.
                                 * @since 1.8.4
                                 */
                                getTeamColorName(player: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* minecraft class */ any>): string;

                                /**
                                 * @return the color of this player's team or {@code null} if this player is not in a team.
                                 * @since 1.8.4
                                 */
                                getTeamColorName(): string;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getTeams(): JavaList<TeamHelper>;

                                /**
                                 * @param p
                                 * @since 1.3.0
                                 * @return
                                 */
                                getPlayerTeam(p: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper</* minecraft class */ any>): TeamHelper;

                                /**
                                 * @since 1.6.5
                                 * @return team for client player
                                 */
                                getPlayerTeam(): TeamHelper;

                                /**
                                 * @since 1.2.9
                                 * @return the {@link ScoreboardObjectiveHelper} for the currently displayed sidebar scoreboard.
                                 */
                                getCurrentScoreboard(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper;

                            }

                            /**
                             * @author Wagyourtail
                             */
                            const BlockDataHelper: JavaClassStatics<BlockDataHelper, BlockDataHelper$$constructor>;
                            interface BlockDataHelper$$constructor extends SuppressProperties {

                                new (b: /* minecraft class */ any, e: /* minecraft class */ any, bp: /* minecraft class */ any): BlockDataHelper;

                            }
                            interface BlockDataHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @since 1.1.7
                                 * @return the {@code x} value of the block.
                                 */
                                getX(): number;

                                /**
                                 * @since 1.1.7
                                 * @return the {@code y} value of the block.
                                 */
                                getY(): number;

                                /**
                                 * @since 1.1.7
                                 * @return the {@code z} value of the block.
                                 */
                                getZ(): number;

                                /**
                                 * @return the item ID of the block.
                                 */
                                getId(): ItemId;

                                /**
                                 * @return the translated name of the block. (was string before 1.6.5)
                                 */
                                getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @return 
                                 * @since 1.5.1, used to be a {@link Map}<{@link String}, {@link String}>
                                 */
                                getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<any>;

                                /**
                                 * @return 
                                 * @since 1.6.5
                                 */
                                getBlockStateHelper(): BlockStateHelper;

                                /**
                                 * @return 
                                 * @since 1.6.5
                                 * @deprecated use {@link #getBlock()} instead.
                                 */
                                getBlockHelper(): BlockHelper;

                                /**
                                 * @return the block
                                 * @since 1.6.5
                                 */
                                getBlock(): BlockHelper;

                                /**
                                 * @since 1.1.7
                                 * @return block state data as a {@link Map}.
                                 */
                                getBlockState(): JavaMap<string, string>;

                                /**
                                 * @since 1.2.7
                                 * @return the block pos.
                                 */
                                getBlockPos(): BlockPosHelper;
                                getRawBlock(): /* minecraft class */ any;
                                getRawBlockState(): /* minecraft class */ any;
                                getRawBlockEntity(): /* minecraft class */ any;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const ChunkHelper: JavaClassStatics<ChunkHelper, ChunkHelper$$constructor>;
                            interface ChunkHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): ChunkHelper;

                            }
                            interface ChunkHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return the first block (0 0 0 coordinate) of this chunk.
                                 * @since 1.8.4
                                 */
                                getStartingBlock(): BlockPosHelper;

                                /**
                                 * The coordinates are relative to the starting chunk position, see
                                 *  {@link #getStartingBlock}.
                                 * @param xOffset the xOffset offset
                                 * @param y the actual y coordinate
                                 * @param zOffset the zOffset offset
                                 * @return the block offset from the starting block of this chunk by xOffset y zOffset.
                                 * @since 1.8.4
                                 */
                                getOffsetBlock(xOffset: int, y: int, zOffset: int): BlockPosHelper;

                                /**
                                 * @return the maximum height of this chunk.
                                 * @since 1.8.4
                                 */
                                getMaxBuildHeight(): number;

                                /**
                                 * @return the minimum height of this chunk.
                                 * @since 1.8.4
                                 */
                                getMinBuildHeight(): number;

                                /**
                                 * @return the height of this chunk.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * @param xOffset the xOffset coordinate
                                 * @param zOffset the zOffset coordinate
                                 * @param heightmap the heightmap to use
                                 * @return the maximum {@code y} position of all blocks inside this chunk.
                                 * @since 1.8.4
                                 */
                                getTopYAt(xOffset: int, zOffset: int, heightmap: /* minecraft class */ any): number;

                                /**
                                 * @return the {@code x} coordinate (not the world coordinate) of this chunk.
                                 * @since 1.8.4
                                 */
                                getChunkX(): number;

                                /**
                                 * @return the {@code z} coordinate (not the world coordinate) of this chunk.
                                 * @since 1.8.4
                                 */
                                getChunkZ(): number;

                                /**
                                 * @param xOffset the x offset
                                 * @param y the y coordinate
                                 * @param zOffset the z offset
                                 * @return the biome at the given position.
                                 * @since 1.8.4
                                 */
                                getBiome(xOffset: int, y: int, zOffset: int): Biome;

                                /**
                                 * With an increasing inhabited time, the local difficulty increases and stronger mobs will
                                 *  spawn. Because the time is cumulative, the more players are in the chunk, the faster the time
                                 *  will increase.
                                 * @return the cumulative time players have spent inside this chunk.
                                 * @since 1.8.4
                                 */
                                getInhabitedTime(): number;

                                /**
                                 * @return all entities inside this chunk.
                                 * @since 1.8.4
                                 */
                                getEntities(): JavaList<any>;

                                /**
                                 * @return all tile entity positions inside this chunk.
                                 * @since 1.8.4
                                 */
                                getTileEntities(): JavaList<BlockPosHelper>;

                                /**
                                 * @param includeAir whether to include air blocks or not
                                 * @param callback the callback function
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                forEach(includeAir: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<BlockDataHelper, any, any, any>): ChunkHelper;

                                /**
                                 * @param blocks the blocks to search for
                                 * @return {@code true} if this chunk contains at least one of the specified blocks,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                containsAny(...blocks: BlockId[]): boolean;

                                /**
                                 * @param blocks the blocks to search for
                                 * @return {@code true} if the chunk contains all the specified blocks, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                containsAll(...blocks: BlockId[]): boolean;

                                /**
                                 * @return a map of the raw heightmap data.
                                 * @since 1.8.4
                                 */
                                getHeightmaps(): JavaCollection<java.util.Map$Entry</* minecraft class */ any, /* minecraft class */ any>>;

                                /**
                                 * @return the raw surface heightmap.
                                 * @since 1.8.4
                                 */
                                getSurfaceHeightmap(): /* minecraft class */ any;

                                /**
                                 * @return the raw ocean floor heightmap.
                                 * @since 1.8.4
                                 */
                                getOceanFloorHeightmap(): /* minecraft class */ any;

                                /**
                                 * @return the raw motion blocking heightmap.
                                 * @since 1.8.4
                                 */
                                getMotionBlockingHeightmap(): /* minecraft class */ any;

                                /**
                                 * @return the raw motion blocking heightmap without leaves.
                                 * @since 1.8.4
                                 */
                                getMotionBlockingNoLeavesHeightmap(): /* minecraft class */ any;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const DirectionHelper: JavaClassStatics<DirectionHelper, DirectionHelper$$constructor>;
                            interface DirectionHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): DirectionHelper;

                            }
                            interface DirectionHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return the name of this direction.
                                 * @since 1.8.4
                                 */
                                getName(): string;

                                /**
                                 * @return the name of the axis this direction is aligned to.
                                 * @since 1.8.4
                                 */
                                getAxis(): string;

                                /**
                                 * @return {@code true} if this direction is vertical, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isVertical(): boolean;

                                /**
                                 * @return {@code true} if this direction is horizontal, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isHorizontal(): boolean;

                                /**
                                 * @return {@code true} if this direction is pointing in a positive direction, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                isTowardsPositive(): boolean;

                                /**
                                 * @return the yaw of this direction.
                                 * @since 1.8.4
                                 */
                                getYaw(): number;

                                /**
                                 * @return the pitch of this direction.
                                 * @since 1.8.4
                                 */
                                getPitch(): number;

                                /**
                                 * @return the opposite direction.
                                 * @since 1.8.4
                                 */
                                getOpposite(): DirectionHelper;

                                /**
                                 * @return the direction to the left.
                                 * @since 1.8.4
                                 */
                                getLeft(): DirectionHelper;

                                /**
                                 * @return the direction to the right.
                                 * @since 1.8.4
                                 */
                                getRight(): DirectionHelper;

                                /**
                                 * @return the direction as a directional vector.
                                 * @since 1.8.4
                                 */
                                getVector(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                /**
                                 * @param yaw the yaw to check
                                 * @return {@code true} if the yaw is facing this direction more than any other one,
                                 *          {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                pointsTo(yaw: double): boolean;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.3.0
                             */
                            const TeamHelper: JavaClassStatics<TeamHelper, TeamHelper$$constructor>;
                            interface TeamHelper$$constructor extends SuppressProperties {

                                new (t: /* minecraft class */ any): TeamHelper;

                            }
                            interface TeamHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getName(): string;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getDisplayName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getPlayerList(): JavaList<string>;

                                /**
                                 * @return the formatting of this team's color.
                                 * @since 1.8.4
                                 */
                                getColorFormat(): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;

                                /**
                                 * @since 1.3.0
                                 * @return 
                                 * @deprecated use {@link #getColorIndex()} instead.
                                 */
                                getColor(): number;

                                /**
                                 * @return the color index of this team.
                                 * @since 1.8.4
                                 */
                                getColorIndex(): number;

                                /**
                                 * @return the color value for this team or {@code -1} if it has no color.
                                 * @since 1.8.4
                                 */
                                getColorValue(): number;

                                /**
                                 * @return the name of this team's color.
                                 * @since 1.8.4
                                 */
                                getColorName(): string;

                                /**
                                 * @return the scoreboard including this team.
                                 * @since 1.8.4
                                 */
                                getScoreboard(): ScoreboardsHelper;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getPrefix(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getSuffix(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                getCollisionRule(): string;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                isFriendlyFire(): boolean;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                showFriendlyInvisibles(): boolean;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                nametagVisibility(): string;

                                /**
                                 * @since 1.3.0
                                 * @return
                                 */
                                deathMessageVisibility(): string;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const UniversalBlockStateHelper: JavaClassStatics<UniversalBlockStateHelper, UniversalBlockStateHelper$$constructor> & {

                                main(args: string[]): void;

                            }
                            interface UniversalBlockStateHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any): UniversalBlockStateHelper;

                            }
                            interface UniversalBlockStateHelper extends BlockStateHelper {

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getAttachment(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getEastWallShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getNorthWallShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getSouthWallShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getWestWallShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getEastWireConnection(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getNorthWireConnection(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getSouthWireConnection(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getWestWireConnection(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getBlockHalf(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getDoubleBlockHalf(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getRailShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getStraightRailShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getOrientation(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getWallMountLocation(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getHorizontalAxis(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getAxis(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getHorizontalFacing(): DirectionHelper;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getHopperFacing(): DirectionHelper;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getFacing(): DirectionHelper;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isUp(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isDown(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isNorth(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSouth(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isEast(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isWest(): boolean;

                                /**
                                 * Used on beehives.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getHoneyLevel(): number;

                                /**
                                 * Used on scaffolding.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isBottom(): boolean;

                                /**
                                 * Used on bubble columns.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isBubbleColumnDown(): boolean;

                                /**
                                 * Used on bubble columns.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isBubbleColumnUp(): boolean;

                                /**
                                 * Used on trip wire hooks.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isAttached(): boolean;

                                /**
                                 * Used on trip wires.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isDisarmed(): boolean;

                                /**
                                 * Used on command blocks.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isConditional(): boolean;

                                /**
                                 * Used on hoppers.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isEnabled(): boolean;

                                /**
                                 * Used on pistons.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isExtended(): boolean;

                                /**
                                 * Used on piston heads.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isShort(): boolean;

                                /**
                                 * Used on end portal frames.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasEye(): boolean;

                                /**
                                 * Used on fluids.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isFalling(): boolean;

                                /**
                                 * Used on fluids and stuff
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getLevel(): number;

                                /**
                                 * @since 1.8.4
                                 * @return
                                 */
                                getMaxLevel(): number;

                                /**
                                 * @since 1.8.4
                                 * @return
                                 */
                                getMinLevel(): number;

                                /**
                                 * Used on lanterns.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isHanging(): boolean;

                                /**
                                 * Used on brewing stands.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasBottle0(): boolean;

                                /**
                                 * Used on brewing stands.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasBottle1(): boolean;

                                /**
                                 * Used on brewing stands.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasBottle2(): boolean;

                                /**
                                 * Used on jukeboxes.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasRecord(): boolean;

                                /**
                                 * Used on lecterns.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasBook(): boolean;

                                /**
                                 * Used on daylight sensors.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isInverted(): boolean;

                                /**
                                 * Used on fence gates.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isInWall(): boolean;

                                /**
                                 * Used on fence gates, barrels, trap doors and doors.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isOpen(): boolean;

                                /**
                                 * Used on candles, all types of furnaces, campfires and redstone torches.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isLit(): boolean;

                                /**
                                 * Used on repeaters.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isLocked(): boolean;

                                /**
                                 * Used on repeaters.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getDelay(): number;

                                /**
                                 * Used on beds.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isOccupied(): boolean;

                                /**
                                 * Used on leaves.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isPersistent(): boolean;

                                /**
                                 * Used on leaves and scaffold.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getDistance(): number;

                                /**
                                 * Used on leaves and scaffold.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getMaxDistance(): number;

                                /**
                                 * Used on leaves and scaffold.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getMinDistance(): number;

                                /**
                                 * Used on bells, buttons, detector rails, diodes, doors, fence gates, lecterns, levers,  
                                 *  lightning rods, note blocks, observers, powered rails, pressure plates, trap doors, trip wire
                                 *  hooks and trip wires.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isPowered(): boolean;

                                /**
                                 * Used on campfires.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSignalFire(): boolean;

                                /**
                                 * Used on snowy dirt blocks.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSnowy(): boolean;

                                /**
                                 * Used on dispensers.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isTriggered(): boolean;

                                /**
                                 * Used on tnt.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isUnstable(): boolean;

                                /**
                                 * Used on amethysts, corals, rails, dripleaves, dripleaf stems, campfires, candles, chains,  
                                 *  chests, conduits, fences, double plants, ender chests, iron bars, glass panes, glow lichen,  
                                 *  hanging roots, ladders, lanterns, light blocks, lightning rods, pointed dripstone,  
                                 *  scaffolding , sculk sensors, sea pickles, signs, stairs, slabs, trap doors and walls
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isWaterlogged(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getBedPart(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getDoorHinge(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getInstrument(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getPistonType(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getSlabType(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getStairShape(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getStructureBlockMode(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getBambooLeaves(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getTilt(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getVerticalDirection(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getThickness(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getChestType(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getComparatorMode(): string;

                                /**
                                 * Used on cave vine roots.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                hasBerries(): boolean;

                                /**
                                 * crop age and such
                                 * @return 
                                 * @author Wagyourtail
                                 * @since 1.8.4
                                 */
                                getAge(): number;
                                getMaxAge(): number;

                                /**
                                 * Used on cakes.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getBites(): number;

                                /**
                                 * Used on candles.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getCandles(): number;

                                /**
                                 * Used on turtle eggs.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getEggs(): number;

                                /**
                                 * Used on turtle eggs.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getHatched(): number;

                                /**
                                 * Used on snow layers.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getLayers(): number;

                                /**
                                 * Used on farmland.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getMoisture(): number;

                                /**
                                 * Used on note blocks.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getNote(): number;

                                /**
                                 * Used on sea pickles.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getPickles(): number;

                                /**
                                 * Used on daylight sensors, redstone wires, sculk sensors, target blocks, weighted pressure
                                 *  plates.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getPower(): number;

                                /**
                                 * Used on bamboo, saplings.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getStage(): number;

                                /**
                                 * Used on respawn anchors.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getCharges(): number;

                                /**
                                 * Used on sculk sensors.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isShrieking(): boolean;

                                /**
                                 * Used on sculk sensors.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                canSummon(): boolean;

                                /**
                                 * Used on sculk sensors.
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getSculkSensorPhase(): string;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isBloom(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                getRotation(): number;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSlot0Occupied(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSlot1Occupied(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSlot2Occupied(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSlot3Occupied(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSlot4Occupied(): boolean;

                                /**
                                 * @return 
                                 * @since 1.8.4
                                 */
                                isSlot5Occupied(): boolean;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const StateHelper: JavaClassStatics<StateHelper<any>, StateHelper$$constructor>;
                            interface StateHelper$$constructor extends SuppressProperties {

                                new <U extends /* minecraft class */ any>(base: U): StateHelper<U>;

                            }
                            interface StateHelper<U = /* minecraft class */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<U> {

                                /**
                                 * @return a map of the state properties with its identifier and value.
                                 * @since 1.8.4
                                 */
                                toMap(): JavaMap<string, string>;
                                with<T extends java.lang.Comparable<any>>(property: string, value: string): StateHelper<U>;

                            }

                            export {
                                FluidStateHelper,
                                PlayerListEntryHelper,
                                BlockStateHelper,
                                BlockHelper,
                                BlockPosHelper,
                                ServerInfoHelper,
                                ScoreboardsHelper,
                                BlockDataHelper,
                                ChunkHelper,
                                DirectionHelper,
                                TeamHelper,
                                UniversalBlockStateHelper,
                                StateHelper
                            }

                        }
                        namespace world {

                            namespace entity {

                                /**
                                 * @author Wagyourtail
                                 * @since 1.2.1
                                 */
                                const BossBarHelper: JavaClassStatics<BossBarHelper, BossBarHelper$$constructor>;
                                interface BossBarHelper$$constructor extends SuppressProperties {

                                    new (b: /* minecraft class */ any): BossBarHelper;

                                }
                                interface BossBarHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                    /**
                                     * @since 1.2.1
                                     * @return boss bar uuid.
                                     */
                                    getUUID(): string;

                                    /**
                                     * @since 1.2.1
                                     * @return percent of boss bar remaining.
                                     */
                                    getPercent(): number;

                                    /**
                                     * @since 1.2.1
                                     * @return boss bar color.
                                     */
                                    getColor(): BossBarColor;

                                    /**
                                     * @since 1.2.1
                                     * @return boss bar notch style.
                                     */
                                    getStyle(): BossBarStyle;

                                    /**
                                     * @return the color of this boss bar.
                                     * @since 1.8.4
                                     */
                                    getColorValue(): number;

                                    /**
                                     * @return the format of the boss bar's color.
                                     * @since 1.8.4
                                     */
                                    getColorFormat(): xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;

                                    /**
                                     * @since 1.2.1
                                     * @return name of boss bar
                                     */
                                    getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                }

                                /**
                                 * @author Wagyourtail
                                 * @see PlayerEntityHelper
                                 * @since 1.0.3
                                 */
                                const ClientPlayerEntityHelper: JavaClassStatics<ClientPlayerEntityHelper<any>, ClientPlayerEntityHelper$$constructor>;
                                interface ClientPlayerEntityHelper$$constructor extends SuppressProperties {

                                    new <T extends /* minecraft class */ any>(e: T): ClientPlayerEntityHelper<T>;

                                }
                                interface ClientPlayerEntityHelper<T = /* minecraft class */ any> extends PlayerEntityHelper<T> {

                                    /**
                                     * Sets the player rotation along the given axis and keeps the other axis the same.
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    lookAt(direction: string): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param yaw (was pitch prior to 1.2.6)
                                     * @param pitch (was yaw prior to 1.2.6)
                                     * @return 
                                     * @since 1.0.3
                                     */
                                    lookAt(yaw: double, pitch: double): ClientPlayerEntityHelper<T>;

                                    /**
                                     * look at the specified coordinates.
                                     * @param x
                                     * @param y
                                     * @param z
                                     * @return 
                                     * @since 1.2.8
                                     */
                                    lookAt(x: double, y: double, z: double): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate of the block to look at
                                     * @param y the y coordinate of the block to look at
                                     * @param z the z coordinate of the block to look at
                                     * @return {@code true} if the player is targeting the specified block, {@code false}
                                     *          otherwise.
                                     * @since 1.8.4
                                     */
                                    tryLookAt(x: int, y: int, z: int): boolean;

                                    /**
                                     * Will try many rotations to find one that will make the player target the specified block. If
                                     *  successful, the player will be turned towards the block and `true` will be returned. If
                                     *  `false` is returned, the player will keep its current rotation.
                                     * @param pos the position of the block to look at
                                     * @return {@code true} if the player is targeting the specified block, {@code false}
                                     *          otherwise.
                                     * @since 1.8.4
                                     */
                                    tryLookAt(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): boolean;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    turnLeft(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    turnRight(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    turnBack(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param entity
                                     * @since 1.5.0
                                     */
                                    attack(entity: EntityHelper<any>): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @param await
                                     * @param entity
                                     */
                                    attack(entity: EntityHelper<any>, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to attack
                                     * @param y the y coordinate to attack
                                     * @param z the z coordinate to attack
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    attack(x: int, y: int, z: int, direction: Direction): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x
                                     * @param y
                                     * @param z
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @since 1.5.0
                                     */
                                    attack(x: int, y: int, z: int, direction: Hexit): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to attack
                                     * @param y the y coordinate to attack
                                     * @param z the z coordinate to attack
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @param await whether to wait for the attack to finish
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    attack(x: int, y: int, z: int, direction: Direction, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @param x
                                     * @param y
                                     * @param z
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @param await
                                     * @throws InterruptedException
                                     */
                                    attack(x: int, y: int, z: int, direction: Hexit, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param entity
                                     * @param offHand
                                     * @since 1.5.0, renamed from {@code interact} in 1.6.0
                                     */
                                    interactEntity(entity: EntityHelper<any>, offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param entity
                                     * @param offHand
                                     * @param await
                                     * @since 1.6.0
                                     * @throws InterruptedException
                                     */
                                    interactEntity(entity: EntityHelper<any>, offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param offHand
                                     * @since 1.5.0, renamed from {@code interact} in 1.6.0
                                     */
                                    interactItem(offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @param offHand
                                     * @param await
                                     */
                                    interactItem(offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to interact
                                     * @param y the y coordinate to interact
                                     * @param z the z coordinate to interact
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Direction, offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x
                                     * @param y
                                     * @param z
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @param offHand
                                     * @since 1.5.0, renamed from {@code interact} in 1.6.0
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Hexit, offHand: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x the x coordinate to interact
                                     * @param y the y coordinate to interact
                                     * @param z the z coordinate to interact
                                     * @param direction possible values are "up", "down", "north", "south", "east", "west"
                                     * @param await whether to wait for the interaction to complete
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Direction, offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param x
                                     * @param y
                                     * @param z
                                     * @param direction 0-5 in order: [DOWN, UP, NORTH, SOUTH, WEST, EAST];
                                     * @param offHand
                                     * @param await whether to wait for the interaction to complete
                                     * @since 1.5.0, renamed from {@code interact} in 1.6.0
                                     */
                                    interactBlock(x: int, y: int, z: int, direction: Hexit, offHand: boolean, await: boolean): ClientPlayerEntityHelper<T>;
                                    /** @since 1.5.0 */
                                    interact(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @param await
                                     */
                                    interact(await: boolean): ClientPlayerEntityHelper<T>;
                                    /** @since 1.5.0 */
                                    attack(): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.0
                                     * @param await
                                     */
                                    attack(await: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param stop
                                     * @since 1.6.3
                                     * @return
                                     */
                                    setLongAttack(stop: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @param stop
                                     * @since 1.6.3
                                     * @return
                                     */
                                    setLongInteract(stop: boolean): ClientPlayerEntityHelper<T>;

                                    /**
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getItemCooldownsRemainingTicks(): JavaMap<string, number>;

                                    /**
                                     * @param item
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getItemCooldownRemainingTicks(item: ItemId): number;

                                    /**
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getTicksSinceCooldownsStart(): JavaMap<ItemId, number>;

                                    /**
                                     * @param item
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getTicksSinceCooldownStart(item: ItemId): number;

                                    /**
                                     * @return 
                                     * @since 1.1.2
                                     */
                                    getFoodLevel(): number;

                                    /**
                                     * This will return the invisible hunger decade that you may have seen in mods as a yellow overlay.
                                     * @return the saturation level.
                                     * @since 1.8.4
                                     */
                                    getSaturation(): number;

                                    /**
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    dropHeldItem(dropStack: boolean): ClientPlayerEntityHelper<any>;

                                    /**
                                     * @return an advancement manager to work with advancements.
                                     * @since 1.8.4
                                     */
                                    getAdvancementManager(): xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementManagerHelper;

                                    /**
                                     * The returned time is an approximation and will likely be off by a few ticks, although it
                                     *  should always be less than the actual time.
                                     * @param block the block to mine
                                     * @return the time in ticks that it will approximately take the player with the currently held
                                     *          item to mine said block.
                                     */
                                    calculateMiningSpeed(block: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): number;

                                    /**
                                     * Calculate mining speed for a given block mined with a specified item in ticks. Use air to
                                     *  calculate the mining speed for the hand. The returned time is an approximation and will
                                     *  likely be off by a few ticks, although it should always be less than the actual time.
                                     * @param usedItem the item to mine with
                                     * @param blockState the block to mine
                                     * @return the time in ticks that it will approximately take the player with the specified item
                                     *          to mine said block.
                                     * @since 1.8.4
                                     */
                                    calculateMiningSpeed(usedItem: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, blockState: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper): number;

                                }

                                /**
                                 * @author Wagyourtail
                                 */
                                const PlayerEntityHelper: JavaClassStatics<PlayerEntityHelper<any>, PlayerEntityHelper$$constructor>;
                                interface PlayerEntityHelper$$constructor extends SuppressProperties {

                                    new <T extends /* minecraft class */ any>(e: T): PlayerEntityHelper<T>;

                                }
                                interface PlayerEntityHelper<T = /* minecraft class */ any> extends LivingEntityHelper<T> {

                                    /**
                                     * get player's actual name. (not display name)
                                     * @since 1.8.4
                                     */
                                    getPlayerName(): string;

                                    /**
                                     * @since 1.0.3
                                     * @see PlayerAbilitiesHelper
                                     * @return
                                     */
                                    getAbilities(): PlayerAbilitiesHelper;
                                    /** @since 1.2.0 */
                                    getMainHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getOffHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getHeadArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getChestArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getLegArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
                                    /** @since 1.2.0 */
                                    getFootArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.2.5 [citation needed]
                                     * @return
                                     */
                                    getXP(): number;

                                    /**
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getXPLevel(): number;

                                    /**
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getXPProgress(): number;

                                    /**
                                     * @since 1.6.5
                                     * @return
                                     */
                                    getXPToLevelUp(): number;

                                    /**
                                     * @since 1.2.5 [citation needed]
                                     * @return
                                     */
                                    isSleeping(): boolean;

                                    /**
                                     * @since 1.2.5 [citation needed]
                                     * @return if the player has slept the minimum ammount of time to pass the night.
                                     */
                                    isSleepingLongEnough(): boolean;

                                    /**
                                     * @return the fishing bobber of the player, or {@code null} if the player is not fishing.
                                     * @since 1.8.4
                                     */
                                    getFishingBobber(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.FishingBobberEntityHelper;

                                    /**
                                     * @since 1.8.4
                                     * @return
                                     */
                                    getAttackCooldownProgress(): number;

                                    /**
                                     * @since 1.8.4
                                     * @return
                                     */
                                    getAttackCooldownProgressPerTick(): number;

                                    /**
                                     * @return the player's score.
                                     * @since 1.8.4
                                     */
                                    getScore(): number;

                                }

                                /**
                                 * @author Wagyourtail
                                 */
                                const EntityHelper: JavaClassStatics<EntityHelper<any>> & NoConstructor & {

                                    /**
                                     * mostly for internal use.
                                     * @param e mc entity.
                                     * @return correct subclass of this.
                                     */
                                    create(e: /* minecraft class */ any): EntityHelper<any>;

                                }
                                interface EntityHelper<T = /* minecraft class */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T> {

                                    /**
                                     * @return entity position.
                                     */
                                    getPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @return entity block position.
                                     * @since 1.6.5
                                     */
                                    getBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                                    /**
                                     * @return the entity's eye position.
                                     * @since 1.8.4
                                     */
                                    getEyePos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @return entity chunk coordinates. Since Pos2D only has x and y fields, z coord is y.
                                     * @since 1.6.5
                                     */
                                    getChunkPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

                                    /**
                                     * @since 1.0.8
                                     * @return the {@code x} value of the entity.
                                     */
                                    getX(): number;

                                    /**
                                     * @since 1.0.8
                                     * @return the {@code y} value of the entity.
                                     */
                                    getY(): number;

                                    /**
                                     * @since 1.0.8
                                     * @return the {@code z} value of the entity.
                                     */
                                    getZ(): number;

                                    /**
                                     * @since 1.2.8
                                     * @return the current eye height offset for the entitye.
                                     */
                                    getEyeHeight(): number;

                                    /**
                                     * @since 1.0.8
                                     * @return the {@code pitch} value of the entity.
                                     */
                                    getPitch(): number;

                                    /**
                                     * @since 1.0.8
                                     * @return the {@code yaw} value of the entity.
                                     */
                                    getYaw(): number;

                                    /**
                                     * @return the name of the entity.
                                     * @since 1.0.8 [citation needed], returned string until 1.6.4
                                     */
                                    getName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                    /**
                                     * @return the type of the entity.
                                     */
                                    getType(): EntityId;

                                    /**
                                     * @since 1.1.9
                                     * @return if the entity has the glowing effect.
                                     */
                                    isGlowing(): boolean;

                                    /**
                                     * @since 1.1.9
                                     * @return if the entity is in lava.
                                     */
                                    isInLava(): boolean;

                                    /**
                                     * @since 1.1.9
                                     * @return if the entity is on fire.
                                     */
                                    isOnFire(): boolean;

                                    /**
                                     * @return {@code true} if the entity is sneaking, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isSneaking(): boolean;

                                    /**
                                     * @return {@code true} if the entity is sprinting, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isSprinting(): boolean;

                                    /**
                                     * @since 1.1.8 [citation needed]
                                     * @return the vehicle of the entity.
                                     */
                                    getVehicle(): EntityHelper<any>;

                                    /**
                                     * @since 1.1.8 [citation needed]
                                     * @return the entity passengers.
                                     */
                                    getPassengers(): JavaList<EntityHelper<any>>;

                                    /**
                                     * @since 1.2.8, was a {@link String} until 1.5.0
                                     * @return
                                     */
                                    getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<any>;

                                    /**
                                     * @since 1.6.4
                                     * @param name
                                     */
                                    setCustomName(name: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): EntityHelper<T>;

                                    /**
                                     * sets the name to always display
                                     * @since 1.8.0
                                     * @param b
                                     */
                                    setCustomNameVisible(b: boolean): EntityHelper<T>;

                                    /**
                                     * @param color
                                     */
                                    setGlowingColor(color: int): EntityHelper<T>;
                                    resetGlowingColor(): EntityHelper<T>;

                                    /**
                                     * warning: affected by setGlowingColor
                                     * @since 1.8.2
                                     * @return glow color
                                     */
                                    getGlowingColor(): number;

                                    /**
                                     * Sets whether the entity is glowing.
                                     * @since 1.1.9
                                     * @param val
                                     * @return
                                     */
                                    setGlowing(val: boolean): EntityHelper<T>;

                                    /**
                                     * reset the glowing effect to proper value.
                                     * @since 1.6.3
                                     * @return
                                     */
                                    resetGlowing(): EntityHelper<T>;

                                    /**
                                     * Checks if the entity is still alive.
                                     * @since 1.2.8
                                     * @return
                                     */
                                    isAlive(): boolean;

                                    /**
                                     * @since 1.6.5
                                     * @return UUID of the entity, random* if not a player, otherwise the player's uuid.
                                     */
                                    getUUID(): string;

                                    /**
                                     * @return the maximum amount of air this entity can have.
                                     * @since 1.8.4
                                     */
                                    getMaxAir(): number;

                                    /**
                                     * @return the amount of air this entity has.
                                     * @since 1.8.4
                                     */
                                    getAir(): number;

                                    /**
                                     * @return this entity's current speed in blocks per second.
                                     * @since 1.8.4
                                     */
                                    getSpeed(): number;

                                    /**
                                     * @return the direction the entity is facing, rounded to the nearest 45 degrees.
                                     * @since 1.8.4
                                     */
                                    getFacingDirection(): xyz.wagyourtail.jsmacros.client.api.helpers.world.DirectionHelper;

                                    /**
                                     * @return the distance between this entity and the specified one.
                                     * @since 1.8.4
                                     */
                                    distanceTo(entity: EntityHelper<any>): number;

                                    /**
                                     * @return the distance between this entity and the specified position.
                                     * @since 1.8.4
                                     */
                                    distanceTo(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): number;

                                    /**
                                     * @return the distance between this entity and the specified position.
                                     * @since 1.8.4
                                     */
                                    distanceTo(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): number;

                                    /**
                                     * @return the distance between this entity and the specified position.
                                     * @since 1.8.4
                                     */
                                    distanceTo(x: double, y: double, z: double): number;

                                    /**
                                     * @return the velocity vector.
                                     * @since 1.8.4
                                     */
                                    getVelocity(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @return the chunk helper for the chunk this entity is in.
                                     * @since 1.8.4
                                     */
                                    getChunk(): xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;

                                    /**
                                     * @return the name of the biome this entity is in.
                                     * @since 1.8.4
                                     */
                                    getBiome(): Biome;

                                    /**
                                     * @since 1.6.3
                                     * @return cast of this entity helper (mainly for typescript)
                                     */
                                    asClientPlayer(): ClientPlayerEntityHelper<any>;

                                    /**
                                     * @since 1.6.3
                                     * @return cast of this entity helper (mainly for typescript)
                                     */
                                    asPlayer(): PlayerEntityHelper<any>;

                                    /**
                                     * @since 1.6.3
                                     * @return cast of this entity helper (mainly for typescript)
                                     */
                                    asVillager(): VillagerEntityHelper;

                                    /**
                                     * @since 1.6.3
                                     * @return cast of this entity helper (mainly for typescript)
                                     */
                                    asMerchant(): MerchantEntityHelper<any>;

                                    /**
                                     * @since 1.6.3
                                     * @return cast of this entity helper (mainly for typescript)
                                     */
                                    asLiving(): LivingEntityHelper<any>;

                                    /**
                                     * @return this helper as an animal entity helper (mainly for typescript).
                                     * @since 1.8.4
                                     */
                                    asAnimal(): LivingEntityHelper<any>;

                                    /**
                                     * @since 1.6.3
                                     * @return cast of this entity helper (mainly for typescript)
                                     */
                                    asItem(): ItemEntityHelper;

                                    /**
                                     * @return the entity as a server entity if an integrated server is running and {@code null} otherwise.
                                     * @since 1.8.4
                                     */
                                    asServerEntity(): EntityHelper<any>;

                                }

                                /** @since 1.6.3 */
                                const VillagerEntityHelper: JavaClassStatics<VillagerEntityHelper, VillagerEntityHelper$$constructor>;
                                interface VillagerEntityHelper$$constructor extends SuppressProperties {

                                    new (e: /* minecraft class */ any): VillagerEntityHelper;

                                }
                                interface VillagerEntityHelper extends MerchantEntityHelper</* minecraft class */ any> {

                                    /**
                                     * @since 1.6.3
                                     * @return
                                     */
                                    getProfession(): VillagerProfession;

                                    /**
                                     * @since 1.6.3
                                     * @return
                                     */
                                    getStyle(): VillagerStyle;

                                    /**
                                     * @since 1.6.3
                                     * @return
                                     */
                                    getLevel(): number;

                                }

                                const LivingEntityHelper: JavaClassStatics<LivingEntityHelper<any>, LivingEntityHelper$$constructor>;
                                interface LivingEntityHelper$$constructor extends SuppressProperties {

                                    new <T extends /* minecraft class */ any>(e: T): LivingEntityHelper<T>;

                                }
                                interface LivingEntityHelper<T = /* minecraft class */ any> extends EntityHelper<T> {

                                    /**
                                     * @since 1.2.7
                                     * @return entity status effects.
                                     */
                                    getStatusEffects(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper>;

                                    /**
                                     * For client side entities, excluding the player, this will most likely return `false`
                                     *  even if the entity has the effect, as effects are not synced to the client.
                                     * @param id
                                     * @return {@code true} if the entity has the specified status effect, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    hasStatusEffect(id: StatusEffectId): boolean;

                                    /**
                                     * @since 1.2.7
                                     * @see ItemStackHelper
                                     * @return the item in the entity's main hand.
                                     */
                                    getMainHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.2.7
                                     * @return the item in the entity's off hand.
                                     */
                                    getOffHand(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.2.7
                                     * @return the item in the entity's head armor slot.
                                     */
                                    getHeadArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.2.7
                                     * @return the item in the entity's chest armor slot.
                                     */
                                    getChestArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.2.7
                                     * @return the item in the entity's leg armor slot.
                                     */
                                    getLegArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.2.7
                                     * @return the item in the entity's foot armor slot.
                                     */
                                    getFootArmor(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @since 1.3.1
                                     * @return entity's health
                                     */
                                    getHealth(): number;

                                    /**
                                     * @since 1.6.5
                                     * @return entity's max health
                                     */
                                    getMaxHealth(): number;

                                    /**
                                     * @return the entity's absorption amount.
                                     * @since 1.8.4
                                     */
                                    getAbsorptionHealth(): number;

                                    /**
                                     * @return the entity's armor value.
                                     * @since 1.8.4
                                     */
                                    getArmor(): number;

                                    /**
                                     * @return the entity's default health.
                                     * @since 1.8.4
                                     */
                                    getDefaultHealth(): number;

                                    /**
                                     * @return the entity's mob category, {@code UNDEAD}, {@code DEFAULT}, {@code ARTHROPOD}, or
                                     *          {@code ILLAGER}, {@code AQUATIC} or {@code UNKNOWN}.
                                     * @since 1.8.4
                                     */
                                    getMobCategory(): MobCategory;

                                    /**
                                     * @since 1.2.7
                                     * @return if the entity is in a bed.
                                     */
                                    isSleeping(): boolean;

                                    /**
                                     * @since 1.5.0
                                     * @return if the entity has elytra deployed
                                     */
                                    isFallFlying(): boolean;

                                    /**
                                     * @return the bow pull progress of the entity, {@code 0} by default.
                                     * @since 1.8.4
                                     */
                                    getBowPullProgress(): number;

                                    /**
                                     * @return {@code true} if the entity is a baby, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isBaby(): boolean;

                                    /**
                                     * @param entity the entity to check line of sight to
                                     * @return {@code true} if the player has line of sight to the specified entity, {@code false}
                                     *          otherwise.
                                     * @since 1.8.4
                                     */
                                    canSeeEntity(entity: EntityHelper<any>): boolean;

                                    /**
                                     * @param entity the entity to check line of sight to
                                     * @param simpleCast whether to use a simple raycast or a more complex one
                                     * @return {@code true} if the entity has line of sight to the specified entity, {@code false}
                                     *          otherwise.
                                     * @since 1.8.4
                                     */
                                    canSeeEntity(entity: EntityHelper<any>, simpleCast: boolean): boolean;

                                }

                                const ItemEntityHelper: JavaClassStatics<ItemEntityHelper, ItemEntityHelper$$constructor>;
                                interface ItemEntityHelper$$constructor extends SuppressProperties {

                                    new (e: /* minecraft class */ any): ItemEntityHelper;

                                }
                                interface ItemEntityHelper extends EntityHelper</* minecraft class */ any> {

                                    getContainedItemStack(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                }

                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.3
                                 */
                                const PlayerAbilitiesHelper: JavaClassStatics<PlayerAbilitiesHelper, PlayerAbilitiesHelper$$constructor>;
                                interface PlayerAbilitiesHelper$$constructor extends SuppressProperties {

                                    new (a: /* minecraft class */ any): PlayerAbilitiesHelper;

                                }
                                interface PlayerAbilitiesHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                    /**
                                     * @since 1.0.3
                                     * @return whether the player can be damaged.
                                     */
                                    getInvulnerable(): boolean;

                                    /**
                                     * @since 1.0.3
                                     * @return if the player is currently flying.
                                     */
                                    getFlying(): boolean;

                                    /**
                                     * @since 1.0.3
                                     * @return if the player is allowed to fly.
                                     */
                                    getAllowFlying(): boolean;

                                    /**
                                     * @since 1.0.3
                                     * @return if the player is in creative.
                                     */
                                    getCreativeMode(): boolean;

                                    /**
                                     * Even if this method returns true, the player may not be able to modify the world due to other
                                     *  restrictions such as plugins and mods. Modifying the world includes, placing, breaking or
                                     *  interacting with blocks.
                                     * @return {@code true} if the player is allowed to modify the world, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    canModifyWorld(): boolean;

                                    /**
                                     * set the player flying state.
                                     * @since 1.0.3
                                     * @param b
                                     * @return
                                     */
                                    setFlying(b: boolean): PlayerAbilitiesHelper;

                                    /**
                                     * set the player allow flying state.
                                     * @since 1.0.3
                                     * @param b
                                     * @return
                                     */
                                    setAllowFlying(b: boolean): PlayerAbilitiesHelper;

                                    /**
                                     * @since 1.0.3
                                     * @return the player fly speed multiplier.
                                     */
                                    getFlySpeed(): number;

                                    /**
                                     * set the player fly speed multiplier.
                                     * @since 1.0.3
                                     * @param flySpeed
                                     * @return
                                     */
                                    setFlySpeed(flySpeed: double): PlayerAbilitiesHelper;

                                    /**
                                     * @return the player's walk speed.
                                     * @since 1.8.4
                                     */
                                    getWalkSpeed(): number;

                                    /**
                                     * @param speed the new walk speed
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWalkSpeed(speed: double): PlayerAbilitiesHelper;

                                }

                                const MerchantEntityHelper: JavaClassStatics<MerchantEntityHelper<any>, MerchantEntityHelper$$constructor>;
                                interface MerchantEntityHelper$$constructor extends SuppressProperties {

                                    new <T extends /* minecraft class */ any>(e: T): MerchantEntityHelper<T>;

                                }
                                interface MerchantEntityHelper<T = /* minecraft class */ any> extends LivingEntityHelper<T> {

                                    /**
                                     * these might not work... depends on the data the server sends, maybe just singleplayer.
                                     * @return
                                     */
                                    getTrades(): JavaList<TradeOfferHelper>;
                                    refreshTrades(): JavaList<TradeOfferHelper>;

                                    /**
                                     * @return
                                     */
                                    getExperience(): number;

                                    /**
                                     * @return
                                     */
                                    hasCustomer(): boolean;

                                }

                                const TradeOfferHelper: JavaClassStatics<TradeOfferHelper, TradeOfferHelper$$constructor>;
                                interface TradeOfferHelper$$constructor extends SuppressProperties {

                                    new (base: /* minecraft class */ any, index: int, inv: xyz.wagyourtail.jsmacros.client.api.classes.inventory.VillagerInventory): TradeOfferHelper;

                                }
                                interface TradeOfferHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                    /**
                                     * @return list of input items required
                                     */
                                    getInput(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                    /**
                                     * The returned item uses the adjusted price, in form of its stack size and will be empty
                                     *  {@link ItemStackHelper#isEmpty} if the first input doesn't exist.
                                     * @return the first input item.
                                     * @since 1.8.4
                                     */
                                    getLeftInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * The returned item uses the adjusted price, in form of its stack size and will be empty
                                     *  {@link ItemStackHelper#isEmpty} if the first input doesn't exist.
                                     * @return the second input item.
                                     * @since 1.8.4
                                     */
                                    getRightInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return output item that will be received
                                     */
                                    getOutput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the index if this trade in the given villager inventory.
                                     * @since 1.8.4
                                     */
                                    getIndex(): number;

                                    /**
                                     * select trade offer on screen
                                     */
                                    select(): TradeOfferHelper;

                                    /**
                                     * @return
                                     */
                                    isAvailable(): boolean;

                                    /**
                                     * @return trade offer as nbt tag
                                     */
                                    getNBT(): xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<any>;

                                    /**
                                     * @return current number of uses
                                     */
                                    getUses(): number;

                                    /**
                                     * @return max uses before it locks
                                     */
                                    getMaxUses(): number;

                                    /**
                                     * @return {@code true} if after a successful trade xp will be summoned, {@code false}
                                     *          otherwise.
                                     * @since 1.8.4
                                     */
                                    shouldRewardPlayerExperience(): boolean;

                                    /**
                                     * @return experience gained for trade
                                     */
                                    getExperience(): number;

                                    /**
                                     * @return current price adjustment, negative is discount.
                                     */
                                    getCurrentPriceAdjustment(): number;

                                    /**
                                     * @return the original priced item without any adjustments due to rewards or demand.
                                     * @since 1.8.4
                                     */
                                    getOriginalFirstInput(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @return the original price of the item without any adjustments due to rewards or demand.
                                     * @since 1.8.4
                                     */
                                    getOriginalPrice(): number;

                                    /**
                                     * @return the adjusted price of the item.
                                     * @since 1.8.4
                                     */
                                    getAdjustedPrice(): number;

                                    /**
                                     * A negative value is a discount and means that the player has a good reputation with the
                                     *  villager, while a positive value is a premium. Hero of the village will always affect and
                                     *  reduce this value.
                                     * @return the special price multiplier, which affects the price of the item depending on the
                                     *          player's reputation with the villager.
                                     * @since 1.8.4
                                     */
                                    getSpecialPrice(): number;

                                    /**
                                     * A higher price multiplier means that the price of these trades can vary much more than normal
                                     *  ones. The default value is 0.05 and 0.2 for armor and tools.
                                     * @return the price multiplier, which is only depended on the type of trade.
                                     * @since 1.8.4
                                     */
                                    getPriceMultiplier(): number;

                                    /**
                                     * The demand bonus is globally applied to all trades of this type for all villagers and
                                     *  players. It is used to increase the price of trades that are in high demand. The demand is
                                     *  only calculated and updated on restock. Note that a villager can always restock, even if no
                                     *  items were traded with him. Updating the demand is done with the following formula:  
                                     *  ``` `demand = demand + 2 * uses - maxUses` ```  
                                     *  Thus trading only half of the max uses will not increase the demand.  
                                     *  The demand is also capped at 0, so it can not decrease the price.
                                     * @return the demand bonus for this trade.
                                     * @since 1.8.4
                                     */
                                    getDemandBonus(): number;

                                }

                                export {
                                    BossBarHelper,
                                    ClientPlayerEntityHelper,
                                    PlayerEntityHelper,
                                    EntityHelper,
                                    VillagerEntityHelper,
                                    LivingEntityHelper,
                                    ItemEntityHelper,
                                    PlayerAbilitiesHelper,
                                    MerchantEntityHelper,
                                    TradeOfferHelper
                                }

                            }
                            namespace entity {

                                namespace specialized.projectile {

                                    /**
                                     * @author Etheradon
                                     * @since 1.8.4
                                     */
                                    const FishingBobberEntityHelper: JavaClassStatics<FishingBobberEntityHelper, FishingBobberEntityHelper$$constructor>;
                                    interface FishingBobberEntityHelper$$constructor extends SuppressProperties {

                                        new (base: /* minecraft class */ any): FishingBobberEntityHelper;

                                    }
                                    interface FishingBobberEntityHelper extends xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* minecraft class */ any> {

                                        /**
                                         * @return {@code true} if a fish has been caught, {@code false} otherwise.
                                         * @since 1.8.4
                                         */
                                        hasCaughtFish(): boolean;

                                        /**
                                         * When in open water the player can get treasures from fishing.
                                         * @return {@code true} if the bobber is in open water, {@code false} otherwise.
                                         * @since 1.8.4
                                         */
                                        isInOpenWater(): boolean;

                                        /**
                                         * @return {@code true} if the bobber has an entity hooked, {@code false} otherwise.
                                         * @since 1.8.4
                                         */
                                        hasEntityHooked(): boolean;

                                        /**
                                         * @return the hooked entity, or {@code null} if there is no entity hooked.
                                         * @since 1.8.4
                                         */
                                        getHookedEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

                                    }

                                    export { FishingBobberEntityHelper }

                                }

                            }

                        }

                        namespace screen {

                            /**
                             * @author Wagyourtail
                             * @since 1.2.9
                             */
                            const ScoreboardObjectiveHelper: JavaClassStatics<ScoreboardObjectiveHelper, ScoreboardObjectiveHelper$$constructor>;
                            interface ScoreboardObjectiveHelper$$constructor extends SuppressProperties {

                                new (o: /* minecraft class */ any): ScoreboardObjectiveHelper;

                            }
                            interface ScoreboardObjectiveHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                /**
                                 * @return player name to score map
                                 */
                                getPlayerScores(): JavaMap<string, number>;

                                /**
                                 * @since 1.8.0
                                 * @return
                                 */
                                scoreToDisplayName(): JavaMap<number, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @since 1.7.0
                                 * @return
                                 */
                                getKnownPlayers(): JavaList<string>;

                                /**
                                 * @since 1.8.0
                                 * @return
                                 */
                                getKnownPlayersDisplayNames(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;

                                /**
                                 * @return name of scoreboard
                                 * @since 1.2.9
                                 */
                                getName(): string;

                                /**
                                 * @return name of scoreboard
                                 * @since 1.2.9
                                 */
                                getDisplayName(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const LockButtonWidgetHelper: JavaClassStatics<LockButtonWidgetHelper, LockButtonWidgetHelper$$constructor>;
                            interface LockButtonWidgetHelper$$constructor extends SuppressProperties {

                                new (btn: /* minecraft class */ any): LockButtonWidgetHelper;
                                new (btn: /* minecraft class */ any, zIndex: int): LockButtonWidgetHelper;

                            }
                            interface LockButtonWidgetHelper extends ClickableWidgetHelper<LockButtonWidgetHelper, /* minecraft class */ any> {

                                /**
                                 * @return {@code true} if the button is locked, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isLocked(): boolean;

                                /**
                                 * @param locked whether to lock the button or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setLocked(locked: boolean): LockButtonWidgetHelper;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.0.5
                             */
                            const ClickableWidgetHelper: JavaClassStatics<ClickableWidgetHelper<any, any>, ClickableWidgetHelper$$constructor>;
                            interface ClickableWidgetHelper$$constructor extends SuppressProperties {

                                new <B extends ClickableWidgetHelper<B, T>, T extends /* minecraft class */ any>(btn: T): ClickableWidgetHelper<B, T>;
                                new <B extends ClickableWidgetHelper<B, T>, T extends /* minecraft class */ any>(btn: T, zIndex: int): ClickableWidgetHelper<B, T>;

                            }
                            interface ClickableWidgetHelper<B extends ClickableWidgetHelper<B, T>, T = /* minecraft class */ any> extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T>, xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement, xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B> {
                                zIndex: number;
                                tooltips: JavaList</* minecraft class */ any>;

                                /**
                                 * @since 1.0.5
                                 * @return the {@code x} coordinate of the button.
                                 */
                                getX(): number;

                                /**
                                 * @since 1.0.5
                                 * @return the {@code y} coordinate of the button.
                                 */
                                getY(): number;

                                /**
                                 * Set the button position.
                                 * @since 1.0.5
                                 * @param x
                                 * @param y
                                 * @return
                                 */
                                setPos(x: int, y: int): B;

                                /**
                                 * @since 1.0.5
                                 * @return
                                 */
                                getWidth(): number;

                                /**
                                 * @return the height of the button.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * change the text.
                                 * @since 1.0.5, renamed from {@code setText} in 1.3.1
                                 * @deprecated only deprecated in buttonWidgetHelper for confusing name.
                                 * @param label
                                 * @return
                                 */
                                setLabel(label: string): B;

                                /**
                                 * change the text.
                                 * @since 1.3.1
                                 * @param helper
                                 * @return
                                 */
                                setLabel(helper: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): B;

                                /**
                                 * @since 1.2.3, renamed fro {@code getText} in 1.3.1
                                 * @return current button text.
                                 */
                                getLabel(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @since 1.0.5
                                 * @return button clickable state.
                                 */
                                getActive(): boolean;

                                /**
                                 * set the button clickable state.
                                 * @since 1.0.5
                                 * @param t
                                 * @return
                                 */
                                setActive(t: boolean): B;

                                /**
                                 * set the button width.
                                 * @since 1.0.5
                                 * @param width
                                 * @return
                                 */
                                setWidth(width: int): B;

                                /**
                                 * clicks button
                                 * @since 1.3.1
                                 */
                                click(): B;

                                /**
                                 * clicks button
                                 * @param await should wait for button to finish clicking.
                                 * @since 1.3.1
                                 */
                                click(await: boolean): B;

                                /**
                                 * @param tooltips the tooltips to set
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setTooltip(...tooltips: any[]): B;

                                /**
                                 * @param tooltip the tooltips to add
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                addTooltip(tooltip: any): B;

                                /**
                                 * @param index the index of the tooltip to remove
                                 * @return {@code true} if the tooltip was removed successfully, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                removeTooltip(index: int): boolean;

                                /**
                                 * @param tooltip the tooltip to remove
                                 * @return {@code true} if the tooltip was removed successfully, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                removeTooltip(tooltip: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): boolean;

                                /**
                                 * @return a copy of the tooltips.
                                 * @since 1.8.4
                                 */
                                getTooltips(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper>;
                                getZIndex(): number;
                                getScaledWidth(): number;
                                getParentWidth(): number;
                                getScaledHeight(): number;
                                getParentHeight(): number;
                                getScaledLeft(): number;
                                getScaledTop(): number;
                                moveTo(x: int, y: int): B;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const CheckBoxWidgetHelper: JavaClassStatics<CheckBoxWidgetHelper, CheckBoxWidgetHelper$$constructor>;
                            interface CheckBoxWidgetHelper$$constructor extends SuppressProperties {

                                new (btn: xyz.wagyourtail.wagyourgui.elements.CheckBox): CheckBoxWidgetHelper;
                                new (btn: xyz.wagyourtail.wagyourgui.elements.CheckBox, zIndex: int): CheckBoxWidgetHelper;

                            }
                            interface CheckBoxWidgetHelper extends ClickableWidgetHelper<CheckBoxWidgetHelper, xyz.wagyourtail.wagyourgui.elements.CheckBox> {

                                /**
                                 * @return {@code true} if this button is checked, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isChecked(): boolean;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                toggle(): CheckBoxWidgetHelper;

                                /**
                                 * @param checked whether to check or uncheck this button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setChecked(checked: boolean): CheckBoxWidgetHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const ButtonWidgetHelper$TexturedButtonBuilder: JavaClassStatics<ButtonWidgetHelper$TexturedButtonBuilder, ButtonWidgetHelper$TexturedButtonBuilder$$constructor>;
                            interface ButtonWidgetHelper$TexturedButtonBuilder$$constructor extends SuppressProperties {

                                new (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen): ButtonWidgetHelper$TexturedButtonBuilder;

                            }
                            interface ButtonWidgetHelper$TexturedButtonBuilder extends AbstractWidgetBuilder<ButtonWidgetHelper$TexturedButtonBuilder, /* minecraft class */ any, ButtonWidgetHelper</* minecraft class */ any>> {

                                /**
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                height(height: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @param width the width of the button
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                size(width: int, height: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* minecraft class */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* minecraft class */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the x position in the texture to start drawing from.
                                 * @since 1.8.4
                                 */
                                getU(): number;

                                /**
                                 * @param u the x position in the texture to start drawing from
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                u(u: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the y position in the texture to start drawing from.
                                 * @since 1.8.4
                                 */
                                getV(): number;

                                /**
                                 * @param v the y position in the texture to start drawing from
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                v(v: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @param u the x position in the texture to start drawing from
                                 * @param v the y position in the texture to start drawing from
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                uv(u: int, v: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the hover offset of the button.
                                 * @since 1.8.4
                                 */
                                getHoverOffset(): number;

                                /**
                                 * The hover offset is the vertical amount of pixels to offset the texture when the button
                                 *  is hovered.
                                 * @param hoverOffset the hover offset
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                hoverOffset(hoverOffset: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the id of the texture to use or {@code null} if none is set.
                                 * @since 1.8.4
                                 */
                                getTexture(): string;

                                /**
                                 * @param texture the texture id to use for the button
                                 * @return self for chaining.
                                 */
                                texture(texture: string): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the width of the texture.
                                 * @since 1.8.4
                                 */
                                getTextureWidth(): number;

                                /**
                                 * @param textureWidth the width of the texture
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                textureWidth(textureWidth: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return the height of the texture.
                                 * @since 1.8.4
                                 */
                                getTextureHeight(): number;

                                /**
                                 * @param textureHeight the height of the texture
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                textureHeight(textureHeight: int): ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @param textureWidth the width of the texture
                                 * @param textureHeight the height of the texture
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                textureSize(textureWidth: int, textureHeight: int): ButtonWidgetHelper$TexturedButtonBuilder;
                                createWidget(): ButtonWidgetHelper</* minecraft class */ any>;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.0.5
                             */
                            const TextFieldWidgetHelper: JavaClassStatics<TextFieldWidgetHelper, TextFieldWidgetHelper$$constructor>;
                            interface TextFieldWidgetHelper$$constructor extends SuppressProperties {

                                new (t: /* minecraft class */ any): TextFieldWidgetHelper;
                                new (t: /* minecraft class */ any, zIndex: int): TextFieldWidgetHelper;

                            }
                            interface TextFieldWidgetHelper extends ClickableWidgetHelper<TextFieldWidgetHelper, /* minecraft class */ any> {

                                /**
                                 * @since 1.0.5
                                 * @return the currently entered {@link java.lang.String String}.
                                 */
                                getText(): string;

                                /**
                                 * @since 1.0.5
                                 * @param text
                                 * @return
                                 */
                                setText(text: string): TextFieldWidgetHelper;

                                /**
                                 * set the currently entered {@link java.lang.String}.
                                 * @param text
                                 * @param await
                                 * @return 
                                 * @since 1.3.1
                                 * @throws InterruptedException
                                 */
                                setText(text: string, await: boolean): TextFieldWidgetHelper;

                                /**
                                 * @since 1.0.5
                                 * @param color
                                 * @return
                                 */
                                setEditableColor(color: int): TextFieldWidgetHelper;

                                /**
                                 * @since 1.0.5
                                 * @param edit
                                 * @return
                                 */
                                setEditable(edit: boolean): TextFieldWidgetHelper;

                                /**
                                 * @return {@code true} if the text field is editable, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isEditable(): boolean;

                                /**
                                 * @since 1.0.5
                                 * @param color
                                 * @return
                                 */
                                setUneditableColor(color: int): TextFieldWidgetHelper;

                                /**
                                 * @return the selected text.
                                 * @since 1.8.4
                                 */
                                getSelectedText(): string;

                                /**
                                 * @param suggestion the suggestion to set
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setSuggestion(suggestion: string): TextFieldWidgetHelper;

                                /**
                                 * @return the maximum length of this text field.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                getMaxLength(): number;

                                /**
                                 * @param length the new maximum length
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setMaxLength(length: int): TextFieldWidgetHelper;
                                setSelection(start: int, end: int): TextFieldWidgetHelper;

                                /**
                                 * @param predicate the text filter
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setTextPredicate(predicate: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any>): TextFieldWidgetHelper;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                resetTextPredicate(): TextFieldWidgetHelper;

                                /**
                                 * @param position the cursor position
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCursorPosition(position: int): TextFieldWidgetHelper;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCursorToStart(): TextFieldWidgetHelper;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setCursorToEnd(): TextFieldWidgetHelper;

                            }

                            const ChatHudLineHelper: JavaClassStatics<ChatHudLineHelper, ChatHudLineHelper$$constructor>;
                            interface ChatHudLineHelper$$constructor extends SuppressProperties {

                                new (base: /* minecraft class */ any, hud: /* minecraft class */ any): ChatHudLineHelper;

                            }
                            interface ChatHudLineHelper extends xyz.wagyourtail.jsmacros.core.helpers.BaseHelper</* minecraft class */ any> {

                                getText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
                                getCreationTick(): number;
                                deleteById(): ChatHudLineHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const SliderWidgetHelper: JavaClassStatics<SliderWidgetHelper, SliderWidgetHelper$$constructor>;
                            interface SliderWidgetHelper$$constructor extends SuppressProperties {

                                new (btn: xyz.wagyourtail.wagyourgui.elements.Slider): SliderWidgetHelper;
                                new (btn: xyz.wagyourtail.wagyourgui.elements.Slider, zIndex: int): SliderWidgetHelper;

                            }
                            interface SliderWidgetHelper extends ClickableWidgetHelper<SliderWidgetHelper, xyz.wagyourtail.wagyourgui.elements.Slider> {

                                /**
                                 * @return the current value of this slider.
                                 * @since 1.8.4
                                 */
                                getValue(): number;

                                /**
                                 * @param value the new value
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setValue(value: double): SliderWidgetHelper;

                                /**
                                 * @return the set amount of steps of this slider.
                                 * @since 1.8.4
                                 */
                                getSteps(): number;

                                /**
                                 * @param steps the amount of steps
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setSteps(steps: int): SliderWidgetHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const CyclingButtonWidgetHelper: JavaClassStatics<CyclingButtonWidgetHelper<any>, CyclingButtonWidgetHelper$$constructor>;
                            interface CyclingButtonWidgetHelper$$constructor extends SuppressProperties {

                                new <T>(btn: /* minecraft class */ any): CyclingButtonWidgetHelper<T>;
                                new <T>(btn: /* minecraft class */ any, zIndex: int): CyclingButtonWidgetHelper<T>;

                            }
                            interface CyclingButtonWidgetHelper<T> extends ClickableWidgetHelper<CyclingButtonWidgetHelper<T>, /* minecraft class */ any> {

                                /**
                                 * @return the current value.
                                 * @since 1.8.4
                                 */
                                getValue(): T;

                                /**
                                 * @return the current value in their string representation.
                                 * @since 1.8.4
                                 */
                                getStringValue(): string;

                                /**
                                 * @param val the new value
                                 * @return {@code true} if the value has changed, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                setValue(val: T): boolean;

                                /**
                                 * @param amount the amount to cycle by
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                cycle(amount: int): CyclingButtonWidgetHelper<T>;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                forward(): CyclingButtonWidgetHelper<T>;

                                /**
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                backward(): CyclingButtonWidgetHelper<T>;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const ButtonWidgetHelper: JavaClassStatics<ButtonWidgetHelper<any>, ButtonWidgetHelper$$constructor>;
                            interface ButtonWidgetHelper$$constructor extends SuppressProperties {

                                new <T extends /* minecraft class */ any>(btn: T): ButtonWidgetHelper<T>;
                                new <T extends /* minecraft class */ any>(btn: T, zIndex: int): ButtonWidgetHelper<T>;

                            }
                            interface ButtonWidgetHelper<T = /* minecraft class */ any> extends ClickableWidgetHelper<ButtonWidgetHelper<T>, T> {}

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const SliderWidgetHelper$SliderBuilder: JavaClassStatics<SliderWidgetHelper$SliderBuilder, SliderWidgetHelper$SliderBuilder$$constructor>;
                            interface SliderWidgetHelper$SliderBuilder$$constructor extends SuppressProperties {

                                new (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen): SliderWidgetHelper$SliderBuilder;

                            }
                            interface SliderWidgetHelper$SliderBuilder extends AbstractWidgetBuilder<SliderWidgetHelper$SliderBuilder, xyz.wagyourtail.wagyourgui.elements.Slider, SliderWidgetHelper> {

                                /**
                                 * @return the amount of steps of this slider.
                                 * @since 1.8.4
                                 */
                                getSteps(): number;

                                /**
                                 * @param steps the amount of steps for the slider. Must be greater or equal to 2
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                steps(steps: int): SliderWidgetHelper$SliderBuilder;

                                /**
                                 * @return the initial value of the slider.
                                 * @since 1.8.4
                                 */
                                getValue(): number;

                                /**
                                 * @param value the initial value of the slider. Must be between 0 and steps - 1
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                initially(value: int): SliderWidgetHelper$SliderBuilder;

                                /**
                                 * @return the change listener of the slider.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<SliderWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the change listener for the slider
                                 * @return self for chaining.
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<SliderWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): SliderWidgetHelper$SliderBuilder;
                                createWidget(): SliderWidgetHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const CheckBoxWidgetHelper$CheckBoxBuilder: JavaClassStatics<CheckBoxWidgetHelper$CheckBoxBuilder, CheckBoxWidgetHelper$CheckBoxBuilder$$constructor>;
                            interface CheckBoxWidgetHelper$CheckBoxBuilder$$constructor extends SuppressProperties {

                                new (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen): CheckBoxWidgetHelper$CheckBoxBuilder;

                            }
                            interface CheckBoxWidgetHelper$CheckBoxBuilder extends AbstractWidgetBuilder<CheckBoxWidgetHelper$CheckBoxBuilder, xyz.wagyourtail.wagyourgui.elements.CheckBox, CheckBoxWidgetHelper> {

                                /**
                                 * @return {@code true} if the checkbox is initially checked, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isChecked(): boolean;

                                /**
                                 * @param checked whether the checkbox is initially checked or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                checked(checked: boolean): CheckBoxWidgetHelper$CheckBoxBuilder;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<CheckBoxWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<CheckBoxWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): CheckBoxWidgetHelper$CheckBoxBuilder;
                                createWidget(): CheckBoxWidgetHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const ButtonWidgetHelper$ButtonBuilder: JavaClassStatics<ButtonWidgetHelper$ButtonBuilder, ButtonWidgetHelper$ButtonBuilder$$constructor>;
                            interface ButtonWidgetHelper$ButtonBuilder$$constructor extends SuppressProperties {

                                new (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen): ButtonWidgetHelper$ButtonBuilder;

                            }
                            interface ButtonWidgetHelper$ButtonBuilder extends AbstractWidgetBuilder<ButtonWidgetHelper$ButtonBuilder, /* minecraft class */ any, ButtonWidgetHelper</* minecraft class */ any>> {

                                /**
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                height(height: int): ButtonWidgetHelper$ButtonBuilder;

                                /**
                                 * @param width the width of the button
                                 * @param height this argument is ignored and will always be set to 20
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                size(width: int, height: int): ButtonWidgetHelper$ButtonBuilder;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* minecraft class */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<ButtonWidgetHelper</* minecraft class */ any>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): ButtonWidgetHelper$ButtonBuilder;
                                createWidget(): ButtonWidgetHelper</* minecraft class */ any>;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const CyclingButtonWidgetHelper$CyclicButtonBuilder: JavaClassStatics<CyclingButtonWidgetHelper$CyclicButtonBuilder<any>, CyclingButtonWidgetHelper$CyclicButtonBuilder$$constructor>;
                            interface CyclingButtonWidgetHelper$CyclicButtonBuilder$$constructor extends SuppressProperties {

                                new <T>(screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, valueToText: xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                            }
                            interface CyclingButtonWidgetHelper$CyclicButtonBuilder<T> extends AbstractWidgetBuilder<CyclingButtonWidgetHelper$CyclicButtonBuilder<T>, /* minecraft class */ any, CyclingButtonWidgetHelper<T>> {

                                /**
                                 * @return the initial value of the slider.
                                 * @since 1.8.4
                                 */
                                getInitialValue(): T;

                                /**
                                 * @param value the initial value of the slider
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                initially(value: T): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * The option text is a prefix of all values, seperated by a colon.
                                 * @return the option text of the button or an empty text if it is omitted.
                                 * @since 1.8.4
                                 */
                                getOption(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @param option the option text of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                option(option: string): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param option the option text of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                option(option: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<CyclingButtonWidgetHelper<T>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<CyclingButtonWidgetHelper<T>, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return the function to convert a value to a text.
                                 * @since 1.8.4
                                 */
                                getValueToText(): xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>;

                                /**
                                 * @param valueToText the function to convert a value to a text
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                valueToText(valueToText: xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * The button will normally cycle through the default values, but if the alternate toggle is
                                 *  true, it will cycle through the alternate values.
                                 * @return the list of all default values.
                                 * @since 1.8.4
                                 */
                                getDefaultValues(): JavaList<T>;

                                /**
                                 * The button will normally cycle through the default values, but if the alternate toggle is
                                 *  true, it will cycle through the alternate values.
                                 * @return the list of all alternate values.
                                 * @since 1.8.4
                                 */
                                getAlternateValues(): JavaList<T>;

                                /**
                                 * @param values the default values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                values(...values: T[]): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param values the alternate values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                alternatives(...values: T[]): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param defaults the default values of the button
                                 * @param alternatives the alternate values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                values(defaults: T[], alternatives: T[]): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @param defaults the default values of the button
                                 * @param alternatives the alternate values of the button
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                values(defaults: JavaList<T>, alternatives: JavaList<T>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return the toggle function to determine if the button should cycle through the default
                                 *          or the alternate values.
                                 * @since 1.8.4
                                 */
                                getAlternateToggle(): xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, boolean, any>;

                                /**
                                 * @param alternateToggle the toggle function to determine if the button should cycle
                                 *                         through the default or the alternate values
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                alternateToggle(alternateToggle: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, boolean, any>): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;

                                /**
                                 * @return {@code true} if the prefix option text should be omitted, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                isOptionTextOmitted(): boolean;

                                /**
                                 * @param optionTextOmitted whether the prefix option text should be omitted or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                omitTextOption(optionTextOmitted: boolean): CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;
                                createWidget(): CyclingButtonWidgetHelper<T>;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const TextFieldWidgetHelper$TextFieldBuilder: JavaClassStatics<TextFieldWidgetHelper$TextFieldBuilder, TextFieldWidgetHelper$TextFieldBuilder$$constructor>;
                            interface TextFieldWidgetHelper$TextFieldBuilder$$constructor extends SuppressProperties {

                                new (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, textRenderer: /* minecraft class */ any): TextFieldWidgetHelper$TextFieldBuilder;

                            }
                            interface TextFieldWidgetHelper$TextFieldBuilder extends AbstractWidgetBuilder<TextFieldWidgetHelper$TextFieldBuilder, /* minecraft class */ any, TextFieldWidgetHelper> {

                                /**
                                 * @return the callback for when the text is changed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<string, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the callback for when the text is changed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): TextFieldWidgetHelper$TextFieldBuilder;

                                /**
                                 * @return the current suggestion.
                                 * @since 1.8.4
                                 */
                                getSuggestion(): string;

                                /**
                                 * @param suggestion the suggestion to use
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestion(suggestion: string): TextFieldWidgetHelper$TextFieldBuilder;
                                createWidget(): TextFieldWidgetHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const LockButtonWidgetHelper$LockButtonBuilder: JavaClassStatics<LockButtonWidgetHelper$LockButtonBuilder, LockButtonWidgetHelper$LockButtonBuilder$$constructor>;
                            interface LockButtonWidgetHelper$LockButtonBuilder$$constructor extends SuppressProperties {

                                new (screen: xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen): LockButtonWidgetHelper$LockButtonBuilder;

                            }
                            interface LockButtonWidgetHelper$LockButtonBuilder extends AbstractWidgetBuilder<LockButtonWidgetHelper$LockButtonBuilder, /* minecraft class */ any, LockButtonWidgetHelper> {

                                /**
                                 * @return the initial state of the lock button.
                                 * @since 1.8.4
                                 */
                                isLocked(): boolean;

                                /**
                                 * @param locked whether to initially lock the button or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                locked(locked: boolean): LockButtonWidgetHelper$LockButtonBuilder;

                                /**
                                 * @return the action to run when the button is pressed.
                                 * @since 1.8.4
                                 */
                                getAction(): xyz.wagyourtail.jsmacros.core.MethodWrapper<LockButtonWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>;

                                /**
                                 * @param action the action to run when the button is pressed
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                action(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<LockButtonWidgetHelper, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen, any, any>): LockButtonWidgetHelper$LockButtonBuilder;
                                createWidget(): LockButtonWidgetHelper;

                            }

                            /**
                             * @author Etheradon
                             * @since 1.8.4
                             */
                            const AbstractWidgetBuilder: JavaClassStatics<AbstractWidgetBuilder<any, any, any>> & NoConstructor;
                            interface AbstractWidgetBuilder<B extends AbstractWidgetBuilder<B, T, U>, T = /* minecraft class */ any, U extends ClickableWidgetHelper<U, T>> extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B> {

                                /**
                                 * @return the width of the widget.
                                 * @since 1.8.4
                                 */
                                getWidth(): number;

                                /**
                                 * @param width the width of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                width(width: int): B;

                                /**
                                 * @return the height of the widget.
                                 * @since 1.8.4
                                 */
                                getHeight(): number;

                                /**
                                 * @param height the height of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                height(height: int): B;

                                /**
                                 * @param width the width of the widget
                                 * @param height the height of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                size(width: int, height: int): B;

                                /**
                                 * @return the z-index of the widget.
                                 * @since 1.8.4
                                 */
                                getZIndex(): number;

                                /**
                                 * @param zIndex the z-index of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                zIndex(zIndex: int): B;

                                /**
                                 * @return the x position of the widget.
                                 * @since 1.8.4
                                 */
                                getX(): number;

                                /**
                                 * @param x the x position of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                x(x: int): B;

                                /**
                                 * @return the y position of the widget.
                                 * @since 1.8.4
                                 */
                                getY(): number;

                                /**
                                 * @param y the y position of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                y(y: int): B;

                                /**
                                 * @param x the x position of the widget
                                 * @param y the y position of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                pos(x: int, y: int): B;

                                /**
                                 * @return the message of the widget or an empty text if none is set.
                                 * @since 1.8.4
                                 */
                                getMessage(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                /**
                                 * @param message the message of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                message(message: string): B;

                                /**
                                 * @param message the message of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                message(message: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): B;

                                /**
                                 * An inactive widget can not be interacted with and may have a different appearance.
                                 * @return {@code true} if the widget is active, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isActive(): boolean;

                                /**
                                 * An inactive widget can not be interacted with and may have a different appearance.
                                 * @param active whether the widget should be active or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                active(active: boolean): B;

                                /**
                                 * @return {@code true} if the widget is visible, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isVisible(): boolean;

                                /**
                                 * @param visible whether the widget should be visible or not
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                visible(visible: boolean): B;

                                /**
                                 * @return the alpha value of the widget.
                                 * @since 1.8.4
                                 */
                                getAlpha(): number;

                                /**
                                 * @param alpha the alpha value of the widget
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                alpha(alpha: double): B;

                                /**
                                 * @return the build widget for the set properties.
                                 * @since 1.8.4
                                 */
                                build(): U;
                                getScaledWidth(): number;
                                getParentWidth(): number;
                                getScaledHeight(): number;
                                getParentHeight(): number;
                                getScaledLeft(): number;
                                getScaledTop(): number;
                                moveTo(x: int, y: int): B;

                            }

                            export {
                                ScoreboardObjectiveHelper,
                                LockButtonWidgetHelper,
                                ClickableWidgetHelper,
                                CheckBoxWidgetHelper,
                                ButtonWidgetHelper$TexturedButtonBuilder,
                                TextFieldWidgetHelper,
                                ChatHudLineHelper,
                                SliderWidgetHelper,
                                CyclingButtonWidgetHelper,
                                ButtonWidgetHelper,
                                SliderWidgetHelper$SliderBuilder,
                                CheckBoxWidgetHelper$CheckBoxBuilder,
                                ButtonWidgetHelper$ButtonBuilder,
                                CyclingButtonWidgetHelper$CyclicButtonBuilder,
                                TextFieldWidgetHelper$TextFieldBuilder,
                                LockButtonWidgetHelper$LockButtonBuilder,
                                AbstractWidgetBuilder
                            }

                        }

                    }

                    namespace classes {

                        /**
                         * usage: `builder.append("hello,").withColor(0xc).append(" World!").withColor(0x6)`
                         * @author Wagyourtail
                         * @since 1.3.0
                         */
                        const TextBuilder: JavaClassStatics<TextBuilder, TextBuilder$$constructor>;
                        interface TextBuilder$$constructor extends SuppressProperties {

                            new (): TextBuilder;

                        }
                        interface TextBuilder extends JavaObject {

                            /**
                             * move on to next section and set it's text.
                             * @param text a {@link String}, {@link TextHelper} or {@link TextBuilder}
                             * @since 1.3.0
                             * @return
                             */
                            append(text: any): TextBuilder;

                            /**
                             * set current section's color by color code as hex, like `0x6` for gold
                             *  and `0xc` for red.
                             * @param color
                             * @since 1.3.0
                             * @return
                             */
                            withColor(color: int): TextBuilder;

                            /**
                             * Add text with custom colors.
                             * @since 1.3.1
                             * @param r red {@code 0-255}
                             * @param g green {@code 0-255}
                             * @param b blue {@code 0-255}
                             * @return
                             */
                            withColor(r: int, g: int, b: int): TextBuilder;

                            /**
                             * set other formatting options for the current section
                             * @param underline
                             * @param bold
                             * @param italic
                             * @param strikethrough
                             * @param magic
                             * @since 1.3.0
                             * @return
                             */
                            withFormatting(underline: boolean, bold: boolean, italic: boolean, strikethrough: boolean, magic: boolean): TextBuilder;

                            /**
                             * @param formattings the formattings to apply
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            withFormatting(...formattings: xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper[]): TextBuilder;

                            /**
                             * set current section's hover event to show text
                             * @param text
                             * @since 1.3.0
                             * @return
                             */
                            withShowTextHover(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): TextBuilder;

                            /**
                             * set current section's hover event to show an item
                             * @param item
                             * @since 1.3.0
                             * @return
                             */
                            withShowItemHover(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): TextBuilder;

                            /**
                             * set current section's hover event to show an entity
                             * @param entity
                             * @since 1.3.0
                             * @return
                             */
                            withShowEntityHover(entity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper</* minecraft class */ any>): TextBuilder;

                            /**
                             * custom click event.
                             * @param action
                             * @since 1.3.0
                             * @return
                             */
                            withCustomClickEvent(action: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, any, any>): TextBuilder;

                            /**
                             * normal click events like: `open_url`, `open_file`, `run_command`, `suggest_command`, `change_page`, and `copy_to_clipboard`
                             * @param action
                             * @param value
                             * @since 1.3.0
                             * @return
                             */
                            withClickEvent(action: TextClickAction, value: string): TextBuilder;
                            withStyle(style: xyz.wagyourtail.jsmacros.client.api.helpers.StyleHelper): TextBuilder;

                            /**
                             * @return the width of this text.
                             * @since 1.8.4
                             */
                            getWidth(): number;

                            /**
                             * Build to a {@link TextHelper}
                             * @since 1.3.0
                             * @return
                             */
                            build(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const RegistryHelper: JavaClassStatics<RegistryHelper, RegistryHelper$$constructor> & {

                            parseIdentifier(id: string): /* minecraft class */ any;
                            parseNameSpace(id: string): string;

                        }
                        interface RegistryHelper$$constructor extends SuppressProperties {

                            new (): RegistryHelper;

                        }
                        interface RegistryHelper extends JavaObject {

                            /**
                             * @param id the item's id
                             * @return an {@link ItemHelper} for the given item.
                             * @since 1.8.4
                             */
                            getItem(id: ItemId): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper;

                            /**
                             * @param id the item's id
                             * @return an {@link ItemStackHelper} for the given item.
                             * @since 1.8.4
                             */
                            getItemStack(id: ItemId): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            /**
                             * @param id the item's id
                             * @param nbt the item's nbt
                             * @return an {@link ItemStackHelper} for the given item and nbt data.
                             * @throws CommandSyntaxException if the nbt data is invalid.
                             * @since 1.8.4
                             */
                            getItemStack(id: ItemId, nbt: string): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                            /**
                             * @return a list of all registered item ids.
                             * @since 1.8.4
                             */
                            getItemIds(): JavaList<ItemId>;

                            /**
                             * @return a list of all registered items.
                             * @since 1.8.4
                             */
                            getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper>;

                            /**
                             * @param id the block's id
                             * @return an {@link BlockHelper} for the given block.
                             * @since 1.8.4
                             */
                            getBlock(id: BlockId): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper;

                            /**
                             * @param id the block's id
                             * @return an {@link BlockStateHelper} for the given block.
                             * @since 1.8.4
                             */
                            getBlockState(id: BlockId): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;

                            /**
                             * @param id the block's id
                             * @param nbt the block's nbt
                             * @return an {@link BlockStateHelper} for the given block with the specified nbt.
                             * @throws CommandSyntaxException if the nbt data is invalid.
                             * @since 1.8.4
                             */
                            getBlockState(id: BlockId, nbt: string): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;

                            /**
                             * @return a list of all registered block ids.
                             * @since 1.8.4
                             */
                            getBlockIds(): JavaList<BlockId>;

                            /**
                             * @return a list of all registered blocks.
                             * @since 1.8.4
                             */
                            getBlocks(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper>;

                            /**
                             * @param id the enchantment's id
                             * @return an {@link EnchantmentHelper} for the given enchantment.
                             * @since 1.8.4
                             */
                            getEnchantment(id: EnchantmentId): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper;

                            /**
                             * @param id the enchantment's id
                             * @param level the level of the enchantment
                             * @return an {@link EnchantmentHelper} for the given enchantment with the specified level.
                             * @since 1.8.4
                             */
                            getEnchantment(id: EnchantmentId, level: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper;

                            /**
                             * @return a list of all registered enchantment ids.
                             * @since 1.8.4
                             */
                            getEnchantmentIds(): JavaList<EnchantmentId>;

                            /**
                             * @return a list of all registered enchantments.
                             * @since 1.8.4
                             */
                            getEnchantments(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper>;

                            /**
                             * @param type the id of the entity's type
                             * @return an {@link EntityHelper} for the given entity.
                             * @since 1.8.4
                             */
                            getEntity(type: EntityId): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

                            /**
                             * @param type the id of the entity's type
                             * @return an {@link EntityType} for the given entity.
                             * @since 1.8.4
                             */
                            getRawEntityType(type: EntityId): /* minecraft class */ any;

                            /**
                             * @return a list of all entity type ids.
                             * @since 1.8.4
                             */
                            getEntityTypeIds(): JavaList<EntityId>;

                            /**
                             * @param id the fluid's id
                             * @return an {@link FluidStateHelper} for the given fluid.
                             * @since 1.8.4
                             */
                            getFluidState(id: string): xyz.wagyourtail.jsmacros.client.api.helpers.world.FluidStateHelper;

                            /**
                             * @return a list of all feature ids.
                             * @since 1.8.4
                             */
                            getFeatureIds(): JavaList<FeatureId>;

                            /**
                             * @return a list of all structure feature ids.
                             * @since 1.8.4
                             */
                            getStructureFeatureIds(): JavaList<StructureFeatureId>;

                            /**
                             * @return a list of all painting motive ids.
                             * @since 1.8.4
                             */
                            getPaintingIds(): JavaList<PaintingId>;

                            /**
                             * @return a list of all particle type ids.
                             * @since 1.8.4
                             */
                            getParticleTypeIds(): JavaList<ParticleTypeId>;

                            /**
                             * @return a list of all game event names.
                             * @since 1.8.4
                             */
                            getGameEventNames(): JavaList<GameEventName>;

                            /**
                             * @return a list of all status effect ids.
                             * @since 1.8.4
                             */
                            getStatusEffectIds(): JavaList<StatusEffectId>;

                            /**
                             * @return a list of all block entity type ids.
                             * @since 1.8.4
                             */
                            getBlockEntityTypeIds(): JavaList<BlockEntityTypeId>;

                            /**
                             * @return a list of all screen handler ids.
                             * @since 1.8.4
                             */
                            getScreenHandlerIds(): JavaList<ScreenHandlerId>;

                            /**
                             * @return a list of all recipe type ids.
                             * @since 1.8.4
                             */
                            getRecipeTypeIds(): JavaList<RecipeTypeId>;

                            /**
                             * @return a list of all villager type ids.
                             * @since 1.8.4
                             */
                            getVillagerTypeIds(): JavaList<VillagerTypeId>;

                            /**
                             * @return a list of all villager profession ids.
                             * @since 1.8.4
                             */
                            getVillagerProfessionIds(): JavaList<VillagerProfession>;

                            /**
                             * @return a list of all point of interest type ids.
                             * @since 1.8.4
                             */
                            getPointOfInterestTypeIds(): JavaList<PointOfInterestTypeId>;

                            /**
                             * @return a list of all memory module type ids.
                             * @since 1.8.4
                             */
                            getMemoryModuleTypeIds(): JavaList<MemoryModuleTypeId>;

                            /**
                             * @return a list of all villager sensor type ids.
                             * @since 1.8.4
                             */
                            getSensorTypeIds(): JavaList<SensorTypeId>;

                            /**
                             * @return a list of all villager activity type ids.
                             * @since 1.8.4
                             */
                            getActivityTypeIds(): JavaList<ActivityTypeId>;

                            /**
                             * @return a list of all stat type ids.
                             * @since 1.8.4
                             */
                            getStatTypeIds(): JavaList<StatTypeId>;

                            /**
                             * @return a list of all entity attribute ids.
                             * @since 1.8.4
                             */
                            getEntityAttributeIds(): JavaList<EntityAttributeId>;

                            /**
                             * @return a list of all potion type ids.
                             * @since 1.8.4
                             */
                            getPotionTypeIds(): JavaList<PotionTypeId>;

                            /**
                             * @param identifier the String representation of the identifier, with the namespace and path
                             * @return the raw minecraft Identifier.
                             * @since 1.8.4
                             */
                            getIdentifier(identifier: string): /* minecraft class */ any;

                        }

                        /**
                         * @author Etheradon
                         * @since 1.8.4
                         */
                        const CustomImage: JavaClassStatics<CustomImage, CustomImage$$constructor> & {
                            readonly IMAGES: JavaMap<string, CustomImage>;

                            createWidget(width: int, height: int, name: string): CustomImage;
                            createWidget(path: string, name: string): CustomImage;

                            /**
                             * Minecraft textures use an ABGR format for some reason.
                             * @param argb the argb color to transform
                             * @return the abgr argb for the given argb color.
                             * @since 1.8.4
                             */
                            nativeARGBFlip(argb: int): number;

                        }
                        interface CustomImage$$constructor extends SuppressProperties {

                            new (image: java.awt.image.BufferedImage): CustomImage;
                            new (image: java.awt.image.BufferedImage, name: string): CustomImage;

                        }
                        interface CustomImage extends JavaObject {

                            /**
                             * @return the name of this image.
                             * @since 1.8.4
                             */
                            getName(): string;

                            /**
                             * The image can be used with the drawImage methods to draw it onto this image.
                             * @param path the path to the image, relative to the jsMacros config folder
                             * @return an image from the given path.
                             * @see #drawImage(Image, int, int, int, int)
                             * @see #drawImage(Image, int, int, int, int, int, int, int, int)
                             * @since 1.8.4
                             */
                            loadImage(path: string): java.awt.image.BufferedImage;

                            /**
                             * Loads the image from the given path and returns a subimage of it from the given positions.  
                             *  The image can be used with the drawImage methods to draw it onto this image.
                             * @param path the path to the image, relative to the jsMacros config folder
                             * @param x the x position to get the subimage from
                             * @param y the y position to get the subimage from
                             * @param width the width of the subimage
                             * @param height the height of the subimage
                             * @return the cropped image from the given path.
                             * @see #drawImage(Image, int, int, int, int)
                             * @see #drawImage(Image, int, int, int, int, int, int, int, int)
                             * @since 1.8.4
                             */
                            loadImage(path: string, x: int, y: int, width: int, height: int): java.awt.image.BufferedImage;

                            /**
                             * Updates the texture to be drawn with the contents of this image. Any changes made to this
                             *  image will only be displayed after calling this method. The method must not be called after
                             *  each change, but rather when the image is finished being changed.
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            update(): CustomImage;

                            /**
                             * Saves this image to the given path. The file will be saved as a png.
                             * @param path the path to the image, relative to the jsMacros config folder
                             * @param fileName the file name of the image, without the extension
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            saveImage(path: string, fileName: string): CustomImage;

                            /**
                             * The identifier should be used with any buttons and textures in the draw2D and other classes,  
                             *  which require an identifier.
                             * @return the identifier of this image.
                             * @since 1.8.4
                             */
                            getIdentifier(): string;

                            /**
                             * The width is a constant and will not change.
                             * @return the width of this image.
                             * @since 1.8.4
                             */
                            getWidth(): number;

                            /**
                             * The height is a constant and will not change.
                             * @return the height of this image.
                             * @since 1.8.4
                             */
                            getHeight(): number;

                            /**
                             * @return the internal BufferedImage of this image, which all updates are made to.
                             * @since 1.8.4
                             */
                            getImage(): java.awt.image.BufferedImage;

                            /**
                             * The color is in the ARGB format.
                             * @param x the x position to get the color from
                             * @param y the y position to get the color from
                             * @return the color at the given position.
                             * @since 1.8.4
                             */
                            getPixel(x: int, y: int): number;

                            /**
                             * The color is in the ARGB format.
                             * @param x the x position to set the color at
                             * @param y the y position to set the color at
                             * @param argb the ARGB value to set the pixel to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setPixel(x: int, y: int, argb: int): CustomImage;

                            /**
                             * @param img the image to draw onto this image
                             * @param x the x position to draw the image at
                             * @param y the y position to draw the image at
                             * @param width the width of the image to draw
                             * @param height the height of the image to draw
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawImage(img: java.awt.Image, x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param img the image to draw onto this image
                             * @param x the x position to draw the image at
                             * @param y the y position to draw the image at
                             * @param width the width of the image to draw
                             * @param height the height of the image to draw
                             * @param sourceX the x position of the subimage to draw
                             * @param sourceY the y position of the subimage to draw
                             * @param sourceWidth the width of the subimage to draw
                             * @param sourceHeight the height of the subimage to draw
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawImage(img: java.awt.Image, x: int, y: int, width: int, height: int, sourceX: int, sourceY: int, sourceWidth: int, sourceHeight: int): CustomImage;

                            /**
                             * The color is a rgb value which is used for draw and fill operations.
                             * @return the graphics current rgb color.
                             * @since 1.8.4
                             */
                            getGraphicsColor(): number;

                            /**
                             * The color is a rgb value which is used for draw and fill operations.
                             * @param color the rgb color to use for graphics operations
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setGraphicsColor(color: int): CustomImage;

                            /**
                             * @param x the x position of the origin point
                             * @param y the y position of the origin point
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            translate(x: int, y: int): CustomImage;

                            /**
                             * @param x the x coordinate of the rectangle to intersect the clip with
                             * @param y the y coordinate of the rectangle to intersect the clip with
                             * @param width the width of the rectangle to intersect the clip with
                             * @param height the height of the rectangle to intersect the clip with
                             * @return self for chaining.
                             */
                            clipRect(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param x the x coordinate of the new clip rectangle
                             * @param y the y coordinate of the new clip rectangle
                             * @param width the width of the new clip rectangle
                             * @param height the height of the new clip rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setClip(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setPaintMode(): CustomImage;

                            /**
                             * @param color the color to use for the xor operation
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            setXorMode(color: int): CustomImage;

                            /**
                             * @return an array with the bounds of the current clip.
                             * @since 1.8.4
                             */
                            getClipBounds(): java.awt.Rectangle;

                            /**
                             * @param x the x position to copy from
                             * @param y the y position to copy from
                             * @param width the width of the area to copy
                             * @param height the height of the area to copy
                             * @param dx the offset to the x position to copy to
                             * @param dy the offset to the y position to copy to
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            copyArea(x: int, y: int, width: int, height: int, dx: int, dy: int): CustomImage;

                            /**
                             * @param x1 the first x position of the line
                             * @param y1 the first y position of the line
                             * @param x2 the second x position of the line
                             * @param y2 the second y position of the line
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawLine(x1: int, y1: int, x2: int, y2: int): CustomImage;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawRect(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillRect(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            clearRect(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param x the x position of the rectangle
                             * @param y the y position of the rectangle
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @param color the rgb color to fill the rectangle with
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            clearRect(x: int, y: int, width: int, height: int, color: int): CustomImage;

                            /**
                             * @param x the x position to draw the rectangle at
                             * @param y the y position to draw the rectangle at
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @param arcWidth the horizontal diameter of the arc at the four corners
                             * @param arcHeight the vertical diameter of the arc at the four corners
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawRoundRect(x: int, y: int, width: int, height: int, arcWidth: int, arcHeight: int): CustomImage;

                            /**
                             * @param x the x position to draw the rectangle at
                             * @param y the y position to draw the rectangle at
                             * @param width the width of the rectangle
                             * @param height the height of the rectangle
                             * @param arcWidth the horizontal diameter of the arc at the four corners
                             * @param arcHeight the vertical diameter of the arc at the four corners
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillRoundRect(x: int, y: int, width: int, height: int, arcWidth: int, arcHeight: int): CustomImage;

                            /**
                             * @param x the x position to draw the 3D rectangle at
                             * @param y the y position to draw the 3D rectangle at
                             * @param width the width of the 3D rectangle
                             * @param height the height of the 3D rectangle
                             * @param raised whether the rectangle should be raised above the surface or etched into the
                             *                surface
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            draw3DRect(x: int, y: int, width: int, height: int, raised: boolean): CustomImage;

                            /**
                             * @param x the x position to draw the 3D rectangle at
                             * @param y the y position to draw the 3D rectangle at
                             * @param width the width of the 3D rectangle
                             * @param height the height of the 3D rectangle
                             * @param raised whether the rectangle should be raised above the surface or etched into the
                             *                surface
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fill3DRect(x: int, y: int, width: int, height: int, raised: boolean): CustomImage;

                            /**
                             * @param x the x position to draw the oval at
                             * @param y the y position to draw the oval at
                             * @param width the width of the oval
                             * @param height the height of the oval
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawOval(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param x the x position to draw the oval at
                             * @param y the y position to draw the oval at
                             * @param width the width of the oval
                             * @param height the height of the oval
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillOval(x: int, y: int, width: int, height: int): CustomImage;

                            /**
                             * @param x the x position to draw the arc at
                             * @param y the y position to draw the arc at
                             * @param width the width of the arc
                             * @param height the height of the arc
                             * @param startAngle the beginning angle
                             * @param arcAngle the angular extent of the arc, relative to the start angle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawArc(x: int, y: int, width: int, height: int, startAngle: int, arcAngle: int): CustomImage;

                            /**
                             * @param x the x position to draw the arc at
                             * @param y the y position to draw the arc at
                             * @param width the width of the arc
                             * @param height the height of the arc
                             * @param startAngle the beginning angle
                             * @param arcAngle the angular extent of the arc, relative to the start angle
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillArc(x: int, y: int, width: int, height: int, startAngle: int, arcAngle: int): CustomImage;

                            /**
                             * The x and y array must have the same length and order for the points.
                             * @param pointsX an array of all x positions of the points in the polygon
                             * @param pointsY an array of all y positions of the points in the polygon
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawPolygonLine(pointsX: int[], pointsY: int[]): CustomImage;

                            /**
                             * The x and y array must have the same length and order for the points.
                             * @param pointsX an array of all x positions of the points in the polygon
                             * @param pointsY an array of all y positions of the points in the polygon
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawPolygon(pointsX: int[], pointsY: int[]): CustomImage;

                            /**
                             * The x and y array must have the same length and order for the points.
                             * @param pointsX an array of all x positions of the points in the polygon
                             * @param pointsY an array of all y positions of the points in the polygon
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            fillPolygon(pointsX: int[], pointsY: int[]): CustomImage;

                            /**
                             * @param x the x position to draw the string at
                             * @param y the y position to draw the string at
                             * @param text the text to draw
                             * @return self for chaining.
                             * @since 1.8.4
                             */
                            drawString(x: int, y: int, text: string): CustomImage;

                            /**
                             * @param toAnalyze the string to analyze
                             * @return the width of the string for the current font in pixels
                             * @since 1.8.4
                             */
                            getStringWidth(toAnalyze: string): number;

                        }

                        /**
                         * An object, that combines all possible player inputs
                         * @author NotSomeBot
                         * @since 1.4.0
                         */
                        const PlayerInput: JavaClassStatics<PlayerInput, PlayerInput$$constructor> & {

                            /**
                             * Parses each row of CSV string into a `PlayerInput`.  
                             *  The capitalization of the header matters.<br>  
                             *  About the columns:  
                             *  <ul>  
                             *    <li> `movementForward` and `movementSideways` as a number</li>  
                             *    <li>`yaw` and `pitch` as an absolute number</li>  
                             *    <li>`jumping`, `sneaking` and `sprinting` have to be boolean</li>  
                             *  </ul>  
                             *
                             *  The separation must be a "," it's a csv...(but spaces don't matter)<br>  
                             *  Quoted values don't work
                             * @param csv CSV string to be parsed
                             * @return {@code List<PlayerInput>} Each row parsed as a {@code PlayerInput}
                             * @see #PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            fromCsv(csv: string): JavaList<PlayerInput>;

                            /**
                             * Parses a JSON string into a `PlayerInput` Object<br>  
                             *  Capitalization of the keys matters.
                             * @param json JSON string to be parsed
                             * @return The JSON parsed into a {@code PlayerInput}
                             * @see #fromCsv(String)
                             * @since 1.4.0
                             */
                            fromJson(json: string): PlayerInput;

                        }
                        interface PlayerInput$$constructor extends SuppressProperties {

                            /**
                             * Creates a new `PlayerInput` Object with all values set either to 0 or false
                             * @see #PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            new (): PlayerInput;

                            /**
                             * Creates a new `PlayerInput` Object with all other values set either to 0 or false
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
                             * @param yaw yaw of the player
                             * @see #PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            new (movementForward: float, movementSideways: float, yaw: float): PlayerInput;

                            /**
                             * Creates a new `PlayerInput` Object with all other values set either to 0 or false
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param yaw yaw of the player
                             * @param jumping jump input
                             * @param sprinting sprint input
                             * @see #PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            new (movementForward: float, yaw: float, jumping: boolean, sprinting: boolean): PlayerInput;

                            /**
                             * Creates a new `PlayerInput` Object from a minecraft input with the missing values extra
                             * @param input Minecraft Input to be converted.
                             * @param yaw yaw of the player
                             * @param pitch pitch of the player
                             * @param sprinting sprint input
                             * @see #PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            new (input: /* minecraft class */ any, yaw: float, pitch: float, sprinting: boolean): PlayerInput;

                            /**
                             * Creates a new `PlayerInput` Object with all double values converted to floats
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
                             * @param yaw yaw of the player
                             * @param pitch pitch of the player
                             * @param jumping jump input
                             * @param sneaking sneak input
                             * @param sprinting sprint input
                             * @see #PlayerInput(float, float, float, float, boolean, boolean, boolean)
                             * @since 1.4.0
                             */
                            new (movementForward: double, movementSideways: double, yaw: double, pitch: double, jumping: boolean, sneaking: boolean, sprinting: boolean): PlayerInput;

                            /**
                             * Creates a new `PlayerInput` Object
                             * @param movementForward 1 = forward input (W); 0 = no input; -1 = backward input (S)
                             * @param movementSideways 1 = left input (A); 0 = no input; -1 = right input (D)
                             * @param yaw yaw of the player
                             * @param pitch pitch of the player
                             * @param jumping jump input
                             * @param sneaking sneak input
                             * @param sprinting sprint input
                             * @since 1.4.0
                             */
                            new (movementForward: float, movementSideways: float, yaw: float, pitch: float, jumping: boolean, sneaking: boolean, sprinting: boolean): PlayerInput;

                            /**
                             * Creates a clone `PlayerInput` Object
                             * @param input the {@code PlayerInput} object to be cloned
                             * @since 1.4.0
                             */
                            new (input: PlayerInput): PlayerInput;

                        }
                        interface PlayerInput extends JavaObject {
                            movementForward: number;
                            movementSideways: number;
                            yaw: number;
                            pitch: number;
                            jumping: boolean;
                            sneaking: boolean;
                            sprinting: boolean;

                            /**
                             * Converts the current object into a string.  
                             *  This can be used to convert current inputs created using `Player.getCurrentPlayerInput()`
                             *  to either JSON or CSV.  
                             *
                             *  The output can be converted into a PlayerInput object again by using either
                             *  `fromCsv(String, String)` or `fromJson(String)`.
                             * @param varNames whether to include variable Names(=JSON) or not(=CSV)
                             * @return The {@code PlayerInput} object as a string
                             * @since 1.4.0
                             */
                            toString(varNames: boolean): string;
                            toString(): string;
                            clone(): PlayerInput;

                        }

                        export { TextBuilder, RegistryHelper, CustomImage, PlayerInput }

                    }
                    namespace classes {

                        namespace inventory {

                            /** @since 1.7.0 */
                            const CommandManager: JavaClassStatics<CommandManager, CommandManager$$constructor> & {
                                instance: CommandManager;
                            }
                            interface CommandManager$$constructor extends SuppressProperties {

                                new (): CommandManager;

                            }
                            interface CommandManager extends JavaObject {

                                /**
                                 * @since 1.7.0
                                 * @return list of commands
                                 */
                                getValidCommands(): JavaList<string>;

                                /**
                                 * @param name
                                 * @since 1.7.0
                                 * @return
                                 */
                                createCommandBuilder(name: string): CommandBuilder;

                                /**
                                 * @param command
                                 * @return 
                                 * @since 1.7.0
                                 * @throws IllegalAccessException
                                 */
                                unregisterCommand(command: string): xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper;

                                /**
                                 * warning: this method is hacky
                                 * @since 1.7.0
                                 * @param node
                                 */
                                reRegisterCommand(node: xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper): void;

                                /**
                                 * @since 1.8.2
                                 * @param commandPart
                                 */
                                getArgumentAutocompleteOptions(commandPart: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<JavaList<string>, any, any, any>): void;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.0.8
                             */
                            const Inventory: JavaClassStatics<Inventory<any>> & NoConstructor & {

                                create(): Inventory<any>;
                                create(s: /* minecraft class */ any): Inventory<any>;

                            }
                            interface Inventory<T = /* minecraft class */ any> extends JavaObject {

                                /**
                                 * @param slot
                                 * @since 1.5.0
                                 * @return
                                 */
                                click(slot: int): Inventory<T>;

                                /**
                                 * Clicks a slot with a mouse button.~~if the slot is a container, it will click the first slot in the container
                                 * @since 1.0.8
                                 * @param slot
                                 * @param mousebutton
                                 * @return
                                 */
                                click(slot: int, mousebutton: Bit): Inventory<T>;

                                /**
                                 * Does a drag-click with a mouse button. (the slots don't have to be in order or even adjacent, but when vanilla minecraft calls the underlying function they're always sorted...)
                                 * @param slots
                                 * @param mousebutton
                                 * @return
                                 */
                                dragClick(slots: int[], mousebutton: Bit): Inventory<T>;

                                /**
                                 * @since 1.5.0
                                 * @param slot
                                 */
                                dropSlot(slot: int): Inventory<T>;

                                /**
                                 * @param slot the slot to drop
                                 * @param stack decide whether to drop the whole stack or just a single item
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                dropSlot(slot: int, stack: boolean): Inventory<T>;

                                /**
                                 * @param item the item to check for
                                 * @return {@code true} if the item is contined anywhere in the inventory, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                contains(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): boolean;

                                /**
                                 * @param item the item to check for
                                 * @return {@code true} if the item is contined anywhere in the inventory, {@code false}
                                 *          otherwise.
                                 * @since 1.8.4
                                 */
                                contains(item: ItemId): boolean;

                                /**
                                 * @return the first empty slot in the main inventory or {@code -1} if there are no empty
                                 *          slots.
                                 * @since 1.8.4
                                 */
                                findFreeInventorySlot(): number;

                                /**
                                 * @return the first empty hotbar slot or {@code -1} if there are no empty slots.
                                 * @since 1.8.4
                                 */
                                findFreeHotbarSlot(): number;

                                /**
                                 * @param mapIdentifiers the identifier of the inventory sections to check
                                 * @return the first empty slot in the given inventory sections, or {@code -1} if there are no
                                 *          empty slots.
                                 * @since 1.8.4
                                 */
                                findFreeSlot(...mapIdentifiers: InvMapId[]): number;

                                /**
                                 * @return a map of all item ids and their total count inside the inventory.
                                 * @since 1.8.4
                                 */
                                getItemCount(): JavaMap<ItemId, number>;

                                /**
                                 * @return a list of all items in the inventory.
                                 * @since 1.8.4
                                 */
                                getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @param mapIdentifiers the inventory sections
                                 * @return a list of all items in the given inventory sections.
                                 * @since 1.8.4
                                 */
                                getItems(...mapIdentifiers: InvMapId[]): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper>;

                                /**
                                 * @param item the item to search for
                                 * @return all slots containing the given item.
                                 * @since 1.8.4
                                 */
                                findItem(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): JavaArray<number>;

                                /**
                                 * @param item the item to search for
                                 * @return all slots containing the given item.
                                 * @since 1.8.4
                                 */
                                findItem(item: ItemId): JavaArray<number>;

                                /**
                                 * @param mapIdentifiers the inventory sections
                                 * @return all slots indexes in the given inventory sections.
                                 * @since 1.8.4
                                 */
                                getSlots(...mapIdentifiers: InvMapId[]): JavaArray<number>;

                                /**
                                 * @since 1.2.5
                                 * @return the index of the selected hotbar slot.
                                 */
                                getSelectedHotbarSlotIndex(): number;

                                /**
                                 * @since 1.2.5
                                 * @param index
                                 */
                                setSelectedHotbarSlotIndex(index: int): void;

                                /**
                                 * closes the inventory, (if the inventory/container is visible it will close the gui). also drops any "held on mouse" items.
                                 * @return
                                 */
                                closeAndDrop(): Inventory<T>;

                                /**
                                 * Closes the inventory, and open gui if applicable.
                                 */
                                close(): void;

                                /**
                                 * simulates a shift-click on a slot.  
                                 *  It should be safe to chain these without {@link FClient#waitTick} at least for a bunch of the same item.
                                 * @param slot
                                 * @return
                                 */
                                quick(slot: int): Inventory<T>;

                                /**
                                 * @param slot
                                 * @since 1.7.0
                                 * @return
                                 */
                                quickAll(slot: int): number;

                                /**
                                 * quicks all that match the slot
                                 * @param slot a slot from the section you want to move items from
                                 * @param button
                                 * @since 1.7.0
                                 * @return number of items that matched
                                 */
                                quickAll(slot: int, button: Bit): number;

                                /**
                                 * @return the held (by the mouse) item.
                                 */
                                getHeld(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @param slot
                                 * @return the item in the slot.
                                 */
                                getSlot(slot: int): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                /**
                                 * @return the size of the container/inventory.
                                 */
                                getTotalSlots(): number;

                                /**
                                 * Splits the held stack into two slots. can be alternatively done with {@link Inventory#dragClick} if this one has issues on some servers.
                                 * @param slot1
                                 * @param slot2
                                 * @return 
                                 * @throws Exception
                                 */
                                split(slot1: int, slot2: int): Inventory<T>;

                                /**
                                 * Does that double click thingy to turn a incomplete stack pickup into a complete stack pickup if you have more in your inventory.
                                 * @param slot
                                 * @return
                                 */
                                grabAll(slot: int): Inventory<T>;

                                /**
                                 * swaps the items in two slots.
                                 * @param slot1
                                 * @param slot2
                                 * @return
                                 */
                                swap(slot1: int, slot2: int): Inventory<T>;

                                /**
                                 * equivalent to hitting the numbers or f for swapping slots to hotbar
                                 * @param slot
                                 * @param hotbarSlot 0-8 or 40 for offhand
                                 * @since 1.6.5 [citation needed]
                                 * @return
                                 */
                                swapHotbar(slot: int, hotbarSlot: HotbarSwapSlot): Inventory<T>;
                                /** @since 1.2.8 */
                                openGui(): void;

                                /**
                                 * @since 1.1.3
                                 * @return the id of the slot under the mouse.
                                 */
                                getSlotUnderMouse(): number;

                                /**
                                 * @since 1.1.3
                                 * @return the part of the mapping the slot is in.
                                 */
                                getType(): InventoryType;

                                /**
                                 * @since 1.1.3
                                 * @return the inventory mappings different depending on the type of open container/inventory.
                                 */
                                getMap(): JavaMap<InvMapId, JavaArray<number>>;

                                /**
                                 * @since 1.1.3
                                 * @param slotNum
                                 * @return returns the part of the mapping the slot is in.
                                 */
                                getLocation(slotNum: int): InvMapId;

                                /**
                                 * @return the x/y position of the specified slot index
                                 * @since 1.8.4
                                 */
                                getSlotPos(slot: int): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;

                                /**
                                 * @return {@code true} if the inventory is a container, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isContainer(): boolean;

                                /**
                                 * @since 1.2.3
                                 * @return
                                 */
                                getContainerTitle(): string;
                                getRawContainer(): T;

                                /**
                                 * @since 1.6.0
                                 * @return
                                 */
                                getCurrentSyncId(): number;

                            }

                            /** @since 1.4.2 */
                            const CommandBuilder: JavaClassStatics<CommandBuilder, CommandBuilder$$constructor>;
                            interface CommandBuilder$$constructor extends SuppressProperties {

                                new (): CommandBuilder;

                            }
                            interface CommandBuilder extends JavaObject {

                                literalArg(name: string): CommandBuilder;
                                booleanArg(name: string): CommandBuilder;
                                intArg(name: string): CommandBuilder;
                                intArg(name: string, min: int, max: int): CommandBuilder;
                                intRangeArg(name: string): CommandBuilder;
                                longArg(name: string): CommandBuilder;
                                longArg(name: string, min: long, max: long): CommandBuilder;
                                floatRangeArg(name: string): CommandBuilder;
                                doubleArg(name: string): CommandBuilder;
                                doubleArg(name: string, min: double, max: double): CommandBuilder;
                                uuidArgType(name: string): CommandBuilder;
                                greedyStringArg(name: string): CommandBuilder;
                                quotedStringArg(name: string): CommandBuilder;
                                wordArg(name: string): CommandBuilder;
                                regexArgType(name: string, regex: string, flags: string): CommandBuilder;
                                textArgType(name: string): CommandBuilder;
                                timeArg(name: string): CommandBuilder;
                                identifierArg(name: string): CommandBuilder;
                                nbtArg(name: string): CommandBuilder;
                                nbtElementArg(name: string): CommandBuilder;
                                nbtCompoundArg(name: string): CommandBuilder;
                                colorArg(name: string): CommandBuilder;
                                angleArg(name: string): CommandBuilder;
                                itemArg(name: string): CommandBuilder;
                                itemStackArg(name: string): CommandBuilder;
                                itemPredicateArg(name: string): CommandBuilder;
                                blockArg(name: string): CommandBuilder;
                                blockStateArg(name: string): CommandBuilder;
                                blockPredicateArg(name: string): CommandBuilder;
                                blockPosArg(name: string): CommandBuilder;
                                columnPosArg(name: string): CommandBuilder;
                                dimensionArg(name: string): CommandBuilder;
                                itemSlotArg(name: string): CommandBuilder;
                                particleArg(name: string): CommandBuilder;

                                /**
                                 * it is recommended to use {@link xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros#runScript}
                                 *  in the callback if you expect to actually do anything complicated with waits.  
                                 *
                                 *  the {@link CommandContextHelper} arg is an {@link BaseEvent}
                                 *  so you can pass it directly to {@link xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros#runScript}.  
                                 *
                                 *  make sure your callback returns a boolean success = true.
                                 * @param callback
                                 * @return
                                 */
                                executes(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper, any, any, any>): CommandBuilder;

                                /**
                                 * @since 1.6.5
                                 * @param suggestions
                                 * @return
                                 */
                                suggestMatching(...suggestions: string[]): CommandBuilder;

                                /**
                                 * @param suggestions the strings to match
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestMatching(suggestions: JavaCollection<string>): CommandBuilder;

                                /**
                                 * @since 1.6.5
                                 * @param suggestions
                                 * @return
                                 */
                                suggestIdentifier(...suggestions: string[]): CommandBuilder;

                                /**
                                 * @param suggestions the identifiers to match
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestIdentifier(suggestions: JavaCollection<string>): CommandBuilder;

                                /**
                                 * @param positions the positions to suggest
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestBlockPositions(...positions: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper[]): CommandBuilder;

                                /**
                                 * @param positions the positions to suggest
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestBlockPositions(positions: JavaCollection<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper>): CommandBuilder;

                                /**
                                 * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                                 *  minecraft selectors "~" and "^" followed by a number.
                                 * @param positions the positions to suggest
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestPositions(...positions: string[]): CommandBuilder;

                                /**
                                 * Positions are strings of the form "x y z" where x, y, and z are numbers or the default
                                 *  minecraft selectors "~" and "^" followed by a number.
                                 * @param positions the positions to match
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                suggestPositions(positions: JavaCollection<string>): CommandBuilder;

                                /**
                                 * @since 1.6.5
                                 * @param callback
                                 * @return
                                 */
                                suggest(callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper, xyz.wagyourtail.jsmacros.client.api.helpers.SuggestionsBuilderHelper, any, any>): CommandBuilder;
                                or(): CommandBuilder;

                                /**
                                 * name overload for {@link #or} to work around language keyword restrictions
                                 * @since 1.5.2
                                 * @return
                                 */
                                otherwise(): CommandBuilder;
                                or(argumentLevel: int): CommandBuilder;

                                /**
                                 * name overload for {@link #or} to work around language keyword restrictions
                                 * @since 1.5.2
                                 * @param argLevel
                                 * @return
                                 */
                                otherwise(argLevel: int): CommandBuilder;
                                register(): void;

                                /**
                                 * @since 1.6.5
                                 *  removes this command
                                 */
                                unregister(): void;

                            }

                            /** @since 1.6.0 */
                            const ChatHistoryManager: JavaClassStatics<ChatHistoryManager, ChatHistoryManager$$constructor>;
                            interface ChatHistoryManager$$constructor extends SuppressProperties {

                                new (hud: /* minecraft class */ any): ChatHistoryManager;

                            }
                            interface ChatHistoryManager extends JavaObject {

                                /**
                                 * @param index
                                 * @since 1.6.0
                                 * @return
                                 */
                                getRecvLine(index: int): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper;

                                /**
                                 * @return the amount of messages in the chat history.
                                 * @throws InterruptedException
                                 * @since 1.8.4
                                 */
                                gerRecvCount(): number;

                                /**
                                 * @return all received messages in the chat history.
                                 * @throws InterruptedException
                                 * @since 1.8.4
                                 */
                                getRecvLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper>;

                                /**
                                 * @since 1.6.0
                                 * @param index
                                 * @param line
                                 */
                                insertRecvText(index: int, line: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): void;

                                /**
                                 * you should probably run {@link #refreshVisible} after...
                                 * @param index
                                 * @param line
                                 * @param timeTicks
                                 * @since 1.6.0
                                 */
                                insertRecvText(index: int, line: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, timeTicks: int): void;

                                /**
                                 * @param index
                                 * @param line
                                 * @param timeTicks
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                insertRecvText(index: int, line: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, timeTicks: int, await: boolean): void;

                                /**
                                 * @since 1.6.0
                                 * @param index
                                 */
                                removeRecvText(index: int): void;

                                /**
                                 * @param index
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                removeRecvText(index: int, await: boolean): void;

                                /**
                                 * @since 1.6.0
                                 * @param text
                                 */
                                removeRecvTextMatching(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): void;

                                /**
                                 * @param text
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                removeRecvTextMatching(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, await: boolean): void;

                                /**
                                 * @since 1.6.0
                                 * @param filter
                                 */
                                removeRecvTextMatchingFilter(filter: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper, any, boolean, any>): void;

                                /**
                                 * @param filter
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                removeRecvTextMatchingFilter(filter: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper, any, boolean, any>, await: boolean): void;

                                /**
                                 * this will reset the view of visible messages
                                 * @since 1.6.0
                                 */
                                refreshVisible(): void;

                                /**
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                refreshVisible(await: boolean): void;
                                /** @since 1.6.0 */
                                clearRecv(): void;

                                /**
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                clearRecv(await: boolean): void;

                                /**
                                 * @since 1.6.0
                                 * @return direct reference to sent message history list. modifications will affect the list.
                                 */
                                getSent(): JavaList<string>;
                                /** @since 1.6.0 */
                                clearSent(): void;

                                /**
                                 * @param await
                                 * @since 1.6.0
                                 * @throws InterruptedException
                                 */
                                clearSent(await: boolean): void;

                            }

                            /** @since 1.3.1 */
                            const VillagerInventory: JavaClassStatics<VillagerInventory> & NoConstructor;
                            interface VillagerInventory extends Inventory</* minecraft class */ any> {

                                /**
                                 * select the trade by its index
                                 * @param index
                                 * @return self for chaining
                                 * @since 1.3.1
                                 */
                                selectTrade(index: int): VillagerInventory;

                                /**
                                 * @return 
                                 * @since 1.3.1
                                 */
                                getExperience(): number;

                                /**
                                 * @return 
                                 * @since 1.3.1
                                 */
                                getLevelProgress(): number;

                                /**
                                 * @return 
                                 * @since 1.3.1
                                 */
                                getMerchantRewardedExperience(): number;

                                /**
                                 * @return 
                                 * @since 1.3.1
                                 */
                                canRefreshTrades(): boolean;

                                /**
                                 * @return 
                                 * @since 1.3.1
                                 */
                                isLeveled(): boolean;

                                /**
                                 * @return list of trade offers
                                 * @since 1.3.1
                                 */
                                getTrades(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.TradeOfferHelper>;

                            }

                            export {
                                CommandManager,
                                Inventory,
                                CommandBuilder,
                                ChatHistoryManager,
                                VillagerInventory
                            }

                        }

                        namespace render {

                            /**
                             * @author Wagyourtail
                             * @since 1.2.7
                             */
                            const IDraw2D: JavaInterfaceStatics<IDraw2D<any>>;
                            interface IDraw2D<T> extends JavaObject {

                                /**
                                 * @since 1.2.7
                                 * @return screen width
                                 */
                                getWidth(): number;

                                /**
                                 * @since 1.2.7
                                 * @return screen height
                                 */
                                getHeight(): number;

                                /**
                                 * @since 1.2.7
                                 * @return text elements
                                 * @deprecated
                                 */
                                getTexts(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text>;

                                /**
                                 * @since 1.2.7
                                 * @return rect elements
                                 * @deprecated
                                 */
                                getRects(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect>;

                                /**
                                 * @return all registered line elements.
                                 * @since 1.8.4
                                 */
                                getLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line>;

                                /**
                                 * @since 1.2.7
                                 * @return item elements
                                 * @deprecated
                                 */
                                getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item>;

                                /**
                                 * @since 1.2.7
                                 * @return image elements
                                 * @deprecated
                                 */
                                getImages(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image>;

                                /**
                                 * @return all registered draw2d elements.
                                 * @since 1.8.4
                                 */
                                getDraw2Ds(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement>;

                                /**
                                 * @since 1.2.9
                                 * @return a read only copy of the list of all elements added by scripts.
                                 */
                                getElements(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>;

                                /**
                                 * removes any element regardless of type.
                                 * @since 1.2.9
                                 * @return self for chaining
                                 */
                                removeElement(e: xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement): T;

                                /**
                                 * re-add an element you removed with {@link #removeElement}
                                 * @since 1.2.9
                                 * @return self for chaining
                                 */
                                reAddElement<T extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>(e: T): T;

                                /**
                                 * @since 1.2.7
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @return added text
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.4.0
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @return added text
                                 */
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.2.7
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.4.0
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 */
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.2.7
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @return added text
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.4.0
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @return added text
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.2.7
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.4.0
                                 * @param text
                                 * @param x screen x
                                 * @param y screen y
                                 * @param color text color
                                 * @param zIndex z-index
                                 * @param shadow include shadow layer
                                 * @param scale text scale (as double)
                                 * @param rotation text rotation (as degrees)
                                 * @return added text
                                 */
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.2.7
                                 * @param t
                                 * @return self for chaining
                                 * @deprecated
                                 */
                                removeText(t: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text): T;

                                /**
                                 * @since 1.2.7
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param id image id, in the form {@code minecraft:textures} path'd as found in texture packs, ie {@code assets/minecraft/textures/gui/recipe_book.png} becomes {@code minecraft:textures/gui/recipe_book.png}
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @return added image
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.4.0
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param zIndex z-index
                                 * @param id image id, in the form {@code minecraft:textures} path'd as found in texture packs, ie {@code assets/minecraft/textures/gui/recipe_book.png} becomes {@code minecraft:textures/gui/recipe_book.png}
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @return added image
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.2.7
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param id image id, in the form {@code minecraft:textures} path'd as found in texture packs, ie {@code assets/minecraft/textures/gui/recipe_book.png} becomes {@code minecraft:textures/gui/recipe_book.png}
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @param rotation the rotation (clockwise) of the texture (as degrees)
                                 * @return added image
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.4.0
                                 * @param x screen x, top left corner
                                 * @param y screen y, top left corner
                                 * @param width width on screen
                                 * @param height height on screen
                                 * @param zIndex z-index
                                 * @param id image id, in the form {@code minecraft:textures} path'd as found in texture packs, ie {@code assets/minecraft/textures/gui/recipe_book.png} becomes {@code minecraft:textures/gui/recipe_book.png}
                                 * @param imageX the left-most coordinate of the texture region
                                 * @param imageY the top-most coordinate of the texture region
                                 * @param regionWidth the width the texture region
                                 * @param regionHeight the height the texture region
                                 * @param textureWidth the width of the entire texture
                                 * @param textureHeight the height of the entire texture
                                 * @param rotation the rotation (clockwise) of the texture (as degrees)
                                 * @return added image
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @param x
                                 * @param y
                                 * @param width
                                 * @param height
                                 * @param zIndex
                                 * @param color
                                 * @param id
                                 * @param imageX
                                 * @param imageY
                                 * @param regionWidth
                                 * @param regionHeight
                                 * @param textureWidth
                                 * @param textureHeight
                                 * @param rotation
                                 * @since 1.6.5
                                 * @return
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @param x
                                 * @param y
                                 * @param width
                                 * @param height
                                 * @param zIndex
                                 * @param alpha
                                 * @param color
                                 * @param id
                                 * @param imageX
                                 * @param imageY
                                 * @param regionWidth
                                 * @param regionHeight
                                 * @param textureWidth
                                 * @param textureHeight
                                 * @param rotation
                                 * @since 1.6.5
                                 * @return
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, alpha: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.2.7
                                 * @param i
                                 * @return self for chaining
                                 * @deprecated
                                 */
                                removeImage(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image): T;

                                /**
                                 * @since 1.2.7
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @param color as hex, with alpha channel
                                 * @return added rect
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.2.7
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @param color as hex
                                 * @param alpha alpha channel 0-255
                                 * @return added rect
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.2.7
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @param color as hex
                                 * @param alpha alpha channel 0-255
                                 * @param rotation as degrees
                                 * @return added rect
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.4.0
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @param color as hex
                                 * @param alpha alpha channel 0-255
                                 * @param rotation as degrees
                                 * @param zIndex z-index
                                 * @return added rect
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.2.7
                                 * @param r
                                 * @return self for chaining
                                 * @deprecated
                                 */
                                removeRect(r: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect): T;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param zIndex the z-index of the line
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param width the width of the line
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param zIndex the z-index of the line
                                 * @param width the width of the line
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param width the width of the line
                                 * @param rotation the rotation (clockwise) of the line (as degrees)
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param x1 the x position of the start
                                 * @param y1 the y position of the start
                                 * @param x2 the x position of the end
                                 * @param y2 the y position of the end
                                 * @param color the color of the line, can include alpha value
                                 * @param zIndex the z-index of the line
                                 * @param width the width of the line
                                 * @param rotation the rotation (clockwise) of the line (as degrees)
                                 * @return the added line.
                                 * @since 1.8.4
                                 */
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;

                                /**
                                 * @param l the line to remove
                                 * @return self chaining.
                                 * @since 1.8.4
                                 */
                                removeLine(l: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line): T;

                                /**
                                 * @since 1.2.7
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param id item id
                                 * @return added item
                                 */
                                addItem(x: int, y: int, id: ItemId): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.4.0
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param id item id
                                 * @return added item
                                 */
                                addItem(x: int, y: int, zIndex: int, id: ItemId): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.7
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 */
                                addItem(x: int, y: int, id: ItemId, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.4.0
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 */
                                addItem(x: int, y: int, zIndex: int, id: ItemId, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.7
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 */
                                addItem(x: int, y: int, id: ItemId, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.4.0
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param id item id
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 */
                                addItem(x: int, y: int, zIndex: int, id: ItemId, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.7
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param item from inventory as helper
                                 * @return added item
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.4.0
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param item from inventory as helper
                                 * @return added item
                                 */
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.7
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.4.0
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @return added item
                                 */
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.7
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.4.0
                                 * @param x left most corner
                                 * @param y top most corner
                                 * @param zIndex z-index
                                 * @param item from inventory as helper
                                 * @param overlay should include overlay health and count
                                 * @param scale scale of item
                                 * @param rotation rotation of item
                                 * @return added item
                                 */
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.7
                                 * @param i
                                 * @return self for chaining
                                 * @deprecated
                                 */
                                removeItem(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item): T;

                                /**
                                 * Tries to add the given draw2d as a child. Fails if cyclic dependencies are detected.
                                 * @param draw2D the draw2d to add
                                 * @param x the x position on this draw2d
                                 * @param y the y position on this draw2d
                                 * @param width the width of the given draw2d
                                 * @param height the height of the given draw2d
                                 * @return a wrapper for the draw2d.
                                 * @since 1.8.4
                                 */
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;

                                /**
                                 * Tries to add the given draw2d as a child. Fails if cyclic dependencies are detected.
                                 * @param draw2D the draw2d to add
                                 * @param x the x position on this draw2d
                                 * @param y the y position on this draw2d
                                 * @param width the width of the given draw2d
                                 * @param height the height of the given draw2d
                                 * @param zIndex the z-index for the draw2d
                                 * @return a wrapper for the draw2d.
                                 * @since 1.8.4
                                 */
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;

                                /**
                                 * @param draw2D the draw2d to remove
                                 * @return self chaining.
                                 * @since 1.8.4
                                 */
                                removeDraw2D(draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement): T;

                                /**
                                 * @return a builder for an {@link Item}.
                                 * @since 1.8.4
                                 */
                                itemBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item$Builder;

                                /**
                                 * @param item the item to use
                                 * @return a builder for an {@link Item}.
                                 * @since 1.8.4
                                 */
                                itemBuilder(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item$Builder;

                                /**
                                 * @return a builder for an {@link Image}.
                                 * @since 1.8.4
                                 */
                                imageBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image$Builder;

                                /**
                                 * @param id the id of the image
                                 * @return a builder for an {@link Image}.
                                 * @since 1.8.4
                                 */
                                imageBuilder(id: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image$Builder;

                                /**
                                 * @return a builder for a {@link Rect}.
                                 * @since 1.8.4
                                 */
                                rectBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect$Builder;

                                /**
                                 * @param x the x position of the rectangle
                                 * @param y the y position of the rectangle
                                 * @param width the width of the rectangle
                                 * @param height the height of the rectangle
                                 * @return a builder for a {@link Rect}.
                                 * @since 1.8.4
                                 */
                                rectBuilder(x: int, y: int, width: int, height: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect$Builder;

                                /**
                                 * @return a builder for a {@link Line}.
                                 * @since 1.8.4
                                 */
                                lineBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line$Builder;

                                /**
                                 * @param x1 the x position of the first point
                                 * @param y1 the y position of the first point
                                 * @param x2 the x position of the second point
                                 * @param y2 the y position of the second point
                                 * @return a builder for a {@link Line}.
                                 * @since 1.8.4
                                 */
                                lineBuilder(x1: int, y1: int, x2: int, y2: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line$Builder;

                                /**
                                 * @return a builder for a {@link Text}.
                                 * @since 1.8.4
                                 */
                                textBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;

                                /**
                                 * @param text the text to display
                                 * @return a builder for a {@link Text}.
                                 * @since 1.8.4
                                 */
                                textBuilder(text: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;

                                /**
                                 * @param text the text to display
                                 * @return a builder for a {@link Text}.
                                 * @since 1.8.4
                                 */
                                textBuilder(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;

                                /**
                                 * @param draw2D the draw2d to add
                                 * @return a builder for a {@link Draw2D}.
                                 * @since 1.8.4
                                 */
                                draw2DBuilder(draw2D: Draw2D): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement$Builder;

                                /**
                                 * @since 1.2.7
                                 * @param onInit calls your method as a {@link Consumer}<{@link T}>
                                 * @return self for chaining
                                 */
                                setOnInit(onInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<T, any, any, any>): T;

                                /**
                                 * @since 1.2.7
                                 * @param catchInit calls your method as a {@link Consumer}<{@link String}>
                                 * @return self for chaining
                                 */
                                setOnFailInit(catchInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any>): T;

                                /**
                                 * internal
                                 * @param matrixStack
                                 */
                                render(matrixStack: /* minecraft class */ any): void;

                                /**
                                 * @since 1.8.4
                                 * @param zIndex
                                 */
                                setZIndex(zIndex: int): void;

                                /**
                                 * @since 1.8.4
                                 * @return
                                 */
                                getZIndex(): number;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.0.5
                             * @see IDraw2D
                             */
                            const Draw2D: JavaClassStatics<Draw2D, Draw2D$$constructor>;
                            interface Draw2D$$constructor extends SuppressProperties {

                                new (): Draw2D;

                            }
                            interface Draw2D extends /* supressed minecraft class */ JavaObject, IDraw2D<Draw2D> {
                                widthSupplier: java.util.function.IntSupplier;
                                heightSupplier: java.util.function.IntSupplier;
                                zIndex: number;
                                visible: boolean;

                                /**
                                 * @since 1.0.5
                                 * @deprecated please use {@link Draw2D#setOnInit(MethodWrapper)}
                                 */
                                onInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<Draw2D, any, any, any>;

                                /**
                                 * @since 1.1.9 [citation needed]
                                 * @deprecated please use {@link Draw2D#setOnFailInit(MethodWrapper)}
                                 */
                                catchInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any>;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#getWidth()
                                 */
                                getWidth(): number;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#getHeight()
                                 */
                                getHeight(): number;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#getTexts()
                                 */
                                getTexts(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text>;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#getRects()
                                 */
                                getRects(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect>;
                                getLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line>;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#getItems()
                                 */
                                getItems(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item>;

                                /**
                                 * @since 1.2.3
                                 * @see IDraw2D#getImages()
                                 */
                                getImages(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image>;
                                getDraw2Ds(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement>;
                                getElements(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>;
                                removeElement(e: xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement): Draw2D;
                                reAddElement<T extends xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>(e: T): T;

                                /**
                                 * @param visible whether to render this element.
                                 * @return self for chaining.
                                 * @since 1.8.4
                                 */
                                setVisible(visible: boolean): Draw2D;

                                /**
                                 * @return {@code true} if this draw2d is visible, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isVisible(): boolean;
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;
                                addDraw2D(draw2D: Draw2D, x: int, y: int, width: int, height: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;
                                removeDraw2D(draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement): Draw2D;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#addText(String, int, int, int, boolean)
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.2.6
                                 * @see IDraw2D#addText(String, int, int, int, boolean, double, double)
                                 */
                                addText(text: string, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
                                addText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#removeText(Text)
                                 */
                                removeText(t: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text): Draw2D;

                                /**
                                 * @since 1.2.3
                                 * @see IDraw2D#addImage(int, int, int, int, String, int, int, int, int, int, int)
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.2.6
                                 * @see IDraw2D#addImage(int, int, int, int, String, int, int, int, int, int, int, double)
                                 */
                                addImage(x: int, y: int, width: int, height: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.4.0
                                 * @see IDraw2D#addImage(int, int, int, int, int, String, int, int, int, int, int, int, double)
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.6.5
                                 * @see IDraw2D#addImage(int, int, int, int, int, int, String, int, int, int, int, int, int, double)
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.6.5
                                 * @see IDraw2D#addImage(int, int, int, int, int, int, int, String, int, int, int, int, int, int, double)
                                 */
                                addImage(x: int, y: int, width: int, height: int, zIndex: int, alpha: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;

                                /**
                                 * @since 1.2.3
                                 * @see IDraw2D#removeImage(Image)
                                 */
                                removeImage(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image): Draw2D;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#addRect(int, int, int, int, int)
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.1.8
                                 * @see IDraw2D#addRect(int, int, int, int, int, int)
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.2.6
                                 * @see IDraw2D#addRect(int, int, int, int, int, int, double)
                                 */
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;
                                addRect(x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: double, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#removeRect(Rect)
                                 */
                                removeRect(r: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect): Draw2D;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                addLine(x1: int, y1: int, x2: int, y2: int, color: int, zIndex: int, width: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
                                removeLine(l: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line): Draw2D;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#addItem(int, int, String)
                                 */
                                addItem(x: int, y: int, id: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, id: string): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.0
                                 * @see IDraw2D#addItem(int, int, String, boolean)
                                 */
                                addItem(x: int, y: int, id: string, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, id: string, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.0
                                 * @see IDraw2D#addItem(int, int, String, boolean, double, double)
                                 */
                                addItem(x: int, y: int, id: string, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, id: string, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#addItem(int, int, ItemStackHelper)
                                 */
                                addItem(x: int, y: int, Item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.0
                                 * @see IDraw2D#addItem(int, int, ItemStackHelper, boolean)
                                 */
                                addItem(x: int, y: int, Item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.2.6
                                 * @see IDraw2D#addItem(int, int, ItemStackHelper, boolean, double, double)
                                 */
                                addItem(x: int, y: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
                                addItem(x: int, y: int, zIndex: int, item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;

                                /**
                                 * @since 1.0.5
                                 * @see IDraw2D#removeItem(Item)
                                 */
                                removeItem(i: xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item): Draw2D;
                                init(): void;
                                render(matrixStack: /* minecraft class */ any): void;
                                getElementsByZIndex(): java.util.Iterator<xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement>;

                                /**
                                 * init function, called when window is resized or screen/draw2d is registered.  
                                 *  clears all previous elements when called.
                                 * @since 1.2.7
                                 * @see IDraw2D#setOnInit(MethodWrapper)
                                 * @param onInit calls your method as a {@link java.util.function.Consumer Consumer}<{@link Draw2D}>
                                 */
                                setOnInit(onInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<Draw2D, any, any, any>): Draw2D;

                                /**
                                 * @since 1.2.7
                                 * @see IDraw2D#setOnFailInit(MethodWrapper)
                                 * @param catchInit calls your method as a {@link java.util.function.Consumer Consumer}<{@link java.lang.String String}>
                                 */
                                setOnFailInit(catchInit: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, any, any, any>): Draw2D;

                                /**
                                 * register so the overlay actually renders
                                 * @since 1.6.5
                                 * @return self for chaining
                                 */
                                register(): Draw2D;

                                /**
                                 * unregister so the overlay stops rendering
                                 * @since 1.6.5
                                 * @return self for chaining
                                 */
                                unregister(): Draw2D;
                                setZIndex(zIndex: int): void;
                                getZIndex(): number;

                            }

                            /**
                             * {@link Draw2D} is cool
                             * @author Wagyourtail
                             * @since 1.0.6
                             */
                            const Draw3D: JavaClassStatics<Draw3D, Draw3D$$constructor>;
                            interface Draw3D$$constructor extends SuppressProperties {

                                new (): Draw3D;

                            }
                            interface Draw3D extends JavaObject {

                                /**
                                 * @return 
                                 * @since 1.0.6
                                 */
                                getBoxes(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box>;

                                /**
                                 * @return 
                                 * @since 1.0.6
                                 */
                                getLines(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D>;

                                /**
                                 * @return 
                                 * @since 1.6.5
                                 */
                                getDraw2Ds(): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface>;

                                /**
                                 * @param box
                                 * @since 1.8.4
                                 */
                                addBox(box: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box): void;

                                /**
                                 * @param line
                                 * @since 1.8.4
                                 */
                                addLine(line: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D): void;

                                /**
                                 * @param surface
                                 * @since 1.8.4
                                 */
                                addSurface(surface: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface): void;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @param fillColor
                                 * @param fill
                                 * @return The {@link Box} you added.
                                 * @since 1.0.6
                                 */
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, fillColor: int, fill: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @param fillColor
                                 * @param fill
                                 * @param cull
                                 * @return 
                                 * @since 1.3.1
                                 */
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, fillColor: int, fill: boolean, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @param alpha
                                 * @param fillColor
                                 * @param fillAlpha
                                 * @param fill
                                 * @return the {@link Box} you added.
                                 * @since 1.1.8
                                 */
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, fillColor: int, fillAlpha: int, fill: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;
                                addBox(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, fillColor: int, fillAlpha: int, fill: boolean, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * @param b
                                 * @return 
                                 * @since 1.0.6
                                 */
                                removeBox(b: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box): Draw3D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @return the {@link Line3D} you added.
                                 * @since 1.0.6
                                 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @param cull
                                 * @return 
                                 * @since 1.3.1
                                 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @param alpha
                                 * @return the {@link Line3D} you added.
                                 * @since 1.1.8
                                 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @param color
                                 * @param alpha
                                 * @param cull
                                 * @return 
                                 * @since 1.3.1
                                 */
                                addLine(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;

                                /**
                                 * @param l
                                 * @return 
                                 * @since 1.0.6
                                 */
                                removeLine(l: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D): Draw3D;

                                /**
                                 * Draws a cube({@link Box}) with a specific radius(`side length = 2*radius`)
                                 * @param point the center point
                                 * @param radius 1/2 of the side length of the cube
                                 * @param color point color
                                 * @return the {@link Box} generated, and visualized
                                 * @see Box
                                 * @since 1.4.0
                                 */
                                addPoint(point: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, radius: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * Draws a cube({@link Box}) with a specific radius(`side length = 2*radius`)
                                 * @param x x value of the center point
                                 * @param y y value of the center point
                                 * @param z z value of the center point
                                 * @param radius 1/2 of the side length of the cube
                                 * @param color point color
                                 * @return the {@link Box} generated, and visualized
                                 * @see Box
                                 * @since 1.4.0
                                 */
                                addPoint(x: double, y: double, z: double, radius: double, color: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * Draws a cube({@link Box}) with a specific radius(`side length = 2*radius`)
                                 * @param x x value of the center point
                                 * @param y y value of the center point
                                 * @param z z value of the center point
                                 * @param radius 1/2 of the side length of the cube
                                 * @param color point color
                                 * @param alpha alpha of the point
                                 * @param cull whether to cull the point or not
                                 * @return the {@link Box} generated, and visualized
                                 * @see Box
                                 * @since 1.4.0
                                 */
                                addPoint(x: double, y: double, z: double, radius: double, color: int, alpha: int, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;

                                /**
                                 * @param x top left
                                 * @param y
                                 * @param z
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @param width
                                 * @param height
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double, width: double, height: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @param xRot
                                 * @param yRot
                                 * @param zRot
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @param xRot
                                 * @param yRot
                                 * @param zRot
                                 * @param width
                                 * @param height
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @param xRot
                                 * @param yRot
                                 * @param zRot
                                 * @param width
                                 * @param height
                                 * @param minSubdivisions
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double, minSubdivisions: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @param xRot
                                 * @param yRot
                                 * @param zRot
                                 * @param width
                                 * @param height
                                 * @param minSubdivisions
                                 * @param renderBack
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double, minSubdivisions: int, renderBack: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;

                                /**
                                 * @param x top left
                                 * @param y
                                 * @param z
                                 * @param xRot
                                 * @param yRot
                                 * @param zRot
                                 * @param width
                                 * @param height
                                 * @param minSubdivisions
                                 * @param renderBack
                                 * @since 1.6.5
                                 * @return
                                 */
                                addDraw2D(x: double, y: double, z: double, xRot: double, yRot: double, zRot: double, width: double, height: double, minSubdivisions: int, renderBack: boolean, cull: boolean): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
                                /** @since 1.6.5 */
                                removeDraw2D(surface: xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface): void;

                                /**
                                 * @return a new {@link Box.Builder} instance.
                                 * @since 1.8.4
                                 */
                                boxBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;

                                /**
                                 * @param pos the block position of the box
                                 * @return a new {@link Box.Builder} instance.
                                 * @since 1.8.4
                                 */
                                boxBuilder(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;

                                /**
                                 * @param x the x coordinate of the box
                                 * @param y the y coordinate of the box
                                 * @param z the z coordinate of the box
                                 * @return a new {@link Box.Builder} instance.
                                 * @since 1.8.4
                                 */
                                boxBuilder(x: int, y: int, z: int): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;

                                /**
                                 * @return a new {@link Line3D.Builder} instance.
                                 * @since 1.8.4
                                 */
                                lineBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D$Builder;

                                /**
                                 * @return a new {@link Surface.Builder} instance.
                                 * @since 1.8.4
                                 */
                                surfaceBuilder(): xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface$Builder;

                                /**
                                 * register so it actually shows up
                                 * @return self for chaining
                                 * @since 1.6.5
                                 */
                                register(): Draw3D;

                                /**
                                 * @return self for chaining
                                 * @since 1.6.5
                                 */
                                unregister(): Draw3D;
                                render(matrixStack: /* minecraft class */ any, tickDelta: float): void;

                            }

                            /**
                             * just go look at {@link IScreen}
                             *  since all the methods are done through a mixin...
                             * @author Wagyourtail
                             * @since 1.0.5
                             * @see IScreen
                             */
                            const ScriptScreen: JavaClassStatics<ScriptScreen, ScriptScreen$$constructor>;
                            interface ScriptScreen$$constructor extends SuppressProperties {

                                new (title: string, dirt: boolean): ScriptScreen;

                            }
                            interface ScriptScreen extends xyz.wagyourtail.wagyourgui.BaseScreen {
                                drawTitle: boolean;

                                /**
                                 * @since 1.8.4
                                 *  WARNING: this can break the game if you set it false and don't have a way to close the screen.
                                 */
                                shouldCloseOnEsc: boolean;
                                /** @since 1.8.4 */
                                shouldPause: boolean;

                                /**
                                 * @param parent parent screen to go to when this one exits.
                                 * @since 1.4.0
                                 */
                                setParent(parent: IScreen): void;
                                setParent(parent: /* minecraft class */ any): void;

                                /**
                                 * add custom stuff to the render function on the main thread.
                                 * @param onRender pos3d elements are mousex, mousey, tickDelta
                                 * @since 1.4.0
                                 */
                                setOnRender(onRender: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, /* minecraft class */ any, any, any>): void;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.2.7
                             */
                            const IScreen: JavaInterfaceStatics<IScreen>;
                            interface IScreen extends IDraw2D<IScreen> {

                                /**
                                 * @since 1.2.7
                                 * @return
                                 */
                                getScreenClassName(): string;

                                /**
                                 * @since 1.0.5
                                 * @return
                                 */
                                getTitleText(): string;

                                /**
                                 * in `1.3.1` updated to work with all button widgets not just ones added by scripts.
                                 * @since 1.0.5
                                 * @return
                                 */
                                getButtonWidgets(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>>;

                                /**
                                 * in `1.3.1` updated to work with all text fields not just ones added by scripts.
                                 * @since 1.0.5
                                 * @return
                                 */
                                getTextFields(): JavaList<xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper>;

                                /**
                                 * @since 1.0.5
                                 * @param x
                                 * @param y
                                 * @param width
                                 * @param height
                                 * @param text
                                 * @param callback calls your method as a {@link Consumer}<{@link ClickableWidgetHelper}>
                                 * @return
                                 */
                                addButton(x: int, y: int, width: int, height: int, text: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>;

                                /**
                                 * @since 1.4.0
                                 * @param x
                                 * @param y
                                 * @param width
                                 * @param height
                                 * @param zIndex
                                 * @param text
                                 * @param callback calls your method as a {@link Consumer}<{@link ClickableWidgetHelper}>
                                 * @return
                                 */
                                addButton(x: int, y: int, width: int, height: int, zIndex: int, text: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param showMessage whether to show the message or not
                                 * @param callback calls your method as a
                                 *                     {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, text: string, checked: boolean, showMessage: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param callback calls your method as a {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, text: string, checked: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param zIndex the z-index of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param callback calls your method as a {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, zIndex: int, text: string, checked: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the checkbox
                                 * @param y the y position of the checkbox
                                 * @param width the width of the checkbox
                                 * @param height the height of the checkbox
                                 * @param zIndex the z-index of the checkbox
                                 * @param text the text to display next to the checkbox
                                 * @param checked whether the checkbox is checked or not
                                 * @param showMessage whether to show the message or not
                                 * @param callback calls your method as a
                                 *                     {@link Consumer}<{@link CheckBoxWidgetHelper}>
                                 * @return a {@link CheckBoxWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCheckbox(x: int, y: int, width: int, height: int, zIndex: int, text: string, checked: boolean, showMessage: boolean, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @param steps the number of steps the slider should have
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, text: string, value: double, steps: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param zIndex the z-index of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @param steps the number of steps the slider should have
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, zIndex: int, text: string, value: double, steps: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, text: string, value: double, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the slider
                                 * @param y the y position of the slider
                                 * @param width the width of the slider
                                 * @param height the height of the slider
                                 * @param zIndex the z-index of the slider
                                 * @param text the text to be displayed inside the slider
                                 * @param value the initial value of the slider
                                 * @param callback calls your method as a {@link Consumer}<{@link SliderWidgetHelper}>
                                 * @return a {@link SliderWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addSlider(x: int, y: int, width: int, height: int, zIndex: int, text: string, value: double, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;

                                /**
                                 * @param x the x position of the textured button
                                 * @param y the y position of the textured button
                                 * @param width the width of the textured button
                                 * @param height the height of the textured button
                                 * @param textureStartX the x position in the texture to start drawing from
                                 * @param textureStartY the y position in the texture to start drawing from
                                 * @param hoverOffset the offset to add to the textureStartY when the button is hovered
                                 * @param texture the identifier of the texture to use
                                 * @param textureWidth the width of the texture
                                 * @param textureHeight the height of the texture
                                 * @param callback calls your method as a
                                 *                       {@link Consumer}<{@link ButtonWidgetHelper}>
                                 * @return a {@link ButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addTexturedButton(x: int, y: int, width: int, height: int, textureStartX: int, textureStartY: int, hoverOffset: int, texture: string, textureWidth: int, textureHeight: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>;

                                /**
                                 * @param x the x position of the textured button
                                 * @param y the y position of the textured button
                                 * @param width the width of the textured button
                                 * @param height the height of the textured button
                                 * @param zIndex the z-index of the textured button
                                 * @param textureStartX the x position in the texture to start drawing from
                                 * @param textureStartY the y position in the texture to start drawing from
                                 * @param hoverOffset the offset to add to the textureStartY when the button is hovered
                                 * @param texture the identifier of the texture to use
                                 * @param textureWidth the width of the texture
                                 * @param textureHeight the height of the texture
                                 * @param callback calls your method as a
                                 *                       {@link Consumer}<{@link ButtonWidgetHelper}>
                                 * @return a {@link ButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addTexturedButton(x: int, y: int, width: int, height: int, zIndex: int, textureStartX: int, textureStartY: int, hoverOffset: int, texture: string, textureWidth: int, textureHeight: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>;

                                /**
                                 * @param x the x position of the textured button
                                 * @param y the y position of the textured button
                                 * @param width the width of the textured button
                                 * @param height the height of the textured button
                                 * @param textureStartX the x position in the texture to start drawing from
                                 * @param textureStartY the y position in the texture to start drawing from
                                 * @param texture the identifier of the texture to use
                                 * @param callback calls your method as a
                                 *                       {@link Consumer}<{@link ButtonWidgetHelper}>
                                 * @return a {@link ButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addTexturedButton(x: int, y: int, width: int, height: int, textureStartX: int, textureStartY: int, texture: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>;

                                /**
                                 * @param x the x position of the textured button
                                 * @param y the y position of the textured button
                                 * @param width the width of the textured button
                                 * @param height the height of the textured button
                                 * @param zIndex the z-index of the textured button
                                 * @param textureStartX the x position in the texture to start drawing from
                                 * @param textureStartY the y position in the texture to start drawing from
                                 * @param texture the identifier of the texture to use
                                 * @param callback calls your method as a
                                 *                       {@link Consumer}<{@link ButtonWidgetHelper}>
                                 * @return a {@link ButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addTexturedButton(x: int, y: int, width: int, height: int, zIndex: int, textureStartX: int, textureStartY: int, texture: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper</* minecraft class */ any>;

                                /**
                                 * @param x the x position of the lock button
                                 * @param y the y position of the lock button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link LockButtonWidgetHelper}>
                                 * @return {@link LockButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addLockButton(x: int, y: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper;

                                /**
                                 * @param x the x position of the lock button
                                 * @param y the y position of the lock button
                                 * @param zIndex the z-index of the lock button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link LockButtonWidgetHelper}>
                                 * @return {@link LockButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addLockButton(x: int, y: int, zIndex: int, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param initial the initial value of the cycling button
                                 * @return {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, values: string[], initial: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param zIndex the z-index of the cycling button
                                 * @param callback calls your method as a
                                 *                  {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param initial the initial value of the cycling button
                                 * @return {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, zIndex: int, values: string[], initial: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param zIndex the z-index of the cycling button
                                 * @param callback calls your method as a
                                 *                      {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param alternatives the alternative values to cycle through
                                 * @param prefix the prefix of the values
                                 * @param initial the initial value of the cycling button
                                 * @return {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, zIndex: int, values: string[], alternatives: string[], initial: string, prefix: string, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @param x the x position of the cylcing button
                                 * @param y the y position of the cylcing button
                                 * @param width the width of the cylcing button
                                 * @param height the height of the cycling button
                                 * @param zIndex the z-index of the cycling button
                                 * @param callback calls your method as a
                                 *                         {@link Consumer}<{@link CyclingButtonWidgetHelper}>
                                 * @param values the values to cycle through
                                 * @param alternatives the alternative values to cycle through
                                 * @param prefix the prefix of the values
                                 * @param initial the initial value of the cycling button
                                 * @param alternateToggle the method to determine if the cycling button should use the
                                 *                         alternative values
                                 * @return {@link CyclingButtonWidgetHelper} for the given input.
                                 * @since 1.8.4
                                 */
                                addCyclingButton(x: int, y: int, width: int, height: int, zIndex: int, values: string[], alternatives: string[], initial: string, prefix: string, alternateToggle: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, boolean, any>, callback: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<any>;

                                /**
                                 * @since 1.0.5
                                 * @param btn
                                 * @return
                                 * @deprecated
                                 */
                                removeButton(btn: xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<any, any>): IScreen;

                                /**
                                 * @since 1.0.5
                                 * @param x
                                 * @param y
                                 * @param width
                                 * @param height
                                 * @param message
                                 * @param onChange calls your method as a {@link Consumer}<{@link String}>
                                 * @return
                                 */
                                addTextInput(x: int, y: int, width: int, height: int, message: string, onChange: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper;

                                /**
                                 * @since 1.0.5
                                 * @param x
                                 * @param y
                                 * @param width
                                 * @param height
                                 * @param zIndex
                                 * @param message
                                 * @param onChange calls your method as a {@link Consumer}<{@link String}>
                                 * @return
                                 */
                                addTextInput(x: int, y: int, width: int, height: int, zIndex: int, message: string, onChange: xyz.wagyourtail.jsmacros.core.MethodWrapper<string, IScreen, any, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper;

                                /**
                                 * @since 1.0.5
                                 * @param inp
                                 * @return
                                 * @deprecated
                                 */
                                removeTextInput(inp: xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper): IScreen;

                                /**
                                 * @since 1.2.7
                                 * @param onMouseDown calls your method as a {@link BiConsumer}<{@link Pos2D}, {@link Integer}>
                                 * @return
                                 */
                                setOnMouseDown(onMouseDown: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, int, any, any>): IScreen;

                                /**
                                 * @since 1.2.7
                                 * @param onMouseDrag calls your method as a {@link BiConsumer}<{@link Vec2D}, {@link Integer}>
                                 * @return
                                 */
                                setOnMouseDrag(onMouseDrag: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Vec2D, int, any, any>): IScreen;

                                /**
                                 * @since 1.2.7
                                 * @param onMouseUp calls your method as a {@link BiConsumer}<{@link Pos2D}, {@link Integer}>
                                 * @return
                                 */
                                setOnMouseUp(onMouseUp: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, int, any, any>): IScreen;

                                /**
                                 * @since 1.2.7
                                 * @param onScroll calls your method as a {@link BiConsumer}<{@link Pos2D}, {@link Double}>
                                 * @return
                                 */
                                setOnScroll(onScroll: xyz.wagyourtail.jsmacros.core.MethodWrapper<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, double, any, any>): IScreen;

                                /**
                                 * @since 1.2.7
                                 * @param onKeyPressed calls your method as a {@link BiConsumer}<{@link Integer}, {@link Integer}>
                                 * @return
                                 */
                                setOnKeyPressed(onKeyPressed: xyz.wagyourtail.jsmacros.core.MethodWrapper<int, int, any, any>): IScreen;

                                /**
                                 * @since 1.8.4
                                 * @param onCharTyped calls your method as a {@link BiConsumer}<{@link Character}, {@link Integer}>
                                 * @return
                                 */
                                setOnCharTyped(onCharTyped: xyz.wagyourtail.jsmacros.core.MethodWrapper<char, int, any, any>): IScreen;

                                /**
                                 * @since 1.2.7
                                 * @param onClose calls your method as a {@link Consumer}<{@link IScreen}>
                                 * @return
                                 */
                                setOnClose(onClose: xyz.wagyourtail.jsmacros.core.MethodWrapper<IScreen, any, any, any>): IScreen;
                                /** @since 1.1.9 */
                                close(): void;

                                /**
                                 * calls the screen's init function re-loading it.
                                 * @since 1.2.7
                                 */
                                reloadScreen(): IScreen;

                                /**
                                 * @return a new builder for buttons.
                                 * @since 1.8.4
                                 */
                                buttonBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$ButtonBuilder;

                                /**
                                 * @return a new builder for checkboxes.
                                 * @since 1.8.4
                                 */
                                checkBoxBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper$CheckBoxBuilder;

                                /**
                                 * @param checked whether the checkbox should be checked by default
                                 * @return a new builder for checkboxes.
                                 * @since 1.8.4
                                 */
                                checkBoxBuilder(checked: boolean): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper$CheckBoxBuilder;

                                /**
                                 * @return a new builder for cycling buttons.
                                 * @since 1.8.4
                                 */
                                cyclicButtonBuilder(valueToText: xyz.wagyourtail.jsmacros.core.MethodWrapper<any, any, xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, any>): xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper$CyclicButtonBuilder<any>;

                                /**
                                 * @return a new builder for lock buttons.
                                 * @since 1.8.4
                                 */
                                lockButtonBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper$LockButtonBuilder;

                                /**
                                 * @param locked whether the lock button should be locked by default
                                 * @return a new builder for lock buttons.
                                 * @since 1.8.4
                                 */
                                lockButtonBuilder(locked: boolean): xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper$LockButtonBuilder;

                                /**
                                 * @return a new builder for sliders.
                                 * @since 1.8.4
                                 */
                                sliderBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper$SliderBuilder;

                                /**
                                 * @return a new builder for text fields.
                                 * @since 1.8.4
                                 */
                                textFieldBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper$TextFieldBuilder;

                                /**
                                 * @return a new builder for textured buttons.
                                 * @since 1.8.4
                                 */
                                texturedButtonBuilder(): xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$TexturedButtonBuilder;

                                /**
                                 * @return {@code true} if the shift key is pressed, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isShiftDown(): boolean;

                                /**
                                 * @return {@code true} if the ctrl key is pressed, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isCtrlDown(): boolean;

                                /**
                                 * @return {@code true} if the alt key is pressed, {@code false} otherwise.
                                 * @since 1.8.4
                                 */
                                isAltDown(): boolean;
                                getOnClose(): xyz.wagyourtail.jsmacros.core.MethodWrapper<IScreen, any, any, any>;

                            }

                            export { IDraw2D, Draw2D, Draw3D, ScriptScreen, IScreen }

                        }
                        namespace render {

                            namespace components {

                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.5
                                 */
                                const Text: JavaClassStatics<Text, Text$$constructor>;
                                interface Text$$constructor extends SuppressProperties {

                                    new (text: string, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: float): Text;
                                    new (text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper, x: int, y: int, color: int, zIndex: int, shadow: boolean, scale: double, rotation: float): Text;

                                }
                                interface Text extends RenderElement, Alignable<Text> {
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>;
                                    text: /* minecraft class */ any;
                                    scale: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x: number;
                                    y: number;
                                    color: number;
                                    width: number;
                                    shadow: boolean;
                                    zIndex: number;

                                    /**
                                     * @param x the new x position for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): Text;

                                    /**
                                     * @return the x position of this element.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the new y position for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): Text;

                                    /**
                                     * @return the y position of this element.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x
                                     * @param y
                                     * @return 
                                     * @since 1.0.5
                                     */
                                    setPos(x: int, y: int): Text;

                                    /**
                                     * @param text
                                     * @return 
                                     * @since 1.0.5
                                     */
                                    setText(text: string): Text;

                                    /**
                                     * @param text
                                     * @return 
                                     * @since 1.2.7
                                     */
                                    setText(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): Text;

                                    /**
                                     * @return 
                                     * @since 1.2.7
                                     */
                                    getText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                    /**
                                     * @return 
                                     * @since 1.0.5
                                     */
                                    getWidth(): number;

                                    /**
                                     * @return the height of this text.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param shadow whether the text should be rendered with a shadow
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setShadow(shadow: boolean): Text;

                                    /**
                                     * @return {@code true} if this text element is rendered with a shadow, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    hasShadow(): boolean;

                                    /**
                                     * @param scale
                                     * @return 
                                     * @throws IllegalArgumentException
                                     * @since 1.0.5
                                     */
                                    setScale(scale: double): Text;

                                    /**
                                     * @return the scale of this text.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation
                                     * @return 
                                     * @since 1.0.5
                                     */
                                    setRotation(rotation: double): Text;

                                    /**
                                     * @return the rotation of this text.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this text should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Text;

                                    /**
                                     * @return {@code true} if this text should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param color the new color for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setColor(color: int): Text;

                                    /**
                                     * @return the color of this text.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param zIndex the new z-index for this text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): Text;
                                    getZIndex(): number;
                                    render3D(matrices: /* minecraft class */ any, mouseX: int, mouseY: int, delta: float): void;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Text;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Text;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Item$Builder: JavaClassStatics<Item$Builder, Item$Builder$$constructor>;
                                interface Item$Builder$$constructor extends SuppressProperties {

                                    new (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Item$Builder;

                                }
                                interface Item$Builder extends RenderElementBuilder<Item>, Alignable<Item$Builder> {

                                    /**
                                     * @param x the x position of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): Item$Builder;

                                    /**
                                     * @return the x position of the item.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): Item$Builder;

                                    /**
                                     * @return the y position of the item.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the item
                                     * @param y the y position of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): Item$Builder;

                                    /**
                                     * @param item the item to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    item(item: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): Item$Builder;

                                    /**
                                     * @param id the id of the item to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    item(id: ItemId): Item$Builder;

                                    /**
                                     * @param id the id of the item to draw
                                     * @param count the stack size
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    item(id: ItemId, count: int): Item$Builder;

                                    /**
                                     * @return the item to be drawn.
                                     * @since 1.8.4
                                     */
                                    getItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * This also sets the overlay to be shown.
                                     * @param overlayText the overlay text
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    overlayText(overlayText: string): Item$Builder;

                                    /**
                                     * @return the overlay text.
                                     * @since 1.8.4
                                     */
                                    getOverlayText(): string;

                                    /**
                                     * @param visible whether the overlay should be visible or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    overlayVisible(visible: boolean): Item$Builder;

                                    /**
                                     * @return {@code true} if the overlay should be visible, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isOverlayVisible(): boolean;

                                    /**
                                     * @param scale the scale of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    scale(scale: double): Item$Builder;

                                    /**
                                     * @return the scale of the item.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the item in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): Item$Builder;

                                    /**
                                     * @return the rotation (clockwise) of the item in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the item should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Item$Builder;

                                    /**
                                     * @return {@code true} if this item should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of the item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): Item$Builder;

                                    /**
                                     * @return the z-index of the item.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Item$Builder;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Text$Builder: JavaClassStatics<Text$Builder, Text$Builder$$constructor>;
                                interface Text$Builder$$constructor extends SuppressProperties {

                                    new (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Text$Builder;

                                }
                                interface Text$Builder extends RenderElementBuilder<Text>, Alignable<Text$Builder> {

                                    /**
                                     * @param text the content of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    text(text: xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper): Text$Builder;

                                    /**
                                     * @param text the content of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    text(text: xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder): Text$Builder;

                                    /**
                                     * @param text the content of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    text(text: string): Text$Builder;

                                    /**
                                     * @return the content of the text element.
                                     * @since 1.8.4
                                     */
                                    getText(): xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;

                                    /**
                                     * @param x the x position of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): Text$Builder;

                                    /**
                                     * @return the x position of the text element.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): Text$Builder;

                                    /**
                                     * @return the y position of the text element.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the text element
                                     * @param y the y position of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): Text$Builder;

                                    /**
                                     * @return the width of the string.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @return the height of the string.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param color the color of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): Text$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): Text$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): Text$Builder;

                                    /**
                                     * @return the color of the text element.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param scale the scale of the text element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    scale(scale: double): Text$Builder;

                                    /**
                                     * @return the scale of the text element.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the text element in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): Text$Builder;

                                    /**
                                     * @return the rotation (clockwise) of the text element in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this text should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Text$Builder;

                                    /**
                                     * @return {@code true} if this text should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param shadow whether the text should have a shadow or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    shadow(shadow: boolean): Text$Builder;

                                    /**
                                     * @return {@code true} if the text element has a shadow, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    hasShadow(): boolean;

                                    /**
                                     * @param zIndex the z-index of the text element
                                     * @return self for chaining.
                                     */
                                    zIndex(zIndex: int): Text$Builder;

                                    /**
                                     * @return the z-index of the text element.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    createElement(): Text;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Text$Builder;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Draw2DElement: JavaClassStatics<Draw2DElement, Draw2DElement$$constructor>;
                                interface Draw2DElement$$constructor extends SuppressProperties {

                                    new (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D, x: int, y: int, width: java.util.function.IntSupplier, height: java.util.function.IntSupplier, zIndex: int, scale: float, rotation: float): Draw2DElement;

                                }
                                interface Draw2DElement extends RenderElement, Alignable<Draw2DElement> {
                                    readonly draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>;
                                    x: number;
                                    y: number;
                                    width: java.util.function.IntSupplier;
                                    height: java.util.function.IntSupplier;
                                    scale: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    zIndex: number;

                                    /**
                                     * @return the internal draw2D this draw2D element is wrapping.
                                     * @since 1.8.4
                                     */
                                    getDraw2D(): xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;

                                    /**
                                     * @param x the x position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): Draw2DElement;

                                    /**
                                     * @return the x position of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): Draw2DElement;

                                    /**
                                     * @return the y position of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position
                                     * @param y the y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(x: int, y: int): Draw2DElement;

                                    /**
                                     * @param width the width
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: int): Draw2DElement;

                                    /**
                                     * @return the width of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setHeight(height: int): Draw2DElement;

                                    /**
                                     * @return the height of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width
                                     * @param height the height
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setSize(width: int, height: int): Draw2DElement;

                                    /**
                                     * @param scale the scale
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setScale(scale: double): Draw2DElement;

                                    /**
                                     * @return the scale of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotation(rotation: double): Draw2DElement;

                                    /**
                                     * @return the rotation of this draw2D.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this draw2D should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Draw2DElement;

                                    /**
                                     * @return {@code true} if this draw2D should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of this draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): Draw2DElement;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Draw2DElement;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Draw2DElement;

                                }

                                /**
                                 * @author Wagyourtail
                                 */
                                const RenderElement: JavaInterfaceStatics<RenderElement> & {
                                    readonly mc: /* minecraft class */ any;
                                }
                                interface RenderElement extends JavaObject {

                                    getZIndex(): number;
                                    render3D(matrices: /* minecraft class */ any, mouseX: int, mouseY: int, delta: float): void;
                                    setupMatrix(matrices: /* minecraft class */ any, x: double, y: double, scale: float, rotation: float): void;
                                    setupMatrix(matrices: /* minecraft class */ any, x: double, y: double, scale: float, rotation: float, width: double, height: double, rotateAroundCenter: boolean): void;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Draw2DElement$Builder: JavaClassStatics<Draw2DElement$Builder, Draw2DElement$Builder$$constructor>;
                                interface Draw2DElement$Builder$$constructor extends SuppressProperties {

                                    new (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>, draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D): Draw2DElement$Builder;

                                }
                                interface Draw2DElement$Builder extends RenderElementBuilder<Draw2DElement>, Alignable<Draw2DElement$Builder> {

                                    /**
                                     * @param x the x position of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): Draw2DElement$Builder;

                                    /**
                                     * @return the x position of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): Draw2DElement$Builder;

                                    /**
                                     * @return the y position of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the draw2D
                                     * @param y the y position of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): Draw2DElement$Builder;

                                    /**
                                     * @param width the width of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: int): Draw2DElement$Builder;

                                    /**
                                     * @return the width of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: int): Draw2DElement$Builder;

                                    /**
                                     * @return the height of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the draw2D
                                     * @param height the height of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: int, height: int): Draw2DElement$Builder;

                                    /**
                                     * @param scale the scale of the draw2D
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    scale(scale: double): Draw2DElement$Builder;

                                    /**
                                     * @return the scale of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the draw2D in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): Draw2DElement$Builder;

                                    /**
                                     * @return the rotation (clockwise) of the draw2D in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this draw2D should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Draw2DElement$Builder;

                                    /**
                                     * @return {@code true} if this draw2D should be rotated around its center,
                                     *      {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @return the z-index of the draw2D.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): Draw2DElement$Builder;

                                    /**
                                     * @return the z-index of the draw2D.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Draw2DElement$Builder;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Image$Builder: JavaClassStatics<Image$Builder, Image$Builder$$constructor>;
                                interface Image$Builder$$constructor extends SuppressProperties {

                                    new (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Image$Builder;

                                }
                                interface Image$Builder extends RenderElementBuilder<Image>, Alignable<Image$Builder> {

                                    /**
                                     * Will automatically set all attributes to the default values of the custom image.  
                                     *  Values set before the call of this method will be overwritten.
                                     * @param customImage the custom image to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fromCustomImage(customImage: xyz.wagyourtail.jsmacros.client.api.classes.CustomImage): Image$Builder;

                                    /**
                                     * @param identifier the identifier of the image to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    identifier(identifier: string): Image$Builder;

                                    /**
                                     * @return the identifier of the used image or {@code null} if no image is used.
                                     * @since 1.8.4
                                     */
                                    getIdentifier(): string;

                                    /**
                                     * @param x the x position of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x(x: int): Image$Builder;

                                    /**
                                     * @return the x position of the image.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the y position of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y(y: int): Image$Builder;

                                    /**
                                     * @return the y position of the image.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the x position of the image
                                     * @param y the y position of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: int, y: int): Image$Builder;

                                    /**
                                     * @param width the width of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: int): Image$Builder;

                                    /**
                                     * @return the width of the image.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: int): Image$Builder;

                                    /**
                                     * @return the height of the image.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the image
                                     * @param height the height of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: int, height: int): Image$Builder;

                                    /**
                                     * @param imageX the x position in the image texture to start drawing from
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    imageX(imageX: int): Image$Builder;

                                    /**
                                     * @return the x position in the image texture to start drawing from.
                                     * @since 1.8.4
                                     */
                                    getImageX(): number;

                                    /**
                                     * @param imageY the y position in the image texture to start drawing from
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    imageY(imageY: int): Image$Builder;

                                    /**
                                     * @return the y position in the image texture to start drawing from.
                                     * @since 1.8.4
                                     */
                                    getImageY(): number;

                                    /**
                                     * @param imageX the x position in the image texture to start drawing from
                                     * @param imageY the y position in the image texture to start drawing from
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    imagePos(imageX: int, imageY: int): Image$Builder;

                                    /**
                                     * @param regionWidth the width of the region to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    regionWidth(regionWidth: int): Image$Builder;

                                    /**
                                     * @return the width of the region to draw.
                                     * @since 1.8.4
                                     */
                                    getRegionWidth(): number;

                                    /**
                                     * @param regionHeight the height of the region to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    regionHeight(regionHeight: int): Image$Builder;

                                    /**
                                     * @return the height of the region to draw.
                                     * @since 1.8.4
                                     */
                                    getRegionHeight(): number;

                                    /**
                                     * @param regionWidth the width of the region to draw
                                     * @param regionHeight the height of the region to draw
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    regionSize(regionWidth: int, regionHeight: int): Image$Builder;

                                    /**
                                     * @param x the x position in the image texture to start drawing from
                                     * @param y the y position in the image texture to start drawing from
                                     * @param width the width of the region to draw
                                     * @param height the height of the region to draw
                                     * @return 
                                     * @since 1.8.4
                                     */
                                    regions(x: int, y: int, width: int, height: int): Image$Builder;

                                    /**
                                     * @param x the x position in the image texture to start drawing from
                                     * @param y the y position in the image texture to start drawing from
                                     * @param width the width of the region to draw
                                     * @param height the height of the region to draw
                                     * @param textureWidth the width of the used texture
                                     * @param textureHeight the height of the used texture
                                     * @return 
                                     * @since 1.8.4
                                     */
                                    regions(x: int, y: int, width: int, height: int, textureWidth: int, textureHeight: int): Image$Builder;

                                    /**
                                     * @param textureWidth the width of the used texture
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    textureWidth(textureWidth: int): Image$Builder;

                                    /**
                                     * @return the width of the used texture.
                                     * @since 1.8.4
                                     */
                                    getTextureWidth(): number;

                                    /**
                                     * @param textureHeight the height of the used texture
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    textureHeight(textureHeight: int): Image$Builder;

                                    /**
                                     * @return the height of the used texture.
                                     * @since 1.8.4
                                     */
                                    getTextureHeight(): number;

                                    /**
                                     * @param textureWidth the width of the used texture
                                     * @param textureHeight the height of the used texture
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    textureSize(textureWidth: int, textureHeight: int): Image$Builder;

                                    /**
                                     * @param color the color of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): Image$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): Image$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): Image$Builder;

                                    /**
                                     * @param color the color of the image
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): Image$Builder;

                                    /**
                                     * @return the color of the image.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): Image$Builder;

                                    /**
                                     * @return the alpha value of the color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the image in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): Image$Builder;

                                    /**
                                     * @return the rotation (clockwise) of the image in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the image should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Image$Builder;

                                    /**
                                     * @return {@code true} if this image should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of the image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): Image$Builder;

                                    /**
                                     * @return the z-index of the image.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    createElement(): Image;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Image$Builder;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Line$Builder: JavaClassStatics<Line$Builder, Line$Builder$$constructor>;
                                interface Line$Builder$$constructor extends SuppressProperties {

                                    new (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Line$Builder;

                                }
                                interface Line$Builder extends RenderElementBuilder<Line>, Alignable<Line$Builder> {

                                    /**
                                     * @param x1 the x position of the first point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x1(x1: int): Line$Builder;

                                    /**
                                     * @return the x position of the first point.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the y position of the first point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y1(y1: int): Line$Builder;

                                    /**
                                     * @return the y position of the first point.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the x position of the first point
                                     * @param y1 the y position of the first point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: int, y1: int): Line$Builder;

                                    /**
                                     * @param x2 the x position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x2(x2: int): Line$Builder;

                                    /**
                                     * @return the x position of the second point.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the y position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y2(y2: int): Line$Builder;

                                    /**
                                     * @return the y position of the second point.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the x position of the second point
                                     * @param y2 the y position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: int, y2: int): Line$Builder;

                                    /**
                                     * @param x1 the x position of the first point
                                     * @param y1 the y position of the first point
                                     * @param x2 the x position of the second point
                                     * @param y2 the y position of the second point
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: int, y1: int, x2: int, y2: int): Line$Builder;

                                    /**
                                     * @param rotation the rotation (clockwise) of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): Line$Builder;

                                    /**
                                     * @return the rotation (clockwise) of the line.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this line should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Line$Builder;

                                    /**
                                     * @return {@code true} if this line should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param width the width of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: double): Line$Builder;

                                    /**
                                     * @return the width of the line.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): Line$Builder;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): Line$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): Line$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): Line$Builder;

                                    /**
                                     * @return the color of the line.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): Line$Builder;

                                    /**
                                     * @return the alpha value of the color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param zIndex the z-index of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): Line$Builder;

                                    /**
                                     * @return the z-index of the line.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    moveTo(x: int, y: int): Line$Builder;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Rect$Builder: JavaClassStatics<Rect$Builder, Rect$Builder$$constructor>;
                                interface Rect$Builder$$constructor extends SuppressProperties {

                                    new (draw2D: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Rect$Builder;

                                }
                                interface Rect$Builder extends RenderElementBuilder<Rect>, Alignable<Rect$Builder> {

                                    /**
                                     * @param x1 the first x position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x1(x1: int): Rect$Builder;

                                    /**
                                     * @return the first x position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the first y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y1(y1: int): Rect$Builder;

                                    /**
                                     * @return the first y position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the first x position of the rectangle
                                     * @param y1 the first y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: int, y1: int): Rect$Builder;

                                    /**
                                     * @param x2 the second x position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    x2(x2: int): Rect$Builder;

                                    /**
                                     * @return the second x position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the second y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    y2(y2: int): Rect$Builder;

                                    /**
                                     * @return the second y position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the second x position of the rectangle
                                     * @param y2 the second y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: int, y2: int): Rect$Builder;

                                    /**
                                     * @param x1 the first x position of the rectangle
                                     * @param y1 the first y position of the rectangle
                                     * @param x2 the second x position of the rectangle
                                     * @param y2 the second y position of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: int, y1: int, x2: int, y2: int): Rect$Builder;

                                    /**
                                     * The width will just set the x2 position to `x1 + width`.
                                     * @param width the width of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: int): Rect$Builder;

                                    /**
                                     * @return the width of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * The width will just set the y2 position to `y1 + height`.
                                     * @param height the height of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: int): Rect$Builder;

                                    /**
                                     * @return the height of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the rectangle
                                     * @param height the height of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: int, height: int): Rect$Builder;

                                    /**
                                     * @param color the color of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): Rect$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): Rect$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): Rect$Builder;

                                    /**
                                     * @param color the color of the rectangle
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): Rect$Builder;

                                    /**
                                     * @return the color of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): Rect$Builder;

                                    /**
                                     * @return the alpha value of the color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the rectangle in degrees
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(rotation: double): Rect$Builder;

                                    /**
                                     * @return the rotation (clockwise) of the rectangle in degrees.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this rectangle should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Rect$Builder;

                                    /**
                                     * @return {@code true} if this rectangle should be rotated around its center,
                                     *      {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the z-index of the rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndex: int): Rect$Builder;

                                    /**
                                     * @return the z-index of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getZIndex(): number;
                                    createElement(): Rect;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Rect$Builder;

                                }

                                /**
                                 * @author Wagyourtail
                                 * @since 1.2.3
                                 */
                                const Image: JavaClassStatics<Image, Image$$constructor>;
                                interface Image$$constructor extends SuppressProperties {

                                    new (x: int, y: int, width: int, height: int, zIndex: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: float): Image;
                                    new (x: int, y: int, width: int, height: int, zIndex: int, alpha: int, color: int, id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int, rotation: float): Image;

                                }
                                interface Image extends RenderElement, Alignable<Image> {
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x: number;
                                    y: number;
                                    width: number;
                                    height: number;
                                    imageX: number;
                                    imageY: number;
                                    regionWidth: number;
                                    regionHeight: number;
                                    textureWidth: number;
                                    textureHeight: number;
                                    color: number;
                                    zIndex: number;

                                    /**
                                     * @param id
                                     * @param imageX
                                     * @param imageY
                                     * @param regionWidth
                                     * @param regionHeight
                                     * @param textureWidth
                                     * @param textureHeight
                                     * @return self for chaining.
                                     * @since 1.2.3
                                     */
                                    setImage(id: string, imageX: int, imageY: int, regionWidth: int, regionHeight: int, textureWidth: int, textureHeight: int): Image;

                                    /**
                                     * @return 
                                     * @since 1.2.3
                                     */
                                    getImage(): string;

                                    /**
                                     * @param x the new x position of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): Image;

                                    /**
                                     * @return the x position of this image.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the new y position of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): Image;

                                    /**
                                     * @return the y position of this image.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x the new x position of this image
                                     * @param y the new y position of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(x: int, y: int): Image;

                                    /**
                                     * @param x
                                     * @param y
                                     * @param width
                                     * @param height
                                     * @since 1.2.3
                                     */
                                    setPos(x: int, y: int, width: int, height: int): Image;

                                    /**
                                     * @param width the new width of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: int): Image;

                                    /**
                                     * @return the width of this image.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the new height of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setHeight(height: int): Image;

                                    /**
                                     * @return the height of this image.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the new width of this image
                                     * @param height the new height of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setSize(width: int, height: int): Image;

                                    /**
                                     * @param color
                                     * @return 
                                     * @since 1.6.5
                                     */
                                    setColor(color: int): Image;

                                    /**
                                     * @param color
                                     * @param alpha
                                     * @return 
                                     * @since 1.6.5
                                     */
                                    setColor(color: int, alpha: int): Image;

                                    /**
                                     * @return the color of this image.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @return the alpha value of this image.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation
                                     * @return 
                                     * @since 1.2.6
                                     */
                                    setRotation(rotation: double): Image;

                                    /**
                                     * @return the rotation of this image.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the image should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Image;

                                    /**
                                     * @return {@code true} if this image should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the new z-index of this image
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): Image;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Image;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Image;

                                }

                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.5
                                 */
                                const Item: JavaClassStatics<Item, Item$$constructor>;
                                interface Item$$constructor extends SuppressProperties {

                                    new (x: int, y: int, zIndex: int, id: ItemId, overlay: boolean, scale: double, rotation: float): Item;
                                    new (x: int, y: int, zIndex: int, i: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: float): Item;
                                    new (x: int, y: int, zIndex: int, itemStack: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper, overlay: boolean, scale: double, rotation: float, ovText: string): Item;

                                }
                                interface Item extends RenderElement, Alignable<Item> {
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>;
                                    item: /* minecraft class */ any;
                                    ovText: string;
                                    overlay: boolean;
                                    scale: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x: number;
                                    y: number;
                                    zIndex: number;

                                    /**
                                     * @param i
                                     * @return 
                                     * @since 1.0.5 [citation needed]
                                     */
                                    setItem(i: xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper): Item;

                                    /**
                                     * @param id
                                     * @param count
                                     * @return 
                                     * @since 1.0.5 [citation needed]
                                     */
                                    setItem(id: ItemId, count: int): Item;

                                    /**
                                     * @return 
                                     * @since 1.0.5 [citation needed]
                                     */
                                    getItem(): xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;

                                    /**
                                     * @param x the new x position of this element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX(x: int): Item;

                                    /**
                                     * @return the x position of this element.
                                     * @since 1.8.4
                                     */
                                    getX(): number;

                                    /**
                                     * @param y the new y position of this element
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY(y: int): Item;

                                    /**
                                     * @return the y position of this element.
                                     * @since 1.8.4
                                     */
                                    getY(): number;

                                    /**
                                     * @param x
                                     * @param y
                                     * @return 
                                     * @since 1.0.5
                                     */
                                    setPos(x: int, y: int): Item;

                                    /**
                                     * @param scale
                                     * @return 
                                     * @throws IllegalArgumentException
                                     * @since 1.2.6
                                     */
                                    setScale(scale: double): Item;

                                    /**
                                     * @return the scale of this item.
                                     * @since 1.8.4
                                     */
                                    getScale(): number;

                                    /**
                                     * @param rotation
                                     * @return 
                                     * @since 1.2.6
                                     */
                                    setRotation(rotation: double): Item;

                                    /**
                                     * @return the rotation of this item.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether the item should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Item;

                                    /**
                                     * @return {@code true} if this item should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param overlay
                                     * @return 
                                     * @since 1.2.0
                                     */
                                    setOverlay(overlay: boolean): Item;

                                    /**
                                     * @return {@code true}, if the overlay, i.e. the durability bar, and the overlay text or
                                     *      item count should be shown, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    shouldShowOverlay(): boolean;

                                    /**
                                     * @param ovText
                                     * @return 
                                     * @since 1.2.0
                                     */
                                    setOverlayText(ovText: string): Item;

                                    /**
                                     * @return the overlay text of this item.
                                     * @since 1.8.4
                                     */
                                    getOverlayText(): string;

                                    /**
                                     * @param zIndex the new z-index of this item
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): Item;
                                    getZIndex(): number;
                                    render3D(matrices: /* minecraft class */ any, mouseX: int, mouseY: int, delta: float): void;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Item;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Item;

                                }

                                /**
                                 * @author Wagyourtail
                                 * @since 1.0.5
                                 */
                                const Rect: JavaClassStatics<Rect, Rect$$constructor>;
                                interface Rect$$constructor extends SuppressProperties {

                                    new (x1: int, y1: int, x2: int, y2: int, color: int, rotation: float, zIndex: int): Rect;
                                    new (x1: int, y1: int, x2: int, y2: int, color: int, alpha: int, rotation: float, zIndex: int): Rect;

                                }
                                interface Rect extends RenderElement, Alignable<Rect> {
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    x1: number;
                                    y1: number;
                                    x2: number;
                                    y2: number;
                                    color: number;
                                    zIndex: number;

                                    /**
                                     * @param x1 the first x position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX1(x1: int): Rect;

                                    /**
                                     * @return the first x position of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the first y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY1(y1: int): Rect;

                                    /**
                                     * @return the first y position of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the first x position of this rectangle
                                     * @param y1 the first y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos1(x1: int, y1: int): Rect;

                                    /**
                                     * @param x2 the second x position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX2(x2: int): Rect;

                                    /**
                                     * @return the second x position of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the second y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY2(y2: int): Rect;

                                    /**
                                     * @return the second y position of the rectangle.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the second x position of this rectangle
                                     * @param y2 the second y position of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos2(x2: int, y2: int): Rect;

                                    /**
                                     * @param x1
                                     * @param y1
                                     * @param x2
                                     * @param y2
                                     * @return 
                                     * @since 1.1.8
                                     */
                                    setPos(x1: int, y1: int, x2: int, y2: int): Rect;

                                    /**
                                     * @param width the new width of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: int): Rect;

                                    /**
                                     * @return the width of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the new height of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setHeight(height: int): Rect;

                                    /**
                                     * @return the height of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the new width of this rectangle
                                     * @param height the new height of this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setSize(width: int, height: int): Rect;

                                    /**
                                     * @param color
                                     * @return 
                                     * @since 1.0.5
                                     */
                                    setColor(color: int): Rect;

                                    /**
                                     * @param color
                                     * @param alpha
                                     * @return 
                                     * @since 1.1.8
                                     */
                                    setColor(color: int, alpha: int): Rect;

                                    /**
                                     * @param alpha
                                     * @return 
                                     * @since 1.1.8
                                     */
                                    setAlpha(alpha: int): Rect;

                                    /**
                                     * @return the color value of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @return the alpha value of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation
                                     * @return 
                                     * @since 1.2.6
                                     */
                                    setRotation(rotation: double): Rect;

                                    /**
                                     * @return the rotation of this rectangle.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this rectangle should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Rect;

                                    /**
                                     * @return {@code true} if this rectangle should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param zIndex the new z-index for this rectangle
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): Rect;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Rect;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;
                                    moveTo(x: int, y: int): Rect;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Line: JavaClassStatics<Line, Line$$constructor>;
                                interface Line$$constructor extends SuppressProperties {

                                    new (x1: int, y1: int, x2: int, y2: int, color: int, rotation: float, width: float, zIndex: int): Line;

                                }
                                interface Line extends RenderElement, Alignable<Line> {
                                    parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>;
                                    x1: number;
                                    y1: number;
                                    x2: number;
                                    y2: number;
                                    color: number;
                                    rotation: number;
                                    rotateCenter: boolean;
                                    width: number;
                                    zIndex: number;

                                    /**
                                     * @param x1 the x position of the start of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX1(x1: int): Line;

                                    /**
                                     * @return the x position of the start of the line.
                                     * @since 1.8.4
                                     */
                                    getX1(): number;

                                    /**
                                     * @param y1 the y position of the start of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY1(y1: int): Line;

                                    /**
                                     * @return the y position of the start of the line.
                                     * @since 1.8.4
                                     */
                                    getY1(): number;

                                    /**
                                     * @param x1 the x position of the start of the line
                                     * @param y1 the y position of the start of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos1(x1: int, y1: int): Line;

                                    /**
                                     * @param x2 the x position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setX2(x2: int): Line;

                                    /**
                                     * @return the x position of the end of the line.
                                     * @since 1.8.4
                                     */
                                    getX2(): number;

                                    /**
                                     * @param y2 the y position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setY2(y2: int): Line;

                                    /**
                                     * @return the y position of the end of the line.
                                     * @since 1.8.4
                                     */
                                    getY2(): number;

                                    /**
                                     * @param x2 the x position of the end of the line
                                     * @param y2 the y position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos2(x2: int, y2: int): Line;

                                    /**
                                     * @param x1 the x position of the start of the line
                                     * @param y1 the y position of the start of the line
                                     * @param x2 the x position of the end of the line
                                     * @param y2 the y position of the end of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(x1: int, y1: int, x2: int, y2: int): Line;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setColor(color: int): Line;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setColor(color: int, alpha: int): Line;

                                    /**
                                     * @return the color of the line.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value of the line's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setAlpha(alpha: int): Line;

                                    /**
                                     * @return the alpha value of the line's color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param rotation the rotation (clockwise) of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotation(rotation: double): Line;

                                    /**
                                     * @return the rotation (clockwise) of the line.
                                     * @since 1.8.4
                                     */
                                    getRotation(): number;

                                    /**
                                     * @param rotateCenter whether this line should be rotated around its center
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Line;

                                    /**
                                     * @return {@code true} if this line should be rotated around its center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param width the width of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setWidth(width: double): Line;

                                    /**
                                     * @return the width of the line.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param zIndex the z-index of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setZIndex(zIndex: int): Line;
                                    getZIndex(): number;
                                    setParent(parent: xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<any>): Line;
                                    moveTo(x: int, y: int): Line;
                                    getScaledWidth(): number;
                                    getParentWidth(): number;
                                    getScaledHeight(): number;
                                    getParentHeight(): number;
                                    getScaledLeft(): number;
                                    getScaledTop(): number;

                                }

                                /**
                                 * @param <T> the type of the render element for this builder
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const RenderElementBuilder: JavaClassStatics<RenderElementBuilder<any>> & NoConstructor;
                                interface RenderElementBuilder<T extends RenderElement> extends JavaObject {

                                    /**
                                     * @return the newly created element.
                                     * @since 1.8.4
                                     */
                                    build(): T;

                                    /**
                                     * Builds and adds the element to the draw2D the builder was created from.
                                     * @return the newly created element.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): T;

                                }

                                /**
                                 * @param <B> the builder class
                                 * @since 1.8.4
                                 */
                                const Alignable: JavaInterfaceStatics<Alignable<any>> & {

                                    /**
                                     * Parse the string containing a percentage of the form `x%` and return its value.
                                     * @param string the string to parse
                                     * @return the percentage or {@code -1} if the string is not a valid percentage.
                                     * @since 1.8.4
                                     */
                                    parsePercentage(string: string): number;

                                }
                                interface Alignable<B extends Alignable<B>> extends JavaObject {

                                    /**
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see #alignHorizontally(Alignable, String, int)
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(other: Alignable<any>, alignment: string): B;

                                    /**
                                     * The alignment must be of the format
                                     *  `[left|center|right|x%]On[left|center|right|x%]`. The input is case-insensitive.  
                                     *  The first alignment is for the element this method is called on and the second is for the
                                     *  other element. As an example, `LeftOnCenter` would align the left side of this
                                     *  element to the center of the other element.
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(other: Alignable<any>, alignment: string, offset: int): B;

                                    /**
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see #alignHorizontally(String, int)
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(alignment: string): B;

                                    /**
                                     * Possible alignments are `left`, `center`, `right` or `y%` where y
                                     *  is a number between 0 and 100.
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignHorizontally(alignment: string, offset: int): B;

                                    /**
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see #alignVertically(Alignable, String, int)
                                     * @since 1.8.4
                                     */
                                    alignVertically(other: Alignable<any>, alignment: string): B;

                                    /**
                                     * The alignment must be of the format
                                     *  `[top|center|bottom|y%]On[top|center|bottom|y%]`. The input is case-insensitive.  
                                     *  The first alignment is for the element this method is called on and the second is for the
                                     *  other element. As an example, `BottomOnTop` would align the bottom side of this
                                     *  element to the top of the other element. Thus, the element would be placed above the
                                     *  other one.
                                     * @param other the element to align to
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignVertically(other: Alignable<any>, alignment: string, offset: int): B;

                                    /**
                                     * @param alignment the alignment to use
                                     * @return self for chaining.
                                     * @see #alignVertically(String, int)
                                     * @since 1.8.4
                                     */
                                    alignVertically(alignment: string): B;

                                    /**
                                     * Possible alignments are `top`, `center`, `bottom` or `x%` where x
                                     *  is a number between 0 and 100.
                                     * @param alignment the alignment to use
                                     * @param offset the offset to use
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alignVertically(alignment: string, offset: int): B;

                                    /**
                                     * @param horizontal the horizontal alignment to use
                                     * @param vertical the vertical alignment to use
                                     * @return self for chaining.
                                     * @see #align(String, int, String, int)
                                     * @since 1.8.4
                                     */
                                    align(horizontal: string, vertical: string): B;

                                    /**
                                     * @param horizontal the horizontal alignment to use
                                     * @param horizontalOffset the horizontal offset to use
                                     * @param vertical the vertical alignment to use
                                     * @param verticalOffset the vertical offset to use
                                     * @return self for chaining.
                                     * @see #alignHorizontally(String, int)
                                     * @see #alignVertically(String, int)
                                     * @since 1.8.4
                                     */
                                    align(horizontal: string, horizontalOffset: int, vertical: string, verticalOffset: int): B;

                                    /**
                                     * @param other the element to align to
                                     * @param horizontal the horizontal alignment to use
                                     * @param vertical the vertical alignment to use
                                     * @return self for chaining.
                                     * @see #align(Alignable, String, int, String, int)
                                     * @since 1.8.4
                                     */
                                    align(other: Alignable<any>, horizontal: string, vertical: string): B;

                                    /**
                                     * @param other the element to align to
                                     * @param horizontal the horizontal alignment to use
                                     * @param horizontalOffset the horizontal offset to use
                                     * @param vertical the vertical alignment to use
                                     * @param verticalOffset the vertical offset to use
                                     * @return self for chaining.
                                     * @see #alignHorizontally(Alignable, String, int)
                                     * @see #alignVertically(Alignable, String, int)
                                     * @since 1.8.4
                                     */
                                    align(other: Alignable<any>, horizontal: string, horizontalOffset: int, vertical: string, verticalOffset: int): B;

                                    /**
                                     * @param x the new x position
                                     * @param y the new y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    moveTo(x: int, y: int): B;

                                    /**
                                     * @param x the new x position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    moveToX(x: int): B;

                                    /**
                                     * @param y the new y position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    moveToY(y: int): B;

                                    /**
                                     * @return the scaled width of the element.
                                     * @since 1.8.4
                                     */
                                    getScaledWidth(): number;

                                    /**
                                     * @return the width of the parent element.
                                     * @since 1.8.4
                                     */
                                    getParentWidth(): number;

                                    /**
                                     * @return the scaled height of the element.
                                     * @since 1.8.4
                                     */
                                    getScaledHeight(): number;

                                    /**
                                     * @return the height of the parent element.
                                     * @since 1.8.4
                                     */
                                    getParentHeight(): number;

                                    /**
                                     * @return the position of the scaled element's left side.
                                     * @since 1.8.4
                                     */
                                    getScaledLeft(): number;

                                    /**
                                     * @return the position of the scaled element's top side.
                                     * @since 1.8.4
                                     */
                                    getScaledTop(): number;

                                    /**
                                     * @return the position of the scaled element's right side.
                                     * @since 1.8.4
                                     */
                                    getScaledRight(): number;

                                    /**
                                     * @return the position of the scaled element's bottom side.
                                     * @since 1.8.4
                                     */
                                    getScaledBottom(): number;

                                }

                                export {
                                    Text,
                                    Item$Builder,
                                    Text$Builder,
                                    Draw2DElement,
                                    RenderElement,
                                    Draw2DElement$Builder,
                                    Image$Builder,
                                    Line$Builder,
                                    Rect$Builder,
                                    Image,
                                    Item,
                                    Rect,
                                    Line,
                                    RenderElementBuilder,
                                    Alignable
                                }

                            }

                            namespace components3d {

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Box$Builder: JavaClassStatics<Box$Builder, Box$Builder$$constructor>;
                                interface Box$Builder$$constructor extends SuppressProperties {

                                    new (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): Box$Builder;

                                }
                                interface Box$Builder extends JavaObject {

                                    /**
                                     * @param pos1 the first position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Box$Builder;

                                    /**
                                     * @param pos1 the first position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Box$Builder;

                                    /**
                                     * @param x1 the x coordinate of the first position of the box
                                     * @param y1 the y coordinate of the first position of the box
                                     * @param z1 the z coordinate of the first position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: double, y1: double, z1: double): Box$Builder;

                                    /**
                                     * @return the first position of the box.
                                     * @since 1.8.4
                                     */
                                    getPos1(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Box$Builder;

                                    /**
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Box$Builder;

                                    /**
                                     * @param x2 the x coordinate of the second position of the box
                                     * @param y2 the y coordinate of the second position of the box
                                     * @param z2 the z coordinate of the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: double, y2: double, z2: double): Box$Builder;

                                    /**
                                     * @return the second position of the box.
                                     * @since 1.8.4
                                     */
                                    getPos2(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param x1 the x coordinate of the first position of the box
                                     * @param y1 the y coordinate of the first position of the box
                                     * @param z1 the z coordinate of the first position of the box
                                     * @param x2 the x coordinate of the second position of the box
                                     * @param y2 the y coordinate of the second position of the box
                                     * @param z2 the z coordinate of the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Box$Builder;

                                    /**
                                     * @param pos1 the first position of the box
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Box$Builder;

                                    /**
                                     * @param pos1 the first position of the box
                                     * @param pos2 the second position of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Box$Builder;

                                    /**
                                     * Highlights the given block position.
                                     * @param x the x coordinate of the block
                                     * @param y the y coordinate of the block
                                     * @param z the z coordinate of the block
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    forBlock(x: int, y: int, z: int): Box$Builder;

                                    /**
                                     * Highlights the given block position.
                                     * @param pos the block position
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    forBlock(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Box$Builder;

                                    /**
                                     * @param color the color of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): Box$Builder;

                                    /**
                                     * @param color the fill color of the box
                                     * @param alpha the alpha value for the box's fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): Box$Builder;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): Box$Builder;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @param a the alpha component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): Box$Builder;

                                    /**
                                     * @return the color of the box.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value for the box's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): Box$Builder;

                                    /**
                                     * @return the alpha value of the box's color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param fillColor the fill color of the box
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(fillColor: int): Box$Builder;

                                    /**
                                     * @param fillColor the fill color of the box
                                     * @param alpha the alpha value for the box's fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(fillColor: int, alpha: int): Box$Builder;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(r: int, g: int, b: int): Box$Builder;

                                    /**
                                     * @param r the red component of the fill color
                                     * @param g the green component of the fill color
                                     * @param b the blue component of the fill color
                                     * @param a the alpha component of the fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillColor(r: int, g: int, b: int, a: int): Box$Builder;

                                    /**
                                     * @return the fill color of the box.
                                     * @since 1.8.4
                                     */
                                    getFillColor(): number;

                                    /**
                                     * @param fillAlpha the alpha value for the box's fill color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fillAlpha(fillAlpha: int): Box$Builder;

                                    /**
                                     * @return the alpha value of the box's fill color.
                                     * @since 1.8.4
                                     */
                                    getFillAlpha(): number;

                                    /**
                                     * @param fill {@code true} if the box should be filled, {@code false} otherwise
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    fill(fill: boolean): Box$Builder;

                                    /**
                                     * @return {@code true} if the box should be filled, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isFilled(): boolean;

                                    /**
                                     * @param cull whether to enable culling or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    cull(cull: boolean): Box$Builder;

                                    /**
                                     * @return {@code true} if culling is enabled for this box, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isCulled(): boolean;

                                    /**
                                     * Creates the box for the given values and adds it to the draw3D.
                                     * @return the build box.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): Box;

                                    /**
                                     * Builds the box from the given values.
                                     * @return the build box.
                                     */
                                    build(): Box;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Line3D$Builder: JavaClassStatics<Line3D$Builder, Line3D$Builder$$constructor>;
                                interface Line3D$Builder$$constructor extends SuppressProperties {

                                    new (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): Line3D$Builder;

                                }
                                interface Line3D$Builder extends JavaObject {

                                    /**
                                     * @param pos1 the first position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Line3D$Builder;

                                    /**
                                     * @param pos1 the first position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Line3D$Builder;

                                    /**
                                     * @param x1 the x coordinate of the first position of the line
                                     * @param y1 the y coordinate of the first position of the line
                                     * @param z1 the z coordinate of the first position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos1(x1: double, y1: double, z1: double): Line3D$Builder;

                                    /**
                                     * @return the first position of the line.
                                     * @since 1.8.4
                                     */
                                    getPos1(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Line3D$Builder;

                                    /**
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Line3D$Builder;

                                    /**
                                     * @param x2 the x coordinate of the second position of the line
                                     * @param y2 the y coordinate of the second position of the line
                                     * @param z2 the z coordinate of the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos2(x2: int, y2: int, z2: int): Line3D$Builder;

                                    /**
                                     * @return the second position of the line.
                                     * @since 1.8.4
                                     */
                                    getPos2(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param x1 the x coordinate of the first position of the line
                                     * @param y1 the y coordinate of the first position of the line
                                     * @param z1 the z coordinate of the first position of the line
                                     * @param x2 the x coordinate of the second position of the line
                                     * @param y2 the x coordinate of the second position of the line
                                     * @param z2 the z coordinate of the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x1: int, y1: int, z1: int, x2: int, y2: int, z2: int): Line3D$Builder;

                                    /**
                                     * @param pos1 the first position of the line
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper, pos2: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Line3D$Builder;

                                    /**
                                     * @param pos1 the first position of the line
                                     * @param pos2 the second position of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos1: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, pos2: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Line3D$Builder;

                                    /**
                                     * @param color the color of the line
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int): Line3D$Builder;

                                    /**
                                     * @param color the color of the line
                                     * @param alpha the alpha value of the line's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(color: int, alpha: int): Line3D$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int): Line3D$Builder;

                                    /**
                                     * @param r the red component of the color
                                     * @param g the green component of the color
                                     * @param b the blue component of the color
                                     * @param a the alpha value of the color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    color(r: int, g: int, b: int, a: int): Line3D$Builder;

                                    /**
                                     * @return the color of the line.
                                     * @since 1.8.4
                                     */
                                    getColor(): number;

                                    /**
                                     * @param alpha the alpha value for the line's color
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    alpha(alpha: int): Line3D$Builder;

                                    /**
                                     * @return the alpha value of the line's color.
                                     * @since 1.8.4
                                     */
                                    getAlpha(): number;

                                    /**
                                     * @param cull whether to cull the line or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    cull(cull: boolean): Line3D$Builder;

                                    /**
                                     * @return {@code true} if the line should be culled, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isCulled(): boolean;

                                    /**
                                     * Creates the line for the given values and adds it to the draw3D.
                                     * @return the build line.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): Line3D;

                                    /**
                                     * Builds the line from the given values.
                                     * @return the build line.
                                     */
                                    build(): Line3D;

                                }

                                /**
                                 * @author Wagyourtail
                                 */
                                const Line3D: JavaClassStatics<Line3D, Line3D$$constructor>;
                                interface Line3D$$constructor extends SuppressProperties {

                                    new (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, cull: boolean): Line3D;
                                    new (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, cull: boolean): Line3D;

                                }
                                interface Line3D extends JavaObject {
                                    pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
                                    color: number;
                                    cull: boolean;

                                    /**
                                     * @param x1
                                     * @param y1
                                     * @param z1
                                     * @param x2
                                     * @param y2
                                     * @param z2
                                     * @since 1.0.6
                                     */
                                    setPos(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): void;

                                    /**
                                     * @param color
                                     * @since 1.0.6
                                     */
                                    setColor(color: int): void;

                                    /**
                                     * @param color
                                     * @param alpha
                                     * @since 1.1.8
                                     */
                                    setColor(color: int, alpha: int): void;

                                    /**
                                     * @param alpha
                                     * @since 1.1.8
                                     */
                                    setAlpha(alpha: int): void;
                                    render(matrixStack: /* minecraft class */ any): void;

                                }

                                /**
                                 * @author Wagyourtail
                                 */
                                const Box: JavaClassStatics<Box, Box$$constructor>;
                                interface Box$$constructor extends SuppressProperties {

                                    new (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, fillColor: int, fill: boolean, cull: boolean): Box;
                                    new (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double, color: int, alpha: int, fillColor: int, fillAlpha: int, fill: boolean, cull: boolean): Box;

                                }
                                interface Box extends JavaObject {
                                    pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
                                    color: number;
                                    fillColor: number;
                                    fill: boolean;
                                    cull: boolean;

                                    /**
                                     * @param x1
                                     * @param y1
                                     * @param z1
                                     * @param x2
                                     * @param y2
                                     * @param z2
                                     * @since 1.0.6
                                     */
                                    setPos(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): void;

                                    /**
                                     * @param color
                                     * @since 1.0.6
                                     */
                                    setColor(color: int): void;

                                    /**
                                     * @param fillColor
                                     * @since 1.0.6
                                     */
                                    setFillColor(fillColor: int): void;

                                    /**
                                     * @param color
                                     * @param alpha
                                     * @since 1.1.8
                                     */
                                    setColor(color: int, alpha: int): void;

                                    /**
                                     * @param alpha
                                     * @since 1.1.8
                                     */
                                    setAlpha(alpha: int): void;

                                    /**
                                     * @param fillColor
                                     * @param alpha
                                     * @since 1.1.8
                                     */
                                    setFillColor(fillColor: int, alpha: int): void;

                                    /**
                                     * @param alpha
                                     * @since 1.1.8
                                     */
                                    setFillAlpha(alpha: int): void;

                                    /**
                                     * @param fill
                                     * @since 1.0.6
                                     */
                                    setFill(fill: boolean): void;
                                    render(matrixStack: /* minecraft class */ any): void;

                                }

                                /**
                                 * @author Etheradon
                                 * @since 1.8.4
                                 */
                                const Surface$Builder: JavaClassStatics<Surface$Builder, Surface$Builder$$constructor>;
                                interface Surface$Builder$$constructor extends SuppressProperties {

                                    new (parent: xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D): Surface$Builder;

                                }
                                interface Surface$Builder extends JavaObject {

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Surface$Builder;

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Surface$Builder;

                                    /**
                                     * @param x the x position of the surface
                                     * @param y the y position of the surface
                                     * @param z the z position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    pos(x: double, y: double, z: double): Surface$Builder;

                                    /**
                                     * @return the position of the surface.
                                     * @since 1.8.4
                                     */
                                    getPos(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * The surface will move with the entity at the offset location.
                                     * @param boundEntity the entity to bind the surface to
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    bindToEntity(boundEntity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): Surface$Builder;

                                    /**
                                     * @return the entity the surface is bound to, or {@code null} if it is not bound to an
                                     *      entity.
                                     * @since 1.8.4
                                     */
                                    getBoundEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

                                    /**
                                     * @param entityOffset the offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    boundOffset(entityOffset: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Surface$Builder;

                                    /**
                                     * @param x the x offset from the entity's position to render the surface at
                                     * @param y the y offset from the entity's position to render the surface at
                                     * @param z the z offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    boundOffset(x: double, y: double, z: double): Surface$Builder;

                                    /**
                                     * @return the offset from the entity's position to render the surface at.
                                     * @since 1.8.4
                                     */
                                    getBoundOffset(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param xRot the x rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    xRotation(xRot: double): Surface$Builder;

                                    /**
                                     * @return the x rotation of the surface.
                                     * @since 1.8.4
                                     */
                                    getXRotation(): number;

                                    /**
                                     * @param yRot the y rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    yRotation(yRot: double): Surface$Builder;

                                    /**
                                     * @return the y rotation of the surface.
                                     * @since 1.8.4
                                     */
                                    getYRotation(): number;

                                    /**
                                     * @param zRot the z rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zRotation(zRot: double): Surface$Builder;

                                    /**
                                     * @return the z rotation of the surface.
                                     * @since 1.8.4
                                     */
                                    getZRotation(): number;

                                    /**
                                     * @param xRot the x rotation of the surface
                                     * @param yRot the y rotation of the surface
                                     * @param zRot the z rotation of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotation(xRot: double, yRot: double, zRot: double): Surface$Builder;

                                    /**
                                     * @param rotateCenter whether to rotate around the center of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateCenter(rotateCenter: boolean): Surface$Builder;

                                    /**
                                     * @return {@code true} if this surface should be rotated around its center,
                                     *      {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;

                                    /**
                                     * @param rotateToPlayer whether to rotate the surface to face the player or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    rotateToPlayer(rotateToPlayer: boolean): Surface$Builder;

                                    /**
                                     * @return {@code true} if the surface should be rotated to face the player,
                                     *      {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    doesRotateToPlayer(): boolean;

                                    /**
                                     * @param width the width of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    width(width: double): Surface$Builder;

                                    /**
                                     * @return the width of the surface.
                                     * @since 1.8.4
                                     */
                                    getWidth(): number;

                                    /**
                                     * @param height the height of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    height(height: double): Surface$Builder;

                                    /**
                                     * @return the height of the surface.
                                     * @since 1.8.4
                                     */
                                    getHeight(): number;

                                    /**
                                     * @param width the width of the surface
                                     * @param height the height of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    size(width: double, height: double): Surface$Builder;

                                    /**
                                     * @param minSubdivisions the minimum number of subdivisions
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    minSubdivisions(minSubdivisions: int): Surface$Builder;

                                    /**
                                     * @return the minimum number of subdivisions.
                                     * @since 1.8.4
                                     */
                                    getMinSubdivisions(): number;

                                    /**
                                     * @param renderBack whether the back of the surface should be rendered or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    renderBack(renderBack: boolean): Surface$Builder;

                                    /**
                                     * @return {@code true} if the back of the surface should be rendered, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    shouldRenderBack(): boolean;

                                    /**
                                     * @param cull whether to enable culling or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    cull(cull: boolean): Surface$Builder;

                                    /**
                                     * @return {@code true} if culling is enabled for this box, {@code false} otherwise.
                                     * @since 1.8.4
                                     */
                                    isCulled(): boolean;

                                    /**
                                     * @param zIndexScale the scale of the z-index
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    zIndex(zIndexScale: double): Surface$Builder;

                                    /**
                                     * @return the scale of the z-index.
                                     * @since 1.8.4
                                     */
                                    getZIndexScale(): number;

                                    /**
                                     * Creates the surface for the given values and adds it to the draw3D.
                                     * @return the build surface.
                                     * @since 1.8.4
                                     */
                                    buildAndAdd(): Surface;

                                    /**
                                     * Builds the surface from the given values.
                                     * @return the build surface.
                                     */
                                    build(): Surface;

                                }

                                /**
                                 * @author Wagyourtail
                                 * @since 1.6.5
                                 */
                                const Surface: JavaClassStatics<Surface, Surface$$constructor>;
                                interface Surface$$constructor extends SuppressProperties {

                                    new (pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, rotations: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D, sizes: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D, minSubdivisions: int, renderBack: boolean, cull: boolean): Surface;

                                }
                                interface Surface extends xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D, xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement {
                                    rotateToPlayer: boolean;
                                    rotateCenter: boolean;
                                    boundEntity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;
                                    boundOffset: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
                                    readonly pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
                                    readonly rotations: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * scale that zIndex is multiplied by to get the actual offset (in blocks) for rendering
                                     *  default: `1/1000` if there is still z-fighting, increase this value
                                     * @since 1.6.5
                                     */
                                    zIndexScale: number;
                                    renderBack: boolean;
                                    cull: boolean;

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(pos: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Surface;

                                    /**
                                     * @param pos the position of the surface
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setPos(pos: xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper): Surface;
                                    setPos(x: double, y: double, z: double): Surface;

                                    /**
                                     * The surface will move with the entity at the offset location.
                                     * @param boundEntity the entity to bind the surface to
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    bindToEntity(boundEntity: xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>): Surface;

                                    /**
                                     * @return the entity the surface is bound to, or {@code null} if it is not bound to an
                                     *      entity.
                                     * @since 1.8.4
                                     */
                                    getBoundEntity(): xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<any>;

                                    /**
                                     * @param boundOffset the offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setBoundOffset(boundOffset: xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D): Surface;

                                    /**
                                     * @param x the x offset from the entity's position to render the surface at
                                     * @param y the y offset from the entity's position to render the surface at
                                     * @param z the z offset from the entity's position to render the surface at
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setBoundOffset(x: double, y: double, z: double): Surface;

                                    /**
                                     * @return the offset from the entity's position to render the surface at.
                                     * @since 1.8.4
                                     */
                                    getBoundOffset(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;

                                    /**
                                     * @param rotateToPlayer whether to rotate the surface to face the player or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateToPlayer(rotateToPlayer: boolean): Surface;

                                    /**
                                     * @return {@code true} if the surface should be rotated to face the player, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    doesRotateToPlayer(): boolean;
                                    setRotations(x: double, y: double, z: double): void;
                                    setSizes(x: double, y: double): void;
                                    getSizes(): xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;
                                    setMinSubdivisions(minSubdivisions: int): void;
                                    getMinSubdivisions(): number;
                                    getHeight(): number;
                                    getWidth(): number;

                                    /**
                                     * @param rotateCenter whether to rotate the surface around its center or not
                                     * @return self for chaining.
                                     * @since 1.8.4
                                     */
                                    setRotateCenter(rotateCenter: boolean): Surface;

                                    /**
                                     * @return {@code true} if this surface is rotated around it's center, {@code false}
                                     *      otherwise.
                                     * @since 1.8.4
                                     */
                                    isRotatingCenter(): boolean;
                                    init(): void;
                                    getZIndex(): number;
                                    render3D(matrixStack: /* minecraft class */ any, mouseX: int, mouseY: int, delta: float): void;

                                }

                                export {
                                    Box$Builder,
                                    Line3D$Builder,
                                    Line3D,
                                    Box,
                                    Surface$Builder,
                                    Surface
                                }

                            }

                        }

                        namespace math {

                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            const Vec2D: JavaClassStatics<Vec2D, Vec2D$$constructor>;
                            interface Vec2D$$constructor extends SuppressProperties {

                                new (x1: double, y1: double, x2: double, y2: double): Vec2D;
                                new (start: Pos2D, end: Pos2D): Vec2D;

                            }
                            interface Vec2D extends JavaObject {
                                x1: number;
                                y1: number;
                                x2: number;
                                y2: number;

                                getX1(): number;
                                getY1(): number;
                                getX2(): number;
                                getY2(): number;
                                getDeltaX(): number;
                                getDeltaY(): number;
                                getStart(): Pos2D;
                                getEnd(): Pos2D;
                                getMagnitude(): number;

                                /**
                                 * @return magnitude squared
                                 * @since 1.6.5
                                 */
                                getMagnitudeSq(): number;
                                add(vec: Vec2D): Vec2D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @return 
                                 * @since 1.6.3
                                 */
                                add(x1: double, y1: double, x2: double, y2: double): Vec2D;
                                multiply(vec: Vec2D): Vec2D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @return 
                                 * @since 1.6.3
                                 */
                                multiply(x1: double, y1: double, x2: double, y2: double): Vec2D;

                                /**
                                 * @param scale
                                 * @return 
                                 * @since 1.6.3
                                 */
                                scale(scale: double): Vec2D;
                                dotProduct(vec: Vec2D): number;
                                reverse(): Vec2D;

                                /**
                                 * @return a new Vec2D with the same direction but a magnitude of 1
                                 * @since 1.6.5
                                 */
                                normalize(): Vec2D;
                                to3D(): Vec3D;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            const Pos3D: JavaClassStatics<Pos3D, Pos3D$$constructor> & {
                                readonly ZERO: Pos3D;
                            }
                            interface Pos3D$$constructor extends SuppressProperties {

                                new (vec: /* minecraft class */ any): Pos3D;
                                new (x: double, y: double, z: double): Pos3D;

                            }
                            interface Pos3D extends Pos2D {
                                z: number;

                                getZ(): number;
                                add(pos: Pos3D): Pos3D;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @return 
                                 * @since 1.6.3
                                 */
                                add(x: double, y: double, z: double): Pos3D;
                                add(pos: Pos2D): Pos2D;

                                /**
                                 * @param x
                                 * @param y
                                 * @return 
                                 * @since 1.6.3
                                 */
                                add(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(pos: Pos3D): Pos3D;

                                /**
                                 * @param x the x coordinate to subtract
                                 * @param y the y coordinate to subtract
                                 * @param z the z coordinate to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(x: double, y: double, z: double): Pos3D;

                                /**
                                 * @param pos the position to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to subtract
                                 * @param y the y coordinate to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(x: double, y: double): Pos2D;
                                multiply(pos: Pos3D): Pos3D;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @return 
                                 * @since 1.6.3
                                 */
                                multiply(x: double, y: double, z: double): Pos3D;
                                multiply(pos: Pos2D): Pos2D;

                                /**
                                 * @param x
                                 * @param y
                                 * @return 
                                 * @since 1.6.3
                                 */
                                multiply(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(pos: Pos3D): Pos3D;

                                /**
                                 * @param x the x coordinate to divide by
                                 * @param y the y coordinate to divide by
                                 * @param z the z coordinate to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(x: double, y: double, z: double): Pos3D;

                                /**
                                 * @param pos the position to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to divide by
                                 * @param y the y coordinate to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(x: double, y: double): Pos2D;

                                /**
                                 * @param scale
                                 * @return 
                                 * @since 1.6.3
                                 */
                                scale(scale: double): Pos3D;
                                toVector(): Vec3D;

                                /**
                                 * @param start_pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toVector(start_pos: Pos2D): Vec3D;

                                /**
                                 * @param start_pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toVector(start_pos: Pos3D): Vec3D;

                                /**
                                 * @param start_x
                                 * @param start_y
                                 * @param start_z
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toVector(start_x: double, start_y: double, start_z: double): Vec3D;

                                /**
                                 * @param start_x
                                 * @param start_y
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toVector(start_x: double, start_y: double): Vec2D;

                                /**
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(): Vec3D;
                                toReverseVector(end_pos: Pos2D): Vec3D;

                                /**
                                 * @param end_pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(end_pos: Pos3D): Vec3D;

                                /**
                                 * @param end_x
                                 * @param end_y
                                 * @param end_z
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(end_x: double, end_y: double, end_z: double): Vec3D;

                                /**
                                 * @param end_x
                                 * @param end_y
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(end_x: double, end_y: double): Vec2D;

                                /**
                                 * @return 
                                 * @since 1.8.0
                                 */
                                toBlockPos(): xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;

                                /**
                                 * @return 
                                 * @since 1.8.0
                                 */
                                toRawBlockPos(): /* minecraft class */ any;

                                /**
                                 * @return the raw minecraft double vector with the same coordinates as this position.
                                 * @since 1.8.4
                                 */
                                toMojangDoubleVector(): /* minecraft class */ any;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            const Vec3D: JavaClassStatics<Vec3D, Vec3D$$constructor>;
                            interface Vec3D$$constructor extends SuppressProperties {

                                new (x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Vec3D;
                                new (start: Pos3D, end: Pos3D): Vec3D;

                            }
                            interface Vec3D extends Vec2D {
                                z1: number;
                                z2: number;

                                getZ1(): number;
                                getZ2(): number;
                                getDeltaZ(): number;
                                getStart(): Pos3D;
                                getEnd(): Pos3D;
                                getMagnitude(): number;
                                getMagnitudeSq(): number;
                                add(vec: Vec3D): Vec3D;
                                add(vec: Vec2D): Vec2D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @return 
                                 * @since 1.6.3
                                 */
                                add(x1: double, y1: double, x2: double, y2: double): Vec2D;

                                /**
                                 * @param pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                addStart(pos: Pos3D): Vec3D;

                                /**
                                 * @param pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                addEnd(pos: Pos3D): Vec3D;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @return 
                                 * @since 1.6.4
                                 */
                                addStart(x: double, y: double, z: double): Vec3D;

                                /**
                                 * @param x
                                 * @param y
                                 * @param z
                                 * @return 
                                 * @since 1.6.4
                                 */
                                addEnd(x: double, y: double, z: double): Vec3D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @return 
                                 * @since 1.6.3
                                 */
                                add(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Vec3D;
                                multiply(vec: Vec3D): Vec3D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param z1
                                 * @param x2
                                 * @param y2
                                 * @param z2
                                 * @return 
                                 * @since 1.6.3
                                 */
                                multiply(x1: double, y1: double, z1: double, x2: double, y2: double, z2: double): Vec3D;
                                multiply(vec: Vec2D): Vec2D;

                                /**
                                 * @param x1
                                 * @param y1
                                 * @param x2
                                 * @param y2
                                 * @return 
                                 * @since 1.6.3
                                 */
                                multiply(x1: double, y1: double, x2: double, y2: double): Vec2D;

                                /**
                                 * @param scale
                                 * @return 
                                 * @since 1.6.3
                                 */
                                scale(scale: double): Vec3D;

                                /**
                                 * @return 
                                 * @since 1.6.5
                                 */
                                normalize(): Vec3D;
                                getPitch(): number;
                                getYaw(): number;
                                dotProduct(vec: Vec3D): number;
                                dotProduct(vec: Vec2D): number;
                                crossProduct(vec: Vec3D): Vec3D;
                                reverse(): Vec3D;

                                /**
                                 * @return 
                                 * @since 1.6.5
                                 */
                                toMojangFloatVector(): org.joml.Vector3f;

                            }

                            /**
                             * @author Wagyourtail
                             * @since 1.2.6 [citation needed]
                             */
                            const Pos2D: JavaClassStatics<Pos2D, Pos2D$$constructor> & {
                                readonly ZERO: Pos2D;
                            }
                            interface Pos2D$$constructor extends SuppressProperties {

                                new (x: double, y: double): Pos2D;

                            }
                            interface Pos2D extends JavaObject {
                                x: number;
                                y: number;

                                getX(): number;
                                getY(): number;
                                add(pos: Pos2D): Pos2D;

                                /**
                                 * @param x
                                 * @param y
                                 * @return 
                                 * @since 1.6.3
                                 */
                                add(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to subtract
                                 * @param y the y coordinate to subtract
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                sub(x: double, y: double): Pos2D;
                                multiply(pos: Pos2D): Pos2D;

                                /**
                                 * @param x
                                 * @param y
                                 * @return 
                                 * @since 1.6.3
                                 */
                                multiply(x: double, y: double): Pos2D;

                                /**
                                 * @param pos the position to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(pos: Pos2D): Pos2D;

                                /**
                                 * @param x the x coordinate to divide by
                                 * @param y the y coordinate to divide by
                                 * @return the new position.
                                 * @since 1.8.4
                                 */
                                divide(x: double, y: double): Pos2D;

                                /**
                                 * @param scale
                                 * @return 
                                 * @since 1.6.3
                                 */
                                scale(scale: double): Pos2D;
                                to3D(): Pos3D;
                                toVector(): Vec2D;

                                /**
                                 * @param start_pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toVector(start_pos: Pos2D): Vec2D;

                                /**
                                 * @param start_x
                                 * @param start_y
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toVector(start_x: double, start_y: double): Vec2D;

                                /**
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(): Vec2D;

                                /**
                                 * @param end_pos
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(end_pos: Pos2D): Vec2D;

                                /**
                                 * @param end_x
                                 * @param end_y
                                 * @return 
                                 * @since 1.6.4
                                 */
                                toReverseVector(end_x: double, end_y: double): Vec2D;

                            }

                            export { Vec2D, Pos3D, Vec3D, Pos2D }

                        }

                        namespace worldscanner {

                            /**
                             * The builder can be used to create a world scanner with native java functions. This is especially useful for languages like javascript that
                             *  don't support multithreading, which causes streams to run sequential instead of parallel.  
                             *  The builder has two filters for the block and the block state, which need to be configured separately.  
                             *  If one function is not defined, it will just be ignored when building the scanner.<br>  
                             *  The block and block state filters have to start with a 'with' command like {@link #withStateFilter} or {@link #withStringBlockFilter}.  
                             *  This will overwrite all previous filters of the same type. To add more commands, it's possible to use commands with the prefix 'and', 'or', 'xor'.  
                             *  The 'not' command will just negate the whole block or block state filter and doesn't need any arguments.<br>  
                             *
                             *  All other commands need some arguments to work. For String functions, it's one of these functions: 'equals', 'contains', 'startsWith', 'endsWith' or 'matches'.  
                             *  The strings to match are passed as vararg parameters (as many as needed, separated by a comma `is("chest", "barrel", "ore"`) and the filter acts
                             *  like a logical or, so only one of the arguments needs to match the criteria. It should be noted, that string functions call the toString method, so
                             *  comparing a block with something like "minecraft:stone" will always return false, because the toString method gives "{minecraft:stone}". For doing this
                             *  use either contains or the equals method with 'getId', as shown later.<br>  
                             *  This will match any block that includes 'stone' or 'diorit' in its name:  
                             *  ```  
                             *  withStringBlockFilter().contains("stone") //create new block filter, check if it contains stone
                             *  .orStringBlockFilter().contains("diorit") //append new block filter with or and check if it contains diorit
                             *  ```  
                             *
                             *  For non String functions, the method name must be passed when creating the filter. The names can be any method in {@link BlockStateHelper} or {@link BlockHelper}.  
                             *  For more complex filters, use the MethodWrapper function {@link xyz.wagyourtail.jsmacros.client.api.library.impl.FWorld#getWorldScanner}.  
                             *  Depending on the return type of the method, the following parameters must be passed to 'is' or 'test'. There are two methods, because 'is' is a keyword in some languages.<br>  
                             *  ```  
                             *  For any number:  
                             *    - is(operation, number) with operation = '>', '>=', '<', '<=', '==', '!=' and the number that should be compared to,  
                             *      i.e. is(">=", 8) returns true if the returned number is greater or equal to 8.  
                             *  For any String:  
                             *    - is(method, string) with method = 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH', 'MATCHES' and the string is the one to compare the returned value to,  
                             *      i.e. is("ENDS_WITH", "ore") checks if the returned string ends with ore (can be used with withBlockFilter("getId")).  
                             *  For any Boolean:  
                             *    - is(val) with val either `true` or `false`
                             *      i.e. is(false) returns true if the returned boolean value is false
                             *  ```
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            const WorldScannerBuilder: JavaClassStatics<WorldScannerBuilder, WorldScannerBuilder$$constructor>;
                            interface WorldScannerBuilder$$constructor extends SuppressProperties {

                                new (): WorldScannerBuilder;

                            }
                            interface WorldScannerBuilder extends JavaObject {

                                withStateFilter(method: BooStrNumMethod<BlockStateHelper>): WorldScannerBuilder;
                                andStateFilter(method: BooStrNumMethod<BlockStateHelper>): WorldScannerBuilder;
                                orStateFilter(method: BooStrNumMethod<BlockStateHelper>): WorldScannerBuilder;
                                notStateFilter(): WorldScannerBuilder;
                                withBlockFilter(method: BooStrNumMethod<BlockHelper>): WorldScannerBuilder;
                                andBlockFilter(method: BooStrNumMethod<BlockHelper>): WorldScannerBuilder;
                                orBlockFilter(method: BooStrNumMethod<BlockHelper>): WorldScannerBuilder;
                                notBlockFilter(): WorldScannerBuilder;
                                withStringBlockFilter(): WorldScannerBuilder;
                                andStringBlockFilter(): WorldScannerBuilder;
                                orStringBlockFilter(): WorldScannerBuilder;
                                withStringStateFilter(): WorldScannerBuilder;
                                andStringStateFilter(): WorldScannerBuilder;
                                orStringStateFilter(): WorldScannerBuilder;
                                is(...args: any[]): $WorldScannerBuilder;
                                /** for boolean value */
                                is(value: boolean): $WorldScannerBuilder;
                                /** for string value */
                                is(method: StringFilterMethod, value: string): $WorldScannerBuilder;
                                /** for char value */
                                is(value: string): $WorldScannerBuilder;
                                /** for number value */
                                is(operation: NumberFilterOperation, value: number): WorldScannerBuilder;
                                is(methodArgs: any[], filterArgs: any[]): $WorldScannerBuilder;
                                /** for boolean value */
                                is(methodArgs: any[], filterArgs: [boolean]): $WorldScannerBuilder;
                                /** for string value */
                                is(methodArgs: any[], filterArgs: [StringFilterMethod, string]): $WorldScannerBuilder;
                                /** for char value */
                                is(methodArgs: any[], filterArgs: [string]): $WorldScannerBuilder;
                                /** for number value */
                                is(methodArgs: any[], filterArgs: [NumberFilterOperation, number]): WorldScannerBuilder;
                                test(...args: any[]): $WorldScannerBuilder;
                                /** for boolean value */
                                test(value: boolean): $WorldScannerBuilder;
                                /** for string value */
                                test(method: StringFilterMethod, value: string): $WorldScannerBuilder;
                                /** for char value */
                                test(value: string): $WorldScannerBuilder;
                                /** for number value */
                                test(operation: NumberFilterOperation, value: number): WorldScannerBuilder;
                                test(methodArgs: any[], filterArgs: any[]): $WorldScannerBuilder;
                                /** for boolean value */
                                test(methodArgs: any[], filterArgs: [boolean]): $WorldScannerBuilder;
                                /** for string value */
                                test(methodArgs: any[], filterArgs: [StringFilterMethod, string]): $WorldScannerBuilder;
                                /** for char value */
                                test(methodArgs: any[], filterArgs: [string]): $WorldScannerBuilder;
                                /** for number value */
                                test(methodArgs: any[], filterArgs: [NumberFilterOperation, number]): WorldScannerBuilder;
                                equals(...args: string[]): WorldScannerBuilder;
                                equals(arg0: any): boolean;
                                contains(...args: string[]): WorldScannerBuilder;
                                startsWith(...args: string[]): WorldScannerBuilder;
                                endsWith(...args: string[]): WorldScannerBuilder;
                                matches(...args: string[]): WorldScannerBuilder;
                                build(): WorldScanner;

                            }

                            /**
                             * A class to scan the world for certain blocks. The results of the filters are cached,  
                             *  so it's a good idea to reuse an instance of this if possible.  
                             *  The scanner can either return a list of all block positions or
                             *  a list of blocks and their respective count for every block / state matching the filters criteria.
                             * @author Etheradon
                             * @since 1.6.5
                             */
                            const WorldScanner: JavaClassStatics<WorldScanner, WorldScanner$$constructor>;
                            interface WorldScanner$$constructor extends SuppressProperties {

                                /**
                                 * Creates a new World scanner with for the given world. It accepts two boolean functions,  
                                 *  one for {@link BlockHelper} and the other for {@link BlockStateHelper}.
                                 * @param world the world to scan
                                 * @param blockFilter a filter method for the blocks
                                 * @param stateFilter a filter method for the block states
                                 */
                                new (world: /* minecraft class */ any, blockFilter: java.util.function.Function<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper, boolean>, stateFilter: java.util.function.Function<xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper, boolean>): WorldScanner;

                            }
                            interface WorldScanner extends JavaObject {

                                /**
                                 * Gets a list of all chunks in the given range around the center chunk.
                                 * @param centerX the x coordinate of the center chunk to scan around
                                 * @param centerZ the z coordinate of the center chunk to scan around
                                 * @param chunkrange the range to scan around the center chunk
                                 * @return a list of all matching block positions.
                                 */
                                getChunkRange(centerX: int, centerZ: int, chunkrange: int): JavaList</* minecraft class */ any>;

                                /**
                                 * Scans all chunks in the given range around the player and returns a list of all block positions, for blocks matching the filter.  
                                 *  This will scan in a square with length 2*range + 1. So range = 0 for example will only scan the chunk the player
                                 *  is standing in, while range = 1 will scan in a 3x3 area.
                                 * @param chunkRange the range to scan around the center chunk
                                 * @return a list of all matching block positions.
                                 */
                                scanAroundPlayer(chunkRange: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * Scans all chunks in the given range around the center chunk and returns a list of all block positions, for blocks matching the filter.  
                                 *  This will scan in a square with length 2*range + 1. So range = 0 for example will only scan the specified chunk,  
                                 *  while range = 1 will scan in a 3x3 area.
                                 * @param centerX the x coordinate of the center chunk to scan around
                                 * @param centerZ the z coordinate of the center chunk to scan around
                                 * @param chunkrange the range to scan around the center chunk
                                 * @return a list of all matching block positions.
                                 */
                                scanChunkRange(centerX: int, centerZ: int, chunkrange: int): JavaList<xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D>;

                                /**
                                 * Gets the amount of all blocks matching the criteria inside the chunk.
                                 * @param chunkX the x coordinate of the chunk to scan
                                 * @param chunkZ the z coordinate of the chunk to scan
                                 * @param ignoreState whether multiple states should be combined to a single block
                                 * @return a map of all blocks inside the specified chunk and their respective count.
                                 */
                                getBlocksInChunk(chunkX: int, chunkZ: int, ignoreState: boolean): JavaMap<string, number>;

                                /**
                                 * Gets the amount of all blocks matching the criteria inside a square around the player.
                                 * @param centerX the x coordinate of the center chunk to scan around
                                 * @param centerZ the z coordinate of the center chunk to scan around
                                 * @param chunkRange the range to scan around the center chunk
                                 * @param ignoreState whether multiple states should be combined to a single block
                                 * @return a map of all blocks inside the specified chunks and their respective count.
                                 */
                                getBlocksInChunks(centerX: int, centerZ: int, chunkRange: int, ignoreState: boolean): JavaMap<string, number>;

                                /**
                                 * Get the amount of cached block states. This will normally be around 200 - 400.
                                 * @return the amount of cached block states.
                                 */
                                getCachedAmount(): number;

                            }

                            export { WorldScannerBuilder, WorldScanner }

                        }

                    }

                }

                namespace gui {

                    namespace editor {

                        const SelectCursor: JavaClassStatics<SelectCursor, SelectCursor$$constructor>;
                        interface SelectCursor$$constructor extends SuppressProperties {

                            new (defaultStyle: /* minecraft class */ any): SelectCursor;

                        }
                        interface SelectCursor extends JavaObject {
                            onChange: java.util.function.Consumer<SelectCursor>;
                            defaultStyle: /* minecraft class */ any;
                            startLine: number;
                            endLine: number;
                            startIndex: number;
                            endIndex: number;
                            startLineIndex: number;
                            endLineIndex: number;
                            dragStartIndex: number;
                            arrowLineIndex: number;
                            arrowEnd: boolean;
                            startCol: number;
                            endCol: number;

                            updateStartIndex(startIndex: int, current: string): void;
                            updateEndIndex(endIndex: int, current: string): void;

                        }

                        const History: JavaClassStatics<History, History$$constructor>;
                        interface History$$constructor extends SuppressProperties {

                            new (start: string, cursor: SelectCursor): History;

                        }
                        interface History extends JavaObject {
                            onChange: java.util.function.Consumer<string>;
                            current: string;

                            /**
                             * @param position
                             * @param content
                             * @return is new step.
                             */
                            addChar(position: int, content: char): boolean;
                            add(position: int, content: string): boolean;

                            /**
                             * @param position
                             * @return is new step.
                             */
                            deletePos(position: int, length: int): boolean;

                            /**
                             * @param position
                             * @return is new step
                             */
                            bkspacePos(position: int, length: int): boolean;
                            shiftLine(startLine: int, lines: int, shiftDown: boolean): boolean;
                            replace(position: int, length: int, content: string): void;
                            tabLines(startLine: int, lineCount: int, reverse: boolean): void;
                            tabLinesKeepCursor(startLine: int, startLineIndex: int, endLineIndex: int, lineCount: int, reverse: boolean): void;

                            /**
                             * @return position of step. -1 if nothing to undo.
                             */
                            undo(): number;

                            /**
                             * @return position of step. -1 if nothing to redo.
                             */
                            redo(): number;

                        }

                        export { SelectCursor, History }

                    }
                    namespace editor {

                        namespace highlighting {

                            const AutoCompleteSuggestion: JavaClassStatics<AutoCompleteSuggestion, AutoCompleteSuggestion$$constructor>;
                            interface AutoCompleteSuggestion$$constructor extends SuppressProperties {

                                new (startIndex: int, suggestion: string): AutoCompleteSuggestion;
                                new (startIndex: int, suggestion: string, displayText: /* minecraft class */ any): AutoCompleteSuggestion;

                            }
                            interface AutoCompleteSuggestion extends JavaObject {
                                readonly startIndex: number;
                                readonly suggestion: string;
                                readonly displayText: /* minecraft class */ any;
                            }

                            const AbstractRenderCodeCompiler: JavaClassStatics<AbstractRenderCodeCompiler, AbstractRenderCodeCompiler$$constructor>;
                            interface AbstractRenderCodeCompiler$$constructor extends SuppressProperties {

                                new (language: string, screen: xyz.wagyourtail.jsmacros.client.gui.screens.EditorScreen): AbstractRenderCodeCompiler;

                            }
                            interface AbstractRenderCodeCompiler extends JavaObject {

                                recompileRenderedText(text: string): void;
                                getRightClickOptions(index: int): JavaMap<string, java.lang.Runnable>;
                                getRenderedText(): JavaArray</* minecraft class */ any>;
                                getSuggestions(): JavaList<AutoCompleteSuggestion>;

                            }

                            export { AutoCompleteSuggestion, AbstractRenderCodeCompiler }

                        }

                    }

                    namespace screens {

                        const EditorScreen: JavaClassStatics<EditorScreen, EditorScreen$$constructor> & {
                            readonly langs: JavaList<string>;
                            defaultStyle: /* minecraft class */ any;

                            openAndScrollToIndex(file: java.io.File, startIndex: int, endIndex: int): void;
                            openAndScrollToLine(file: java.io.File, line: int, col: int, endCol: int): void;

                        }
                        interface EditorScreen$$constructor extends SuppressProperties {

                            new (parent: /* minecraft class */ any, file: java.io.File): EditorScreen;

                        }
                        interface EditorScreen extends xyz.wagyourtail.wagyourgui.BaseScreen {
                            readonly history: xyz.wagyourtail.jsmacros.client.gui.editor.History;
                            readonly cursor: xyz.wagyourtail.jsmacros.client.gui.editor.SelectCursor;
                            blockFirst: boolean;
                            textRenderTime: number;
                            prevChar: number;
                            language: string;
                            codeCompiler: xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AbstractRenderCodeCompiler;

                            getDefaultLanguage(): string;
                            setScroll(pages: double): void;
                            setLanguage(language: string): void;
                            copyToClipboard(): void;
                            pasteFromClipboard(): void;
                            cutToClipboard(): void;
                            scrollToCursor(): void;
                            save(): void;
                            needSave(): boolean;
                            openParent(): void;
                            selectWordAtCursor(): void;
                            updateSettings(): void;

                        }

                        export { EditorScreen }

                    }

                }

            }

        }

        namespace wagyourgui {

            const BaseScreen: JavaClassStatics<BaseScreen> & NoConstructor & {

                trimmed(textRenderer: /* minecraft class */ any, str: /* minecraft class */ any, width: int): /* minecraft class */ any;

            }
            interface BaseScreen extends /* supressed minecraft class */ JavaObject, xyz.wagyourtail.wagyourgui.overlays.IOverlayParent, xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen {

                setParent(parent: /* minecraft class */ any): void;
                reload(): void;
                openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                getFirstOverlayParent(): xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;
                getChildOverlay(): xyz.wagyourtail.wagyourgui.overlays.OverlayContainer;
                openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer, disableButtons: boolean): void;
                closeOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                updateSettings(): void;
                openParent(): void;

            }

            export { BaseScreen }

        }
        namespace wagyourgui {

            namespace overlays {

                const IOverlayParent: JavaInterfaceStatics<IOverlayParent>;
                interface IOverlayParent extends xyz.wagyourtail.wagyourgui.containers.IContainerParent {

                    closeOverlay(overlay: OverlayContainer): void;
                    setFocused(focused: /* minecraft class */ any | null): void;
                    getChildOverlay(): OverlayContainer;

                }

                const OverlayContainer: JavaClassStatics<OverlayContainer, OverlayContainer$$constructor>;
                interface OverlayContainer$$constructor extends SuppressProperties {

                    new (x: int, y: int, width: int, height: int, textRenderer: /* minecraft class */ any, parent: IOverlayParent): OverlayContainer;

                }
                interface OverlayContainer extends xyz.wagyourtail.wagyourgui.containers.MultiElementContainer<IOverlayParent>, IOverlayParent {
                    savedBtnStates: JavaMap</* minecraft class */ any, boolean>;
                    scroll: xyz.wagyourtail.wagyourgui.elements.Scrollbar;

                    remove(btn: /* minecraft class */ any): void;
                    openOverlay(overlay: OverlayContainer): void;
                    getFirstOverlayParent(): IOverlayParent;
                    openOverlay(overlay: OverlayContainer, disableButtons: boolean): void;
                    getChildOverlay(): OverlayContainer;
                    closeOverlay(overlay: OverlayContainer): void;
                    setFocused(focused: /* minecraft class */ any | null): void;
                    onClick(mouseX: double, mouseY: double, button: int): void;

                    /**
                     * @return true if should be handled by overlay
                     */
                    keyPressed(keyCode: int, scanCode: int, modifiers: int): boolean;
                    close(): void;
                    onClose(): void;
                    renderBackground(matrices: /* minecraft class */ any): void;
                    render(matrices: /* minecraft class */ any, mouseX: int, mouseY: int, delta: float): void;

                }

                export { IOverlayParent, OverlayContainer }

            }

            namespace containers {

                const MultiElementContainer: JavaClassStatics<MultiElementContainer<any>, MultiElementContainer$$constructor>;
                interface MultiElementContainer$$constructor extends SuppressProperties {

                    new <T extends IContainerParent>(x: int, y: int, width: int, height: int, textRenderer: /* minecraft class */ any, parent: T): MultiElementContainer<T>;

                }
                interface MultiElementContainer<T extends IContainerParent> extends /* supressed minecraft class */ JavaObject, IContainerParent {
                    readonly parent: T;
                    x: number;
                    y: number;
                    width: number;
                    height: number;

                    init(): void;
                    getVisible(): boolean;
                    setVisible(visible: boolean): void;
                    addDrawableChild<T extends (/* minecraft class */ any & /* minecraft class */ any & /* minecraft class */ any)>(drawableElement: T): T;
                    getButtons(): JavaList</* minecraft class */ any>;
                    setPos(x: int, y: int, width: int, height: int): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer, disableButtons: boolean): void;
                    remove(button: /* minecraft class */ any): void;
                    getFirstOverlayParent(): xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;
                    render(matrices: /* minecraft class */ any, mouseX: int, mouseY: int, delta: float): void;

                }

                const IContainerParent: JavaInterfaceStatics<IContainerParent>;
                interface IContainerParent extends JavaObject {

                    addDrawableChild<T extends (/* minecraft class */ any & /* minecraft class */ any & /* minecraft class */ any)>(drawableElement: T): T;
                    remove(button: /* minecraft class */ any): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer): void;
                    openOverlay(overlay: xyz.wagyourtail.wagyourgui.overlays.OverlayContainer, disableButtons: boolean): void;
                    getFirstOverlayParent(): xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;

                }

                export { MultiElementContainer, IContainerParent }

            }

            namespace elements {

                /**
                 * @author Etheradon
                 * @since 1.8.4
                 */
                const Slider: JavaClassStatics<Slider, Slider$$constructor>;
                interface Slider$$constructor extends SuppressProperties {

                    new (x: int, y: int, width: int, height: int, text: /* minecraft class */ any, value: double, action: java.util.function.Consumer<Slider>, steps: int): Slider;
                    new (x: int, y: int, width: int, height: int, text: /* minecraft class */ any, value: double, action: java.util.function.Consumer<Slider>): Slider;

                }
                interface Slider extends /* supressed minecraft class */ JavaObject {

                    roundValue(value: double): number;
                    getValue(): number;
                    setValue(mouseX: double): void;
                    getSteps(): number;
                    setSteps(steps: int): void;
                    setMessage(message: string): void;

                }

                /**
                 * @author Etheradon
                 * @since 1.8.4
                 */
                const CheckBox: JavaClassStatics<CheckBox, CheckBox$$constructor>;
                interface CheckBox$$constructor extends SuppressProperties {

                    new (x: int, y: int, width: int, height: int, text: /* minecraft class */ any, checked: boolean, action: java.util.function.Consumer<CheckBox>): CheckBox;
                    new (x: int, y: int, width: int, height: int, text: /* minecraft class */ any, checked: boolean, showMessage: boolean, action: java.util.function.Consumer<CheckBox>): CheckBox;

                }
                interface CheckBox extends /* supressed minecraft class */ JavaObject {}

                const Scrollbar: JavaClassStatics<Scrollbar, Scrollbar$$constructor>;
                interface Scrollbar$$constructor extends SuppressProperties {

                    new (x: int, y: int, width: int, height: int, color: int, borderColor: int, highlightColor: int, scrollPages: double, onChange: java.util.function.Consumer<double>): Scrollbar;

                }
                interface Scrollbar extends /* supressed minecraft class */ JavaObject {

                    setPos(x: int, y: int, width: int, height: int): Scrollbar;
                    setScrollPages(scrollPages: double): void;
                    scrollToPercent(percent: double): void;
                    onChange(): void;

                }

                export { Slider, CheckBox, Scrollbar }

            }

        }

    }

    namespace com {

        namespace mojang {

            namespace brigadier {

                const AmbiguityConsumer: JavaInterfaceStatics<AmbiguityConsumer<any>>;
                interface AmbiguityConsumer<S> extends JavaObject {

                    ambiguous(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.tree.CommandNode<S>, arg2: com.mojang.brigadier.tree.CommandNode<S>, arg3: JavaCollection<string>): void;

                }

                const Command: JavaInterfaceStatics<Command<any>> & {
                    readonly SINGLE_SUCCESS: number;
                }
                interface Command<S> extends JavaObject {

                    run(arg0: com.mojang.brigadier.context.CommandContext<S>): number;

                }

                const StringReader: JavaClassStatics<StringReader, StringReader$$constructor> & {

                    isAllowedNumber(arg0: char): boolean;
                    isQuotedStringStart(arg0: char): boolean;
                    isAllowedInUnquotedString(arg0: char): boolean;

                }
                interface StringReader$$constructor extends SuppressProperties {

                    new (arg0: StringReader): StringReader;
                    new (arg0: string): StringReader;

                }
                interface StringReader extends ImmutableStringReader {

                    getString(): string;
                    setCursor(arg0: int): void;
                    getRemainingLength(): number;
                    getTotalLength(): number;
                    getCursor(): number;
                    getRead(): string;
                    getRemaining(): string;
                    canRead(arg0: int): boolean;
                    canRead(): boolean;
                    peek(): number;
                    peek(arg0: int): number;
                    read(): number;
                    skip(): void;
                    skipWhitespace(): void;
                    readInt(): number;
                    readLong(): number;
                    readDouble(): number;
                    readFloat(): number;
                    readUnquotedString(): string;
                    readQuotedString(): string;
                    readStringUntil(arg0: char): string;
                    readString(): string;
                    readBoolean(): boolean;
                    expect(arg0: char): void;

                }

                const ImmutableStringReader: JavaInterfaceStatics<ImmutableStringReader>;
                interface ImmutableStringReader extends JavaObject {

                    getString(): string;
                    getRemainingLength(): number;
                    getTotalLength(): number;
                    getCursor(): number;
                    getRead(): string;
                    getRemaining(): string;
                    canRead(arg0: int): boolean;
                    canRead(): boolean;
                    peek(): number;
                    peek(arg0: int): number;

                }

                const Message: JavaInterfaceStatics<Message>;
                interface Message extends JavaObject {

                    getString(): string;

                }

                const CommandDispatcher: JavaClassStatics<CommandDispatcher<any>, CommandDispatcher$$constructor> & {
                    readonly ARGUMENT_SEPARATOR: string;
                    readonly ARGUMENT_SEPARATOR_CHAR: number;
                }
                interface CommandDispatcher$$constructor extends SuppressProperties {

                    new <S>(arg0: com.mojang.brigadier.tree.RootCommandNode<S>): CommandDispatcher<S>;
                    new <S>(): CommandDispatcher<S>;

                }
                interface CommandDispatcher<S> extends JavaObject {

                    register(arg0: com.mojang.brigadier.builder.LiteralArgumentBuilder<S>): com.mojang.brigadier.tree.LiteralCommandNode<S>;
                    setConsumer(arg0: ResultConsumer<S>): void;
                    execute(arg0: string, arg1: S): number;
                    execute(arg0: StringReader, arg1: S): number;
                    execute(arg0: ParseResults<S>): number;
                    parse(arg0: string, arg1: S): ParseResults<S>;
                    parse(arg0: StringReader, arg1: S): ParseResults<S>;
                    getAllUsage(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: S, arg2: boolean): JavaArray<string>;
                    getSmartUsage(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: S): JavaMap<com.mojang.brigadier.tree.CommandNode<S>, string>;
                    getCompletionSuggestions(arg0: ParseResults<S>): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                    getCompletionSuggestions(arg0: ParseResults<S>, arg1: int): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                    getRoot(): com.mojang.brigadier.tree.RootCommandNode<S>;
                    getPath(arg0: com.mojang.brigadier.tree.CommandNode<S>): JavaCollection<string>;
                    findNode(arg0: JavaCollection<string>): com.mojang.brigadier.tree.CommandNode<S>;
                    findAmbiguities(arg0: AmbiguityConsumer<S>): void;

                }

                const RedirectModifier: JavaInterfaceStatics<RedirectModifier<any>>;
                interface RedirectModifier<S> extends JavaObject {

                    apply(arg0: com.mojang.brigadier.context.CommandContext<S>): JavaCollection<S>;

                }

                const ParseResults: JavaClassStatics<ParseResults<any>, ParseResults$$constructor>;
                interface ParseResults$$constructor extends SuppressProperties {

                    new <S>(arg0: com.mojang.brigadier.context.CommandContextBuilder<S>, arg1: ImmutableStringReader, arg2: JavaMap<com.mojang.brigadier.tree.CommandNode<S>, com.mojang.brigadier.exceptions.CommandSyntaxException>): ParseResults<S>;
                    new <S>(arg0: com.mojang.brigadier.context.CommandContextBuilder<S>): ParseResults<S>;

                }
                interface ParseResults<S> extends JavaObject {

                    getContext(): com.mojang.brigadier.context.CommandContextBuilder<S>;
                    getReader(): ImmutableStringReader;
                    getExceptions(): JavaMap<com.mojang.brigadier.tree.CommandNode<S>, com.mojang.brigadier.exceptions.CommandSyntaxException>;

                }

                const ResultConsumer: JavaInterfaceStatics<ResultConsumer<any>>;
                interface ResultConsumer<S> extends JavaObject {

                    onCommandComplete(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: boolean, arg2: int): void;

                }

                const SingleRedirectModifier: JavaInterfaceStatics<SingleRedirectModifier<any>>;
                interface SingleRedirectModifier<S> extends JavaObject {

                    apply(arg0: com.mojang.brigadier.context.CommandContext<S>): S;

                }

                export {
                    AmbiguityConsumer,
                    Command,
                    StringReader,
                    ImmutableStringReader,
                    Message,
                    CommandDispatcher,
                    RedirectModifier,
                    ParseResults,
                    ResultConsumer,
                    SingleRedirectModifier
                }

            }
            namespace brigadier {

                namespace context {

                    const StringRange: JavaClassStatics<StringRange, StringRange$$constructor> & {

                        at(arg0: int): StringRange;
                        between(arg0: int, arg1: int): StringRange;
                        encompassing(arg0: StringRange, arg1: StringRange): StringRange;

                    }
                    interface StringRange$$constructor extends SuppressProperties {

                        new (arg0: int, arg1: int): StringRange;

                    }
                    interface StringRange extends JavaObject {

                        getStart(): number;
                        getEnd(): number;
                        get(arg0: com.mojang.brigadier.ImmutableStringReader): string;
                        get(arg0: string): string;
                        isEmpty(): boolean;
                        getLength(): number;

                    }

                    const CommandContextBuilder: JavaClassStatics<CommandContextBuilder<any>, CommandContextBuilder$$constructor>;
                    interface CommandContextBuilder$$constructor extends SuppressProperties {

                        new <S>(arg0: com.mojang.brigadier.CommandDispatcher<S>, arg1: S, arg2: com.mojang.brigadier.tree.CommandNode<S>, arg3: int): CommandContextBuilder<S>;

                    }
                    interface CommandContextBuilder<S> extends JavaObject {

                        withSource(arg0: S): CommandContextBuilder<S>;
                        getSource(): S;
                        getRootNode(): com.mojang.brigadier.tree.CommandNode<S>;
                        withArgument(arg0: string, arg1: ParsedArgument<S, any>): CommandContextBuilder<S>;
                        getArguments(): JavaMap<string, ParsedArgument<S, any>>;
                        withCommand(arg0: com.mojang.brigadier.Command<S>): CommandContextBuilder<S>;
                        withNode(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: StringRange): CommandContextBuilder<S>;
                        copy(): CommandContextBuilder<S>;
                        withChild(arg0: CommandContextBuilder<S>): CommandContextBuilder<S>;
                        getChild(): CommandContextBuilder<S>;
                        getLastChild(): CommandContextBuilder<S>;
                        getCommand(): com.mojang.brigadier.Command<S>;
                        getNodes(): JavaList<ParsedCommandNode<S>>;
                        build(arg0: string): CommandContext<S>;
                        getDispatcher(): com.mojang.brigadier.CommandDispatcher<S>;
                        getRange(): StringRange;
                        findSuggestionContext(arg0: int): SuggestionContext<S>;

                    }

                    const CommandContext: JavaClassStatics<CommandContext<any>, CommandContext$$constructor>;
                    interface CommandContext$$constructor extends SuppressProperties {

                        new <S>(arg0: S, arg1: string, arg2: JavaMap<string, ParsedArgument<S, any>>, arg3: com.mojang.brigadier.Command<S>, arg4: com.mojang.brigadier.tree.CommandNode<S>, arg5: JavaList<ParsedCommandNode<S>>, arg6: StringRange, arg7: CommandContext<S>, arg8: com.mojang.brigadier.RedirectModifier<S>, arg9: boolean): CommandContext<S>;

                    }
                    interface CommandContext<S> extends JavaObject {

                        copyFor(arg0: S): CommandContext<S>;
                        getChild(): CommandContext<S>;
                        getLastChild(): CommandContext<S>;
                        getCommand(): com.mojang.brigadier.Command<S>;
                        getSource(): S;
                        getArgument<V>(arg0: string, arg1: JavaClassArg<V>): V;
                        getRedirectModifier(): com.mojang.brigadier.RedirectModifier<S>;
                        getRange(): StringRange;
                        getInput(): string;
                        getRootNode(): com.mojang.brigadier.tree.CommandNode<S>;
                        getNodes(): JavaList<ParsedCommandNode<S>>;
                        hasNodes(): boolean;
                        isForked(): boolean;

                    }

                    const SuggestionContext: JavaClassStatics<SuggestionContext<any>, SuggestionContext$$constructor>;
                    interface SuggestionContext$$constructor extends SuppressProperties {

                        new <S>(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: int): SuggestionContext<S>;

                    }
                    interface SuggestionContext<S> extends JavaObject {
                        readonly parent: com.mojang.brigadier.tree.CommandNode<S>;
                        readonly startPos: number;
                    }

                    const ParsedArgument: JavaClassStatics<ParsedArgument<any, any>, ParsedArgument$$constructor>;
                    interface ParsedArgument$$constructor extends SuppressProperties {

                        new <S, T>(arg0: int, arg1: int, arg2: T): ParsedArgument<S, T>;

                    }
                    interface ParsedArgument<S, T> extends JavaObject {

                        getRange(): StringRange;
                        getResult(): T;

                    }

                    const ParsedCommandNode: JavaClassStatics<ParsedCommandNode<any>, ParsedCommandNode$$constructor>;
                    interface ParsedCommandNode$$constructor extends SuppressProperties {

                        new <S>(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: StringRange): ParsedCommandNode<S>;

                    }
                    interface ParsedCommandNode<S> extends JavaObject {

                        getNode(): com.mojang.brigadier.tree.CommandNode<S>;
                        getRange(): StringRange;

                    }

                    export {
                        StringRange,
                        CommandContextBuilder,
                        CommandContext,
                        SuggestionContext,
                        ParsedArgument,
                        ParsedCommandNode
                    }

                }

                namespace suggestion {

                    const SuggestionsBuilder: JavaClassStatics<SuggestionsBuilder, SuggestionsBuilder$$constructor>;
                    interface SuggestionsBuilder$$constructor extends SuppressProperties {

                        new (arg0: string, arg1: string, arg2: int): SuggestionsBuilder;
                        new (arg0: string, arg1: int): SuggestionsBuilder;

                    }
                    interface SuggestionsBuilder extends JavaObject {

                        getInput(): string;
                        getStart(): number;
                        getRemaining(): string;
                        getRemainingLowerCase(): string;
                        build(): Suggestions;
                        buildFuture(): java.util.concurrent.CompletableFuture<Suggestions>;
                        suggest(arg0: string): SuggestionsBuilder;
                        suggest(arg0: string, arg1: com.mojang.brigadier.Message): SuggestionsBuilder;
                        suggest(arg0: int): SuggestionsBuilder;
                        suggest(arg0: int, arg1: com.mojang.brigadier.Message): SuggestionsBuilder;
                        add(arg0: SuggestionsBuilder): SuggestionsBuilder;
                        createOffset(arg0: int): SuggestionsBuilder;
                        restart(): SuggestionsBuilder;

                    }

                    const Suggestions: JavaClassStatics<Suggestions, Suggestions$$constructor> & {

                        empty(): java.util.concurrent.CompletableFuture<Suggestions>;
                        merge(arg0: string, arg1: JavaCollection<Suggestions>): Suggestions;
                        create(arg0: string, arg1: JavaCollection<Suggestion>): Suggestions;

                    }
                    interface Suggestions$$constructor extends SuppressProperties {

                        new (arg0: com.mojang.brigadier.context.StringRange, arg1: JavaList<Suggestion>): Suggestions;

                    }
                    interface Suggestions extends JavaObject {

                        getRange(): com.mojang.brigadier.context.StringRange;
                        getList(): JavaList<Suggestion>;
                        isEmpty(): boolean;

                    }

                    const Suggestion: JavaClassStatics<Suggestion, Suggestion$$constructor>;
                    interface Suggestion$$constructor extends SuppressProperties {

                        new (arg0: com.mojang.brigadier.context.StringRange, arg1: string): Suggestion;
                        new (arg0: com.mojang.brigadier.context.StringRange, arg1: string, arg2: com.mojang.brigadier.Message): Suggestion;

                    }
                    interface Suggestion extends java.lang.Comparable<Suggestion> {

                        getRange(): com.mojang.brigadier.context.StringRange;
                        getText(): string;
                        getTooltip(): com.mojang.brigadier.Message;
                        apply(arg0: string): string;
                        compareTo(arg0: Suggestion): number;
                        compareToIgnoreCase(arg0: Suggestion): number;
                        expand(arg0: string, arg1: com.mojang.brigadier.context.StringRange): Suggestion;

                    }

                    export { SuggestionsBuilder, Suggestions, Suggestion }

                }

                namespace tree {

                    const CommandNode: JavaClassStatics<CommandNode<any>> & NoConstructor;
                    interface CommandNode<S> extends java.lang.Comparable<CommandNode<S>> {

                        getCommand(): com.mojang.brigadier.Command<S>;
                        getChildren(): JavaCollection<CommandNode<S>>;
                        getChild(arg0: string): CommandNode<S>;
                        getRedirect(): CommandNode<S>;
                        getRedirectModifier(): com.mojang.brigadier.RedirectModifier<S>;
                        canUse(arg0: S): boolean;
                        addChild(arg0: CommandNode<S>): void;
                        findAmbiguities(arg0: com.mojang.brigadier.AmbiguityConsumer<S>): void;
                        getRequirement(): java.util.function.Predicate<S>;
                        getName(): string;
                        getUsageText(): string;
                        parse(arg0: com.mojang.brigadier.StringReader, arg1: com.mojang.brigadier.context.CommandContextBuilder<S>): void;
                        listSuggestions(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: com.mojang.brigadier.suggestion.SuggestionsBuilder): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                        createBuilder(): com.mojang.brigadier.builder.ArgumentBuilder<S, any>;
                        getRelevantNodes(arg0: com.mojang.brigadier.StringReader): JavaCollection<any>;
                        compareTo(arg0: CommandNode<S>): number;
                        isFork(): boolean;
                        getExamples(): JavaCollection<string>;

                    }

                    const LiteralCommandNode: JavaClassStatics<LiteralCommandNode<any>, LiteralCommandNode$$constructor>;
                    interface LiteralCommandNode$$constructor extends SuppressProperties {

                        new <S>(arg0: string, arg1: com.mojang.brigadier.Command<S>, arg2: java.util.function.Predicate<S>, arg3: CommandNode<S>, arg4: com.mojang.brigadier.RedirectModifier<S>, arg5: boolean): LiteralCommandNode<S>;

                    }
                    interface LiteralCommandNode<S> extends CommandNode<S> {

                        getLiteral(): string;
                        getName(): string;
                        parse(arg0: com.mojang.brigadier.StringReader, arg1: com.mojang.brigadier.context.CommandContextBuilder<S>): void;
                        listSuggestions(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: com.mojang.brigadier.suggestion.SuggestionsBuilder): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                        isValidInput(arg0: string): boolean;
                        getUsageText(): string;
                        createBuilder(): com.mojang.brigadier.builder.LiteralArgumentBuilder<S>;
                        getExamples(): JavaCollection<string>;

                    }

                    const RootCommandNode: JavaClassStatics<RootCommandNode<any>, RootCommandNode$$constructor>;
                    interface RootCommandNode$$constructor extends SuppressProperties {

                        new <S>(): RootCommandNode<S>;

                    }
                    interface RootCommandNode<S> extends CommandNode<S> {

                        getName(): string;
                        getUsageText(): string;
                        parse(arg0: com.mojang.brigadier.StringReader, arg1: com.mojang.brigadier.context.CommandContextBuilder<S>): void;
                        listSuggestions(arg0: com.mojang.brigadier.context.CommandContext<S>, arg1: com.mojang.brigadier.suggestion.SuggestionsBuilder): java.util.concurrent.CompletableFuture<com.mojang.brigadier.suggestion.Suggestions>;
                        isValidInput(arg0: string): boolean;
                        createBuilder(): com.mojang.brigadier.builder.ArgumentBuilder<S, any>;
                        getExamples(): JavaCollection<string>;

                    }

                    export { CommandNode, LiteralCommandNode, RootCommandNode }

                }

                namespace builder {

                    const ArgumentBuilder: JavaClassStatics<ArgumentBuilder<any, any>, ArgumentBuilder$$constructor>;
                    interface ArgumentBuilder$$constructor extends SuppressProperties {

                        new <S, T extends ArgumentBuilder<S, T>>(): ArgumentBuilder<S, T>;

                    }
                    interface ArgumentBuilder<S, T extends ArgumentBuilder<S, T>> extends JavaObject {

                        then(arg0: ArgumentBuilder<S, any>): T;
                        then(arg0: com.mojang.brigadier.tree.CommandNode<S>): T;
                        getArguments(): JavaCollection<com.mojang.brigadier.tree.CommandNode<S>>;
                        executes(arg0: com.mojang.brigadier.Command<S>): T;
                        getCommand(): com.mojang.brigadier.Command<S>;
                        requires(arg0: java.util.function.Predicate<S>): T;
                        getRequirement(): java.util.function.Predicate<S>;
                        redirect(arg0: com.mojang.brigadier.tree.CommandNode<S>): T;
                        redirect(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.SingleRedirectModifier<S>): T;
                        fork(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.RedirectModifier<S>): T;
                        forward(arg0: com.mojang.brigadier.tree.CommandNode<S>, arg1: com.mojang.brigadier.RedirectModifier<S>, arg2: boolean): T;
                        getRedirect(): com.mojang.brigadier.tree.CommandNode<S>;
                        getRedirectModifier(): com.mojang.brigadier.RedirectModifier<S>;
                        isFork(): boolean;
                        build(): com.mojang.brigadier.tree.CommandNode<S>;

                    }

                    const LiteralArgumentBuilder: JavaClassStatics<LiteralArgumentBuilder<any>> & NoConstructor & {

                        literal<S>(arg0: string): LiteralArgumentBuilder<S>;

                    }
                    interface LiteralArgumentBuilder<S> extends ArgumentBuilder<S, LiteralArgumentBuilder<S>> {

                        getLiteral(): string;
                        build(): com.mojang.brigadier.tree.LiteralCommandNode<S>;

                    }

                    export { ArgumentBuilder, LiteralArgumentBuilder }

                }

                namespace exceptions {

                    const CommandSyntaxException: JavaClassStatics<CommandSyntaxException, CommandSyntaxException$$constructor> & {
                        readonly CONTEXT_AMOUNT: number;
                        ENABLE_COMMAND_STACK_TRACES: boolean;
                        BUILT_IN_EXCEPTIONS: BuiltInExceptionProvider;
                    }
                    interface CommandSyntaxException$$constructor extends SuppressProperties {

                        new (arg0: CommandExceptionType, arg1: com.mojang.brigadier.Message): CommandSyntaxException;
                        new (arg0: CommandExceptionType, arg1: com.mojang.brigadier.Message, arg2: string, arg3: int): CommandSyntaxException;

                    }
                    interface CommandSyntaxException extends java.lang.Exception {

                        getMessage(): string;
                        getRawMessage(): com.mojang.brigadier.Message;
                        getContext(): string;
                        getType(): CommandExceptionType;
                        getInput(): string;
                        getCursor(): number;

                    }

                    const BuiltInExceptionProvider: JavaInterfaceStatics<BuiltInExceptionProvider>;
                    interface BuiltInExceptionProvider extends JavaObject {

                        doubleTooLow(): Dynamic2CommandExceptionType;
                        doubleTooHigh(): Dynamic2CommandExceptionType;
                        floatTooLow(): Dynamic2CommandExceptionType;
                        floatTooHigh(): Dynamic2CommandExceptionType;
                        integerTooLow(): Dynamic2CommandExceptionType;
                        integerTooHigh(): Dynamic2CommandExceptionType;
                        longTooLow(): Dynamic2CommandExceptionType;
                        longTooHigh(): Dynamic2CommandExceptionType;
                        literalIncorrect(): DynamicCommandExceptionType;
                        readerExpectedStartOfQuote(): SimpleCommandExceptionType;
                        readerExpectedEndOfQuote(): SimpleCommandExceptionType;
                        readerInvalidEscape(): DynamicCommandExceptionType;
                        readerInvalidBool(): DynamicCommandExceptionType;
                        readerInvalidInt(): DynamicCommandExceptionType;
                        readerExpectedInt(): SimpleCommandExceptionType;
                        readerInvalidLong(): DynamicCommandExceptionType;
                        readerExpectedLong(): SimpleCommandExceptionType;
                        readerInvalidDouble(): DynamicCommandExceptionType;
                        readerExpectedDouble(): SimpleCommandExceptionType;
                        readerInvalidFloat(): DynamicCommandExceptionType;
                        readerExpectedFloat(): SimpleCommandExceptionType;
                        readerExpectedBool(): SimpleCommandExceptionType;
                        readerExpectedSymbol(): DynamicCommandExceptionType;
                        dispatcherUnknownCommand(): SimpleCommandExceptionType;
                        dispatcherUnknownArgument(): SimpleCommandExceptionType;
                        dispatcherExpectedArgumentSeparator(): SimpleCommandExceptionType;
                        dispatcherParseException(): DynamicCommandExceptionType;

                    }

                    const CommandExceptionType: JavaInterfaceStatics<CommandExceptionType>;
                    interface CommandExceptionType extends JavaObject {}

                    const DynamicCommandExceptionType: JavaClassStatics<DynamicCommandExceptionType, DynamicCommandExceptionType$$constructor>;
                    interface DynamicCommandExceptionType$$constructor extends SuppressProperties {

                        new (arg0: java.util.function.Function<any, com.mojang.brigadier.Message>): DynamicCommandExceptionType;

                    }
                    interface DynamicCommandExceptionType extends CommandExceptionType {

                        create(arg0: any): CommandSyntaxException;
                        createWithContext(arg0: com.mojang.brigadier.ImmutableStringReader, arg1: any): CommandSyntaxException;

                    }

                    const Dynamic2CommandExceptionType: JavaClassStatics<Dynamic2CommandExceptionType, Dynamic2CommandExceptionType$$constructor>;
                    interface Dynamic2CommandExceptionType$$constructor extends SuppressProperties {

                        new (arg0: Dynamic2CommandExceptionType$Function): Dynamic2CommandExceptionType;

                    }
                    interface Dynamic2CommandExceptionType extends CommandExceptionType {

                        create(arg0: any, arg1: any): CommandSyntaxException;
                        createWithContext(arg0: com.mojang.brigadier.ImmutableStringReader, arg1: any, arg2: any): CommandSyntaxException;

                    }

                    const SimpleCommandExceptionType: JavaClassStatics<SimpleCommandExceptionType, SimpleCommandExceptionType$$constructor>;
                    interface SimpleCommandExceptionType$$constructor extends SuppressProperties {

                        new (arg0: com.mojang.brigadier.Message): SimpleCommandExceptionType;

                    }
                    interface SimpleCommandExceptionType extends CommandExceptionType {

                        create(): CommandSyntaxException;
                        createWithContext(arg0: com.mojang.brigadier.ImmutableStringReader): CommandSyntaxException;

                    }

                    const Dynamic2CommandExceptionType$Function: JavaInterfaceStatics<Dynamic2CommandExceptionType$Function>;
                    interface Dynamic2CommandExceptionType$Function extends JavaObject {

                        apply(arg0: any, arg1: any): com.mojang.brigadier.Message;

                    }

                    export {
                        CommandSyntaxException,
                        BuiltInExceptionProvider,
                        CommandExceptionType,
                        DynamicCommandExceptionType,
                        Dynamic2CommandExceptionType,
                        SimpleCommandExceptionType,
                        Dynamic2CommandExceptionType$Function
                    }

                }

            }

            namespace authlib {

                const GameProfile: JavaClassStatics<GameProfile, GameProfile$$constructor>;
                interface GameProfile$$constructor extends SuppressProperties {

                    new (arg0: java.util.UUID, arg1: string): GameProfile;

                }
                interface GameProfile extends JavaObject {

                    getId(): java.util.UUID;
                    getName(): string;
                    getProperties(): com.mojang.authlib.properties.PropertyMap;
                    isComplete(): boolean;
                    isLegacy(): boolean;

                }

                export { GameProfile }

            }
            namespace authlib {

                namespace properties {

                    const PropertyMap: JavaClassStatics<PropertyMap, PropertyMap$$constructor>;
                    interface PropertyMap$$constructor extends SuppressProperties {

                        new (): PropertyMap;

                    }
                    interface PropertyMap extends com.google.common.collect.ForwardingMultimap<string, Property> {}

                    const Property: JavaClassStatics<Property, Property$$constructor>;
                    interface Property$$constructor extends SuppressProperties {

                        new (arg0: string, arg1: string): Property;
                        new (arg0: string, arg1: string, arg2: string): Property;

                    }
                    interface Property extends JavaObject {

                        getName(): string;
                        getValue(): string;
                        getSignature(): string;
                        hasSignature(): boolean;
                        /** @deprecated */
                        isSignatureValid(arg0: java.security.PublicKey): boolean;

                    }

                    export { PropertyMap, Property }

                }

            }

        }

        namespace google {

            namespace gson {

                const JsonObject: JavaClassStatics<JsonObject, JsonObject$$constructor>;
                interface JsonObject$$constructor extends SuppressProperties {

                    new (): JsonObject;

                }
                interface JsonObject extends JsonElement {

                    deepCopy(): JsonObject;
                    add(arg0: string, arg1: JsonElement): void;
                    remove(arg0: string): JsonElement;
                    addProperty(arg0: string, arg1: string): void;
                    addProperty(arg0: string, arg1: java.lang.Number): void;
                    addProperty(arg0: string, arg1: boolean): void;
                    addProperty(arg0: string, arg1: char): void;
                    entrySet(): JavaSet<java.util.Map$Entry<string, JsonElement>>;
                    keySet(): JavaSet<string>;
                    size(): number;
                    has(arg0: string): boolean;
                    get(arg0: string): JsonElement;
                    getAsJsonPrimitive(arg0: string): JsonPrimitive;
                    getAsJsonPrimitive(): JsonPrimitive;
                    getAsJsonArray(arg0: string): JsonArray;
                    getAsJsonArray(): JsonArray;
                    getAsJsonObject(arg0: string): JsonObject;
                    getAsJsonObject(): JsonObject;
                    asMap(): JavaMap<string, JsonElement>;

                }

                const JsonPrimitive: JavaClassStatics<JsonPrimitive, JsonPrimitive$$constructor>;
                interface JsonPrimitive$$constructor extends SuppressProperties {

                    new (arg0: boolean): JsonPrimitive;
                    new (arg0: java.lang.Number): JsonPrimitive;
                    new (arg0: string): JsonPrimitive;
                    new (arg0: char): JsonPrimitive;

                }
                interface JsonPrimitive extends JsonElement {

                    deepCopy(): JsonPrimitive;
                    isBoolean(): boolean;
                    getAsBoolean(): boolean;
                    isNumber(): boolean;
                    getAsNumber(): java.lang.Number;
                    isString(): boolean;
                    getAsString(): string;
                    getAsDouble(): number;
                    getAsBigDecimal(): java.math.BigDecimal;
                    getAsBigInteger(): java.math.BigInteger;
                    getAsFloat(): number;
                    getAsLong(): number;
                    getAsShort(): number;
                    getAsInt(): number;
                    getAsByte(): number;
                    /** @deprecated */
                    getAsCharacter(): number;

                }

                const JsonElement: JavaClassStatics<JsonElement, JsonElement$$constructor>;
                interface JsonElement$$constructor extends SuppressProperties {

                    /** @deprecated */
                    new (): JsonElement;

                }
                interface JsonElement extends JavaObject {

                    deepCopy(): JsonElement;
                    isJsonArray(): boolean;
                    isJsonObject(): boolean;
                    isJsonPrimitive(): boolean;
                    isJsonNull(): boolean;
                    getAsJsonObject(): JsonObject;
                    getAsJsonArray(): JsonArray;
                    getAsJsonPrimitive(): JsonPrimitive;
                    getAsJsonNull(): JsonNull;
                    getAsBoolean(): boolean;
                    getAsNumber(): java.lang.Number;
                    getAsString(): string;
                    getAsDouble(): number;
                    getAsFloat(): number;
                    getAsLong(): number;
                    getAsInt(): number;
                    getAsByte(): number;
                    /** @deprecated */
                    getAsCharacter(): number;
                    getAsBigDecimal(): java.math.BigDecimal;
                    getAsBigInteger(): java.math.BigInteger;
                    getAsShort(): number;

                }

                const JsonArray: JavaClassStatics<JsonArray, JsonArray$$constructor>;
                interface JsonArray$$constructor extends SuppressProperties {

                    new (): JsonArray;
                    new (arg0: int): JsonArray;

                }
                interface JsonArray extends JsonElement, java.lang.Iterable<JsonElement> {

                    deepCopy(): JsonArray;
                    add(arg0: boolean): void;
                    add(arg0: char): void;
                    add(arg0: java.lang.Number): void;
                    add(arg0: string): void;
                    add(arg0: JsonElement): void;
                    addAll(arg0: JsonArray): void;
                    set(arg0: int, arg1: JsonElement): JsonElement;
                    remove(arg0: JsonElement): boolean;
                    remove(arg0: int): JsonElement;
                    contains(arg0: JsonElement): boolean;
                    size(): number;
                    isEmpty(): boolean;
                    iterator(): java.util.Iterator<JsonElement>;
                    get(arg0: int): JsonElement;
                    getAsNumber(): java.lang.Number;
                    getAsString(): string;
                    getAsDouble(): number;
                    getAsBigDecimal(): java.math.BigDecimal;
                    getAsBigInteger(): java.math.BigInteger;
                    getAsFloat(): number;
                    getAsLong(): number;
                    getAsInt(): number;
                    getAsByte(): number;
                    /** @deprecated */
                    getAsCharacter(): number;
                    getAsShort(): number;
                    getAsBoolean(): boolean;
                    asList(): JavaList<JsonElement>;

                }

                const JsonNull: JavaClassStatics<JsonNull, JsonNull$$constructor> & {
                    readonly INSTANCE: JsonNull;
                }
                interface JsonNull$$constructor extends SuppressProperties {

                    /** @deprecated */
                    new (): JsonNull;

                }
                interface JsonNull extends JsonElement {

                    deepCopy(): JsonNull;

                }

                export { JsonObject, JsonPrimitive, JsonElement, JsonArray, JsonNull }

            }

            namespace common.collect {

                const ForwardingObject: JavaClassStatics<ForwardingObject> & NoConstructor;
                interface ForwardingObject extends JavaObject {}

                const ForwardingMultimap: JavaClassStatics<ForwardingMultimap<any, any>> & NoConstructor;
                interface ForwardingMultimap<K, V> extends ForwardingObject, Multimap<K, V> {

                    asMap(): JavaMap<K, JavaCollection<V>>;
                    clear(): void;
                    containsEntry(arg0: any, arg1: any): boolean;
                    containsKey(arg0: any): boolean;
                    containsValue(arg0: any): boolean;
                    entries(): JavaCollection<java.util.Map$Entry<K, V>>;
                    get(arg0: K): JavaCollection<V>;
                    isEmpty(): boolean;
                    keys(): Multiset<K>;
                    keySet(): JavaSet<K>;
                    put(arg0: K, arg1: V): boolean;
                    putAll(arg0: K, arg1: java.lang.Iterable<any>): boolean;
                    putAll(arg0: Multimap<any, any>): boolean;
                    remove(arg0: any, arg1: any): boolean;
                    removeAll(arg0: any): JavaCollection<V>;
                    replaceValues(arg0: K, arg1: java.lang.Iterable<any>): JavaCollection<V>;
                    size(): number;
                    values(): JavaCollection<V>;

                }

                const Multimap: JavaInterfaceStatics<Multimap<any, any>>;
                interface Multimap<K, V> extends JavaObject {

                    size(): number;
                    isEmpty(): boolean;
                    containsKey(arg0: any): boolean;
                    containsValue(arg0: any): boolean;
                    containsEntry(arg0: any, arg1: any): boolean;
                    put(arg0: K, arg1: V): boolean;
                    remove(arg0: any, arg1: any): boolean;
                    putAll(arg0: K, arg1: java.lang.Iterable<any>): boolean;
                    putAll(arg0: Multimap<any, any>): boolean;
                    replaceValues(arg0: K, arg1: java.lang.Iterable<any>): JavaCollection<V>;
                    removeAll(arg0: any): JavaCollection<V>;
                    clear(): void;
                    get(arg0: K): JavaCollection<V>;
                    keySet(): JavaSet<K>;
                    keys(): Multiset<K>;
                    values(): JavaCollection<V>;
                    entries(): JavaCollection<java.util.Map$Entry<K, V>>;
                    forEach(arg0: java.util.function.BiConsumer<any, any>): void;
                    asMap(): JavaMap<K, JavaCollection<V>>;

                }

                const Multiset: JavaInterfaceStatics<Multiset<any>>;
                interface Multiset<E> extends JavaCollection<E> {

                    size(): number;
                    count(arg0: any): number;
                    add(arg0: E, arg1: int): number;
                    add(arg0: E): boolean;
                    remove(arg0: any, arg1: int): number;
                    remove(arg0: any): boolean;
                    setCount(arg0: E, arg1: int): number;
                    setCount(arg0: E, arg1: int, arg2: int): boolean;
                    elementSet(): JavaSet<E>;
                    entrySet(): JavaSet<Multiset$Entry<E>>;
                    forEachEntry(arg0: java.util.function.ObjIntConsumer<any>): void;
                    iterator(): java.util.Iterator<E>;
                    contains(arg0: any): boolean;
                    containsAll(arg0: JavaCollection<any>): boolean;
                    removeAll(arg0: JavaCollection<any>): boolean;
                    retainAll(arg0: JavaCollection<any>): boolean;
                    forEach(arg0: java.util.function.Consumer<any>): void;
                    spliterator(): java.util.Spliterator<E>;

                }

                const Multiset$Entry: JavaInterfaceStatics<Multiset$Entry<any>>;
                interface Multiset$Entry<E> extends JavaObject {

                    getElement(): E;
                    getCount(): number;

                }

                export {
                    ForwardingObject,
                    ForwardingMultimap,
                    Multimap,
                    Multiset,
                    Multiset$Entry
                }

            }

        }

        namespace neovisionaries.ws.client {

            const WebSocket: JavaClassStatics<WebSocket> & NoConstructor;
            interface WebSocket extends JavaObject {

                recreate(): WebSocket;
                recreate(arg0: int): WebSocket;
                getState(): WebSocketState;
                isOpen(): boolean;
                addProtocol(arg0: string): WebSocket;
                removeProtocol(arg0: string): WebSocket;
                clearProtocols(): WebSocket;
                addExtension(arg0: WebSocketExtension): WebSocket;
                addExtension(arg0: string): WebSocket;
                removeExtension(arg0: WebSocketExtension): WebSocket;
                removeExtensions(arg0: string): WebSocket;
                clearExtensions(): WebSocket;
                addHeader(arg0: string, arg1: string): WebSocket;
                removeHeaders(arg0: string): WebSocket;
                clearHeaders(): WebSocket;
                setUserInfo(arg0: string): WebSocket;
                setUserInfo(arg0: string, arg1: string): WebSocket;
                clearUserInfo(): WebSocket;
                isExtended(): boolean;
                setExtended(arg0: boolean): WebSocket;
                isAutoFlush(): boolean;
                setAutoFlush(arg0: boolean): WebSocket;
                isMissingCloseFrameAllowed(): boolean;
                setMissingCloseFrameAllowed(arg0: boolean): WebSocket;
                isDirectTextMessage(): boolean;
                setDirectTextMessage(arg0: boolean): WebSocket;
                flush(): WebSocket;
                getFrameQueueSize(): number;
                setFrameQueueSize(arg0: int): WebSocket;
                getMaxPayloadSize(): number;
                setMaxPayloadSize(arg0: int): WebSocket;
                getPingInterval(): number;
                setPingInterval(arg0: long): WebSocket;
                getPongInterval(): number;
                setPongInterval(arg0: long): WebSocket;
                getPingPayloadGenerator(): PayloadGenerator;
                setPingPayloadGenerator(arg0: PayloadGenerator): WebSocket;
                getPongPayloadGenerator(): PayloadGenerator;
                setPongPayloadGenerator(arg0: PayloadGenerator): WebSocket;
                getPingSenderName(): string;
                setPingSenderName(arg0: string): WebSocket;
                getPongSenderName(): string;
                setPongSenderName(arg0: string): WebSocket;
                addListener(arg0: WebSocketListener): WebSocket;
                addListeners(arg0: JavaList<WebSocketListener>): WebSocket;
                removeListener(arg0: WebSocketListener): WebSocket;
                removeListeners(arg0: JavaList<WebSocketListener>): WebSocket;
                clearListeners(): WebSocket;
                getSocket(): java.net.Socket;
                getConnectedSocket(): java.net.Socket;
                getURI(): java.net.URI;
                connect(): WebSocket;
                connect(arg0: java.util.concurrent.ExecutorService): java.util.concurrent.Future<WebSocket>;
                connectable(): java.util.concurrent.Callable<WebSocket>;
                connectAsynchronously(): WebSocket;
                disconnect(): WebSocket;
                disconnect(arg0: int): WebSocket;
                disconnect(arg0: string): WebSocket;
                disconnect(arg0: int, arg1: string): WebSocket;
                disconnect(arg0: int, arg1: string, arg2: long): WebSocket;
                getAgreedExtensions(): JavaList<WebSocketExtension>;
                getAgreedProtocol(): string;
                sendFrame(arg0: WebSocketFrame): WebSocket;
                sendContinuation(): WebSocket;
                sendContinuation(arg0: boolean): WebSocket;
                sendContinuation(arg0: string): WebSocket;
                sendContinuation(arg0: string, arg1: boolean): WebSocket;
                sendContinuation(arg0: byte[]): WebSocket;
                sendContinuation(arg0: byte[], arg1: boolean): WebSocket;
                sendText(arg0: string): WebSocket;
                sendText(arg0: string, arg1: boolean): WebSocket;
                sendBinary(arg0: byte[]): WebSocket;
                sendBinary(arg0: byte[], arg1: boolean): WebSocket;
                sendClose(): WebSocket;
                sendClose(arg0: int): WebSocket;
                sendClose(arg0: int, arg1: string): WebSocket;
                sendPing(): WebSocket;
                sendPing(arg0: byte[]): WebSocket;
                sendPing(arg0: string): WebSocket;
                sendPong(): WebSocket;
                sendPong(arg0: byte[]): WebSocket;
                sendPong(arg0: string): WebSocket;

            }

            const WebSocketFrame: JavaClassStatics<WebSocketFrame, WebSocketFrame$$constructor> & {

                createContinuationFrame(): WebSocketFrame;
                createContinuationFrame(arg0: byte[]): WebSocketFrame;
                createContinuationFrame(arg0: string): WebSocketFrame;
                createTextFrame(arg0: string): WebSocketFrame;
                createBinaryFrame(arg0: byte[]): WebSocketFrame;
                createCloseFrame(): WebSocketFrame;
                createCloseFrame(arg0: int): WebSocketFrame;
                createCloseFrame(arg0: int, arg1: string): WebSocketFrame;
                createPingFrame(): WebSocketFrame;
                createPingFrame(arg0: byte[]): WebSocketFrame;
                createPingFrame(arg0: string): WebSocketFrame;
                createPongFrame(): WebSocketFrame;
                createPongFrame(arg0: byte[]): WebSocketFrame;
                createPongFrame(arg0: string): WebSocketFrame;

            }
            interface WebSocketFrame$$constructor extends SuppressProperties {

                new (): WebSocketFrame;

            }
            interface WebSocketFrame extends JavaObject {

                getFin(): boolean;
                setFin(arg0: boolean): WebSocketFrame;
                getRsv1(): boolean;
                setRsv1(arg0: boolean): WebSocketFrame;
                getRsv2(): boolean;
                setRsv2(arg0: boolean): WebSocketFrame;
                getRsv3(): boolean;
                setRsv3(arg0: boolean): WebSocketFrame;
                getOpcode(): number;
                setOpcode(arg0: int): WebSocketFrame;
                isContinuationFrame(): boolean;
                isTextFrame(): boolean;
                isBinaryFrame(): boolean;
                isCloseFrame(): boolean;
                isPingFrame(): boolean;
                isPongFrame(): boolean;
                isDataFrame(): boolean;
                isControlFrame(): boolean;
                hasPayload(): boolean;
                getPayloadLength(): number;
                getPayload(): JavaArray<number>;
                getPayloadText(): string;
                setPayload(arg0: byte[]): WebSocketFrame;
                setPayload(arg0: string): WebSocketFrame;
                setCloseFramePayload(arg0: int, arg1: string): WebSocketFrame;
                getCloseCode(): number;
                getCloseReason(): string;

            }

            const WebSocketException: JavaClassStatics<WebSocketException, WebSocketException$$constructor>;
            interface WebSocketException$$constructor extends SuppressProperties {

                new (arg0: WebSocketError): WebSocketException;
                new (arg0: WebSocketError, arg1: string): WebSocketException;
                new (arg0: WebSocketError, arg1: java.lang.Throwable): WebSocketException;
                new (arg0: WebSocketError, arg1: string, arg2: java.lang.Throwable): WebSocketException;

            }
            interface WebSocketException extends java.lang.Exception {

                getError(): WebSocketError;

            }

            const WebSocketError: JavaClassStatics<WebSocketError> & NoConstructor & {
                readonly NOT_IN_CREATED_STATE: WebSocketError;
                readonly SOCKET_INPUT_STREAM_FAILURE: WebSocketError;
                readonly SOCKET_OUTPUT_STREAM_FAILURE: WebSocketError;
                readonly OPENING_HAHDSHAKE_REQUEST_FAILURE: WebSocketError;
                readonly OPENING_HANDSHAKE_RESPONSE_FAILURE: WebSocketError;
                readonly STATUS_LINE_EMPTY: WebSocketError;
                readonly STATUS_LINE_BAD_FORMAT: WebSocketError;
                readonly NOT_SWITCHING_PROTOCOLS: WebSocketError;
                readonly HTTP_HEADER_FAILURE: WebSocketError;
                readonly NO_UPGRADE_HEADER: WebSocketError;
                readonly NO_WEBSOCKET_IN_UPGRADE_HEADER: WebSocketError;
                readonly NO_CONNECTION_HEADER: WebSocketError;
                readonly NO_UPGRADE_IN_CONNECTION_HEADER: WebSocketError;
                readonly NO_SEC_WEBSOCKET_ACCEPT_HEADER: WebSocketError;
                readonly UNEXPECTED_SEC_WEBSOCKET_ACCEPT_HEADER: WebSocketError;
                readonly EXTENSION_PARSE_ERROR: WebSocketError;
                readonly UNSUPPORTED_EXTENSION: WebSocketError;
                readonly EXTENSIONS_CONFLICT: WebSocketError;
                readonly UNSUPPORTED_PROTOCOL: WebSocketError;
                readonly INSUFFICENT_DATA: WebSocketError;
                readonly INVALID_PAYLOAD_LENGTH: WebSocketError;
                readonly TOO_LONG_PAYLOAD: WebSocketError;
                readonly INSUFFICIENT_MEMORY_FOR_PAYLOAD: WebSocketError;
                readonly INTERRUPTED_IN_READING: WebSocketError;
                readonly IO_ERROR_IN_READING: WebSocketError;
                readonly IO_ERROR_IN_WRITING: WebSocketError;
                readonly FLUSH_ERROR: WebSocketError;
                readonly NON_ZERO_RESERVED_BITS: WebSocketError;
                readonly UNEXPECTED_RESERVED_BIT: WebSocketError;
                readonly FRAME_MASKED: WebSocketError;
                readonly UNKNOWN_OPCODE: WebSocketError;
                readonly FRAGMENTED_CONTROL_FRAME: WebSocketError;
                readonly UNEXPECTED_CONTINUATION_FRAME: WebSocketError;
                readonly CONTINUATION_NOT_CLOSED: WebSocketError;
                readonly TOO_LONG_CONTROL_FRAME_PAYLOAD: WebSocketError;
                readonly MESSAGE_CONSTRUCTION_ERROR: WebSocketError;
                readonly TEXT_MESSAGE_CONSTRUCTION_ERROR: WebSocketError;
                readonly UNEXPECTED_ERROR_IN_READING_THREAD: WebSocketError;
                readonly UNEXPECTED_ERROR_IN_WRITING_THREAD: WebSocketError;
                readonly PERMESSAGE_DEFLATE_UNSUPPORTED_PARAMETER: WebSocketError;
                readonly PERMESSAGE_DEFLATE_INVALID_MAX_WINDOW_BITS: WebSocketError;
                readonly COMPRESSION_ERROR: WebSocketError;
                readonly DECOMPRESSION_ERROR: WebSocketError;
                readonly SOCKET_CONNECT_ERROR: WebSocketError;
                readonly PROXY_HANDSHAKE_ERROR: WebSocketError;
                readonly SOCKET_OVERLAY_ERROR: WebSocketError;
                readonly SSL_HANDSHAKE_ERROR: WebSocketError;
                readonly NO_MORE_FRAME: WebSocketError;
                readonly HOSTNAME_UNVERIFIED: WebSocketError;

                values(): JavaArray<WebSocketError>;
                valueOf(arg0: string): WebSocketError;

            }
            interface WebSocketError extends java.lang.Enum<WebSocketError> {}

            const WebSocketExtension: JavaClassStatics<WebSocketExtension, WebSocketExtension$$constructor> & {
                readonly PERMESSAGE_DEFLATE: string;

                parse(arg0: string): WebSocketExtension;

            }
            interface WebSocketExtension$$constructor extends SuppressProperties {

                new (arg0: string): WebSocketExtension;
                new (arg0: WebSocketExtension): WebSocketExtension;

            }
            interface WebSocketExtension extends JavaObject {

                getName(): string;
                getParameters(): JavaMap<string, string>;
                containsParameter(arg0: string): boolean;
                getParameter(arg0: string): string;
                setParameter(arg0: string, arg1: string): WebSocketExtension;

            }

            const WebSocketState: JavaClassStatics<WebSocketState> & NoConstructor & {
                readonly CREATED: WebSocketState;
                readonly CONNECTING: WebSocketState;
                readonly OPEN: WebSocketState;
                readonly CLOSING: WebSocketState;
                readonly CLOSED: WebSocketState;

                values(): JavaArray<WebSocketState>;
                valueOf(arg0: string): WebSocketState;

            }
            interface WebSocketState extends java.lang.Enum<WebSocketState> {}

            const WebSocketListener: JavaInterfaceStatics<WebSocketListener>;
            interface WebSocketListener extends JavaObject {

                onStateChanged(arg0: WebSocket, arg1: WebSocketState): void;
                onConnected(arg0: WebSocket, arg1: JavaMap<string, JavaList<string>>): void;
                onConnectError(arg0: WebSocket, arg1: WebSocketException): void;
                onDisconnected(arg0: WebSocket, arg1: WebSocketFrame, arg2: WebSocketFrame, arg3: boolean): void;
                onFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onContinuationFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onTextFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onBinaryFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onCloseFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onPingFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onPongFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onTextMessage(arg0: WebSocket, arg1: string): void;
                onTextMessage(arg0: WebSocket, arg1: byte[]): void;
                onBinaryMessage(arg0: WebSocket, arg1: byte[]): void;
                onSendingFrame(arg0: WebSocket, arg1: WebSocketFrame): void;
                onFrameSent(arg0: WebSocket, arg1: WebSocketFrame): void;
                onFrameUnsent(arg0: WebSocket, arg1: WebSocketFrame): void;
                onThreadCreated(arg0: WebSocket, arg1: ThreadType, arg2: java.lang.Thread): void;
                onThreadStarted(arg0: WebSocket, arg1: ThreadType, arg2: java.lang.Thread): void;
                onThreadStopping(arg0: WebSocket, arg1: ThreadType, arg2: java.lang.Thread): void;
                onError(arg0: WebSocket, arg1: WebSocketException): void;
                onFrameError(arg0: WebSocket, arg1: WebSocketException, arg2: WebSocketFrame): void;
                onMessageError(arg0: WebSocket, arg1: WebSocketException, arg2: JavaList<WebSocketFrame>): void;
                onMessageDecompressionError(arg0: WebSocket, arg1: WebSocketException, arg2: byte[]): void;
                onTextMessageError(arg0: WebSocket, arg1: WebSocketException, arg2: byte[]): void;
                onSendError(arg0: WebSocket, arg1: WebSocketException, arg2: WebSocketFrame): void;
                onUnexpectedError(arg0: WebSocket, arg1: WebSocketException): void;
                handleCallbackError(arg0: WebSocket, arg1: java.lang.Throwable): void;
                onSendingHandshake(arg0: WebSocket, arg1: string, arg2: JavaList<string[]>): void;

            }

            const PayloadGenerator: JavaInterfaceStatics<PayloadGenerator>;
            interface PayloadGenerator extends JavaObject {

                generate(): JavaArray<number>;

            }

            const ThreadType: JavaClassStatics<ThreadType> & NoConstructor & {
                readonly READING_THREAD: ThreadType;
                readonly WRITING_THREAD: ThreadType;
                readonly CONNECT_THREAD: ThreadType;
                readonly FINISH_THREAD: ThreadType;

                values(): JavaArray<ThreadType>;
                valueOf(arg0: string): ThreadType;

            }
            interface ThreadType extends java.lang.Enum<ThreadType> {}

            export {
                WebSocket,
                WebSocketFrame,
                WebSocketException,
                WebSocketError,
                WebSocketExtension,
                WebSocketState,
                WebSocketListener,
                PayloadGenerator,
                ThreadType
            }

        }

    }

    namespace io.noties.prism4j {

        const Prism4j$Node: JavaInterfaceStatics<Prism4j$Node>;
        interface Prism4j$Node extends JavaObject {

            textLength(): number;
            isSyntax(): boolean;

        }

        export { Prism4j$Node }

    }

    namespace org {

        namespace slf4j {

            const Logger: JavaInterfaceStatics<Logger> & {
                readonly ROOT_LOGGER_NAME: string;
            }
            interface Logger extends JavaObject {

                getName(): string;
                makeLoggingEventBuilder(arg0: org.slf4j.event.Level): org.slf4j.spi.LoggingEventBuilder;
                atLevel(arg0: org.slf4j.event.Level): org.slf4j.spi.LoggingEventBuilder;
                isEnabledForLevel(arg0: org.slf4j.event.Level): boolean;
                isTraceEnabled(): boolean;
                trace(arg0: string): void;
                trace(arg0: string, arg1: any): void;
                trace(arg0: string, arg1: any, arg2: any): void;
                trace(arg0: string, ...arg1: any[]): void;
                trace(arg0: string, arg1: java.lang.Throwable): void;
                isTraceEnabled(arg0: Marker): boolean;
                atTrace(): org.slf4j.spi.LoggingEventBuilder;
                trace(arg0: Marker, arg1: string): void;
                trace(arg0: Marker, arg1: string, arg2: any): void;
                trace(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                trace(arg0: Marker, arg1: string, ...arg2: any[]): void;
                trace(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                isDebugEnabled(): boolean;
                debug(arg0: string): void;
                debug(arg0: string, arg1: any): void;
                debug(arg0: string, arg1: any, arg2: any): void;
                debug(arg0: string, ...arg1: any[]): void;
                debug(arg0: string, arg1: java.lang.Throwable): void;
                isDebugEnabled(arg0: Marker): boolean;
                debug(arg0: Marker, arg1: string): void;
                debug(arg0: Marker, arg1: string, arg2: any): void;
                debug(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                debug(arg0: Marker, arg1: string, ...arg2: any[]): void;
                debug(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atDebug(): org.slf4j.spi.LoggingEventBuilder;
                isInfoEnabled(): boolean;
                info(arg0: string): void;
                info(arg0: string, arg1: any): void;
                info(arg0: string, arg1: any, arg2: any): void;
                info(arg0: string, ...arg1: any[]): void;
                info(arg0: string, arg1: java.lang.Throwable): void;
                isInfoEnabled(arg0: Marker): boolean;
                info(arg0: Marker, arg1: string): void;
                info(arg0: Marker, arg1: string, arg2: any): void;
                info(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                info(arg0: Marker, arg1: string, ...arg2: any[]): void;
                info(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atInfo(): org.slf4j.spi.LoggingEventBuilder;
                isWarnEnabled(): boolean;
                warn(arg0: string): void;
                warn(arg0: string, arg1: any): void;
                warn(arg0: string, ...arg1: any[]): void;
                warn(arg0: string, arg1: any, arg2: any): void;
                warn(arg0: string, arg1: java.lang.Throwable): void;
                isWarnEnabled(arg0: Marker): boolean;
                warn(arg0: Marker, arg1: string): void;
                warn(arg0: Marker, arg1: string, arg2: any): void;
                warn(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                warn(arg0: Marker, arg1: string, ...arg2: any[]): void;
                warn(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atWarn(): org.slf4j.spi.LoggingEventBuilder;
                isErrorEnabled(): boolean;
                error(arg0: string): void;
                error(arg0: string, arg1: any): void;
                error(arg0: string, arg1: any, arg2: any): void;
                error(arg0: string, ...arg1: any[]): void;
                error(arg0: string, arg1: java.lang.Throwable): void;
                isErrorEnabled(arg0: Marker): boolean;
                error(arg0: Marker, arg1: string): void;
                error(arg0: Marker, arg1: string, arg2: any): void;
                error(arg0: Marker, arg1: string, arg2: any, arg3: any): void;
                error(arg0: Marker, arg1: string, ...arg2: any[]): void;
                error(arg0: Marker, arg1: string, arg2: java.lang.Throwable): void;
                atError(): org.slf4j.spi.LoggingEventBuilder;

            }

            const Marker: JavaInterfaceStatics<Marker> & {
                readonly ANY_MARKER: string;
                readonly ANY_NON_NULL_MARKER: string;
            }
            interface Marker extends java.io.Serializable {

                getName(): string;
                add(arg0: Marker): void;
                remove(arg0: Marker): boolean;
                /** @deprecated */
                hasChildren(): boolean;
                hasReferences(): boolean;
                iterator(): java.util.Iterator<Marker>;
                contains(arg0: Marker): boolean;
                contains(arg0: string): boolean;

            }

            export { Logger, Marker }

        }
        namespace slf4j {

            namespace event {

                const Level: JavaClassStatics<Level> & NoConstructor & {
                    readonly ERROR: Level;
                    readonly WARN: Level;
                    readonly INFO: Level;
                    readonly DEBUG: Level;
                    readonly TRACE: Level;

                    values(): JavaArray<Level>;
                    valueOf(arg0: string): Level;
                    intToLevel(arg0: int): Level;

                }
                interface Level extends java.lang.Enum<Level> {

                    toInt(): number;

                }

                export { Level }

            }

            namespace spi {

                const LoggingEventBuilder: JavaInterfaceStatics<LoggingEventBuilder>;
                interface LoggingEventBuilder extends JavaObject {

                    setCause(arg0: java.lang.Throwable): LoggingEventBuilder;
                    addMarker(arg0: org.slf4j.Marker): LoggingEventBuilder;
                    addArgument(arg0: any): LoggingEventBuilder;
                    addArgument(arg0: java.util.function.Supplier<any>): LoggingEventBuilder;
                    addKeyValue(arg0: string, arg1: any): LoggingEventBuilder;
                    addKeyValue(arg0: string, arg1: java.util.function.Supplier<any>): LoggingEventBuilder;
                    setMessage(arg0: string): LoggingEventBuilder;
                    setMessage(arg0: java.util.function.Supplier<string>): LoggingEventBuilder;
                    log(): void;
                    log(arg0: string): void;
                    log(arg0: string, arg1: any): void;
                    log(arg0: string, arg1: any, arg2: any): void;
                    log(arg0: string, ...arg1: any[]): void;
                    log(arg0: java.util.function.Supplier<string>): void;

                }

                export { LoggingEventBuilder }

            }

        }

        namespace joor {

            const Reflect: JavaClassStatics<Reflect> & NoConstructor & {

                compile(arg0: string, arg1: string): Reflect;
                compile(arg0: string, arg1: string, arg2: CompileOptions): Reflect;
                /** @deprecated */
                on(arg0: string): Reflect;
                /** @deprecated */
                on(arg0: string, arg1: java.lang.ClassLoader): Reflect;
                /** @deprecated */
                on(arg0: JavaClassArg<any>): Reflect;
                onClass(arg0: string): Reflect;
                onClass(arg0: string, arg1: java.lang.ClassLoader): Reflect;
                onClass(arg0: JavaClassArg<any>): Reflect;
                on(arg0: any): Reflect;
                initValue<T>(arg0: JavaClassArg<T>): T;
                accessible<T extends java.lang.reflect.AccessibleObject>(arg0: T): T;
                wrapper<T>(arg0: JavaClassArg<T>): JavaClass<T>;

            }
            interface Reflect extends JavaObject {

                get<T>(): T;
                set(arg0: string, arg1: any): Reflect;
                get<T>(arg0: string): T;
                field(arg0: string): Reflect;
                fields(): JavaMap<string, Reflect>;
                call(arg0: string): Reflect;
                call(arg0: string, ...arg1: any[]): Reflect;
                create(): Reflect;
                create(...arg0: any[]): Reflect;
                as<P>(arg0: JavaClassArg<P>): P;
                as<P>(arg0: JavaClassArg<P>, ...arg1: JavaClassArg<any>[]): P;
                type(): JavaClass<any>;

            }

            const CompileOptions: JavaClassStatics<CompileOptions, CompileOptions$$constructor>;
            interface CompileOptions$$constructor extends SuppressProperties {

                new (): CompileOptions;

            }
            interface CompileOptions extends JavaObject {

                processors(...arg0: javax.annotation.processing.Processor[]): CompileOptions;
                processors(arg0: JavaList<any>): CompileOptions;
                options(...arg0: string[]): CompileOptions;
                options(arg0: JavaList<string>): CompileOptions;

            }

            export { Reflect, CompileOptions }

        }

        namespace joml {

            const Vector3f: JavaClassStatics<Vector3f, Vector3f$$constructor> & {

                lengthSquared(arg0: float, arg1: float, arg2: float): number;
                length(arg0: float, arg1: float, arg2: float): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;

            }
            interface Vector3f$$constructor extends SuppressProperties {

                new (): Vector3f;
                new (arg0: float): Vector3f;
                new (arg0: float, arg1: float, arg2: float): Vector3f;
                new (arg0: Vector3fc): Vector3f;
                new (arg0: Vector3ic): Vector3f;
                new (arg0: Vector2fc, arg1: float): Vector3f;
                new (arg0: Vector2ic, arg1: float): Vector3f;
                new (arg0: float[]): Vector3f;
                new (arg0: java.nio.ByteBuffer): Vector3f;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector3f;
                new (arg0: java.nio.FloatBuffer): Vector3f;
                new (arg0: int, arg1: java.nio.FloatBuffer): Vector3f;

            }
            interface Vector3f extends java.io.Externalizable, java.lang.Cloneable, Vector3fc {
                x: number;
                y: number;
                z: number;

                x(): number;
                y(): number;
                z(): number;
                set(arg0: Vector3fc): Vector3f;
                set(arg0: Vector3dc): Vector3f;
                set(arg0: Vector3ic): Vector3f;
                set(arg0: Vector2fc, arg1: float): Vector3f;
                set(arg0: Vector2dc, arg1: float): Vector3f;
                set(arg0: Vector2ic, arg1: float): Vector3f;
                set(arg0: float): Vector3f;
                set(arg0: float, arg1: float, arg2: float): Vector3f;
                set(arg0: double): Vector3f;
                set(arg0: double, arg1: double, arg2: double): Vector3f;
                set(arg0: float[]): Vector3f;
                set(arg0: java.nio.ByteBuffer): Vector3f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector3f;
                set(arg0: java.nio.FloatBuffer): Vector3f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Vector3f;
                setFromAddress(arg0: long): Vector3f;
                setComponent(arg0: int, arg1: float): Vector3f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3fc;
                sub(arg0: Vector3fc): Vector3f;
                sub(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                sub(arg0: float, arg1: float, arg2: float): Vector3f;
                sub(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                add(arg0: Vector3fc): Vector3f;
                add(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                add(arg0: float, arg1: float, arg2: float): Vector3f;
                add(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                fma(arg0: Vector3fc, arg1: Vector3fc): Vector3f;
                fma(arg0: float, arg1: Vector3fc): Vector3f;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                fma(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: Vector3fc, arg1: Vector3fc): Vector3f;
                mulAdd(arg0: float, arg1: Vector3fc): Vector3f;
                mulAdd(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mul(arg0: Vector3fc): Vector3f;
                mul(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                div(arg0: Vector3fc): Vector3f;
                div(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: float, arg2: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc): Vector3f;
                mul(arg0: Matrix3fc): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3dc): Vector3f;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3x2fc): Vector3f;
                mul(arg0: Matrix3x2fc, arg1: Vector3f): Vector3f;
                mulTranspose(arg0: Matrix3fc): Vector3f;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4fc): Vector3f;
                mulPosition(arg0: Matrix4x3fc): Vector3f;
                mulPosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposePosition(arg0: Matrix4fc): Vector3f;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPositionW(arg0: Matrix4fc): number;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3f): number;
                mulDirection(arg0: Matrix4dc): Vector3f;
                mulDirection(arg0: Matrix4fc): Vector3f;
                mulDirection(arg0: Matrix4x3fc): Vector3f;
                mulDirection(arg0: Matrix4dc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposeDirection(arg0: Matrix4fc): Vector3f;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float): Vector3f;
                mul(arg0: float, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: float, arg2: float): Vector3f;
                mul(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                div(arg0: float): Vector3f;
                div(arg0: float, arg1: Vector3f): Vector3f;
                div(arg0: float, arg1: float, arg2: float): Vector3f;
                div(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                rotate(arg0: Quaternionfc): Vector3f;
                rotate(arg0: Quaternionfc, arg1: Vector3f): Vector3f;
                rotationTo(arg0: Vector3fc, arg1: Quaternionf): Quaternionf;
                rotationTo(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float): Vector3f;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                rotateX(arg0: float): Vector3f;
                rotateX(arg0: float, arg1: Vector3f): Vector3f;
                rotateY(arg0: float): Vector3f;
                rotateY(arg0: float, arg1: Vector3f): Vector3f;
                rotateZ(arg0: float): Vector3f;
                rotateZ(arg0: float, arg1: Vector3f): Vector3f;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector3f;
                normalize(arg0: Vector3f): Vector3f;
                normalize(arg0: float): Vector3f;
                normalize(arg0: float, arg1: Vector3f): Vector3f;
                cross(arg0: Vector3fc): Vector3f;
                cross(arg0: float, arg1: float, arg2: float): Vector3f;
                cross(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                cross(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                distance(arg0: Vector3fc): number;
                distance(arg0: float, arg1: float, arg2: float): number;
                distanceSquared(arg0: Vector3fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float): number;
                dot(arg0: Vector3fc): number;
                dot(arg0: float, arg1: float, arg2: float): number;
                angleCos(arg0: Vector3fc): number;
                angle(arg0: Vector3fc): number;
                angleSigned(arg0: Vector3fc, arg1: Vector3fc): number;
                angleSigned(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;
                min(arg0: Vector3fc): Vector3f;
                min(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                max(arg0: Vector3fc): Vector3f;
                max(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                zero(): Vector3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector3f;
                negate(arg0: Vector3f): Vector3f;
                absolute(): Vector3f;
                absolute(arg0: Vector3f): Vector3f;
                equals(arg0: Vector3fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float): boolean;
                equals(arg0: any): boolean;
                reflect(arg0: Vector3fc): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float): Vector3f;
                reflect(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                half(arg0: Vector3fc): Vector3f;
                half(arg0: float, arg1: float, arg2: float): Vector3f;
                half(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                half(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                smoothStep(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                hermite(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: float, arg4: Vector3f): Vector3f;
                lerp(arg0: Vector3fc, arg1: float): Vector3f;
                lerp(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                orthogonalize(arg0: Vector3fc): Vector3f;
                orthogonalizeUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                orthogonalizeUnit(arg0: Vector3fc): Vector3f;
                floor(): Vector3f;
                floor(arg0: Vector3f): Vector3f;
                ceil(): Vector3f;
                ceil(arg0: Vector3f): Vector3f;
                round(): Vector3f;
                round(arg0: Vector3f): Vector3f;
                isFinite(): boolean;
                clone(): any;

            }

            const Matrix4dc: JavaInterfaceStatics<Matrix4dc> & {
                readonly PLANE_NX: number;
                readonly PLANE_PX: number;
                readonly PLANE_NY: number;
                readonly PLANE_PY: number;
                readonly PLANE_NZ: number;
                readonly PLANE_PZ: number;
                readonly CORNER_NXNYNZ: number;
                readonly CORNER_PXNYNZ: number;
                readonly CORNER_PXPYNZ: number;
                readonly CORNER_NXPYNZ: number;
                readonly CORNER_PXNYPZ: number;
                readonly CORNER_NXNYPZ: number;
                readonly CORNER_NXPYPZ: number;
                readonly CORNER_PXPYPZ: number;
                readonly PROPERTY_PERSPECTIVE: number;
                readonly PROPERTY_AFFINE: number;
                readonly PROPERTY_IDENTITY: number;
                readonly PROPERTY_TRANSLATION: number;
                readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4dc extends JavaObject {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                mul(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul0(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double, arg16: Matrix4d): Matrix4d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                mulLocal(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulLocalAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mulAffineR(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulTranslationAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulOrthoAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                fma4x3(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                add(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                sub(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                sub4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul4x3ComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(arg0: Matrix4d): Matrix4d;
                invertPerspective(arg0: Matrix4d): Matrix4d;
                invertFrustum(arg0: Matrix4d): Matrix4d;
                invertOrtho(arg0: Matrix4d): Matrix4d;
                invertPerspectiveView(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                invertPerspectiveView(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                invertAffine(arg0: Matrix4d): Matrix4d;
                transpose(arg0: Matrix4d): Matrix4d;
                transpose3x3(arg0: Matrix4d): Matrix4d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                get(arg0: Matrix4d): Matrix4d;
                get4x3(arg0: Matrix4x3d): Matrix4x3d;
                get3x3(arg0: Matrix3d): Matrix3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4dc;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector4d): Vector4d;
                transformProject(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformProject(arg0: Vector4dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector3d): Vector3d;
                transformProject(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformPosition(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4d): Vector4d;
                transformAffine(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                scale(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scale(arg0: double, arg1: Matrix4d): Matrix4d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAroundAffine(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateLocalX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateAroundLocal(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                translate(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translate(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateTowardsXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotate(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4d): Matrix4d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4d): Matrix4d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                getColumn(arg0: int, arg1: Vector4d): Vector4d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix4d): Matrix4d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                unprojectRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unprojectInvRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInvRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtPerspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                frustumCorner(arg0: int, arg1: Vector3d): Vector3d;
                perspectiveOrigin(arg0: Vector3d): Vector3d;
                perspectiveInvOrigin(arg0: Vector3d): Vector3d;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: double, arg1: double, arg2: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                originAffine(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4d): Matrix4d;
                shadow(arg0: Vector4dc, arg1: Matrix4dc, arg2: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4dc, arg5: Matrix4d): Matrix4d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4d): Matrix4d;
                isAffine(): boolean;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                projectedGridRange(arg0: Matrix4dc, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                perspectiveFrustumSlice(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                orthoCrop(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4d;
                lerp(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                testPoint(arg0: double, arg1: double, arg2: double): boolean;
                testSphere(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                testAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): boolean;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                withLookAtUp(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                withLookAtUp(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                mapXZY(arg0: Matrix4d): Matrix4d;
                mapXZnY(arg0: Matrix4d): Matrix4d;
                mapXnYnZ(arg0: Matrix4d): Matrix4d;
                mapXnZY(arg0: Matrix4d): Matrix4d;
                mapXnZnY(arg0: Matrix4d): Matrix4d;
                mapYXZ(arg0: Matrix4d): Matrix4d;
                mapYXnZ(arg0: Matrix4d): Matrix4d;
                mapYZX(arg0: Matrix4d): Matrix4d;
                mapYZnX(arg0: Matrix4d): Matrix4d;
                mapYnXZ(arg0: Matrix4d): Matrix4d;
                mapYnXnZ(arg0: Matrix4d): Matrix4d;
                mapYnZX(arg0: Matrix4d): Matrix4d;
                mapYnZnX(arg0: Matrix4d): Matrix4d;
                mapZXY(arg0: Matrix4d): Matrix4d;
                mapZXnY(arg0: Matrix4d): Matrix4d;
                mapZYX(arg0: Matrix4d): Matrix4d;
                mapZYnX(arg0: Matrix4d): Matrix4d;
                mapZnXY(arg0: Matrix4d): Matrix4d;
                mapZnXnY(arg0: Matrix4d): Matrix4d;
                mapZnYX(arg0: Matrix4d): Matrix4d;
                mapZnYnX(arg0: Matrix4d): Matrix4d;
                mapnXYnZ(arg0: Matrix4d): Matrix4d;
                mapnXZY(arg0: Matrix4d): Matrix4d;
                mapnXZnY(arg0: Matrix4d): Matrix4d;
                mapnXnYZ(arg0: Matrix4d): Matrix4d;
                mapnXnYnZ(arg0: Matrix4d): Matrix4d;
                mapnXnZY(arg0: Matrix4d): Matrix4d;
                mapnXnZnY(arg0: Matrix4d): Matrix4d;
                mapnYXZ(arg0: Matrix4d): Matrix4d;
                mapnYXnZ(arg0: Matrix4d): Matrix4d;
                mapnYZX(arg0: Matrix4d): Matrix4d;
                mapnYZnX(arg0: Matrix4d): Matrix4d;
                mapnYnXZ(arg0: Matrix4d): Matrix4d;
                mapnYnXnZ(arg0: Matrix4d): Matrix4d;
                mapnYnZX(arg0: Matrix4d): Matrix4d;
                mapnYnZnX(arg0: Matrix4d): Matrix4d;
                mapnZXY(arg0: Matrix4d): Matrix4d;
                mapnZXnY(arg0: Matrix4d): Matrix4d;
                mapnZYX(arg0: Matrix4d): Matrix4d;
                mapnZYnX(arg0: Matrix4d): Matrix4d;
                mapnZnXY(arg0: Matrix4d): Matrix4d;
                mapnZnXnY(arg0: Matrix4d): Matrix4d;
                mapnZnYX(arg0: Matrix4d): Matrix4d;
                mapnZnYnX(arg0: Matrix4d): Matrix4d;
                negateX(arg0: Matrix4d): Matrix4d;
                negateY(arg0: Matrix4d): Matrix4d;
                negateZ(arg0: Matrix4d): Matrix4d;
                equals(arg0: Matrix4dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            const Vector3i: JavaClassStatics<Vector3i, Vector3i$$constructor> & {

                lengthSquared(arg0: int, arg1: int, arg2: int): number;
                length(arg0: int, arg1: int, arg2: int): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): number;

            }
            interface Vector3i$$constructor extends SuppressProperties {

                new (): Vector3i;
                new (arg0: int): Vector3i;
                new (arg0: int, arg1: int, arg2: int): Vector3i;
                new (arg0: Vector3ic): Vector3i;
                new (arg0: Vector2ic, arg1: int): Vector3i;
                new (arg0: float, arg1: float, arg2: float, arg3: int): Vector3i;
                new (arg0: double, arg1: double, arg2: double, arg3: int): Vector3i;
                new (arg0: Vector2fc, arg1: float, arg2: int): Vector3i;
                new (arg0: Vector3fc, arg1: int): Vector3i;
                new (arg0: Vector2dc, arg1: float, arg2: int): Vector3i;
                new (arg0: Vector3dc, arg1: int): Vector3i;
                new (arg0: int[]): Vector3i;
                new (arg0: java.nio.ByteBuffer): Vector3i;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector3i;
                new (arg0: java.nio.IntBuffer): Vector3i;
                new (arg0: int, arg1: java.nio.IntBuffer): Vector3i;

            }
            interface Vector3i extends java.io.Externalizable, java.lang.Cloneable, Vector3ic {
                x: number;
                y: number;
                z: number;

                x(): number;
                y(): number;
                z(): number;
                set(arg0: Vector3ic): Vector3i;
                set(arg0: Vector3dc): Vector3i;
                set(arg0: Vector3dc, arg1: int): Vector3i;
                set(arg0: Vector3fc, arg1: int): Vector3i;
                set(arg0: Vector2ic, arg1: int): Vector3i;
                set(arg0: int): Vector3i;
                set(arg0: int, arg1: int, arg2: int): Vector3i;
                set(arg0: int[]): Vector3i;
                set(arg0: java.nio.ByteBuffer): Vector3i;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector3i;
                set(arg0: java.nio.IntBuffer): Vector3i;
                set(arg0: int, arg1: java.nio.IntBuffer): Vector3i;
                setFromAddress(arg0: long): Vector3i;
                get(arg0: int): number;
                setComponent(arg0: int, arg1: int): Vector3i;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3ic;
                sub(arg0: Vector3ic): Vector3i;
                sub(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                sub(arg0: int, arg1: int, arg2: int): Vector3i;
                sub(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                add(arg0: Vector3ic): Vector3i;
                add(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                add(arg0: int, arg1: int, arg2: int): Vector3i;
                add(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                mul(arg0: int): Vector3i;
                mul(arg0: int, arg1: Vector3i): Vector3i;
                mul(arg0: Vector3ic): Vector3i;
                mul(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                mul(arg0: int, arg1: int, arg2: int): Vector3i;
                mul(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                div(arg0: float): Vector3i;
                div(arg0: float, arg1: Vector3i): Vector3i;
                div(arg0: int): Vector3i;
                div(arg0: int, arg1: Vector3i): Vector3i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector3ic): number;
                distance(arg0: int, arg1: int, arg2: int): number;
                gridDistance(arg0: Vector3ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int): number;
                distanceSquared(arg0: Vector3ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int): number;
                zero(): Vector3i;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector3i;
                negate(arg0: Vector3i): Vector3i;
                min(arg0: Vector3ic): Vector3i;
                min(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                max(arg0: Vector3ic): Vector3i;
                max(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                maxComponent(): number;
                minComponent(): number;
                absolute(): Vector3i;
                absolute(arg0: Vector3i): Vector3i;
                equals(arg0: int, arg1: int, arg2: int): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            const Matrix4fc: JavaInterfaceStatics<Matrix4fc> & {
                readonly PLANE_NX: number;
                readonly PLANE_PX: number;
                readonly PLANE_NY: number;
                readonly PLANE_PY: number;
                readonly PLANE_NZ: number;
                readonly PLANE_PZ: number;
                readonly CORNER_NXNYNZ: number;
                readonly CORNER_PXNYNZ: number;
                readonly CORNER_PXPYNZ: number;
                readonly CORNER_NXPYNZ: number;
                readonly CORNER_PXNYPZ: number;
                readonly CORNER_NXNYPZ: number;
                readonly CORNER_NXPYPZ: number;
                readonly CORNER_PXPYPZ: number;
                readonly PROPERTY_PERSPECTIVE: number;
                readonly PROPERTY_AFFINE: number;
                readonly PROPERTY_IDENTITY: number;
                readonly PROPERTY_TRANSLATION: number;
                readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4fc extends JavaObject {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                mul(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul0(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: Matrix4f): Matrix4f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                mulLocal(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulLocalAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix3x2fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mulAffineR(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulTranslationAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulOrthoAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                fma4x3(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                add(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                add4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul4x3ComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(arg0: Matrix4f): Matrix4f;
                invertPerspective(arg0: Matrix4f): Matrix4f;
                invertFrustum(arg0: Matrix4f): Matrix4f;
                invertOrtho(arg0: Matrix4f): Matrix4f;
                invertPerspectiveView(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                invertPerspectiveView(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                invertAffine(arg0: Matrix4f): Matrix4f;
                transpose(arg0: Matrix4f): Matrix4f;
                transpose3x3(arg0: Matrix4f): Matrix4f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                get(arg0: Matrix4f): Matrix4f;
                get4x3(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4d): Matrix4d;
                get3x3(arg0: Matrix3f): Matrix3f;
                get3x3(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector4f): Vector4f;
                transformProject(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector3f): Vector3f;
                transformProject(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: Vector4fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformPosition(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4f): Vector4f;
                transformAffine(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                scale(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                scale(arg0: float, arg1: Matrix4f): Matrix4f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateZ(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateTowardsXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocalX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalZ(arg0: float, arg1: Matrix4f): Matrix4f;
                translate(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtPerspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                rotate(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAroundAffine(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAroundLocal(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unprojectInvRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInvRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                getColumn(arg0: int, arg1: Vector4f): Vector4f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix4f): Matrix4f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                frustumCorner(arg0: int, arg1: Vector3f): Vector3f;
                perspectiveOrigin(arg0: Vector3f): Vector3f;
                perspectiveInvOrigin(arg0: Vector3f): Vector3f;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: float, arg1: float, arg2: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                originAffine(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4f, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4f): Matrix4f;
                shadow(arg0: Vector4f, arg1: Matrix4fc, arg2: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4fc, arg5: Matrix4f): Matrix4f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4f): Matrix4f;
                isAffine(): boolean;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                frustumAabb(arg0: Vector3f, arg1: Vector3f): Matrix4f;
                projectedGridRange(arg0: Matrix4fc, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                perspectiveFrustumSlice(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                orthoCrop(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4f;
                lerp(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                testPoint(arg0: float, arg1: float, arg2: float): boolean;
                testSphere(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                testAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): boolean;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                mapXZY(arg0: Matrix4f): Matrix4f;
                mapXZnY(arg0: Matrix4f): Matrix4f;
                mapXnYnZ(arg0: Matrix4f): Matrix4f;
                mapXnZY(arg0: Matrix4f): Matrix4f;
                mapXnZnY(arg0: Matrix4f): Matrix4f;
                mapYXZ(arg0: Matrix4f): Matrix4f;
                mapYXnZ(arg0: Matrix4f): Matrix4f;
                mapYZX(arg0: Matrix4f): Matrix4f;
                mapYZnX(arg0: Matrix4f): Matrix4f;
                mapYnXZ(arg0: Matrix4f): Matrix4f;
                mapYnXnZ(arg0: Matrix4f): Matrix4f;
                mapYnZX(arg0: Matrix4f): Matrix4f;
                mapYnZnX(arg0: Matrix4f): Matrix4f;
                mapZXY(arg0: Matrix4f): Matrix4f;
                mapZXnY(arg0: Matrix4f): Matrix4f;
                mapZYX(arg0: Matrix4f): Matrix4f;
                mapZYnX(arg0: Matrix4f): Matrix4f;
                mapZnXY(arg0: Matrix4f): Matrix4f;
                mapZnXnY(arg0: Matrix4f): Matrix4f;
                mapZnYX(arg0: Matrix4f): Matrix4f;
                mapZnYnX(arg0: Matrix4f): Matrix4f;
                mapnXYnZ(arg0: Matrix4f): Matrix4f;
                mapnXZY(arg0: Matrix4f): Matrix4f;
                mapnXZnY(arg0: Matrix4f): Matrix4f;
                mapnXnYZ(arg0: Matrix4f): Matrix4f;
                mapnXnYnZ(arg0: Matrix4f): Matrix4f;
                mapnXnZY(arg0: Matrix4f): Matrix4f;
                mapnXnZnY(arg0: Matrix4f): Matrix4f;
                mapnYXZ(arg0: Matrix4f): Matrix4f;
                mapnYXnZ(arg0: Matrix4f): Matrix4f;
                mapnYZX(arg0: Matrix4f): Matrix4f;
                mapnYZnX(arg0: Matrix4f): Matrix4f;
                mapnYnXZ(arg0: Matrix4f): Matrix4f;
                mapnYnXnZ(arg0: Matrix4f): Matrix4f;
                mapnYnZX(arg0: Matrix4f): Matrix4f;
                mapnYnZnX(arg0: Matrix4f): Matrix4f;
                mapnZXY(arg0: Matrix4f): Matrix4f;
                mapnZXnY(arg0: Matrix4f): Matrix4f;
                mapnZYX(arg0: Matrix4f): Matrix4f;
                mapnZYnX(arg0: Matrix4f): Matrix4f;
                mapnZnXY(arg0: Matrix4f): Matrix4f;
                mapnZnXnY(arg0: Matrix4f): Matrix4f;
                mapnZnYX(arg0: Matrix4f): Matrix4f;
                mapnZnYnX(arg0: Matrix4f): Matrix4f;
                negateX(arg0: Matrix4f): Matrix4f;
                negateY(arg0: Matrix4f): Matrix4f;
                negateZ(arg0: Matrix4f): Matrix4f;
                equals(arg0: Matrix4fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            const Matrix3dc: JavaInterfaceStatics<Matrix3dc>;
            interface Matrix3dc extends JavaObject {

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                mul(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulLocal(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mul(arg0: Matrix3fc, arg1: Matrix3d): Matrix3d;
                determinant(): number;
                invert(arg0: Matrix3d): Matrix3d;
                transpose(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                scale(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                scale(arg0: double, arg1: Matrix3d): Matrix3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                rotateX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocalX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix3d): Matrix3d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor(arg0: Matrix3d): Matrix3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                getScale(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                add(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                sub(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulComponentWise(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                lerp(arg0: Matrix3dc, arg1: double, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix3d): Matrix3d;
                equals(arg0: Matrix3dc, arg1: double): boolean;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                reflect(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                reflect(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                isFinite(): boolean;
                quadraticFormProduct(arg0: double, arg1: double, arg2: double): number;
                quadraticFormProduct(arg0: Vector3dc): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(arg0: Matrix3d): Matrix3d;
                mapXZnY(arg0: Matrix3d): Matrix3d;
                mapXnYnZ(arg0: Matrix3d): Matrix3d;
                mapXnZY(arg0: Matrix3d): Matrix3d;
                mapXnZnY(arg0: Matrix3d): Matrix3d;
                mapYXZ(arg0: Matrix3d): Matrix3d;
                mapYXnZ(arg0: Matrix3d): Matrix3d;
                mapYZX(arg0: Matrix3d): Matrix3d;
                mapYZnX(arg0: Matrix3d): Matrix3d;
                mapYnXZ(arg0: Matrix3d): Matrix3d;
                mapYnXnZ(arg0: Matrix3d): Matrix3d;
                mapYnZX(arg0: Matrix3d): Matrix3d;
                mapYnZnX(arg0: Matrix3d): Matrix3d;
                mapZXY(arg0: Matrix3d): Matrix3d;
                mapZXnY(arg0: Matrix3d): Matrix3d;
                mapZYX(arg0: Matrix3d): Matrix3d;
                mapZYnX(arg0: Matrix3d): Matrix3d;
                mapZnXY(arg0: Matrix3d): Matrix3d;
                mapZnXnY(arg0: Matrix3d): Matrix3d;
                mapZnYX(arg0: Matrix3d): Matrix3d;
                mapZnYnX(arg0: Matrix3d): Matrix3d;
                mapnXYnZ(arg0: Matrix3d): Matrix3d;
                mapnXZY(arg0: Matrix3d): Matrix3d;
                mapnXZnY(arg0: Matrix3d): Matrix3d;
                mapnXnYZ(arg0: Matrix3d): Matrix3d;
                mapnXnYnZ(arg0: Matrix3d): Matrix3d;
                mapnXnZY(arg0: Matrix3d): Matrix3d;
                mapnXnZnY(arg0: Matrix3d): Matrix3d;
                mapnYXZ(arg0: Matrix3d): Matrix3d;
                mapnYXnZ(arg0: Matrix3d): Matrix3d;
                mapnYZX(arg0: Matrix3d): Matrix3d;
                mapnYZnX(arg0: Matrix3d): Matrix3d;
                mapnYnXZ(arg0: Matrix3d): Matrix3d;
                mapnYnXnZ(arg0: Matrix3d): Matrix3d;
                mapnYnZX(arg0: Matrix3d): Matrix3d;
                mapnYnZnX(arg0: Matrix3d): Matrix3d;
                mapnZXY(arg0: Matrix3d): Matrix3d;
                mapnZXnY(arg0: Matrix3d): Matrix3d;
                mapnZYX(arg0: Matrix3d): Matrix3d;
                mapnZYnX(arg0: Matrix3d): Matrix3d;
                mapnZnXY(arg0: Matrix3d): Matrix3d;
                mapnZnXnY(arg0: Matrix3d): Matrix3d;
                mapnZnYX(arg0: Matrix3d): Matrix3d;
                mapnZnYnX(arg0: Matrix3d): Matrix3d;
                negateX(arg0: Matrix3d): Matrix3d;
                negateY(arg0: Matrix3d): Matrix3d;
                negateZ(arg0: Matrix3d): Matrix3d;

            }

            const Vector3fc: JavaInterfaceStatics<Vector3fc>;
            interface Vector3fc extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3fc;
                sub(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                sub(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                add(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                add(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                fma(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mulAdd(arg0: float, arg1: Vector3fc, arg2: Vector3f): Vector3f;
                mul(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                div(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulProject(arg0: Matrix4fc, arg1: float, arg2: Vector3f): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3x2fc, arg1: Vector3f): Vector3f;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3f): number;
                mulDirection(arg0: Matrix4dc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3f): Vector3f;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                div(arg0: float, arg1: Vector3f): Vector3f;
                div(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                rotate(arg0: Quaternionfc, arg1: Vector3f): Vector3f;
                rotationTo(arg0: Vector3fc, arg1: Quaternionf): Quaternionf;
                rotationTo(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                rotateX(arg0: float, arg1: Vector3f): Vector3f;
                rotateY(arg0: float, arg1: Vector3f): Vector3f;
                rotateZ(arg0: float, arg1: Vector3f): Vector3f;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector3f): Vector3f;
                normalize(arg0: float, arg1: Vector3f): Vector3f;
                cross(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                cross(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                distance(arg0: Vector3fc): number;
                distance(arg0: float, arg1: float, arg2: float): number;
                distanceSquared(arg0: Vector3fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float): number;
                dot(arg0: Vector3fc): number;
                dot(arg0: float, arg1: float, arg2: float): number;
                angleCos(arg0: Vector3fc): number;
                angle(arg0: Vector3fc): number;
                angleSigned(arg0: Vector3fc, arg1: Vector3fc): number;
                angleSigned(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): number;
                min(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                max(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                negate(arg0: Vector3f): Vector3f;
                absolute(arg0: Vector3f): Vector3f;
                reflect(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                half(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                half(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                smoothStep(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                hermite(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: float, arg4: Vector3f): Vector3f;
                lerp(arg0: Vector3fc, arg1: float, arg2: Vector3f): Vector3f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                orthogonalizeUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                floor(arg0: Vector3f): Vector3f;
                ceil(arg0: Vector3f): Vector3f;
                round(arg0: Vector3f): Vector3f;
                isFinite(): boolean;
                equals(arg0: Vector3fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float): boolean;

            }

            const Matrix3fc: JavaInterfaceStatics<Matrix3fc>;
            interface Matrix3fc extends JavaObject {

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                mul(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulLocal(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                determinant(): number;
                invert(arg0: Matrix3f): Matrix3f;
                transpose(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4f): Matrix4f;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                scale(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                scale(arg0: float, arg1: Matrix3f): Matrix3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                rotateX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocalX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotate(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                get(arg0: int, arg1: int): number;
                getRowColumn(arg0: int, arg1: int): number;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor(arg0: Matrix3f): Matrix3f;
                getScale(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                add(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                sub(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulComponentWise(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                lerp(arg0: Matrix3fc, arg1: float, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix3f): Matrix3f;
                equals(arg0: Matrix3fc, arg1: float): boolean;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                reflect(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                reflect(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                isFinite(): boolean;
                quadraticFormProduct(arg0: float, arg1: float, arg2: float): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(arg0: Matrix3f): Matrix3f;
                mapXZnY(arg0: Matrix3f): Matrix3f;
                mapXnYnZ(arg0: Matrix3f): Matrix3f;
                mapXnZY(arg0: Matrix3f): Matrix3f;
                mapXnZnY(arg0: Matrix3f): Matrix3f;
                mapYXZ(arg0: Matrix3f): Matrix3f;
                mapYXnZ(arg0: Matrix3f): Matrix3f;
                mapYZX(arg0: Matrix3f): Matrix3f;
                mapYZnX(arg0: Matrix3f): Matrix3f;
                mapYnXZ(arg0: Matrix3f): Matrix3f;
                mapYnXnZ(arg0: Matrix3f): Matrix3f;
                mapYnZX(arg0: Matrix3f): Matrix3f;
                mapYnZnX(arg0: Matrix3f): Matrix3f;
                mapZXY(arg0: Matrix3f): Matrix3f;
                mapZXnY(arg0: Matrix3f): Matrix3f;
                mapZYX(arg0: Matrix3f): Matrix3f;
                mapZYnX(arg0: Matrix3f): Matrix3f;
                mapZnXY(arg0: Matrix3f): Matrix3f;
                mapZnXnY(arg0: Matrix3f): Matrix3f;
                mapZnYX(arg0: Matrix3f): Matrix3f;
                mapZnYnX(arg0: Matrix3f): Matrix3f;
                mapnXYnZ(arg0: Matrix3f): Matrix3f;
                mapnXZY(arg0: Matrix3f): Matrix3f;
                mapnXZnY(arg0: Matrix3f): Matrix3f;
                mapnXnYZ(arg0: Matrix3f): Matrix3f;
                mapnXnYnZ(arg0: Matrix3f): Matrix3f;
                mapnXnZY(arg0: Matrix3f): Matrix3f;
                mapnXnZnY(arg0: Matrix3f): Matrix3f;
                mapnYXZ(arg0: Matrix3f): Matrix3f;
                mapnYXnZ(arg0: Matrix3f): Matrix3f;
                mapnYZX(arg0: Matrix3f): Matrix3f;
                mapnYZnX(arg0: Matrix3f): Matrix3f;
                mapnYnXZ(arg0: Matrix3f): Matrix3f;
                mapnYnXnZ(arg0: Matrix3f): Matrix3f;
                mapnYnZX(arg0: Matrix3f): Matrix3f;
                mapnYnZnX(arg0: Matrix3f): Matrix3f;
                mapnZXY(arg0: Matrix3f): Matrix3f;
                mapnZXnY(arg0: Matrix3f): Matrix3f;
                mapnZYX(arg0: Matrix3f): Matrix3f;
                mapnZYnX(arg0: Matrix3f): Matrix3f;
                mapnZnXY(arg0: Matrix3f): Matrix3f;
                mapnZnXnY(arg0: Matrix3f): Matrix3f;
                mapnZnYX(arg0: Matrix3f): Matrix3f;
                mapnZnYnX(arg0: Matrix3f): Matrix3f;
                negateX(arg0: Matrix3f): Matrix3f;
                negateY(arg0: Matrix3f): Matrix3f;
                negateZ(arg0: Matrix3f): Matrix3f;

            }

            const Quaternionfc: JavaInterfaceStatics<Quaternionfc>;
            interface Quaternionfc extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(arg0: Quaternionf): Quaternionf;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                add(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                angle(): number;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                getAsMatrix3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4x3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4x3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                mul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                mul(arg0: float, arg1: Quaternionf): Quaternionf;
                premul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                premul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                invert(arg0: Quaternionf): Quaternionf;
                div(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                conjugate(arg0: Quaternionf): Quaternionf;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesZXY(arg0: Vector3f): Vector3f;
                getEulerAnglesYXZ(arg0: Vector3f): Vector3f;
                lengthSquared(): number;
                slerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                scale(arg0: float, arg1: Quaternionf): Quaternionf;
                integrate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                nlerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                nlerpIterative(arg0: Quaternionfc, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotateTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotateTo(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                rotateX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                difference(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                conjugateBy(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                isFinite(): boolean;
                equals(arg0: Quaternionfc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;

            }

            const Vector2ic: JavaInterfaceStatics<Vector2ic>;
            interface Vector2ic extends JavaObject {

                x(): number;
                y(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                getToAddress(arg0: long): Vector2ic;
                sub(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                sub(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2ic): number;
                distance(arg0: int, arg1: int): number;
                distanceSquared(arg0: Vector2ic): number;
                distanceSquared(arg0: int, arg1: int): number;
                gridDistance(arg0: Vector2ic): number;
                gridDistance(arg0: int, arg1: int): number;
                add(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                add(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                mul(arg0: int, arg1: Vector2i): Vector2i;
                mul(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                mul(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                div(arg0: float, arg1: Vector2i): Vector2i;
                div(arg0: int, arg1: Vector2i): Vector2i;
                negate(arg0: Vector2i): Vector2i;
                min(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                max(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                maxComponent(): number;
                minComponent(): number;
                absolute(arg0: Vector2i): Vector2i;
                get(arg0: int): number;
                equals(arg0: int, arg1: int): boolean;

            }

            const Quaternionf: JavaClassStatics<Quaternionf, Quaternionf$$constructor> & {

                slerp(arg0: Quaternionf[], arg1: float[], arg2: Quaternionf): Quaternionfc;
                nlerp(arg0: Quaternionfc[], arg1: float[], arg2: Quaternionf): Quaternionfc;
                nlerpIterative(arg0: Quaternionf[], arg1: float[], arg2: float, arg3: Quaternionf): Quaternionfc;

            }
            interface Quaternionf$$constructor extends SuppressProperties {

                new (): Quaternionf;
                new (arg0: double, arg1: double, arg2: double, arg3: double): Quaternionf;
                new (arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                new (arg0: Quaternionfc): Quaternionf;
                new (arg0: Quaterniondc): Quaternionf;
                new (arg0: AxisAngle4f): Quaternionf;
                new (arg0: AxisAngle4d): Quaternionf;

            }
            interface Quaternionf extends java.io.Externalizable, java.lang.Cloneable, Quaternionfc {
                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(): Quaternionf;
                normalize(arg0: Quaternionf): Quaternionf;
                add(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                add(arg0: Quaternionfc): Quaternionf;
                add(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                dot(arg0: Quaternionf): number;
                angle(): number;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                getAsMatrix3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getAsMatrix4x3f(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getAsMatrix4x3f(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                set(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                set(arg0: Quaternionfc): Quaternionf;
                set(arg0: Quaterniondc): Quaternionf;
                set(arg0: AxisAngle4f): Quaternionf;
                set(arg0: AxisAngle4d): Quaternionf;
                setAngleAxis(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                setAngleAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaternionf;
                rotationAxis(arg0: AxisAngle4f): Quaternionf;
                rotationAxis(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                rotationAxis(arg0: float, arg1: Vector3fc): Quaternionf;
                rotationX(arg0: float): Quaternionf;
                rotationY(arg0: float): Quaternionf;
                rotationZ(arg0: float): Quaternionf;
                setFromUnnormalized(arg0: Matrix4fc): Quaternionf;
                setFromUnnormalized(arg0: Matrix4x3fc): Quaternionf;
                setFromUnnormalized(arg0: Matrix4x3dc): Quaternionf;
                setFromNormalized(arg0: Matrix4fc): Quaternionf;
                setFromNormalized(arg0: Matrix4x3fc): Quaternionf;
                setFromNormalized(arg0: Matrix4x3dc): Quaternionf;
                setFromUnnormalized(arg0: Matrix4dc): Quaternionf;
                setFromNormalized(arg0: Matrix4dc): Quaternionf;
                setFromUnnormalized(arg0: Matrix3fc): Quaternionf;
                setFromNormalized(arg0: Matrix3fc): Quaternionf;
                setFromUnnormalized(arg0: Matrix3dc): Quaternionf;
                setFromNormalized(arg0: Matrix3dc): Quaternionf;
                fromAxisAngleRad(arg0: Vector3fc, arg1: float): Quaternionf;
                fromAxisAngleRad(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                fromAxisAngleDeg(arg0: Vector3fc, arg1: float): Quaternionf;
                fromAxisAngleDeg(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                mul(arg0: Quaternionfc): Quaternionf;
                mul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                mul(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                mul(arg0: float): Quaternionf;
                mul(arg0: float, arg1: Quaternionf): Quaternionf;
                premul(arg0: Quaternionfc): Quaternionf;
                premul(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                premul(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                premul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformUnit(arg0: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector4f): Vector4f;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverse(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: float, arg1: float, arg2: float, arg3: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                invert(arg0: Quaternionf): Quaternionf;
                invert(): Quaternionf;
                div(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                div(arg0: Quaternionfc): Quaternionf;
                conjugate(): Quaternionf;
                conjugate(arg0: Quaternionf): Quaternionf;
                identity(): Quaternionf;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateZYX(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesZXY(arg0: Vector3f): Vector3f;
                getEulerAnglesYXZ(arg0: Vector3f): Vector3f;
                lengthSquared(): number;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotationZYX(arg0: float, arg1: float, arg2: float): Quaternionf;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Quaternionf;
                slerp(arg0: Quaternionfc, arg1: float): Quaternionf;
                slerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                scale(arg0: float): Quaternionf;
                scale(arg0: float, arg1: Quaternionf): Quaternionf;
                scaling(arg0: float): Quaternionf;
                integrate(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                integrate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                nlerp(arg0: Quaternionfc, arg1: float): Quaternionf;
                nlerp(arg0: Quaternionfc, arg1: float, arg2: Quaternionf): Quaternionf;
                nlerpIterative(arg0: Quaternionfc, arg1: float, arg2: float, arg3: Quaternionf): Quaternionf;
                nlerpIterative(arg0: Quaternionfc, arg1: float, arg2: float): Quaternionf;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Quaternionf;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Quaternionf;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotationTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Quaternionf;
                rotationTo(arg0: Vector3fc, arg1: Vector3fc): Quaternionf;
                rotateTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Quaternionf): Quaternionf;
                rotateTo(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Quaternionf;
                rotateTo(arg0: Vector3fc, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                rotateTo(arg0: Vector3fc, arg1: Vector3fc): Quaternionf;
                rotateX(arg0: float): Quaternionf;
                rotateX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateY(arg0: float): Quaternionf;
                rotateY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateZ(arg0: float): Quaternionf;
                rotateZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalX(arg0: float): Quaternionf;
                rotateLocalX(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalY(arg0: float): Quaternionf;
                rotateLocalY(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateLocalZ(arg0: float): Quaternionf;
                rotateLocalZ(arg0: float, arg1: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: Vector3fc, arg2: Quaternionf): Quaternionf;
                rotateAxis(arg0: float, arg1: Vector3fc): Quaternionf;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float): Quaternionf;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                difference(arg0: Quaternionf): Quaternionf;
                difference(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                conjugateBy(arg0: Quaternionfc): Quaternionf;
                conjugateBy(arg0: Quaternionfc, arg1: Quaternionf): Quaternionf;
                isFinite(): boolean;
                equals(arg0: Quaternionfc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            const Vector3d: JavaClassStatics<Vector3d, Vector3d$$constructor> & {

                lengthSquared(arg0: double, arg1: double, arg2: double): number;
                length(arg0: double, arg1: double, arg2: double): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;

            }
            interface Vector3d$$constructor extends SuppressProperties {

                new (): Vector3d;
                new (arg0: double): Vector3d;
                new (arg0: double, arg1: double, arg2: double): Vector3d;
                new (arg0: Vector3fc): Vector3d;
                new (arg0: Vector3ic): Vector3d;
                new (arg0: Vector2fc, arg1: double): Vector3d;
                new (arg0: Vector2ic, arg1: double): Vector3d;
                new (arg0: Vector3dc): Vector3d;
                new (arg0: Vector2dc, arg1: double): Vector3d;
                new (arg0: double[]): Vector3d;
                new (arg0: float[]): Vector3d;
                new (arg0: java.nio.ByteBuffer): Vector3d;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector3d;
                new (arg0: java.nio.DoubleBuffer): Vector3d;
                new (arg0: int, arg1: java.nio.DoubleBuffer): Vector3d;

            }
            interface Vector3d extends java.io.Externalizable, java.lang.Cloneable, Vector3dc {
                x: number;
                y: number;
                z: number;

                x(): number;
                y(): number;
                z(): number;
                set(arg0: Vector3dc): Vector3d;
                set(arg0: Vector3ic): Vector3d;
                set(arg0: Vector2dc, arg1: double): Vector3d;
                set(arg0: Vector2ic, arg1: double): Vector3d;
                set(arg0: Vector3fc): Vector3d;
                set(arg0: Vector2fc, arg1: double): Vector3d;
                set(arg0: double): Vector3d;
                set(arg0: double, arg1: double, arg2: double): Vector3d;
                set(arg0: double[]): Vector3d;
                set(arg0: float[]): Vector3d;
                set(arg0: java.nio.ByteBuffer): Vector3d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector3d;
                set(arg0: java.nio.DoubleBuffer): Vector3d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Vector3d;
                setFromAddress(arg0: long): Vector3d;
                setComponent(arg0: int, arg1: double): Vector3d;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector3dc;
                sub(arg0: Vector3dc): Vector3d;
                sub(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                sub(arg0: Vector3fc): Vector3d;
                sub(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                sub(arg0: double, arg1: double, arg2: double): Vector3d;
                sub(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                add(arg0: Vector3dc): Vector3d;
                add(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                add(arg0: Vector3fc): Vector3d;
                add(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                add(arg0: double, arg1: double, arg2: double): Vector3d;
                add(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3dc): Vector3d;
                fma(arg0: double, arg1: Vector3dc): Vector3d;
                fma(arg0: Vector3fc, arg1: Vector3fc): Vector3d;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3fc): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3dc, arg1: Vector3dc): Vector3d;
                mulAdd(arg0: double, arg1: Vector3dc): Vector3d;
                mulAdd(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3fc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mul(arg0: Vector3dc): Vector3d;
                mul(arg0: Vector3fc): Vector3d;
                mul(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3d): Vector3d;
                div(arg0: Vector3fc): Vector3d;
                div(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: double, arg2: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc): Vector3d;
                mulProject(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4fc): Vector3d;
                mul(arg0: Matrix3fc): Vector3d;
                mul(arg0: Matrix3dc): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2dc): Vector3d;
                mul(arg0: Matrix3x2dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2fc): Vector3d;
                mul(arg0: Matrix3x2fc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3dc): Vector3d;
                mulTranspose(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3fc): Vector3d;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4fc): Vector3d;
                mulPosition(arg0: Matrix4dc): Vector3d;
                mulPosition(arg0: Matrix4x3dc): Vector3d;
                mulPosition(arg0: Matrix4x3fc): Vector3d;
                mulPosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4dc): Vector3d;
                mulTransposePosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4fc): Vector3d;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPositionW(arg0: Matrix4fc): number;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3d): number;
                mulPositionW(arg0: Matrix4dc): number;
                mulPositionW(arg0: Matrix4dc, arg1: Vector3d): number;
                mulDirection(arg0: Matrix4fc): Vector3d;
                mulDirection(arg0: Matrix4dc): Vector3d;
                mulDirection(arg0: Matrix4x3dc): Vector3d;
                mulDirection(arg0: Matrix4x3fc): Vector3d;
                mulDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4dc): Vector3d;
                mulTransposeDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4fc): Vector3d;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mul(arg0: double): Vector3d;
                mul(arg0: double, arg1: Vector3d): Vector3d;
                mul(arg0: double, arg1: double, arg2: double): Vector3d;
                mul(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                rotate(arg0: Quaterniondc): Vector3d;
                rotate(arg0: Quaterniondc, arg1: Vector3d): Vector3d;
                rotationTo(arg0: Vector3dc, arg1: Quaterniond): Quaterniond;
                rotationTo(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double): Vector3d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                rotateX(arg0: double): Vector3d;
                rotateX(arg0: double, arg1: Vector3d): Vector3d;
                rotateY(arg0: double): Vector3d;
                rotateY(arg0: double, arg1: Vector3d): Vector3d;
                rotateZ(arg0: double): Vector3d;
                rotateZ(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double): Vector3d;
                div(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double, arg1: double, arg2: double): Vector3d;
                div(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector3d;
                normalize(arg0: Vector3d): Vector3d;
                normalize(arg0: double): Vector3d;
                normalize(arg0: double, arg1: Vector3d): Vector3d;
                cross(arg0: Vector3dc): Vector3d;
                cross(arg0: double, arg1: double, arg2: double): Vector3d;
                cross(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                cross(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                distance(arg0: Vector3dc): number;
                distance(arg0: double, arg1: double, arg2: double): number;
                distanceSquared(arg0: Vector3dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double): number;
                dot(arg0: Vector3dc): number;
                dot(arg0: double, arg1: double, arg2: double): number;
                angleCos(arg0: Vector3dc): number;
                angle(arg0: Vector3dc): number;
                angleSigned(arg0: Vector3dc, arg1: Vector3dc): number;
                angleSigned(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                min(arg0: Vector3dc): Vector3d;
                min(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                max(arg0: Vector3dc): Vector3d;
                max(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                zero(): Vector3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector3d;
                negate(arg0: Vector3d): Vector3d;
                absolute(): Vector3d;
                absolute(arg0: Vector3d): Vector3d;
                equals(arg0: Vector3dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double): boolean;
                equals(arg0: any): boolean;
                reflect(arg0: Vector3dc): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double): Vector3d;
                reflect(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                half(arg0: Vector3dc): Vector3d;
                half(arg0: double, arg1: double, arg2: double): Vector3d;
                half(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                half(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                smoothStep(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                hermite(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: double, arg4: Vector3d): Vector3d;
                lerp(arg0: Vector3dc, arg1: double): Vector3d;
                lerp(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                orthogonalize(arg0: Vector3dc): Vector3d;
                orthogonalizeUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                orthogonalizeUnit(arg0: Vector3dc): Vector3d;
                floor(): Vector3d;
                floor(arg0: Vector3d): Vector3d;
                ceil(): Vector3d;
                ceil(arg0: Vector3d): Vector3d;
                round(): Vector3d;
                round(arg0: Vector3d): Vector3d;
                isFinite(): boolean;
                clone(): any;

            }

            const Vector3ic: JavaInterfaceStatics<Vector3ic>;
            interface Vector3ic extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3ic;
                sub(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                sub(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                add(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                add(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                mul(arg0: int, arg1: Vector3i): Vector3i;
                mul(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                mul(arg0: int, arg1: int, arg2: int, arg3: Vector3i): Vector3i;
                div(arg0: float, arg1: Vector3i): Vector3i;
                div(arg0: int, arg1: Vector3i): Vector3i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector3ic): number;
                distance(arg0: int, arg1: int, arg2: int): number;
                gridDistance(arg0: Vector3ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int): number;
                distanceSquared(arg0: Vector3ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int): number;
                negate(arg0: Vector3i): Vector3i;
                min(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                max(arg0: Vector3ic, arg1: Vector3i): Vector3i;
                get(arg0: int): number;
                maxComponent(): number;
                minComponent(): number;
                absolute(arg0: Vector3i): Vector3i;
                equals(arg0: int, arg1: int, arg2: int): boolean;

            }

            const Vector2fc: JavaInterfaceStatics<Vector2fc>;
            interface Vector2fc extends JavaObject {

                x(): number;
                y(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector2fc;
                sub(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                sub(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                dot(arg0: Vector2fc): number;
                angle(arg0: Vector2fc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: float, arg1: float): number;
                distanceSquared(arg0: float, arg1: float): number;
                normalize(arg0: Vector2f): Vector2f;
                normalize(arg0: float, arg1: Vector2f): Vector2f;
                add(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                add(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                negate(arg0: Vector2f): Vector2f;
                mul(arg0: float, arg1: Vector2f): Vector2f;
                mul(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: float, arg1: Vector2f): Vector2f;
                div(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mul(arg0: Matrix2dc, arg1: Vector2f): Vector2f;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mulPosition(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                mulDirection(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                lerp(arg0: Vector2fc, arg1: float, arg2: Vector2f): Vector2f;
                fma(arg0: Vector2fc, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                fma(arg0: float, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                min(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                max(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                maxComponent(): number;
                minComponent(): number;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                floor(arg0: Vector2f): Vector2f;
                ceil(arg0: Vector2f): Vector2f;
                round(arg0: Vector2f): Vector2f;
                isFinite(): boolean;
                absolute(arg0: Vector2f): Vector2f;
                equals(arg0: Vector2fc, arg1: float): boolean;
                equals(arg0: float, arg1: float): boolean;

            }

            const Matrix3x2fc: JavaInterfaceStatics<Matrix3x2fc>;
            interface Matrix3x2fc extends JavaObject {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                mul(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                mulLocal(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                determinant(): number;
                invert(arg0: Matrix3x2f): Matrix3x2f;
                translate(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                translate(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get3x3(arg0: float[], arg1: int): JavaArray<number>;
                get3x3(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                scale(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scale(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                scale(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3f, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformPosition(arg0: Vector2f): Vector2f;
                transformPosition(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformPosition(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformDirection(arg0: Vector2f): Vector2f;
                transformDirection(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformDirection(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                rotate(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateAbout(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                rotateTo(arg0: Vector2fc, arg1: Vector2fc, arg2: Matrix3x2f): Matrix3x2f;
                view(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                origin(arg0: Vector2f): Vector2f;
                viewArea(arg0: float[]): JavaArray<number>;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                unproject(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                unprojectInv(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                testPoint(arg0: float, arg1: float): boolean;
                testCircle(arg0: float, arg1: float, arg2: float): boolean;
                testAar(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: Matrix3x2fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            const Matrix4x3fc: JavaInterfaceStatics<Matrix4x3fc> & {
                readonly PLANE_NX: number;
                readonly PLANE_PX: number;
                readonly PLANE_NY: number;
                readonly PLANE_PY: number;
                readonly PLANE_NZ: number;
                readonly PLANE_PZ: number;
                readonly PROPERTY_IDENTITY: number;
                readonly PROPERTY_TRANSLATION: number;
                readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4x3fc extends JavaObject {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulOrtho(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                fma(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulComponentWise(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                determinant(): number;
                invert(arg0: Matrix4x3f): Matrix4x3f;
                invert(arg0: Matrix4f): Matrix4f;
                invertOrtho(arg0: Matrix4x3f): Matrix4x3f;
                transpose3x3(arg0: Matrix4x3f): Matrix4x3f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: float[], arg1: int): JavaArray<number>;
                getTransposed(arg0: float[]): JavaArray<number>;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                scale(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                scale(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateX(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateY(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateZ(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                translate(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                normal(arg0: Matrix4x3f): Matrix4x3f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4fc, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4x3f): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: Matrix4x3fc, arg2: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3fc, arg5: Matrix4x3f): Matrix4x3f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4x3f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4x3f;
                lerp(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                mapXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnXYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                negateX(arg0: Matrix4x3f): Matrix4x3f;
                negateY(arg0: Matrix4x3f): Matrix4x3f;
                negateZ(arg0: Matrix4x3f): Matrix4x3f;
                equals(arg0: Matrix4x3fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            const Vector2dc: JavaInterfaceStatics<Vector2dc>;
            interface Vector2dc extends JavaObject {

                x(): number;
                y(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getToAddress(arg0: long): Vector2dc;
                sub(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                sub(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                sub(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                mul(arg0: double, arg1: Vector2d): Vector2d;
                mul(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                mul(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                div(arg0: double, arg1: Vector2d): Vector2d;
                div(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                div(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                div(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulPosition(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                mulDirection(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                dot(arg0: Vector2dc): number;
                angle(arg0: Vector2dc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2dc): number;
                distanceSquared(arg0: Vector2dc): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: double, arg1: double): number;
                distanceSquared(arg0: double, arg1: double): number;
                normalize(arg0: Vector2d): Vector2d;
                normalize(arg0: double, arg1: Vector2d): Vector2d;
                add(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                add(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                add(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                negate(arg0: Vector2d): Vector2d;
                lerp(arg0: Vector2dc, arg1: double, arg2: Vector2d): Vector2d;
                fma(arg0: Vector2dc, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                fma(arg0: double, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                min(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                max(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                maxComponent(): number;
                minComponent(): number;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                floor(arg0: Vector2d): Vector2d;
                ceil(arg0: Vector2d): Vector2d;
                round(arg0: Vector2d): Vector2d;
                isFinite(): boolean;
                absolute(arg0: Vector2d): Vector2d;
                equals(arg0: Vector2dc, arg1: double): boolean;
                equals(arg0: double, arg1: double): boolean;

            }

            const Vector3dc: JavaInterfaceStatics<Vector3dc>;
            interface Vector3dc extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector3dc;
                sub(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                sub(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                sub(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                add(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                add(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                add(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                fma(arg0: Vector3dc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                fma(arg0: double, arg1: Vector3fc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: double, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mulAdd(arg0: Vector3fc, arg1: Vector3dc, arg2: Vector3d): Vector3d;
                mul(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3fc, arg1: Vector3d): Vector3d;
                div(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: double, arg2: Vector3d): Vector3d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulProject(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3dc, arg1: Vector3f): Vector3f;
                mul(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2dc, arg1: Vector3d): Vector3d;
                mul(arg0: Matrix3x2fc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3dc, arg1: Vector3d): Vector3d;
                mulTranspose(arg0: Matrix3fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulPosition(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposePosition(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulPositionW(arg0: Matrix4fc, arg1: Vector3d): number;
                mulPositionW(arg0: Matrix4dc, arg1: Vector3d): number;
                mulDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3dc, arg1: Vector3d): Vector3d;
                mulDirection(arg0: Matrix4x3fc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulTransposeDirection(arg0: Matrix4fc, arg1: Vector3d): Vector3d;
                mul(arg0: double, arg1: Vector3d): Vector3d;
                mul(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                rotate(arg0: Quaterniondc, arg1: Vector3d): Vector3d;
                rotationTo(arg0: Vector3dc, arg1: Quaterniond): Quaterniond;
                rotationTo(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                rotateX(arg0: double, arg1: Vector3d): Vector3d;
                rotateY(arg0: double, arg1: Vector3d): Vector3d;
                rotateZ(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double, arg1: Vector3d): Vector3d;
                div(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector3d): Vector3d;
                normalize(arg0: double, arg1: Vector3d): Vector3d;
                cross(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                cross(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                distance(arg0: Vector3dc): number;
                distance(arg0: double, arg1: double, arg2: double): number;
                distanceSquared(arg0: Vector3dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double): number;
                dot(arg0: Vector3dc): number;
                dot(arg0: double, arg1: double, arg2: double): number;
                angleCos(arg0: Vector3dc): number;
                angle(arg0: Vector3dc): number;
                angleSigned(arg0: Vector3dc, arg1: Vector3dc): number;
                angleSigned(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                min(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                max(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                negate(arg0: Vector3d): Vector3d;
                absolute(arg0: Vector3d): Vector3d;
                reflect(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                half(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                half(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                smoothStep(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                hermite(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: double, arg4: Vector3d): Vector3d;
                lerp(arg0: Vector3dc, arg1: double, arg2: Vector3d): Vector3d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector3i): Vector3i;
                get(arg0: Vector3f): Vector3f;
                get(arg0: Vector3d): Vector3d;
                maxComponent(): number;
                minComponent(): number;
                orthogonalize(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                orthogonalizeUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                floor(arg0: Vector3d): Vector3d;
                ceil(arg0: Vector3d): Vector3d;
                round(arg0: Vector3d): Vector3d;
                isFinite(): boolean;
                equals(arg0: Vector3dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double): boolean;

            }

            const AxisAngle4d: JavaClassStatics<AxisAngle4d, AxisAngle4d$$constructor>;
            interface AxisAngle4d$$constructor extends SuppressProperties {

                new (): AxisAngle4d;
                new (arg0: AxisAngle4d): AxisAngle4d;
                new (arg0: AxisAngle4f): AxisAngle4d;
                new (arg0: Quaternionfc): AxisAngle4d;
                new (arg0: Quaterniondc): AxisAngle4d;
                new (arg0: double, arg1: double, arg2: double, arg3: double): AxisAngle4d;
                new (arg0: double, arg1: Vector3dc): AxisAngle4d;
                new (arg0: double, arg1: Vector3f): AxisAngle4d;

            }
            interface AxisAngle4d extends java.io.Externalizable, java.lang.Cloneable {
                angle: number;
                x: number;
                y: number;
                z: number;

                set(arg0: AxisAngle4d): AxisAngle4d;
                set(arg0: AxisAngle4f): AxisAngle4d;
                set(arg0: double, arg1: double, arg2: double, arg3: double): AxisAngle4d;
                set(arg0: double, arg1: Vector3dc): AxisAngle4d;
                set(arg0: double, arg1: Vector3f): AxisAngle4d;
                set(arg0: Quaternionfc): AxisAngle4d;
                set(arg0: Quaterniondc): AxisAngle4d;
                set(arg0: Matrix3fc): AxisAngle4d;
                set(arg0: Matrix3dc): AxisAngle4d;
                set(arg0: Matrix4fc): AxisAngle4d;
                set(arg0: Matrix4x3fc): AxisAngle4d;
                set(arg0: Matrix4dc): AxisAngle4d;
                get(arg0: Quaternionf): Quaternionf;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                normalize(): AxisAngle4d;
                rotate(arg0: double): AxisAngle4d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                clone(): any;

            }

            const AxisAngle4f: JavaClassStatics<AxisAngle4f, AxisAngle4f$$constructor>;
            interface AxisAngle4f$$constructor extends SuppressProperties {

                new (): AxisAngle4f;
                new (arg0: AxisAngle4f): AxisAngle4f;
                new (arg0: Quaternionfc): AxisAngle4f;
                new (arg0: float, arg1: float, arg2: float, arg3: float): AxisAngle4f;
                new (arg0: float, arg1: Vector3fc): AxisAngle4f;

            }
            interface AxisAngle4f extends java.io.Externalizable, java.lang.Cloneable {
                angle: number;
                x: number;
                y: number;
                z: number;

                set(arg0: AxisAngle4f): AxisAngle4f;
                set(arg0: AxisAngle4d): AxisAngle4f;
                set(arg0: float, arg1: float, arg2: float, arg3: float): AxisAngle4f;
                set(arg0: float, arg1: Vector3fc): AxisAngle4f;
                set(arg0: Quaternionfc): AxisAngle4f;
                set(arg0: Quaterniondc): AxisAngle4f;
                set(arg0: Matrix3fc): AxisAngle4f;
                set(arg0: Matrix3dc): AxisAngle4f;
                set(arg0: Matrix4fc): AxisAngle4f;
                set(arg0: Matrix4x3fc): AxisAngle4f;
                set(arg0: Matrix4dc): AxisAngle4f;
                get(arg0: Quaternionf): Quaternionf;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: AxisAngle4f): AxisAngle4f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                normalize(): AxisAngle4f;
                rotate(arg0: float): AxisAngle4f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                clone(): any;

            }

            const Matrix2dc: JavaInterfaceStatics<Matrix2dc>;
            interface Matrix2dc extends JavaObject {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                mul(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mul(arg0: Matrix2fc, arg1: Matrix2d): Matrix2d;
                mulLocal(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                determinant(): number;
                invert(arg0: Matrix2d): Matrix2d;
                transpose(arg0: Matrix2d): Matrix2d;
                get(arg0: Matrix2d): Matrix2d;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(): number;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                scale(arg0: Vector2dc, arg1: Matrix2d): Matrix2d;
                scale(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                scale(arg0: double, arg1: Matrix2d): Matrix2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                transform(arg0: Vector2d): Vector2d;
                transform(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transform(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformTranspose(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                rotate(arg0: double, arg1: Matrix2d): Matrix2d;
                rotateLocal(arg0: double, arg1: Matrix2d): Matrix2d;
                getRow(arg0: int, arg1: Vector2d): Vector2d;
                getColumn(arg0: int, arg1: Vector2d): Vector2d;
                get(arg0: int, arg1: int): number;
                normal(arg0: Matrix2d): Matrix2d;
                getScale(arg0: Vector2d): Vector2d;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                add(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                sub(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mulComponentWise(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                lerp(arg0: Matrix2dc, arg1: double, arg2: Matrix2d): Matrix2d;
                equals(arg0: Matrix2dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            const Matrix4x3f: JavaClassStatics<Matrix4x3f, Matrix4x3f$$constructor>;
            interface Matrix4x3f$$constructor extends SuppressProperties {

                new (): Matrix4x3f;
                new (arg0: Matrix3fc): Matrix4x3f;
                new (arg0: Matrix4x3fc): Matrix4x3f;
                new (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float): Matrix4x3f;
                new (arg0: java.nio.FloatBuffer): Matrix4x3f;
                new (arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Vector3fc): Matrix4x3f;

            }
            interface Matrix4x3f extends java.io.Externalizable, java.lang.Cloneable, Matrix4x3fc {

                assume(arg0: int): Matrix4x3f;
                determineProperties(): Matrix4x3f;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m00(arg0: float): Matrix4x3f;
                m01(arg0: float): Matrix4x3f;
                m02(arg0: float): Matrix4x3f;
                m10(arg0: float): Matrix4x3f;
                m11(arg0: float): Matrix4x3f;
                m12(arg0: float): Matrix4x3f;
                m20(arg0: float): Matrix4x3f;
                m21(arg0: float): Matrix4x3f;
                m22(arg0: float): Matrix4x3f;
                m30(arg0: float): Matrix4x3f;
                m31(arg0: float): Matrix4x3f;
                m32(arg0: float): Matrix4x3f;
                identity(): Matrix4x3f;
                set(arg0: Matrix4x3fc): Matrix4x3f;
                set(arg0: Matrix4fc): Matrix4x3f;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: Matrix4d): Matrix4d;
                set(arg0: Matrix3fc): Matrix4x3f;
                set(arg0: AxisAngle4f): Matrix4x3f;
                set(arg0: AxisAngle4d): Matrix4x3f;
                set(arg0: Quaternionfc): Matrix4x3f;
                set(arg0: Quaterniondc): Matrix4x3f;
                set(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Vector3fc): Matrix4x3f;
                set3x3(arg0: Matrix4x3fc): Matrix4x3f;
                mul(arg0: Matrix4x3fc): Matrix4x3f;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulOrtho(arg0: Matrix4x3fc): Matrix4x3f;
                mulOrtho(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                fma(arg0: Matrix4x3fc, arg1: float): Matrix4x3f;
                fma(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                add(arg0: Matrix4x3fc): Matrix4x3f;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                sub(arg0: Matrix4x3fc): Matrix4x3f;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                mulComponentWise(arg0: Matrix4x3fc): Matrix4x3f;
                mulComponentWise(arg0: Matrix4x3fc, arg1: Matrix4x3f): Matrix4x3f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float): Matrix4x3f;
                set(arg0: float[], arg1: int): Matrix4x3f;
                set(arg0: float[]): Matrix4x3f;
                set(arg0: java.nio.FloatBuffer): Matrix4x3f;
                set(arg0: java.nio.ByteBuffer): Matrix4x3f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4x3f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4x3f;
                setFromAddress(arg0: long): Matrix4x3f;
                determinant(): number;
                invert(arg0: Matrix4x3f): Matrix4x3f;
                invert(arg0: Matrix4f): Matrix4f;
                invert(): Matrix4x3f;
                invertOrtho(arg0: Matrix4x3f): Matrix4x3f;
                invertOrtho(): Matrix4x3f;
                transpose3x3(): Matrix4x3f;
                transpose3x3(arg0: Matrix4x3f): Matrix4x3f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                translation(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                translation(arg0: Vector3fc): Matrix4x3f;
                setTranslation(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setTranslation(arg0: Vector3fc): Matrix4x3f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: float[], arg1: int): JavaArray<number>;
                getTransposed(arg0: float[]): JavaArray<number>;
                zero(): Matrix4x3f;
                scaling(arg0: float): Matrix4x3f;
                scaling(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                scaling(arg0: Vector3fc): Matrix4x3f;
                rotation(arg0: float, arg1: Vector3fc): Matrix4x3f;
                rotation(arg0: AxisAngle4f): Matrix4x3f;
                rotation(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotationX(arg0: float): Matrix4x3f;
                rotationY(arg0: float): Matrix4x3f;
                rotationZ(arg0: float): Matrix4x3f;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotationZYX(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setRotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setRotationZYX(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                setRotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotation(arg0: Quaternionfc): Matrix4x3f;
                translationRotateScale(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): Matrix4x3f;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4x3f;
                translationRotateScaleMul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: Matrix4x3f): Matrix4x3f;
                translationRotateScaleMul(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: Quaternionfc): Matrix4x3f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4x3f;
                translationRotate(arg0: Vector3fc, arg1: Quaternionfc): Matrix4x3f;
                translationRotateMul(arg0: float, arg1: float, arg2: float, arg3: Quaternionfc, arg4: Matrix4x3fc): Matrix4x3f;
                translationRotateMul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: Matrix4x3fc): Matrix4x3f;
                translationRotateInvert(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4x3f;
                translationRotateInvert(arg0: Vector3fc, arg1: Quaternionfc): Matrix4x3f;
                set3x3(arg0: Matrix3fc): Matrix4x3f;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                scale(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                scale(arg0: Vector3fc): Matrix4x3f;
                scale(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                scale(arg0: float): Matrix4x3f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                scaleXY(arg0: float, arg1: float): Matrix4x3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                scale(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                scaleLocal(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateX(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateX(arg0: float): Matrix4x3f;
                rotateY(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateY(arg0: float): Matrix4x3f;
                rotateZ(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateZ(arg0: float): Matrix4x3f;
                rotateXYZ(arg0: Vector3f): Matrix4x3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateZYX(arg0: Vector3f): Matrix4x3f;
                rotateZYX(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotateYXZ(arg0: Vector3f): Matrix4x3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotationAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                rotateLocalX(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocalX(arg0: float): Matrix4x3f;
                rotateLocalY(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocalY(arg0: float): Matrix4x3f;
                rotateLocalZ(arg0: float, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocalZ(arg0: float): Matrix4x3f;
                translate(arg0: Vector3fc): Matrix4x3f;
                translate(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                translate(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                translateLocal(arg0: Vector3fc): Matrix4x3f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                translateLocal(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4x3f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4x3f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrtho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                setOrtho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setLookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                setLookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                setLookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                setLookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                setLookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                setLookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4x3f): Matrix4x3f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: Quaternionfc): Matrix4x3f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3f): Matrix4x3f;
                rotateLocal(arg0: Quaternionfc): Matrix4x3f;
                rotate(arg0: AxisAngle4f): Matrix4x3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3f): Matrix4x3f;
                rotate(arg0: float, arg1: Vector3fc): Matrix4x3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc): Matrix4x3f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4x3f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                reflection(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                reflection(arg0: Quaternionfc, arg1: Vector3fc): Matrix4x3f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                setRow(arg0: int, arg1: Vector4fc): Matrix4x3f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                setColumn(arg0: int, arg1: Vector3fc): Matrix4x3f;
                normal(): Matrix4x3f;
                normal(arg0: Matrix4x3f): Matrix4x3f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(): Matrix4x3f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(): Matrix4x3f;
                normalize3x3(arg0: Matrix4x3f): Matrix4x3f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4fc, arg1: float, arg2: float, arg3: float, arg4: float): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4x3f): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: Matrix4x3fc, arg2: Matrix4x3f): Matrix4x3f;
                shadow(arg0: Vector4fc, arg1: Matrix4x3fc): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3fc, arg5: Matrix4x3f): Matrix4x3f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                billboardCylindrical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                equals(arg0: Matrix4x3fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4x3f): Matrix4x3f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[]): Matrix4x3f;
                swap(arg0: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4x3f): Matrix4x3f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float): Matrix4x3f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4x3f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4x3f;
                lerp(arg0: Matrix4x3fc, arg1: float): Matrix4x3f;
                lerp(arg0: Matrix4x3fc, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4x3f): Matrix4x3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4x3f): Matrix4x3f;
                rotationTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4x3f;
                rotationTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4x3f;
                translationRotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4x3f;
                translationRotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4x3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float): Matrix4x3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: Vector3fc): Matrix4x3f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4x3f): Matrix4x3f;
                withLookAtUp(arg0: float, arg1: float, arg2: float): Matrix4x3f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4x3f): Matrix4x3f;
                mapXZY(): Matrix4x3f;
                mapXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXZnY(): Matrix4x3f;
                mapXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnYnZ(): Matrix4x3f;
                mapXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZY(): Matrix4x3f;
                mapXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapXnZnY(): Matrix4x3f;
                mapXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapYXZ(): Matrix4x3f;
                mapYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYXnZ(): Matrix4x3f;
                mapYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYZX(): Matrix4x3f;
                mapYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYZnX(): Matrix4x3f;
                mapYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXZ(): Matrix4x3f;
                mapYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnXnZ(): Matrix4x3f;
                mapYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZX(): Matrix4x3f;
                mapYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapYnZnX(): Matrix4x3f;
                mapYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZXY(): Matrix4x3f;
                mapZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZXnY(): Matrix4x3f;
                mapZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZYX(): Matrix4x3f;
                mapZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZYnX(): Matrix4x3f;
                mapZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXY(): Matrix4x3f;
                mapZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnXnY(): Matrix4x3f;
                mapZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYX(): Matrix4x3f;
                mapZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapZnYnX(): Matrix4x3f;
                mapZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnXYnZ(): Matrix4x3f;
                mapnXYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZY(): Matrix4x3f;
                mapnXZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXZnY(): Matrix4x3f;
                mapnXZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYZ(): Matrix4x3f;
                mapnXnYZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnYnZ(): Matrix4x3f;
                mapnXnYnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZY(): Matrix4x3f;
                mapnXnZY(arg0: Matrix4x3f): Matrix4x3f;
                mapnXnZnY(): Matrix4x3f;
                mapnXnZnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXZ(): Matrix4x3f;
                mapnYXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYXnZ(): Matrix4x3f;
                mapnYXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZX(): Matrix4x3f;
                mapnYZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYZnX(): Matrix4x3f;
                mapnYZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXZ(): Matrix4x3f;
                mapnYnXZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnXnZ(): Matrix4x3f;
                mapnYnXnZ(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZX(): Matrix4x3f;
                mapnYnZX(arg0: Matrix4x3f): Matrix4x3f;
                mapnYnZnX(): Matrix4x3f;
                mapnYnZnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXY(): Matrix4x3f;
                mapnZXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZXnY(): Matrix4x3f;
                mapnZXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYX(): Matrix4x3f;
                mapnZYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZYnX(): Matrix4x3f;
                mapnZYnX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXY(): Matrix4x3f;
                mapnZnXY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnXnY(): Matrix4x3f;
                mapnZnXnY(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYX(): Matrix4x3f;
                mapnZnYX(arg0: Matrix4x3f): Matrix4x3f;
                mapnZnYnX(): Matrix4x3f;
                mapnZnYnX(arg0: Matrix4x3f): Matrix4x3f;
                negateX(): Matrix4x3f;
                negateX(arg0: Matrix4x3f): Matrix4x3f;
                negateY(): Matrix4x3f;
                negateY(arg0: Matrix4x3f): Matrix4x3f;
                negateZ(): Matrix4x3f;
                negateZ(arg0: Matrix4x3f): Matrix4x3f;
                isFinite(): boolean;
                clone(): any;

            }

            const Vector2f: JavaClassStatics<Vector2f, Vector2f$$constructor> & {

                lengthSquared(arg0: float, arg1: float): number;
                length(arg0: float, arg1: float): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;

            }
            interface Vector2f$$constructor extends SuppressProperties {

                new (): Vector2f;
                new (arg0: float): Vector2f;
                new (arg0: float, arg1: float): Vector2f;
                new (arg0: Vector2fc): Vector2f;
                new (arg0: Vector2ic): Vector2f;
                new (arg0: float[]): Vector2f;
                new (arg0: java.nio.ByteBuffer): Vector2f;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector2f;
                new (arg0: java.nio.FloatBuffer): Vector2f;
                new (arg0: int, arg1: java.nio.FloatBuffer): Vector2f;

            }
            interface Vector2f extends java.io.Externalizable, java.lang.Cloneable, Vector2fc {
                x: number;
                y: number;

                x(): number;
                y(): number;
                set(arg0: float): Vector2f;
                set(arg0: float, arg1: float): Vector2f;
                set(arg0: double): Vector2f;
                set(arg0: double, arg1: double): Vector2f;
                set(arg0: Vector2fc): Vector2f;
                set(arg0: Vector2ic): Vector2f;
                set(arg0: Vector2dc): Vector2f;
                set(arg0: float[]): Vector2f;
                set(arg0: java.nio.ByteBuffer): Vector2f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector2f;
                set(arg0: java.nio.FloatBuffer): Vector2f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Vector2f;
                setFromAddress(arg0: long): Vector2f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                setComponent(arg0: int, arg1: float): Vector2f;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector2fc;
                perpendicular(): Vector2f;
                sub(arg0: Vector2fc): Vector2f;
                sub(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                sub(arg0: float, arg1: float): Vector2f;
                sub(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                dot(arg0: Vector2fc): number;
                angle(arg0: Vector2fc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: float, arg1: float): number;
                distanceSquared(arg0: float, arg1: float): number;
                normalize(): Vector2f;
                normalize(arg0: Vector2f): Vector2f;
                normalize(arg0: float): Vector2f;
                normalize(arg0: float, arg1: Vector2f): Vector2f;
                add(arg0: Vector2fc): Vector2f;
                add(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                add(arg0: float, arg1: float): Vector2f;
                add(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                zero(): Vector2f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector2f;
                negate(arg0: Vector2f): Vector2f;
                mul(arg0: float): Vector2f;
                mul(arg0: float, arg1: Vector2f): Vector2f;
                mul(arg0: float, arg1: float): Vector2f;
                mul(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Vector2fc): Vector2f;
                mul(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: Vector2fc): Vector2f;
                div(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                div(arg0: float): Vector2f;
                div(arg0: float, arg1: Vector2f): Vector2f;
                div(arg0: float, arg1: float): Vector2f;
                div(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                mul(arg0: Matrix2fc): Vector2f;
                mul(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mul(arg0: Matrix2dc): Vector2f;
                mul(arg0: Matrix2dc, arg1: Vector2f): Vector2f;
                mulTranspose(arg0: Matrix2fc): Vector2f;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2f): Vector2f;
                mulPosition(arg0: Matrix3x2fc): Vector2f;
                mulPosition(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                mulDirection(arg0: Matrix3x2fc): Vector2f;
                mulDirection(arg0: Matrix3x2fc, arg1: Vector2f): Vector2f;
                lerp(arg0: Vector2fc, arg1: float): Vector2f;
                lerp(arg0: Vector2fc, arg1: float, arg2: Vector2f): Vector2f;
                equals(arg0: Vector2fc, arg1: float): boolean;
                equals(arg0: float, arg1: float): boolean;
                equals(arg0: any): boolean;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                fma(arg0: Vector2fc, arg1: Vector2fc): Vector2f;
                fma(arg0: float, arg1: Vector2fc): Vector2f;
                fma(arg0: Vector2fc, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                fma(arg0: float, arg1: Vector2fc, arg2: Vector2f): Vector2f;
                min(arg0: Vector2fc): Vector2f;
                min(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                max(arg0: Vector2fc): Vector2f;
                max(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector2f;
                floor(arg0: Vector2f): Vector2f;
                ceil(): Vector2f;
                ceil(arg0: Vector2f): Vector2f;
                round(): Vector2f;
                round(arg0: Vector2f): Vector2f;
                isFinite(): boolean;
                absolute(): Vector2f;
                absolute(arg0: Vector2f): Vector2f;
                clone(): any;

            }

            const Quaterniond: JavaClassStatics<Quaterniond, Quaterniond$$constructor> & {

                slerp(arg0: Quaterniond[], arg1: double[], arg2: Quaterniond): Quaterniondc;
                nlerp(arg0: Quaterniond[], arg1: double[], arg2: Quaterniond): Quaterniondc;
                nlerpIterative(arg0: Quaterniondc[], arg1: double[], arg2: double, arg3: Quaterniond): Quaterniond;

            }
            interface Quaterniond$$constructor extends SuppressProperties {

                new (): Quaterniond;
                new (arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                new (arg0: Quaterniondc): Quaterniond;
                new (arg0: Quaternionfc): Quaterniond;
                new (arg0: AxisAngle4f): Quaterniond;
                new (arg0: AxisAngle4d): Quaterniond;

            }
            interface Quaterniond extends java.io.Externalizable, java.lang.Cloneable, Quaterniondc {
                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(): Quaterniond;
                normalize(arg0: Quaterniond): Quaterniond;
                add(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                add(arg0: Quaterniondc): Quaterniond;
                add(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                dot(arg0: Quaterniondc): number;
                angle(): number;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                set(arg0: Quaterniondc): Quaterniond;
                set(arg0: Quaternionfc): Quaterniond;
                set(arg0: AxisAngle4f): Quaterniond;
                set(arg0: AxisAngle4d): Quaterniond;
                setAngleAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                setAngleAxis(arg0: double, arg1: Vector3dc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4fc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4x3fc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4x3dc): Quaterniond;
                setFromNormalized(arg0: Matrix4fc): Quaterniond;
                setFromNormalized(arg0: Matrix4x3fc): Quaterniond;
                setFromNormalized(arg0: Matrix4x3dc): Quaterniond;
                setFromUnnormalized(arg0: Matrix4dc): Quaterniond;
                setFromNormalized(arg0: Matrix4dc): Quaterniond;
                setFromUnnormalized(arg0: Matrix3fc): Quaterniond;
                setFromNormalized(arg0: Matrix3fc): Quaterniond;
                setFromUnnormalized(arg0: Matrix3dc): Quaterniond;
                setFromNormalized(arg0: Matrix3dc): Quaterniond;
                fromAxisAngleRad(arg0: Vector3dc, arg1: double): Quaterniond;
                fromAxisAngleRad(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                fromAxisAngleDeg(arg0: Vector3dc, arg1: double): Quaterniond;
                fromAxisAngleDeg(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                mul(arg0: Quaterniondc): Quaterniond;
                mul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                mul(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                mul(arg0: double): Quaterniond;
                mul(arg0: double, arg1: Quaterniond): Quaterniond;
                premul(arg0: Quaterniondc): Quaterniond;
                premul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                premul(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                premul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformUnit(arg0: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                invert(arg0: Quaterniond): Quaterniond;
                invert(): Quaterniond;
                div(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                div(arg0: Quaterniondc): Quaterniond;
                conjugate(): Quaterniond;
                conjugate(arg0: Quaterniond): Quaterniond;
                identity(): Quaterniond;
                lengthSquared(): number;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotationZYX(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                slerp(arg0: Quaterniondc, arg1: double): Quaterniond;
                slerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                scale(arg0: double): Quaterniond;
                scale(arg0: double, arg1: Quaterniond): Quaterniond;
                scaling(arg0: double): Quaterniond;
                integrate(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                integrate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                nlerp(arg0: Quaterniondc, arg1: double): Quaterniond;
                nlerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                nlerpIterative(arg0: Quaterniondc, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                nlerpIterative(arg0: Quaterniondc, arg1: double, arg2: double): Quaterniond;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Quaterniond;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Quaterniond;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                difference(arg0: Quaterniondc): Quaterniond;
                difference(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                rotationTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Quaterniond;
                rotationTo(arg0: Vector3dc, arg1: Vector3dc): Quaterniond;
                rotateTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                rotationAxis(arg0: AxisAngle4f): Quaterniond;
                rotationAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                rotationX(arg0: double): Quaterniond;
                rotationY(arg0: double): Quaterniond;
                rotationZ(arg0: double): Quaterniond;
                rotateTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Quaterniond;
                rotateTo(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                rotateTo(arg0: Vector3dc, arg1: Vector3dc): Quaterniond;
                rotateX(arg0: double): Quaterniond;
                rotateX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateY(arg0: double): Quaterniond;
                rotateY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateZ(arg0: double): Quaterniond;
                rotateZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalX(arg0: double): Quaterniond;
                rotateLocalX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalY(arg0: double): Quaterniond;
                rotateLocalY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalZ(arg0: double): Quaterniond;
                rotateLocalZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateZYX(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Quaterniond;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesZXY(arg0: Vector3d): Vector3d;
                getEulerAnglesYXZ(arg0: Vector3d): Vector3d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: Vector3dc): Quaterniond;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double): Quaterniond;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                conjugateBy(arg0: Quaterniondc): Quaterniond;
                conjugateBy(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                isFinite(): boolean;
                equals(arg0: Quaterniondc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            const Vector4dc: JavaInterfaceStatics<Vector4dc>;
            interface Vector4dc extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4dc;
                sub(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                sub(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                sub(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                add(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                add(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                fma(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                fma(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mul(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                div(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3fc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4fc, arg1: Vector4d): Vector4d;
                mulTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffine(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffineTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mulAdd(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mulAdd(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mul(arg0: double, arg1: Vector4d): Vector4d;
                div(arg0: double, arg1: Vector4d): Vector4d;
                rotate(arg0: Quaterniondc, arg1: Vector4d): Vector4d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                rotateX(arg0: double, arg1: Vector4d): Vector4d;
                rotateY(arg0: double, arg1: Vector4d): Vector4d;
                rotateZ(arg0: double, arg1: Vector4d): Vector4d;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector4d): Vector4d;
                normalize(arg0: double, arg1: Vector4d): Vector4d;
                normalize3(arg0: Vector4d): Vector4d;
                distance(arg0: Vector4dc): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double): number;
                distanceSquared(arg0: Vector4dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;
                dot(arg0: Vector4dc): number;
                dot(arg0: double, arg1: double, arg2: double, arg3: double): number;
                angleCos(arg0: Vector4dc): number;
                angle(arg0: Vector4dc): number;
                negate(arg0: Vector4d): Vector4d;
                min(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                max(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                smoothStep(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                hermite(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4dc, arg3: double, arg4: Vector4d): Vector4d;
                lerp(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(arg0: Vector4d): Vector4d;
                ceil(arg0: Vector4d): Vector4d;
                round(arg0: Vector4d): Vector4d;
                isFinite(): boolean;
                absolute(arg0: Vector4d): Vector4d;
                equals(arg0: Vector4dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;

            }

            const Vector4f: JavaClassStatics<Vector4f, Vector4f$$constructor> & {

                lengthSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;
                lengthSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                length(arg0: float, arg1: float, arg2: float, arg3: float): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): number;

            }
            interface Vector4f$$constructor extends SuppressProperties {

                new (): Vector4f;
                new (arg0: Vector4fc): Vector4f;
                new (arg0: Vector4ic): Vector4f;
                new (arg0: Vector3fc, arg1: float): Vector4f;
                new (arg0: Vector3ic, arg1: float): Vector4f;
                new (arg0: Vector2fc, arg1: float, arg2: float): Vector4f;
                new (arg0: Vector2ic, arg1: float, arg2: float): Vector4f;
                new (arg0: float): Vector4f;
                new (arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                new (arg0: float[]): Vector4f;
                new (arg0: java.nio.ByteBuffer): Vector4f;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector4f;
                new (arg0: java.nio.FloatBuffer): Vector4f;
                new (arg0: int, arg1: java.nio.FloatBuffer): Vector4f;

            }
            interface Vector4f extends java.io.Externalizable, java.lang.Cloneable, Vector4fc {
                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                set(arg0: Vector4fc): Vector4f;
                set(arg0: Vector4ic): Vector4f;
                set(arg0: Vector4dc): Vector4f;
                set(arg0: Vector3fc, arg1: float): Vector4f;
                set(arg0: Vector3ic, arg1: float): Vector4f;
                set(arg0: Vector2fc, arg1: float, arg2: float): Vector4f;
                set(arg0: Vector2ic, arg1: float, arg2: float): Vector4f;
                set(arg0: float): Vector4f;
                set(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                set(arg0: float, arg1: float, arg2: float): Vector4f;
                set(arg0: double): Vector4f;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Vector4f;
                set(arg0: float[]): Vector4f;
                set(arg0: java.nio.ByteBuffer): Vector4f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector4f;
                set(arg0: java.nio.FloatBuffer): Vector4f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Vector4f;
                setFromAddress(arg0: long): Vector4f;
                setComponent(arg0: int, arg1: float): Vector4f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4fc;
                sub(arg0: Vector4fc): Vector4f;
                sub(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                sub(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                sub(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                add(arg0: Vector4fc): Vector4f;
                add(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                add(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                fma(arg0: Vector4fc, arg1: Vector4fc): Vector4f;
                fma(arg0: float, arg1: Vector4fc): Vector4f;
                fma(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                fma(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: Vector4fc, arg1: Vector4fc): Vector4f;
                mulAdd(arg0: float, arg1: Vector4fc): Vector4f;
                mulAdd(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mul(arg0: Vector4fc): Vector4f;
                mul(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                div(arg0: Vector4fc): Vector4f;
                div(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4fc): Vector4f;
                mul(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulTranspose(arg0: Matrix4fc): Vector4f;
                mulTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffine(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffineTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4x3fc): Vector4f;
                mul(arg0: Matrix4x3fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float): Vector4f;
                mul(arg0: float, arg1: Vector4f): Vector4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                div(arg0: float): Vector4f;
                div(arg0: float, arg1: Vector4f): Vector4f;
                div(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                div(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotate(arg0: Quaternionfc): Vector4f;
                rotate(arg0: Quaternionfc, arg1: Vector4f): Vector4f;
                rotateAbout(arg0: float, arg1: float, arg2: float, arg3: float): Vector4f;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotateX(arg0: float): Vector4f;
                rotateX(arg0: float, arg1: Vector4f): Vector4f;
                rotateY(arg0: float): Vector4f;
                rotateY(arg0: float, arg1: Vector4f): Vector4f;
                rotateZ(arg0: float): Vector4f;
                rotateZ(arg0: float, arg1: Vector4f): Vector4f;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector4f;
                normalize(arg0: Vector4f): Vector4f;
                normalize(arg0: float): Vector4f;
                normalize(arg0: float, arg1: Vector4f): Vector4f;
                normalize3(): Vector4f;
                normalize3(arg0: Vector4f): Vector4f;
                distance(arg0: Vector4fc): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float): number;
                distanceSquared(arg0: Vector4fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;
                dot(arg0: Vector4fc): number;
                dot(arg0: float, arg1: float, arg2: float, arg3: float): number;
                angleCos(arg0: Vector4fc): number;
                angle(arg0: Vector4fc): number;
                zero(): Vector4f;
                negate(): Vector4f;
                negate(arg0: Vector4f): Vector4f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                min(arg0: Vector4fc): Vector4f;
                min(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                max(arg0: Vector4fc): Vector4f;
                max(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                equals(arg0: Vector4fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: any): boolean;
                smoothStep(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                hermite(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: float, arg4: Vector4f): Vector4f;
                lerp(arg0: Vector4fc, arg1: float): Vector4f;
                lerp(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector4f;
                floor(arg0: Vector4f): Vector4f;
                ceil(): Vector4f;
                ceil(arg0: Vector4f): Vector4f;
                round(): Vector4f;
                round(arg0: Vector4f): Vector4f;
                isFinite(): boolean;
                absolute(): Vector4f;
                absolute(arg0: Vector4f): Vector4f;
                clone(): any;

            }

            const Vector4fc: JavaInterfaceStatics<Vector4fc>;
            interface Vector4fc extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4fc;
                sub(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                sub(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                add(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                add(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                fma(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                fma(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mulAdd(arg0: float, arg1: Vector4fc, arg2: Vector4f): Vector4f;
                mul(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                div(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffine(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulAffineTranspose(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mul(arg0: Matrix4x3fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector4f): Vector4f;
                mulProject(arg0: Matrix4fc, arg1: Vector3f): Vector3f;
                mul(arg0: float, arg1: Vector4f): Vector4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                div(arg0: float, arg1: Vector4f): Vector4f;
                div(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotate(arg0: Quaternionfc, arg1: Vector4f): Vector4f;
                rotateAxis(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                rotateX(arg0: float, arg1: Vector4f): Vector4f;
                rotateY(arg0: float, arg1: Vector4f): Vector4f;
                rotateZ(arg0: float, arg1: Vector4f): Vector4f;
                lengthSquared(): number;
                length(): number;
                normalize(arg0: Vector4f): Vector4f;
                normalize(arg0: float, arg1: Vector4f): Vector4f;
                normalize3(arg0: Vector4f): Vector4f;
                distance(arg0: Vector4fc): number;
                distance(arg0: float, arg1: float, arg2: float, arg3: float): number;
                distanceSquared(arg0: Vector4fc): number;
                distanceSquared(arg0: float, arg1: float, arg2: float, arg3: float): number;
                dot(arg0: Vector4fc): number;
                dot(arg0: float, arg1: float, arg2: float, arg3: float): number;
                angleCos(arg0: Vector4fc): number;
                angle(arg0: Vector4fc): number;
                negate(arg0: Vector4f): Vector4f;
                min(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                max(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                lerp(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                smoothStep(arg0: Vector4fc, arg1: float, arg2: Vector4f): Vector4f;
                hermite(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: float, arg4: Vector4f): Vector4f;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(arg0: Vector4f): Vector4f;
                ceil(arg0: Vector4f): Vector4f;
                round(arg0: Vector4f): Vector4f;
                isFinite(): boolean;
                absolute(arg0: Vector4f): Vector4f;
                equals(arg0: Vector4fc, arg1: float): boolean;
                equals(arg0: float, arg1: float, arg2: float, arg3: float): boolean;

            }

            const Vector2i: JavaClassStatics<Vector2i, Vector2i$$constructor> & {

                lengthSquared(arg0: int, arg1: int): number;
                length(arg0: int, arg1: int): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;

            }
            interface Vector2i$$constructor extends SuppressProperties {

                new (): Vector2i;
                new (arg0: int): Vector2i;
                new (arg0: int, arg1: int): Vector2i;
                new (arg0: float, arg1: float, arg2: int): Vector2i;
                new (arg0: double, arg1: double, arg2: int): Vector2i;
                new (arg0: Vector2ic): Vector2i;
                new (arg0: Vector2fc, arg1: int): Vector2i;
                new (arg0: Vector2dc, arg1: int): Vector2i;
                new (arg0: int[]): Vector2i;
                new (arg0: java.nio.ByteBuffer): Vector2i;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector2i;
                new (arg0: java.nio.IntBuffer): Vector2i;
                new (arg0: int, arg1: java.nio.IntBuffer): Vector2i;

            }
            interface Vector2i extends java.io.Externalizable, java.lang.Cloneable, Vector2ic {
                x: number;
                y: number;

                x(): number;
                y(): number;
                set(arg0: int): Vector2i;
                set(arg0: int, arg1: int): Vector2i;
                set(arg0: Vector2ic): Vector2i;
                set(arg0: Vector2dc): Vector2i;
                set(arg0: Vector2dc, arg1: int): Vector2i;
                set(arg0: Vector2fc, arg1: int): Vector2i;
                set(arg0: int[]): Vector2i;
                set(arg0: java.nio.ByteBuffer): Vector2i;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector2i;
                set(arg0: java.nio.IntBuffer): Vector2i;
                set(arg0: int, arg1: java.nio.IntBuffer): Vector2i;
                setFromAddress(arg0: long): Vector2i;
                get(arg0: int): number;
                setComponent(arg0: int, arg1: int): Vector2i;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                getToAddress(arg0: long): Vector2ic;
                sub(arg0: Vector2ic): Vector2i;
                sub(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                sub(arg0: int, arg1: int): Vector2i;
                sub(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2ic): number;
                distance(arg0: int, arg1: int): number;
                distanceSquared(arg0: Vector2ic): number;
                distanceSquared(arg0: int, arg1: int): number;
                gridDistance(arg0: Vector2ic): number;
                gridDistance(arg0: int, arg1: int): number;
                add(arg0: Vector2ic): Vector2i;
                add(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                add(arg0: int, arg1: int): Vector2i;
                add(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                mul(arg0: int): Vector2i;
                mul(arg0: int, arg1: Vector2i): Vector2i;
                mul(arg0: Vector2ic): Vector2i;
                mul(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                mul(arg0: int, arg1: int): Vector2i;
                mul(arg0: int, arg1: int, arg2: Vector2i): Vector2i;
                div(arg0: float): Vector2i;
                div(arg0: float, arg1: Vector2i): Vector2i;
                div(arg0: int): Vector2i;
                div(arg0: int, arg1: Vector2i): Vector2i;
                zero(): Vector2i;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector2i;
                negate(arg0: Vector2i): Vector2i;
                min(arg0: Vector2ic): Vector2i;
                min(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                max(arg0: Vector2ic): Vector2i;
                max(arg0: Vector2ic, arg1: Vector2i): Vector2i;
                maxComponent(): number;
                minComponent(): number;
                absolute(): Vector2i;
                absolute(arg0: Vector2i): Vector2i;
                equals(arg0: int, arg1: int): boolean;
                equals(arg0: any): boolean;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                clone(): any;

            }

            const Matrix2fc: JavaInterfaceStatics<Matrix2fc>;
            interface Matrix2fc extends JavaObject {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                mul(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulLocal(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                determinant(): number;
                invert(arg0: Matrix2f): Matrix2f;
                transpose(arg0: Matrix2f): Matrix2f;
                get(arg0: Matrix2f): Matrix2f;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: Matrix3f): Matrix3f;
                getRotation(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                scale(arg0: Vector2fc, arg1: Matrix2f): Matrix2f;
                scale(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                scale(arg0: float, arg1: Matrix2f): Matrix2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                transform(arg0: Vector2f): Vector2f;
                transform(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transform(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformTranspose(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                rotate(arg0: float, arg1: Matrix2f): Matrix2f;
                rotateLocal(arg0: float, arg1: Matrix2f): Matrix2f;
                getRow(arg0: int, arg1: Vector2f): Vector2f;
                getColumn(arg0: int, arg1: Vector2f): Vector2f;
                get(arg0: int, arg1: int): number;
                normal(arg0: Matrix2f): Matrix2f;
                getScale(arg0: Vector2f): Vector2f;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                add(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                sub(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulComponentWise(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                lerp(arg0: Matrix2fc, arg1: float, arg2: Matrix2f): Matrix2f;
                equals(arg0: Matrix2fc, arg1: float): boolean;
                isFinite(): boolean;

            }

            const Matrix3d: JavaClassStatics<Matrix3d, Matrix3d$$constructor>;
            interface Matrix3d$$constructor extends SuppressProperties {

                new (): Matrix3d;
                new (arg0: Matrix2dc): Matrix3d;
                new (arg0: Matrix2fc): Matrix3d;
                new (arg0: Matrix3dc): Matrix3d;
                new (arg0: Matrix3fc): Matrix3d;
                new (arg0: Matrix4fc): Matrix3d;
                new (arg0: Matrix4dc): Matrix3d;
                new (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix3d;
                new (arg0: java.nio.DoubleBuffer): Matrix3d;
                new (arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix3d;

            }
            interface Matrix3d extends java.io.Externalizable, java.lang.Cloneable, Matrix3dc {
                m00: number;
                m01: number;
                m02: number;
                m10: number;
                m11: number;
                m12: number;
                m20: number;
                m21: number;
                m22: number;

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m00(arg0: double): Matrix3d;
                m01(arg0: double): Matrix3d;
                m02(arg0: double): Matrix3d;
                m10(arg0: double): Matrix3d;
                m11(arg0: double): Matrix3d;
                m12(arg0: double): Matrix3d;
                m20(arg0: double): Matrix3d;
                m21(arg0: double): Matrix3d;
                m22(arg0: double): Matrix3d;
                set(arg0: Matrix3dc): Matrix3d;
                setTransposed(arg0: Matrix3dc): Matrix3d;
                set(arg0: Matrix3fc): Matrix3d;
                setTransposed(arg0: Matrix3fc): Matrix3d;
                set(arg0: Matrix4x3dc): Matrix3d;
                set(arg0: Matrix4fc): Matrix3d;
                set(arg0: Matrix4dc): Matrix3d;
                set(arg0: Matrix2fc): Matrix3d;
                set(arg0: Matrix2dc): Matrix3d;
                set(arg0: AxisAngle4f): Matrix3d;
                set(arg0: AxisAngle4d): Matrix3d;
                set(arg0: Quaternionfc): Matrix3d;
                set(arg0: Quaterniondc): Matrix3d;
                mul(arg0: Matrix3dc): Matrix3d;
                mul(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulLocal(arg0: Matrix3dc): Matrix3d;
                mulLocal(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mul(arg0: Matrix3fc): Matrix3d;
                mul(arg0: Matrix3fc, arg1: Matrix3d): Matrix3d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix3d;
                set(arg0: double[]): Matrix3d;
                set(arg0: float[]): Matrix3d;
                determinant(): number;
                invert(): Matrix3d;
                invert(arg0: Matrix3d): Matrix3d;
                transpose(): Matrix3d;
                transpose(arg0: Matrix3d): Matrix3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.DoubleBuffer): Matrix3d;
                set(arg0: java.nio.FloatBuffer): Matrix3d;
                set(arg0: java.nio.ByteBuffer): Matrix3d;
                setFloats(arg0: java.nio.ByteBuffer): Matrix3d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix3d;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix3d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3d;
                setFloats(arg0: int, arg1: java.nio.ByteBuffer): Matrix3d;
                setFromAddress(arg0: long): Matrix3d;
                set(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix3d;
                zero(): Matrix3d;
                identity(): Matrix3d;
                scaling(arg0: double): Matrix3d;
                scaling(arg0: double, arg1: double, arg2: double): Matrix3d;
                scaling(arg0: Vector3dc): Matrix3d;
                scale(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                scale(arg0: Vector3dc): Matrix3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                scale(arg0: double, arg1: double, arg2: double): Matrix3d;
                scale(arg0: double, arg1: Matrix3d): Matrix3d;
                scale(arg0: double): Matrix3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                scaleLocal(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotation(arg0: double, arg1: Vector3dc): Matrix3d;
                rotation(arg0: double, arg1: Vector3fc): Matrix3d;
                rotation(arg0: AxisAngle4f): Matrix3d;
                rotation(arg0: AxisAngle4d): Matrix3d;
                rotation(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3d;
                rotationX(arg0: double): Matrix3d;
                rotationY(arg0: double): Matrix3d;
                rotationZ(arg0: double): Matrix3d;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotationZYX(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotation(arg0: Quaterniondc): Matrix3d;
                rotation(arg0: Quaternionfc): Matrix3d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3d): Vector3d;
                transformTranspose(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateX(arg0: double): Matrix3d;
                rotateY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateY(arg0: double): Matrix3d;
                rotateZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateZ(arg0: double): Matrix3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateZYX(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotateYXZ(arg0: Vector3d): Matrix3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Matrix3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3d): Matrix3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3d;
                rotateLocalX(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalX(arg0: double): Matrix3d;
                rotateLocalY(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalY(arg0: double): Matrix3d;
                rotateLocalZ(arg0: double, arg1: Matrix3d): Matrix3d;
                rotateLocalZ(arg0: double): Matrix3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaterniondc): Matrix3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotateLocal(arg0: Quaternionfc): Matrix3d;
                rotate(arg0: Quaterniondc): Matrix3d;
                rotate(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: Quaternionfc): Matrix3d;
                rotate(arg0: Quaternionfc, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4f): Matrix3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix3d): Matrix3d;
                rotate(arg0: AxisAngle4d): Matrix3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3dc): Matrix3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotate(arg0: double, arg1: Vector3fc): Matrix3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix3d): Matrix3d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                setRow(arg0: int, arg1: Vector3dc): Matrix3d;
                setRow(arg0: int, arg1: double, arg2: double, arg3: double): Matrix3d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                setColumn(arg0: int, arg1: Vector3dc): Matrix3d;
                setColumn(arg0: int, arg1: double, arg2: double, arg3: double): Matrix3d;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: double): Matrix3d;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: double): Matrix3d;
                normal(): Matrix3d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor(): Matrix3d;
                cofactor(arg0: Matrix3d): Matrix3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                setLookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                setLookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                getScale(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                equals(arg0: Matrix3dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix3d): Matrix3d;
                add(arg0: Matrix3dc): Matrix3d;
                add(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                sub(arg0: Matrix3dc): Matrix3d;
                sub(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                mulComponentWise(arg0: Matrix3dc): Matrix3d;
                mulComponentWise(arg0: Matrix3dc, arg1: Matrix3d): Matrix3d;
                setSkewSymmetric(arg0: double, arg1: double, arg2: double): Matrix3d;
                lerp(arg0: Matrix3dc, arg1: double): Matrix3d;
                lerp(arg0: Matrix3dc, arg1: double, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix3d): Matrix3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix3d): Matrix3d;
                rotationTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix3d;
                rotationTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double): Matrix3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double): Matrix3d;
                reflect(arg0: Vector3dc): Matrix3d;
                reflect(arg0: Quaterniondc): Matrix3d;
                reflect(arg0: Quaterniondc, arg1: Matrix3d): Matrix3d;
                reflect(arg0: Vector3dc, arg1: Matrix3d): Matrix3d;
                reflection(arg0: double, arg1: double, arg2: double): Matrix3d;
                reflection(arg0: Vector3dc): Matrix3d;
                reflection(arg0: Quaterniondc): Matrix3d;
                isFinite(): boolean;
                quadraticFormProduct(arg0: double, arg1: double, arg2: double): number;
                quadraticFormProduct(arg0: Vector3dc): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(): Matrix3d;
                mapXZY(arg0: Matrix3d): Matrix3d;
                mapXZnY(): Matrix3d;
                mapXZnY(arg0: Matrix3d): Matrix3d;
                mapXnYnZ(): Matrix3d;
                mapXnYnZ(arg0: Matrix3d): Matrix3d;
                mapXnZY(): Matrix3d;
                mapXnZY(arg0: Matrix3d): Matrix3d;
                mapXnZnY(): Matrix3d;
                mapXnZnY(arg0: Matrix3d): Matrix3d;
                mapYXZ(): Matrix3d;
                mapYXZ(arg0: Matrix3d): Matrix3d;
                mapYXnZ(): Matrix3d;
                mapYXnZ(arg0: Matrix3d): Matrix3d;
                mapYZX(): Matrix3d;
                mapYZX(arg0: Matrix3d): Matrix3d;
                mapYZnX(): Matrix3d;
                mapYZnX(arg0: Matrix3d): Matrix3d;
                mapYnXZ(): Matrix3d;
                mapYnXZ(arg0: Matrix3d): Matrix3d;
                mapYnXnZ(): Matrix3d;
                mapYnXnZ(arg0: Matrix3d): Matrix3d;
                mapYnZX(): Matrix3d;
                mapYnZX(arg0: Matrix3d): Matrix3d;
                mapYnZnX(): Matrix3d;
                mapYnZnX(arg0: Matrix3d): Matrix3d;
                mapZXY(): Matrix3d;
                mapZXY(arg0: Matrix3d): Matrix3d;
                mapZXnY(): Matrix3d;
                mapZXnY(arg0: Matrix3d): Matrix3d;
                mapZYX(): Matrix3d;
                mapZYX(arg0: Matrix3d): Matrix3d;
                mapZYnX(): Matrix3d;
                mapZYnX(arg0: Matrix3d): Matrix3d;
                mapZnXY(): Matrix3d;
                mapZnXY(arg0: Matrix3d): Matrix3d;
                mapZnXnY(): Matrix3d;
                mapZnXnY(arg0: Matrix3d): Matrix3d;
                mapZnYX(): Matrix3d;
                mapZnYX(arg0: Matrix3d): Matrix3d;
                mapZnYnX(): Matrix3d;
                mapZnYnX(arg0: Matrix3d): Matrix3d;
                mapnXYnZ(): Matrix3d;
                mapnXYnZ(arg0: Matrix3d): Matrix3d;
                mapnXZY(): Matrix3d;
                mapnXZY(arg0: Matrix3d): Matrix3d;
                mapnXZnY(): Matrix3d;
                mapnXZnY(arg0: Matrix3d): Matrix3d;
                mapnXnYZ(): Matrix3d;
                mapnXnYZ(arg0: Matrix3d): Matrix3d;
                mapnXnYnZ(): Matrix3d;
                mapnXnYnZ(arg0: Matrix3d): Matrix3d;
                mapnXnZY(): Matrix3d;
                mapnXnZY(arg0: Matrix3d): Matrix3d;
                mapnXnZnY(): Matrix3d;
                mapnXnZnY(arg0: Matrix3d): Matrix3d;
                mapnYXZ(): Matrix3d;
                mapnYXZ(arg0: Matrix3d): Matrix3d;
                mapnYXnZ(): Matrix3d;
                mapnYXnZ(arg0: Matrix3d): Matrix3d;
                mapnYZX(): Matrix3d;
                mapnYZX(arg0: Matrix3d): Matrix3d;
                mapnYZnX(): Matrix3d;
                mapnYZnX(arg0: Matrix3d): Matrix3d;
                mapnYnXZ(): Matrix3d;
                mapnYnXZ(arg0: Matrix3d): Matrix3d;
                mapnYnXnZ(): Matrix3d;
                mapnYnXnZ(arg0: Matrix3d): Matrix3d;
                mapnYnZX(): Matrix3d;
                mapnYnZX(arg0: Matrix3d): Matrix3d;
                mapnYnZnX(): Matrix3d;
                mapnYnZnX(arg0: Matrix3d): Matrix3d;
                mapnZXY(): Matrix3d;
                mapnZXY(arg0: Matrix3d): Matrix3d;
                mapnZXnY(): Matrix3d;
                mapnZXnY(arg0: Matrix3d): Matrix3d;
                mapnZYX(): Matrix3d;
                mapnZYX(arg0: Matrix3d): Matrix3d;
                mapnZYnX(): Matrix3d;
                mapnZYnX(arg0: Matrix3d): Matrix3d;
                mapnZnXY(): Matrix3d;
                mapnZnXY(arg0: Matrix3d): Matrix3d;
                mapnZnXnY(): Matrix3d;
                mapnZnXnY(arg0: Matrix3d): Matrix3d;
                mapnZnYX(): Matrix3d;
                mapnZnYX(arg0: Matrix3d): Matrix3d;
                mapnZnYnX(): Matrix3d;
                mapnZnYnX(arg0: Matrix3d): Matrix3d;
                negateX(): Matrix3d;
                negateX(arg0: Matrix3d): Matrix3d;
                negateY(): Matrix3d;
                negateY(arg0: Matrix3d): Matrix3d;
                negateZ(): Matrix3d;
                negateZ(arg0: Matrix3d): Matrix3d;
                clone(): any;

            }

            const Matrix3x2f: JavaClassStatics<Matrix3x2f, Matrix3x2f$$constructor>;
            interface Matrix3x2f$$constructor extends SuppressProperties {

                new (): Matrix3x2f;
                new (arg0: Matrix3x2fc): Matrix3x2f;
                new (arg0: Matrix2fc): Matrix3x2f;
                new (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3x2f;
                new (arg0: java.nio.FloatBuffer): Matrix3x2f;

            }
            interface Matrix3x2f extends Matrix3x2fc, java.io.Externalizable, java.lang.Cloneable {
                m00: number;
                m01: number;
                m10: number;
                m11: number;
                m20: number;
                m21: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                set(arg0: Matrix3x2fc): Matrix3x2f;
                set(arg0: Matrix2fc): Matrix3x2f;
                mul(arg0: Matrix3x2fc): Matrix3x2f;
                mul(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                mulLocal(arg0: Matrix3x2fc): Matrix3x2f;
                mulLocal(arg0: Matrix3x2fc, arg1: Matrix3x2f): Matrix3x2f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3x2f;
                set(arg0: float[]): Matrix3x2f;
                determinant(): number;
                invert(): Matrix3x2f;
                invert(arg0: Matrix3x2f): Matrix3x2f;
                translation(arg0: float, arg1: float): Matrix3x2f;
                translation(arg0: Vector2fc): Matrix3x2f;
                setTranslation(arg0: float, arg1: float): Matrix3x2f;
                setTranslation(arg0: Vector2f): Matrix3x2f;
                translate(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                translate(arg0: float, arg1: float): Matrix3x2f;
                translate(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translate(arg0: Vector2fc): Matrix3x2f;
                translateLocal(arg0: Vector2fc): Matrix3x2f;
                translateLocal(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                translateLocal(arg0: float, arg1: float): Matrix3x2f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get3x3(arg0: float[], arg1: int): JavaArray<number>;
                get3x3(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.FloatBuffer): Matrix3x2f;
                set(arg0: java.nio.ByteBuffer): Matrix3x2f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix3x2f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3x2f;
                setFromAddress(arg0: long): Matrix3x2f;
                zero(): Matrix3x2f;
                identity(): Matrix3x2f;
                scale(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scale(arg0: float, arg1: float): Matrix3x2f;
                scale(arg0: Vector2fc): Matrix3x2f;
                scale(arg0: Vector2fc, arg1: Matrix3x2f): Matrix3x2f;
                scale(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scale(arg0: float): Matrix3x2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float, arg1: float): Matrix3x2f;
                scaleLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                scaleLocal(arg0: float): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                scaleAround(arg0: float, arg1: float, arg2: float): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3x2f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float): Matrix3x2f;
                scaling(arg0: float): Matrix3x2f;
                scaling(arg0: float, arg1: float): Matrix3x2f;
                rotation(arg0: float): Matrix3x2f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3f, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformPosition(arg0: Vector2f): Vector2f;
                transformPosition(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformPosition(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformDirection(arg0: Vector2f): Vector2f;
                transformDirection(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformDirection(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: float): Matrix3x2f;
                rotate(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateLocal(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                rotateLocal(arg0: float): Matrix3x2f;
                rotateAbout(arg0: float, arg1: float, arg2: float): Matrix3x2f;
                rotateAbout(arg0: float, arg1: float, arg2: float, arg3: Matrix3x2f): Matrix3x2f;
                rotateTo(arg0: Vector2fc, arg1: Vector2fc, arg2: Matrix3x2f): Matrix3x2f;
                rotateTo(arg0: Vector2fc, arg1: Vector2fc): Matrix3x2f;
                view(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3x2f): Matrix3x2f;
                view(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3x2f;
                setView(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3x2f;
                origin(arg0: Vector2f): Vector2f;
                viewArea(arg0: float[]): JavaArray<number>;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                unproject(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                unprojectInv(arg0: float, arg1: float, arg2: int[], arg3: Vector2f): Vector2f;
                shearX(arg0: float): Matrix3x2f;
                shearX(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                shearY(arg0: float): Matrix3x2f;
                shearY(arg0: float, arg1: Matrix3x2f): Matrix3x2f;
                span(arg0: Vector2f, arg1: Vector2f, arg2: Vector2f): Matrix3x2f;
                testPoint(arg0: float, arg1: float): boolean;
                testCircle(arg0: float, arg1: float, arg2: float): boolean;
                testAar(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                equals(arg0: Matrix3x2fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                isFinite(): boolean;
                clone(): any;

            }

            const Matrix3f: JavaClassStatics<Matrix3f, Matrix3f$$constructor>;
            interface Matrix3f$$constructor extends SuppressProperties {

                new (): Matrix3f;
                new (arg0: Matrix2fc): Matrix3f;
                new (arg0: Matrix3fc): Matrix3f;
                new (arg0: Matrix4fc): Matrix3f;
                new (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix3f;
                new (arg0: java.nio.FloatBuffer): Matrix3f;
                new (arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix3f;

            }
            interface Matrix3f extends java.io.Externalizable, java.lang.Cloneable, Matrix3fc {
                m00: number;
                m01: number;
                m02: number;
                m10: number;
                m11: number;
                m12: number;
                m20: number;
                m21: number;
                m22: number;

                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m00(arg0: float): Matrix3f;
                m01(arg0: float): Matrix3f;
                m02(arg0: float): Matrix3f;
                m10(arg0: float): Matrix3f;
                m11(arg0: float): Matrix3f;
                m12(arg0: float): Matrix3f;
                m20(arg0: float): Matrix3f;
                m21(arg0: float): Matrix3f;
                m22(arg0: float): Matrix3f;
                set(arg0: Matrix3fc): Matrix3f;
                setTransposed(arg0: Matrix3fc): Matrix3f;
                set(arg0: Matrix4x3fc): Matrix3f;
                set(arg0: Matrix4fc): Matrix3f;
                set(arg0: Matrix2fc): Matrix3f;
                set(arg0: AxisAngle4f): Matrix3f;
                set(arg0: AxisAngle4d): Matrix3f;
                set(arg0: Quaternionfc): Matrix3f;
                set(arg0: Quaterniondc): Matrix3f;
                mul(arg0: Matrix3fc): Matrix3f;
                mul(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulLocal(arg0: Matrix3fc): Matrix3f;
                mulLocal(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix3f;
                set(arg0: float[]): Matrix3f;
                set(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix3f;
                determinant(): number;
                invert(): Matrix3f;
                invert(arg0: Matrix3f): Matrix3f;
                transpose(): Matrix3f;
                transpose(arg0: Matrix3f): Matrix3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4f): Matrix4f;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.FloatBuffer): Matrix3f;
                set(arg0: java.nio.ByteBuffer): Matrix3f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix3f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3f;
                setFromAddress(arg0: long): Matrix3f;
                zero(): Matrix3f;
                identity(): Matrix3f;
                scale(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                scale(arg0: Vector3fc): Matrix3f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                scale(arg0: float, arg1: float, arg2: float): Matrix3f;
                scale(arg0: float, arg1: Matrix3f): Matrix3f;
                scale(arg0: float): Matrix3f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                scaleLocal(arg0: float, arg1: float, arg2: float): Matrix3f;
                scaling(arg0: float): Matrix3f;
                scaling(arg0: float, arg1: float, arg2: float): Matrix3f;
                scaling(arg0: Vector3fc): Matrix3f;
                rotation(arg0: float, arg1: Vector3fc): Matrix3f;
                rotation(arg0: AxisAngle4f): Matrix3f;
                rotation(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3f;
                rotationX(arg0: float): Matrix3f;
                rotationY(arg0: float): Matrix3f;
                rotationZ(arg0: float): Matrix3f;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotationZYX(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotation(arg0: Quaternionfc): Matrix3f;
                transform(arg0: Vector3f): Vector3f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3f): Vector3f;
                transformTranspose(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateX(arg0: float): Matrix3f;
                rotateY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateY(arg0: float): Matrix3f;
                rotateZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateZ(arg0: float): Matrix3f;
                rotateXYZ(arg0: Vector3f): Matrix3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateZYX(arg0: Vector3f): Matrix3f;
                rotateZYX(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotateYXZ(arg0: Vector3f): Matrix3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Matrix3f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix3f): Matrix3f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix3f;
                rotateLocalX(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalX(arg0: float): Matrix3f;
                rotateLocalY(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalY(arg0: float): Matrix3f;
                rotateLocalZ(arg0: float, arg1: Matrix3f): Matrix3f;
                rotateLocalZ(arg0: float): Matrix3f;
                rotate(arg0: Quaternionfc): Matrix3f;
                rotate(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                rotateLocal(arg0: Quaternionfc): Matrix3f;
                rotate(arg0: AxisAngle4f): Matrix3f;
                rotate(arg0: AxisAngle4f, arg1: Matrix3f): Matrix3f;
                rotate(arg0: float, arg1: Vector3fc): Matrix3f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                setLookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                setLookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                setRow(arg0: int, arg1: Vector3fc): Matrix3f;
                setRow(arg0: int, arg1: float, arg2: float, arg3: float): Matrix3f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                setColumn(arg0: int, arg1: Vector3fc): Matrix3f;
                setColumn(arg0: int, arg1: float, arg2: float, arg3: float): Matrix3f;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: float): Matrix3f;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: float): Matrix3f;
                normal(): Matrix3f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor(): Matrix3f;
                cofactor(arg0: Matrix3f): Matrix3f;
                getScale(arg0: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                equals(arg0: Matrix3fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix3f): Matrix3f;
                add(arg0: Matrix3fc): Matrix3f;
                add(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                sub(arg0: Matrix3fc): Matrix3f;
                sub(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                mulComponentWise(arg0: Matrix3fc): Matrix3f;
                mulComponentWise(arg0: Matrix3fc, arg1: Matrix3f): Matrix3f;
                setSkewSymmetric(arg0: float, arg1: float, arg2: float): Matrix3f;
                lerp(arg0: Matrix3fc, arg1: float): Matrix3f;
                lerp(arg0: Matrix3fc, arg1: float, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix3f): Matrix3f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix3f): Matrix3f;
                rotationTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix3f;
                rotationTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix3f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                obliqueZ(arg0: float, arg1: float): Matrix3f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix3f): Matrix3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: Matrix3f): Matrix3f;
                reflect(arg0: float, arg1: float, arg2: float): Matrix3f;
                reflect(arg0: Vector3fc): Matrix3f;
                reflect(arg0: Quaternionfc): Matrix3f;
                reflect(arg0: Quaternionfc, arg1: Matrix3f): Matrix3f;
                reflect(arg0: Vector3fc, arg1: Matrix3f): Matrix3f;
                reflection(arg0: float, arg1: float, arg2: float): Matrix3f;
                reflection(arg0: Vector3fc): Matrix3f;
                reflection(arg0: Quaternionfc): Matrix3f;
                isFinite(): boolean;
                quadraticFormProduct(arg0: float, arg1: float, arg2: float): number;
                quadraticFormProduct(arg0: Vector3fc): number;
                mapXZY(): Matrix3f;
                mapXZY(arg0: Matrix3f): Matrix3f;
                mapXZnY(): Matrix3f;
                mapXZnY(arg0: Matrix3f): Matrix3f;
                mapXnYnZ(): Matrix3f;
                mapXnYnZ(arg0: Matrix3f): Matrix3f;
                mapXnZY(): Matrix3f;
                mapXnZY(arg0: Matrix3f): Matrix3f;
                mapXnZnY(): Matrix3f;
                mapXnZnY(arg0: Matrix3f): Matrix3f;
                mapYXZ(): Matrix3f;
                mapYXZ(arg0: Matrix3f): Matrix3f;
                mapYXnZ(): Matrix3f;
                mapYXnZ(arg0: Matrix3f): Matrix3f;
                mapYZX(): Matrix3f;
                mapYZX(arg0: Matrix3f): Matrix3f;
                mapYZnX(): Matrix3f;
                mapYZnX(arg0: Matrix3f): Matrix3f;
                mapYnXZ(): Matrix3f;
                mapYnXZ(arg0: Matrix3f): Matrix3f;
                mapYnXnZ(): Matrix3f;
                mapYnXnZ(arg0: Matrix3f): Matrix3f;
                mapYnZX(): Matrix3f;
                mapYnZX(arg0: Matrix3f): Matrix3f;
                mapYnZnX(): Matrix3f;
                mapYnZnX(arg0: Matrix3f): Matrix3f;
                mapZXY(): Matrix3f;
                mapZXY(arg0: Matrix3f): Matrix3f;
                mapZXnY(): Matrix3f;
                mapZXnY(arg0: Matrix3f): Matrix3f;
                mapZYX(): Matrix3f;
                mapZYX(arg0: Matrix3f): Matrix3f;
                mapZYnX(): Matrix3f;
                mapZYnX(arg0: Matrix3f): Matrix3f;
                mapZnXY(): Matrix3f;
                mapZnXY(arg0: Matrix3f): Matrix3f;
                mapZnXnY(): Matrix3f;
                mapZnXnY(arg0: Matrix3f): Matrix3f;
                mapZnYX(): Matrix3f;
                mapZnYX(arg0: Matrix3f): Matrix3f;
                mapZnYnX(): Matrix3f;
                mapZnYnX(arg0: Matrix3f): Matrix3f;
                mapnXYnZ(): Matrix3f;
                mapnXYnZ(arg0: Matrix3f): Matrix3f;
                mapnXZY(): Matrix3f;
                mapnXZY(arg0: Matrix3f): Matrix3f;
                mapnXZnY(): Matrix3f;
                mapnXZnY(arg0: Matrix3f): Matrix3f;
                mapnXnYZ(): Matrix3f;
                mapnXnYZ(arg0: Matrix3f): Matrix3f;
                mapnXnYnZ(): Matrix3f;
                mapnXnYnZ(arg0: Matrix3f): Matrix3f;
                mapnXnZY(): Matrix3f;
                mapnXnZY(arg0: Matrix3f): Matrix3f;
                mapnXnZnY(): Matrix3f;
                mapnXnZnY(arg0: Matrix3f): Matrix3f;
                mapnYXZ(): Matrix3f;
                mapnYXZ(arg0: Matrix3f): Matrix3f;
                mapnYXnZ(): Matrix3f;
                mapnYXnZ(arg0: Matrix3f): Matrix3f;
                mapnYZX(): Matrix3f;
                mapnYZX(arg0: Matrix3f): Matrix3f;
                mapnYZnX(): Matrix3f;
                mapnYZnX(arg0: Matrix3f): Matrix3f;
                mapnYnXZ(): Matrix3f;
                mapnYnXZ(arg0: Matrix3f): Matrix3f;
                mapnYnXnZ(): Matrix3f;
                mapnYnXnZ(arg0: Matrix3f): Matrix3f;
                mapnYnZX(): Matrix3f;
                mapnYnZX(arg0: Matrix3f): Matrix3f;
                mapnYnZnX(): Matrix3f;
                mapnYnZnX(arg0: Matrix3f): Matrix3f;
                mapnZXY(): Matrix3f;
                mapnZXY(arg0: Matrix3f): Matrix3f;
                mapnZXnY(): Matrix3f;
                mapnZXnY(arg0: Matrix3f): Matrix3f;
                mapnZYX(): Matrix3f;
                mapnZYX(arg0: Matrix3f): Matrix3f;
                mapnZYnX(): Matrix3f;
                mapnZYnX(arg0: Matrix3f): Matrix3f;
                mapnZnXY(): Matrix3f;
                mapnZnXY(arg0: Matrix3f): Matrix3f;
                mapnZnXnY(): Matrix3f;
                mapnZnXnY(arg0: Matrix3f): Matrix3f;
                mapnZnYX(): Matrix3f;
                mapnZnYX(arg0: Matrix3f): Matrix3f;
                mapnZnYnX(): Matrix3f;
                mapnZnYnX(arg0: Matrix3f): Matrix3f;
                negateX(): Matrix3f;
                negateX(arg0: Matrix3f): Matrix3f;
                negateY(): Matrix3f;
                negateY(arg0: Matrix3f): Matrix3f;
                negateZ(): Matrix3f;
                negateZ(arg0: Matrix3f): Matrix3f;
                clone(): any;

            }

            const Vector2d: JavaClassStatics<Vector2d, Vector2d$$constructor> & {

                lengthSquared(arg0: double, arg1: double): number;
                length(arg0: double, arg1: double): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;

            }
            interface Vector2d$$constructor extends SuppressProperties {

                new (): Vector2d;
                new (arg0: double): Vector2d;
                new (arg0: double, arg1: double): Vector2d;
                new (arg0: Vector2dc): Vector2d;
                new (arg0: Vector2fc): Vector2d;
                new (arg0: Vector2ic): Vector2d;
                new (arg0: double[]): Vector2d;
                new (arg0: float[]): Vector2d;
                new (arg0: java.nio.ByteBuffer): Vector2d;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector2d;
                new (arg0: java.nio.DoubleBuffer): Vector2d;
                new (arg0: int, arg1: java.nio.DoubleBuffer): Vector2d;

            }
            interface Vector2d extends java.io.Externalizable, java.lang.Cloneable, Vector2dc {
                x: number;
                y: number;

                x(): number;
                y(): number;
                set(arg0: double): Vector2d;
                set(arg0: double, arg1: double): Vector2d;
                set(arg0: Vector2dc): Vector2d;
                set(arg0: Vector2fc): Vector2d;
                set(arg0: Vector2ic): Vector2d;
                set(arg0: double[]): Vector2d;
                set(arg0: float[]): Vector2d;
                set(arg0: java.nio.ByteBuffer): Vector2d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector2d;
                set(arg0: java.nio.DoubleBuffer): Vector2d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Vector2d;
                setFromAddress(arg0: long): Vector2d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector2i): Vector2i;
                get(arg0: Vector2f): Vector2f;
                get(arg0: Vector2d): Vector2d;
                setComponent(arg0: int, arg1: double): Vector2d;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getToAddress(arg0: long): Vector2dc;
                perpendicular(): Vector2d;
                sub(arg0: Vector2dc): Vector2d;
                sub(arg0: double, arg1: double): Vector2d;
                sub(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                sub(arg0: Vector2fc): Vector2d;
                sub(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                sub(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                mul(arg0: double): Vector2d;
                mul(arg0: double, arg1: Vector2d): Vector2d;
                mul(arg0: double, arg1: double): Vector2d;
                mul(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                mul(arg0: Vector2dc): Vector2d;
                mul(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                div(arg0: double): Vector2d;
                div(arg0: double, arg1: Vector2d): Vector2d;
                div(arg0: double, arg1: double): Vector2d;
                div(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                div(arg0: Vector2d): Vector2d;
                div(arg0: Vector2fc): Vector2d;
                div(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                div(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2fc): Vector2d;
                mul(arg0: Matrix2dc): Vector2d;
                mul(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mul(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2dc): Vector2d;
                mulTranspose(arg0: Matrix2dc, arg1: Vector2d): Vector2d;
                mulTranspose(arg0: Matrix2fc): Vector2d;
                mulTranspose(arg0: Matrix2fc, arg1: Vector2d): Vector2d;
                mulPosition(arg0: Matrix3x2dc): Vector2d;
                mulPosition(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                mulDirection(arg0: Matrix3x2dc): Vector2d;
                mulDirection(arg0: Matrix3x2dc, arg1: Vector2d): Vector2d;
                dot(arg0: Vector2dc): number;
                angle(arg0: Vector2dc): number;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector2dc): number;
                distanceSquared(arg0: Vector2dc): number;
                distance(arg0: Vector2fc): number;
                distanceSquared(arg0: Vector2fc): number;
                distance(arg0: double, arg1: double): number;
                distanceSquared(arg0: double, arg1: double): number;
                normalize(): Vector2d;
                normalize(arg0: Vector2d): Vector2d;
                normalize(arg0: double): Vector2d;
                normalize(arg0: double, arg1: Vector2d): Vector2d;
                add(arg0: Vector2dc): Vector2d;
                add(arg0: double, arg1: double): Vector2d;
                add(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                add(arg0: Vector2fc): Vector2d;
                add(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                add(arg0: Vector2fc, arg1: Vector2d): Vector2d;
                zero(): Vector2d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                negate(): Vector2d;
                negate(arg0: Vector2d): Vector2d;
                lerp(arg0: Vector2dc, arg1: double): Vector2d;
                lerp(arg0: Vector2dc, arg1: double, arg2: Vector2d): Vector2d;
                equals(arg0: Vector2dc, arg1: double): boolean;
                equals(arg0: double, arg1: double): boolean;
                equals(arg0: any): boolean;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                fma(arg0: Vector2dc, arg1: Vector2dc): Vector2d;
                fma(arg0: double, arg1: Vector2dc): Vector2d;
                fma(arg0: Vector2dc, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                fma(arg0: double, arg1: Vector2dc, arg2: Vector2d): Vector2d;
                min(arg0: Vector2dc): Vector2d;
                min(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                max(arg0: Vector2dc): Vector2d;
                max(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector2d;
                floor(arg0: Vector2d): Vector2d;
                ceil(): Vector2d;
                ceil(arg0: Vector2d): Vector2d;
                round(): Vector2d;
                round(arg0: Vector2d): Vector2d;
                isFinite(): boolean;
                absolute(): Vector2d;
                absolute(arg0: Vector2d): Vector2d;
                clone(): any;

            }

            const Matrix4f: JavaClassStatics<Matrix4f, Matrix4f$$constructor> & {

                perspectiveOffCenterViewFromRectangle(arg0: Vector3f, arg1: Vector3f, arg2: Vector3f, arg3: Vector3f, arg4: float, arg5: boolean, arg6: Matrix4f, arg7: Matrix4f): void;

            }
            interface Matrix4f$$constructor extends SuppressProperties {

                new (): Matrix4f;
                new (arg0: Matrix3fc): Matrix4f;
                new (arg0: Matrix4fc): Matrix4f;
                new (arg0: Matrix4x3fc): Matrix4f;
                new (arg0: Matrix4dc): Matrix4f;
                new (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float): Matrix4f;
                new (arg0: java.nio.FloatBuffer): Matrix4f;
                new (arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: Vector4fc): Matrix4f;

            }
            interface Matrix4f extends java.io.Externalizable, java.lang.Cloneable, Matrix4fc {

                assume(arg0: int): Matrix4f;
                determineProperties(): Matrix4f;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                m00(arg0: float): Matrix4f;
                m01(arg0: float): Matrix4f;
                m02(arg0: float): Matrix4f;
                m03(arg0: float): Matrix4f;
                m10(arg0: float): Matrix4f;
                m11(arg0: float): Matrix4f;
                m12(arg0: float): Matrix4f;
                m13(arg0: float): Matrix4f;
                m20(arg0: float): Matrix4f;
                m21(arg0: float): Matrix4f;
                m22(arg0: float): Matrix4f;
                m23(arg0: float): Matrix4f;
                m30(arg0: float): Matrix4f;
                m31(arg0: float): Matrix4f;
                m32(arg0: float): Matrix4f;
                m33(arg0: float): Matrix4f;
                identity(): Matrix4f;
                set(arg0: Matrix4fc): Matrix4f;
                setTransposed(arg0: Matrix4fc): Matrix4f;
                set(arg0: Matrix4x3fc): Matrix4f;
                set(arg0: Matrix4dc): Matrix4f;
                set(arg0: Matrix3fc): Matrix4f;
                set(arg0: AxisAngle4f): Matrix4f;
                set(arg0: AxisAngle4d): Matrix4f;
                set(arg0: Quaternionfc): Matrix4f;
                set(arg0: Quaterniondc): Matrix4f;
                set3x3(arg0: Matrix4f): Matrix4f;
                set4x3(arg0: Matrix4x3fc): Matrix4f;
                set4x3(arg0: Matrix4f): Matrix4f;
                mul(arg0: Matrix4fc): Matrix4f;
                mul(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul0(arg0: Matrix4fc): Matrix4f;
                mul0(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float): Matrix4f;
                mul(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float, arg16: Matrix4f): Matrix4f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                mul3x3(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                mulLocal(arg0: Matrix4fc): Matrix4f;
                mulLocal(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulLocalAffine(arg0: Matrix4fc): Matrix4f;
                mulLocalAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix4x3fc): Matrix4f;
                mul(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mul(arg0: Matrix3x2fc): Matrix4f;
                mul(arg0: Matrix3x2fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4fc): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4x3fc): Matrix4f;
                mulPerspectiveAffine(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                mulAffineR(arg0: Matrix4fc): Matrix4f;
                mulAffineR(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulAffine(arg0: Matrix4fc): Matrix4f;
                mulAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulTranslationAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulOrthoAffine(arg0: Matrix4fc): Matrix4f;
                mulOrthoAffine(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                fma4x3(arg0: Matrix4fc, arg1: float): Matrix4f;
                fma4x3(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                add(arg0: Matrix4fc): Matrix4f;
                add(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub(arg0: Matrix4fc): Matrix4f;
                sub(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mulComponentWise(arg0: Matrix4fc): Matrix4f;
                mulComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                add4x3(arg0: Matrix4fc): Matrix4f;
                add4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                sub4x3(arg0: Matrix4f): Matrix4f;
                sub4x3(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                mul4x3ComponentWise(arg0: Matrix4fc): Matrix4f;
                mul4x3ComponentWise(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                set(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float): Matrix4f;
                set(arg0: float[], arg1: int): Matrix4f;
                set(arg0: float[]): Matrix4f;
                setTransposed(arg0: float[], arg1: int): Matrix4f;
                setTransposed(arg0: float[]): Matrix4f;
                set(arg0: java.nio.FloatBuffer): Matrix4f;
                set(arg0: java.nio.ByteBuffer): Matrix4f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4f;
                setTransposed(arg0: java.nio.FloatBuffer): Matrix4f;
                setTransposed(arg0: java.nio.ByteBuffer): Matrix4f;
                setFromAddress(arg0: long): Matrix4f;
                setTransposedFromAddress(arg0: long): Matrix4f;
                set(arg0: Vector4fc, arg1: Vector4fc, arg2: Vector4fc, arg3: Vector4fc): Matrix4f;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(arg0: Matrix4f): Matrix4f;
                invert(): Matrix4f;
                invertPerspective(arg0: Matrix4f): Matrix4f;
                invertPerspective(): Matrix4f;
                invertFrustum(arg0: Matrix4f): Matrix4f;
                invertFrustum(): Matrix4f;
                invertOrtho(arg0: Matrix4f): Matrix4f;
                invertOrtho(): Matrix4f;
                invertPerspectiveView(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                invertPerspectiveView(arg0: Matrix4x3fc, arg1: Matrix4f): Matrix4f;
                invertAffine(arg0: Matrix4f): Matrix4f;
                invertAffine(): Matrix4f;
                transpose(arg0: Matrix4f): Matrix4f;
                transpose3x3(): Matrix4f;
                transpose3x3(arg0: Matrix4f): Matrix4f;
                transpose3x3(arg0: Matrix3f): Matrix3f;
                transpose(): Matrix4f;
                translation(arg0: float, arg1: float, arg2: float): Matrix4f;
                translation(arg0: Vector3fc): Matrix4f;
                setTranslation(arg0: float, arg1: float, arg2: float): Matrix4f;
                setTranslation(arg0: Vector3fc): Matrix4f;
                getTranslation(arg0: Vector3f): Vector3f;
                getScale(arg0: Vector3f): Vector3f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4f): Matrix4f;
                get4x3(arg0: Matrix4x3f): Matrix4x3f;
                get(arg0: Matrix4d): Matrix4d;
                get3x3(arg0: Matrix3f): Matrix3f;
                get3x3(arg0: Matrix3d): Matrix3d;
                getRotation(arg0: AxisAngle4f): AxisAngle4f;
                getRotation(arg0: AxisAngle4d): AxisAngle4d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get3x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                zero(): Matrix4f;
                scaling(arg0: float): Matrix4f;
                scaling(arg0: float, arg1: float, arg2: float): Matrix4f;
                scaling(arg0: Vector3fc): Matrix4f;
                rotation(arg0: float, arg1: Vector3fc): Matrix4f;
                rotation(arg0: AxisAngle4f): Matrix4f;
                rotation(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotationX(arg0: float): Matrix4f;
                rotationY(arg0: float): Matrix4f;
                rotationZ(arg0: float): Matrix4f;
                rotationTowardsXY(arg0: float, arg1: float): Matrix4f;
                rotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotationZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                setRotationXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                setRotationZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                setRotationYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotation(arg0: Quaternionfc): Matrix4f;
                translationRotateScale(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): Matrix4f;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4f;
                translationRotateScale(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4f;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: float): Matrix4f;
                translationRotateScaleInvert(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float): Matrix4f;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4f;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: float): Matrix4f;
                translationRotateScaleMulAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: Matrix4f): Matrix4f;
                translationRotateScaleMulAffine(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4f;
                translationRotate(arg0: float, arg1: float, arg2: float, arg3: Quaternionfc): Matrix4f;
                translationRotate(arg0: Vector3fc, arg1: Quaternionfc): Matrix4f;
                translationRotateInvert(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float): Matrix4f;
                translationRotateInvert(arg0: Vector3fc, arg1: Quaternionfc): Matrix4f;
                set3x3(arg0: Matrix3fc): Matrix4f;
                transform(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4f): Vector4f;
                transformTranspose(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformTranspose(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector4f): Vector4f;
                transformProject(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                transformProject(arg0: Vector4fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector3f): Vector3f;
                transformProject(arg0: Vector3f): Vector3f;
                transformProject(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformProject(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformPosition(arg0: Vector3f): Vector3f;
                transformPosition(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformPosition(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: float, arg1: float, arg2: float, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4f): Vector4f;
                transformAffine(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Vector4f): Vector4f;
                scale(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                scale(arg0: Vector3fc): Matrix4f;
                scale(arg0: float, arg1: Matrix4f): Matrix4f;
                scale(arg0: float): Matrix4f;
                scaleXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                scaleXY(arg0: float, arg1: float): Matrix4f;
                scale(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scale(arg0: float, arg1: float, arg2: float): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                scaleAround(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                scaleLocal(arg0: float, arg1: Matrix4f): Matrix4f;
                scaleLocal(arg0: float): Matrix4f;
                scaleLocal(arg0: float, arg1: float, arg2: float): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                scaleAroundLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateX(arg0: float): Matrix4f;
                rotateY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateY(arg0: float): Matrix4f;
                rotateZ(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateZ(arg0: float): Matrix4f;
                rotateTowardsXY(arg0: float, arg1: float): Matrix4f;
                rotateTowardsXY(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateXYZ(arg0: Vector3fc): Matrix4f;
                rotateXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineXYZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateAffineXYZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateZYX(arg0: Vector3f): Matrix4f;
                rotateZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineZYX(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateAffineZYX(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateYXZ(arg0: Vector3f): Matrix4f;
                rotateYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotateAffineYXZ(arg0: float, arg1: float, arg2: float): Matrix4f;
                rotateAffineYXZ(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateTranslation(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAffine(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAffine(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateLocal(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateLocalX(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalX(arg0: float): Matrix4f;
                rotateLocalY(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalY(arg0: float): Matrix4f;
                rotateLocalZ(arg0: float, arg1: Matrix4f): Matrix4f;
                rotateLocalZ(arg0: float): Matrix4f;
                translate(arg0: Vector3fc): Matrix4f;
                translate(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translate(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                translate(arg0: float, arg1: float, arg2: float): Matrix4f;
                translateLocal(arg0: Vector3fc): Matrix4f;
                translateLocal(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                translateLocal(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                translateLocal(arg0: float, arg1: float, arg2: float): Matrix4f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                ortho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                orthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setOrtho(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setOrthoLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                orthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                orthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setOrthoSymmetric(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setOrthoSymmetricLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                ortho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrtho2D(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setOrtho2DLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                lookAlong(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                lookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setLookAlong(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                setLookAlong(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setLookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                setLookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAt(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtPerspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAt(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                setLookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                setLookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc, arg3: Matrix4f): Matrix4f;
                lookAtLH(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                lookAtLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                lookAtPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: Matrix4f): Matrix4f;
                tile(arg0: int, arg1: int, arg2: int, arg3: int): Matrix4f;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                perspective(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                perspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                perspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                perspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                setPerspective(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setPerspective(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setPerspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setPerspectiveRect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setPerspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setPerspectiveOffCenter(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setPerspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setPerspectiveOffCenterFov(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setPerspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setPerspectiveOffCenterFovLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean, arg5: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                perspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                setPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: boolean): Matrix4f;
                setPerspectiveLH(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                frustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setFrustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setFrustum(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean, arg7: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                frustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setFrustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: boolean): Matrix4f;
                setFrustumLH(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                setFromIntrinsic(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: int, arg6: int, arg7: float, arg8: float): Matrix4f;
                rotate(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotate(arg0: Quaternionfc): Matrix4f;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAffine(arg0: Quaternionfc): Matrix4f;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateAroundAffine(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotationAround(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4f): Matrix4f;
                rotateLocal(arg0: Quaternionfc): Matrix4f;
                rotateAroundLocal(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                rotateAroundLocal(arg0: Quaternionfc, arg1: float, arg2: float, arg3: float): Matrix4f;
                rotate(arg0: AxisAngle4f): Matrix4f;
                rotate(arg0: AxisAngle4f, arg1: Matrix4f): Matrix4f;
                rotate(arg0: float, arg1: Vector3fc): Matrix4f;
                rotate(arg0: float, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unproject(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unproject(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                unprojectInvRay(arg0: Vector2fc, arg1: int[], arg2: Vector3f, arg3: Vector3f): Matrix4f;
                unprojectInvRay(arg0: float, arg1: float, arg2: int[], arg3: Vector3f, arg4: Vector3f): Matrix4f;
                unprojectInv(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                unprojectInv(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector4f): Vector4f;
                project(arg0: float, arg1: float, arg2: float, arg3: int[], arg4: Vector3f): Vector3f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector4f): Vector4f;
                project(arg0: Vector3fc, arg1: int[], arg2: Vector3f): Vector3f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                reflect(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                reflect(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc): Matrix4f;
                reflect(arg0: Quaternionfc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                reflect(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float): Matrix4f;
                reflection(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                reflection(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                reflection(arg0: Quaternionfc, arg1: Vector3fc): Matrix4f;
                getRow(arg0: int, arg1: Vector4f): Vector4f;
                getRow(arg0: int, arg1: Vector3f): Vector3f;
                setRow(arg0: int, arg1: Vector4fc): Matrix4f;
                getColumn(arg0: int, arg1: Vector4f): Vector4f;
                getColumn(arg0: int, arg1: Vector3f): Vector3f;
                setColumn(arg0: int, arg1: Vector4fc): Matrix4f;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: float): Matrix4f;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: float): Matrix4f;
                normal(): Matrix4f;
                normal(arg0: Matrix4f): Matrix4f;
                normal(arg0: Matrix3f): Matrix3f;
                cofactor3x3(): Matrix4f;
                cofactor3x3(arg0: Matrix3f): Matrix3f;
                cofactor3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(): Matrix4f;
                normalize3x3(arg0: Matrix4f): Matrix4f;
                normalize3x3(arg0: Matrix3f): Matrix3f;
                frustumPlane(arg0: int, arg1: Vector4f): Vector4f;
                frustumCorner(arg0: int, arg1: Vector3f): Vector3f;
                perspectiveOrigin(arg0: Vector3f): Vector3f;
                perspectiveInvOrigin(arg0: Vector3f): Vector3f;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: float, arg1: float, arg2: Vector3f): Vector3f;
                positiveZ(arg0: Vector3f): Vector3f;
                normalizedPositiveZ(arg0: Vector3f): Vector3f;
                positiveX(arg0: Vector3f): Vector3f;
                normalizedPositiveX(arg0: Vector3f): Vector3f;
                positiveY(arg0: Vector3f): Vector3f;
                normalizedPositiveY(arg0: Vector3f): Vector3f;
                originAffine(arg0: Vector3f): Vector3f;
                origin(arg0: Vector3f): Vector3f;
                shadow(arg0: Vector4f, arg1: float, arg2: float, arg3: float, arg4: float): Matrix4f;
                shadow(arg0: Vector4f, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: Matrix4f): Matrix4f;
                shadow(arg0: Vector4f, arg1: Matrix4fc, arg2: Matrix4f): Matrix4f;
                shadow(arg0: Vector4f, arg1: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4fc, arg5: Matrix4f): Matrix4f;
                shadow(arg0: float, arg1: float, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                billboardCylindrical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                billboardSpherical(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                equals(arg0: Matrix4fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[], arg5: Matrix4f): Matrix4f;
                pick(arg0: float, arg1: float, arg2: float, arg3: float, arg4: int[]): Matrix4f;
                isAffine(): boolean;
                swap(arg0: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float, arg4: Matrix4f): Matrix4f;
                arcball(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                arcball(arg0: float, arg1: Vector3fc, arg2: float, arg3: float): Matrix4f;
                frustumAabb(arg0: Vector3f, arg1: Vector3f): Matrix4f;
                projectedGridRange(arg0: Matrix4fc, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                perspectiveFrustumSlice(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                orthoCrop(arg0: Matrix4fc, arg1: Matrix4f): Matrix4f;
                trapezoidCrop(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float): Matrix4f;
                transformAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Vector3f, arg7: Vector3f): Matrix4f;
                transformAab(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3f, arg3: Vector3f): Matrix4f;
                lerp(arg0: Matrix4fc, arg1: float): Matrix4f;
                lerp(arg0: Matrix4fc, arg1: float, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Matrix4f): Matrix4f;
                rotateTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                rotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: Matrix4f): Matrix4f;
                rotationTowards(arg0: Vector3fc, arg1: Vector3fc): Matrix4f;
                rotationTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): Matrix4f;
                translationRotateTowards(arg0: Vector3fc, arg1: Vector3fc, arg2: Vector3fc): Matrix4f;
                translationRotateTowards(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float): Matrix4f;
                getEulerAnglesZYX(arg0: Vector3f): Vector3f;
                getEulerAnglesXYZ(arg0: Vector3f): Vector3f;
                affineSpan(arg0: Vector3f, arg1: Vector3f, arg2: Vector3f, arg3: Vector3f): Matrix4f;
                testPoint(arg0: float, arg1: float, arg2: float): boolean;
                testSphere(arg0: float, arg1: float, arg2: float, arg3: float): boolean;
                testAab(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): boolean;
                obliqueZ(arg0: float, arg1: float): Matrix4f;
                obliqueZ(arg0: float, arg1: float, arg2: Matrix4f): Matrix4f;
                withLookAtUp(arg0: Vector3fc): Matrix4f;
                withLookAtUp(arg0: Vector3fc, arg1: Matrix4f): Matrix4f;
                withLookAtUp(arg0: float, arg1: float, arg2: float): Matrix4f;
                withLookAtUp(arg0: float, arg1: float, arg2: float, arg3: Matrix4f): Matrix4f;
                mapXZY(): Matrix4f;
                mapXZY(arg0: Matrix4f): Matrix4f;
                mapXZnY(): Matrix4f;
                mapXZnY(arg0: Matrix4f): Matrix4f;
                mapXnYnZ(): Matrix4f;
                mapXnYnZ(arg0: Matrix4f): Matrix4f;
                mapXnZY(): Matrix4f;
                mapXnZY(arg0: Matrix4f): Matrix4f;
                mapXnZnY(): Matrix4f;
                mapXnZnY(arg0: Matrix4f): Matrix4f;
                mapYXZ(): Matrix4f;
                mapYXZ(arg0: Matrix4f): Matrix4f;
                mapYXnZ(): Matrix4f;
                mapYXnZ(arg0: Matrix4f): Matrix4f;
                mapYZX(): Matrix4f;
                mapYZX(arg0: Matrix4f): Matrix4f;
                mapYZnX(): Matrix4f;
                mapYZnX(arg0: Matrix4f): Matrix4f;
                mapYnXZ(): Matrix4f;
                mapYnXZ(arg0: Matrix4f): Matrix4f;
                mapYnXnZ(): Matrix4f;
                mapYnXnZ(arg0: Matrix4f): Matrix4f;
                mapYnZX(): Matrix4f;
                mapYnZX(arg0: Matrix4f): Matrix4f;
                mapYnZnX(): Matrix4f;
                mapYnZnX(arg0: Matrix4f): Matrix4f;
                mapZXY(): Matrix4f;
                mapZXY(arg0: Matrix4f): Matrix4f;
                mapZXnY(): Matrix4f;
                mapZXnY(arg0: Matrix4f): Matrix4f;
                mapZYX(): Matrix4f;
                mapZYX(arg0: Matrix4f): Matrix4f;
                mapZYnX(): Matrix4f;
                mapZYnX(arg0: Matrix4f): Matrix4f;
                mapZnXY(): Matrix4f;
                mapZnXY(arg0: Matrix4f): Matrix4f;
                mapZnXnY(): Matrix4f;
                mapZnXnY(arg0: Matrix4f): Matrix4f;
                mapZnYX(): Matrix4f;
                mapZnYX(arg0: Matrix4f): Matrix4f;
                mapZnYnX(): Matrix4f;
                mapZnYnX(arg0: Matrix4f): Matrix4f;
                mapnXYnZ(): Matrix4f;
                mapnXYnZ(arg0: Matrix4f): Matrix4f;
                mapnXZY(): Matrix4f;
                mapnXZY(arg0: Matrix4f): Matrix4f;
                mapnXZnY(): Matrix4f;
                mapnXZnY(arg0: Matrix4f): Matrix4f;
                mapnXnYZ(): Matrix4f;
                mapnXnYZ(arg0: Matrix4f): Matrix4f;
                mapnXnYnZ(): Matrix4f;
                mapnXnYnZ(arg0: Matrix4f): Matrix4f;
                mapnXnZY(): Matrix4f;
                mapnXnZY(arg0: Matrix4f): Matrix4f;
                mapnXnZnY(): Matrix4f;
                mapnXnZnY(arg0: Matrix4f): Matrix4f;
                mapnYXZ(): Matrix4f;
                mapnYXZ(arg0: Matrix4f): Matrix4f;
                mapnYXnZ(): Matrix4f;
                mapnYXnZ(arg0: Matrix4f): Matrix4f;
                mapnYZX(): Matrix4f;
                mapnYZX(arg0: Matrix4f): Matrix4f;
                mapnYZnX(): Matrix4f;
                mapnYZnX(arg0: Matrix4f): Matrix4f;
                mapnYnXZ(): Matrix4f;
                mapnYnXZ(arg0: Matrix4f): Matrix4f;
                mapnYnXnZ(): Matrix4f;
                mapnYnXnZ(arg0: Matrix4f): Matrix4f;
                mapnYnZX(): Matrix4f;
                mapnYnZX(arg0: Matrix4f): Matrix4f;
                mapnYnZnX(): Matrix4f;
                mapnYnZnX(arg0: Matrix4f): Matrix4f;
                mapnZXY(): Matrix4f;
                mapnZXY(arg0: Matrix4f): Matrix4f;
                mapnZXnY(): Matrix4f;
                mapnZXnY(arg0: Matrix4f): Matrix4f;
                mapnZYX(): Matrix4f;
                mapnZYX(arg0: Matrix4f): Matrix4f;
                mapnZYnX(): Matrix4f;
                mapnZYnX(arg0: Matrix4f): Matrix4f;
                mapnZnXY(): Matrix4f;
                mapnZnXY(arg0: Matrix4f): Matrix4f;
                mapnZnXnY(): Matrix4f;
                mapnZnXnY(arg0: Matrix4f): Matrix4f;
                mapnZnYX(): Matrix4f;
                mapnZnYX(arg0: Matrix4f): Matrix4f;
                mapnZnYnX(): Matrix4f;
                mapnZnYnX(arg0: Matrix4f): Matrix4f;
                negateX(): Matrix4f;
                negateX(arg0: Matrix4f): Matrix4f;
                negateY(): Matrix4f;
                negateY(arg0: Matrix4f): Matrix4f;
                negateZ(): Matrix4f;
                negateZ(arg0: Matrix4f): Matrix4f;
                isFinite(): boolean;
                clone(): any;

            }

            const Matrix4d: JavaClassStatics<Matrix4d, Matrix4d$$constructor> & {

                perspectiveOffCenterViewFromRectangle(arg0: Vector3d, arg1: Vector3d, arg2: Vector3d, arg3: Vector3d, arg4: double, arg5: boolean, arg6: Matrix4d, arg7: Matrix4d): void;

            }
            interface Matrix4d$$constructor extends SuppressProperties {

                new (): Matrix4d;
                new (arg0: Matrix4dc): Matrix4d;
                new (arg0: Matrix4fc): Matrix4d;
                new (arg0: Matrix4x3dc): Matrix4d;
                new (arg0: Matrix4x3fc): Matrix4d;
                new (arg0: Matrix3dc): Matrix4d;
                new (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double): Matrix4d;
                new (arg0: java.nio.DoubleBuffer): Matrix4d;
                new (arg0: Vector4d, arg1: Vector4d, arg2: Vector4d, arg3: Vector4d): Matrix4d;

            }
            interface Matrix4d extends java.io.Externalizable, java.lang.Cloneable, Matrix4dc {

                assume(arg0: int): Matrix4d;
                determineProperties(): Matrix4d;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m03(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m13(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m23(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m33(): number;
                m00(arg0: double): Matrix4d;
                m01(arg0: double): Matrix4d;
                m02(arg0: double): Matrix4d;
                m03(arg0: double): Matrix4d;
                m10(arg0: double): Matrix4d;
                m11(arg0: double): Matrix4d;
                m12(arg0: double): Matrix4d;
                m13(arg0: double): Matrix4d;
                m20(arg0: double): Matrix4d;
                m21(arg0: double): Matrix4d;
                m22(arg0: double): Matrix4d;
                m23(arg0: double): Matrix4d;
                m30(arg0: double): Matrix4d;
                m31(arg0: double): Matrix4d;
                m32(arg0: double): Matrix4d;
                m33(arg0: double): Matrix4d;
                identity(): Matrix4d;
                set(arg0: Matrix4dc): Matrix4d;
                set(arg0: Matrix4fc): Matrix4d;
                setTransposed(arg0: Matrix4dc): Matrix4d;
                set(arg0: Matrix4x3dc): Matrix4d;
                set(arg0: Matrix4x3fc): Matrix4d;
                set(arg0: Matrix3dc): Matrix4d;
                set3x3(arg0: Matrix4dc): Matrix4d;
                set4x3(arg0: Matrix4x3dc): Matrix4d;
                set4x3(arg0: Matrix4x3fc): Matrix4d;
                set4x3(arg0: Matrix4dc): Matrix4d;
                set(arg0: AxisAngle4f): Matrix4d;
                set(arg0: AxisAngle4d): Matrix4d;
                set(arg0: Quaternionfc): Matrix4d;
                set(arg0: Quaterniondc): Matrix4d;
                mul(arg0: Matrix4dc): Matrix4d;
                mul(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul0(arg0: Matrix4dc): Matrix4d;
                mul0(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double): Matrix4d;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double, arg16: Matrix4d): Matrix4d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                mulLocal(arg0: Matrix4dc): Matrix4d;
                mulLocal(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulLocalAffine(arg0: Matrix4dc): Matrix4d;
                mulLocalAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3dc): Matrix4d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2dc): Matrix4d;
                mul(arg0: Matrix3x2dc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix3x2fc): Matrix4d;
                mul(arg0: Matrix3x2fc, arg1: Matrix4d): Matrix4d;
                mul(arg0: Matrix4f): Matrix4d;
                mul(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4dc): Matrix4d;
                mulPerspectiveAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulAffineR(arg0: Matrix4dc): Matrix4d;
                mulAffineR(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulAffine(arg0: Matrix4dc): Matrix4d;
                mulAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulTranslationAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulOrthoAffine(arg0: Matrix4dc): Matrix4d;
                mulOrthoAffine(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                fma4x3(arg0: Matrix4dc, arg1: double): Matrix4d;
                fma4x3(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                add(arg0: Matrix4dc): Matrix4d;
                add(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                sub(arg0: Matrix4dc): Matrix4d;
                sub(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mulComponentWise(arg0: Matrix4dc): Matrix4d;
                mulComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4dc): Matrix4d;
                add4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                add4x3(arg0: Matrix4fc): Matrix4d;
                add4x3(arg0: Matrix4fc, arg1: Matrix4d): Matrix4d;
                sub4x3(arg0: Matrix4dc): Matrix4d;
                sub4x3(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                mul4x3ComponentWise(arg0: Matrix4dc): Matrix4d;
                mul4x3ComponentWise(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double, arg12: double, arg13: double, arg14: double, arg15: double): Matrix4d;
                set(arg0: double[], arg1: int): Matrix4d;
                set(arg0: double[]): Matrix4d;
                set(arg0: float[], arg1: int): Matrix4d;
                set(arg0: float[]): Matrix4d;
                set(arg0: java.nio.DoubleBuffer): Matrix4d;
                set(arg0: java.nio.FloatBuffer): Matrix4d;
                set(arg0: java.nio.ByteBuffer): Matrix4d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix4d;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4d;
                setFloats(arg0: java.nio.ByteBuffer): Matrix4d;
                setFloats(arg0: int, arg1: java.nio.ByteBuffer): Matrix4d;
                setFromAddress(arg0: long): Matrix4d;
                set(arg0: Vector4d, arg1: Vector4d, arg2: Vector4d, arg3: Vector4d): Matrix4d;
                determinant(): number;
                determinant3x3(): number;
                determinantAffine(): number;
                invert(): Matrix4d;
                invert(arg0: Matrix4d): Matrix4d;
                invertPerspective(arg0: Matrix4d): Matrix4d;
                invertPerspective(): Matrix4d;
                invertFrustum(arg0: Matrix4d): Matrix4d;
                invertFrustum(): Matrix4d;
                invertOrtho(arg0: Matrix4d): Matrix4d;
                invertOrtho(): Matrix4d;
                invertPerspectiveView(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                invertPerspectiveView(arg0: Matrix4x3dc, arg1: Matrix4d): Matrix4d;
                invertAffine(arg0: Matrix4d): Matrix4d;
                invertAffine(): Matrix4d;
                transpose(): Matrix4d;
                transpose(arg0: Matrix4d): Matrix4d;
                transpose3x3(): Matrix4d;
                transpose3x3(arg0: Matrix4d): Matrix4d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                translation(arg0: double, arg1: double, arg2: double): Matrix4d;
                translation(arg0: Vector3fc): Matrix4d;
                translation(arg0: Vector3dc): Matrix4d;
                setTranslation(arg0: double, arg1: double, arg2: double): Matrix4d;
                setTranslation(arg0: Vector3dc): Matrix4d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4d): Matrix4d;
                get4x3(arg0: Matrix4x3d): Matrix4x3d;
                get3x3(arg0: Matrix3d): Matrix3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x3Transposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x3Transposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                zero(): Matrix4d;
                scaling(arg0: double): Matrix4d;
                scaling(arg0: double, arg1: double, arg2: double): Matrix4d;
                scaling(arg0: Vector3dc): Matrix4d;
                rotation(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotationX(arg0: double): Matrix4d;
                rotationY(arg0: double): Matrix4d;
                rotationZ(arg0: double): Matrix4d;
                rotationTowardsXY(arg0: double, arg1: double): Matrix4d;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotationZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                setRotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                setRotationZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                setRotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotation(arg0: double, arg1: Vector3dc): Matrix4d;
                rotation(arg0: double, arg1: Vector3fc): Matrix4d;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4d): Vector4d;
                transformTranspose(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformTranspose(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector4d): Vector4d;
                transformProject(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                transformProject(arg0: Vector3d): Vector3d;
                transformProject(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformProject(arg0: Vector4dc, arg1: Vector3d): Vector3d;
                transformProject(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector3d): Vector3d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformPosition(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformDirection(arg0: Vector3f): Vector3f;
                transformDirection(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformDirection(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformAffine(arg0: Vector4d): Vector4d;
                transformAffine(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                set3x3(arg0: Matrix3dc): Matrix4d;
                scale(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                scale(arg0: Vector3dc): Matrix4d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scale(arg0: double, arg1: double, arg2: double): Matrix4d;
                scale(arg0: double, arg1: Matrix4d): Matrix4d;
                scale(arg0: double): Matrix4d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                scaleXY(arg0: double, arg1: double): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                scaleLocal(arg0: double, arg1: Matrix4d): Matrix4d;
                scaleLocal(arg0: double): Matrix4d;
                scaleLocal(arg0: double, arg1: double, arg2: double): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAffine(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateAroundAffine(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotationAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                rotateAroundLocal(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                rotateAroundLocal(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4d;
                translate(arg0: Vector3dc): Matrix4d;
                translate(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translate(arg0: Vector3fc): Matrix4d;
                translate(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                translate(arg0: double, arg1: double, arg2: double): Matrix4d;
                translateLocal(arg0: Vector3fc): Matrix4d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: Vector3dc): Matrix4d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                translateLocal(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateLocalX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalX(arg0: double): Matrix4d;
                rotateLocalY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalY(arg0: double): Matrix4d;
                rotateLocalZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateLocalZ(arg0: double): Matrix4d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateX(arg0: double): Matrix4d;
                rotateY(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateY(arg0: double): Matrix4d;
                rotateZ(arg0: double, arg1: Matrix4d): Matrix4d;
                rotateZ(arg0: double): Matrix4d;
                rotateTowardsXY(arg0: double, arg1: double): Matrix4d;
                rotateTowardsXY(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateXYZ(arg0: Vector3d): Matrix4d;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineXYZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateAffineXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateZYX(arg0: Vector3d): Matrix4d;
                rotateZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineZYX(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateAffineZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateYXZ(arg0: Vector3d): Matrix4d;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotateAffineYXZ(arg0: double, arg1: double, arg2: double): Matrix4d;
                rotateAffineYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                rotation(arg0: AxisAngle4f): Matrix4d;
                rotation(arg0: AxisAngle4d): Matrix4d;
                rotation(arg0: Quaterniondc): Matrix4d;
                rotation(arg0: Quaternionfc): Matrix4d;
                translationRotateScale(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): Matrix4d;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4d;
                translationRotateScale(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc): Matrix4d;
                translationRotateScale(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4d;
                translationRotateScale(arg0: Vector3dc, arg1: Quaterniondc, arg2: double): Matrix4d;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: double): Matrix4d;
                translationRotateScaleInvert(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3dc, arg1: Quaterniondc, arg2: double): Matrix4d;
                translationRotateScaleInvert(arg0: Vector3fc, arg1: Quaternionfc, arg2: double): Matrix4d;
                translationRotateScaleMulAffine(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: Matrix4d): Matrix4d;
                translationRotateScaleMulAffine(arg0: Vector3fc, arg1: Quaterniondc, arg2: Vector3fc, arg3: Matrix4d): Matrix4d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: Quaterniondc): Matrix4d;
                translationRotate(arg0: Vector3dc, arg1: Quaterniondc): Matrix4d;
                translationRotateInvert(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4d;
                translationRotateInvert(arg0: Vector3fc, arg1: Quaternionfc): Matrix4d;
                rotate(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotate(arg0: Quaterniondc): Matrix4d;
                rotate(arg0: Quaternionfc): Matrix4d;
                rotateAffine(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaterniondc): Matrix4d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaterniondc): Matrix4d;
                rotateAffine(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateAffine(arg0: Quaternionfc): Matrix4d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4d): Matrix4d;
                rotateLocal(arg0: Quaternionfc): Matrix4d;
                rotate(arg0: AxisAngle4f): Matrix4d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4d): Matrix4d;
                rotate(arg0: AxisAngle4d): Matrix4d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3dc): Matrix4d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotate(arg0: double, arg1: Vector3fc): Matrix4d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4d): Matrix4d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                getRow(arg0: int, arg1: Vector3d): Vector3d;
                setRow(arg0: int, arg1: Vector4dc): Matrix4d;
                getColumn(arg0: int, arg1: Vector4d): Vector4d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                setColumn(arg0: int, arg1: Vector4dc): Matrix4d;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: double): Matrix4d;
                getRowColumn(arg0: int, arg1: int): number;
                setRowColumn(arg0: int, arg1: int, arg2: double): Matrix4d;
                normal(): Matrix4d;
                normal(arg0: Matrix4d): Matrix4d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(): Matrix4d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(): Matrix4d;
                normalize3x3(arg0: Matrix4d): Matrix4d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unproject(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unproject(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                unprojectRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                unprojectInv(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                unprojectInv(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                unprojectInvRay(arg0: Vector2dc, arg1: int[], arg2: Vector3d, arg3: Vector3d): Matrix4d;
                unprojectInvRay(arg0: double, arg1: double, arg2: int[], arg3: Vector3d, arg4: Vector3d): Matrix4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector4d): Vector4d;
                project(arg0: double, arg1: double, arg2: double, arg3: int[], arg4: Vector3d): Vector3d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector4d): Vector4d;
                project(arg0: Vector3dc, arg1: int[], arg2: Vector3d): Vector3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                reflect(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc): Matrix4d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                reflection(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                reflection(arg0: Quaterniondc, arg1: Vector3dc): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrtho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setOrtho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setLookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                setLookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setLookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                setLookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAtPerspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                setLookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                setLookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4d): Matrix4d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                lookAtPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4d): Matrix4d;
                tile(arg0: int, arg1: int, arg2: int, arg3: int): Matrix4d;
                tile(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                perspective(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                perspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                perspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                perspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                setPerspective(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setPerspective(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setPerspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setPerspectiveRect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setPerspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setPerspectiveOffCenter(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setPerspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setPerspectiveOffCenterFov(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setPerspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setPerspectiveOffCenterFovLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                perspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                setPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4d;
                setPerspectiveLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                frustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setFrustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setFrustum(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                frustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setFrustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4d;
                setFrustumLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                setFromIntrinsic(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: int, arg6: int, arg7: double, arg8: double): Matrix4d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                frustumCorner(arg0: int, arg1: Vector3d): Vector3d;
                perspectiveOrigin(arg0: Vector3d): Vector3d;
                perspectiveInvOrigin(arg0: Vector3d): Vector3d;
                perspectiveFov(): number;
                perspectiveNear(): number;
                perspectiveFar(): number;
                frustumRayDir(arg0: double, arg1: double, arg2: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                originAffine(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double): Matrix4d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4d): Matrix4d;
                shadow(arg0: Vector4dc, arg1: Matrix4dc, arg2: Matrix4d): Matrix4d;
                shadow(arg0: Vector4d, arg1: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4dc, arg5: Matrix4d): Matrix4d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4dc): Matrix4d;
                billboardCylindrical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                equals(arg0: Matrix4dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4d): Matrix4d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[]): Matrix4d;
                isAffine(): boolean;
                swap(arg0: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4d): Matrix4d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double): Matrix4d;
                frustumAabb(arg0: Vector3d, arg1: Vector3d): Matrix4d;
                projectedGridRange(arg0: Matrix4dc, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                perspectiveFrustumSlice(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                orthoCrop(arg0: Matrix4dc, arg1: Matrix4d): Matrix4d;
                trapezoidCrop(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4d;
                lerp(arg0: Matrix4dc, arg1: double): Matrix4d;
                lerp(arg0: Matrix4dc, arg1: double, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4d): Matrix4d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4d): Matrix4d;
                rotationTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4d;
                rotationTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4d;
                translationRotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4d;
                translationRotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                affineSpan(arg0: Vector3d, arg1: Vector3d, arg2: Vector3d, arg3: Vector3d): Matrix4d;
                testPoint(arg0: double, arg1: double, arg2: double): boolean;
                testSphere(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                testAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): boolean;
                obliqueZ(arg0: double, arg1: double): Matrix4d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4d): Matrix4d;
                withLookAtUp(arg0: Vector3dc): Matrix4d;
                withLookAtUp(arg0: Vector3dc, arg1: Matrix4d): Matrix4d;
                withLookAtUp(arg0: double, arg1: double, arg2: double): Matrix4d;
                withLookAtUp(arg0: double, arg1: double, arg2: double, arg3: Matrix4d): Matrix4d;
                mapXZY(): Matrix4d;
                mapXZY(arg0: Matrix4d): Matrix4d;
                mapXZnY(): Matrix4d;
                mapXZnY(arg0: Matrix4d): Matrix4d;
                mapXnYnZ(): Matrix4d;
                mapXnYnZ(arg0: Matrix4d): Matrix4d;
                mapXnZY(): Matrix4d;
                mapXnZY(arg0: Matrix4d): Matrix4d;
                mapXnZnY(): Matrix4d;
                mapXnZnY(arg0: Matrix4d): Matrix4d;
                mapYXZ(): Matrix4d;
                mapYXZ(arg0: Matrix4d): Matrix4d;
                mapYXnZ(): Matrix4d;
                mapYXnZ(arg0: Matrix4d): Matrix4d;
                mapYZX(): Matrix4d;
                mapYZX(arg0: Matrix4d): Matrix4d;
                mapYZnX(): Matrix4d;
                mapYZnX(arg0: Matrix4d): Matrix4d;
                mapYnXZ(): Matrix4d;
                mapYnXZ(arg0: Matrix4d): Matrix4d;
                mapYnXnZ(): Matrix4d;
                mapYnXnZ(arg0: Matrix4d): Matrix4d;
                mapYnZX(): Matrix4d;
                mapYnZX(arg0: Matrix4d): Matrix4d;
                mapYnZnX(): Matrix4d;
                mapYnZnX(arg0: Matrix4d): Matrix4d;
                mapZXY(): Matrix4d;
                mapZXY(arg0: Matrix4d): Matrix4d;
                mapZXnY(): Matrix4d;
                mapZXnY(arg0: Matrix4d): Matrix4d;
                mapZYX(): Matrix4d;
                mapZYX(arg0: Matrix4d): Matrix4d;
                mapZYnX(): Matrix4d;
                mapZYnX(arg0: Matrix4d): Matrix4d;
                mapZnXY(): Matrix4d;
                mapZnXY(arg0: Matrix4d): Matrix4d;
                mapZnXnY(): Matrix4d;
                mapZnXnY(arg0: Matrix4d): Matrix4d;
                mapZnYX(): Matrix4d;
                mapZnYX(arg0: Matrix4d): Matrix4d;
                mapZnYnX(): Matrix4d;
                mapZnYnX(arg0: Matrix4d): Matrix4d;
                mapnXYnZ(): Matrix4d;
                mapnXYnZ(arg0: Matrix4d): Matrix4d;
                mapnXZY(): Matrix4d;
                mapnXZY(arg0: Matrix4d): Matrix4d;
                mapnXZnY(): Matrix4d;
                mapnXZnY(arg0: Matrix4d): Matrix4d;
                mapnXnYZ(): Matrix4d;
                mapnXnYZ(arg0: Matrix4d): Matrix4d;
                mapnXnYnZ(): Matrix4d;
                mapnXnYnZ(arg0: Matrix4d): Matrix4d;
                mapnXnZY(): Matrix4d;
                mapnXnZY(arg0: Matrix4d): Matrix4d;
                mapnXnZnY(): Matrix4d;
                mapnXnZnY(arg0: Matrix4d): Matrix4d;
                mapnYXZ(): Matrix4d;
                mapnYXZ(arg0: Matrix4d): Matrix4d;
                mapnYXnZ(): Matrix4d;
                mapnYXnZ(arg0: Matrix4d): Matrix4d;
                mapnYZX(): Matrix4d;
                mapnYZX(arg0: Matrix4d): Matrix4d;
                mapnYZnX(): Matrix4d;
                mapnYZnX(arg0: Matrix4d): Matrix4d;
                mapnYnXZ(): Matrix4d;
                mapnYnXZ(arg0: Matrix4d): Matrix4d;
                mapnYnXnZ(): Matrix4d;
                mapnYnXnZ(arg0: Matrix4d): Matrix4d;
                mapnYnZX(): Matrix4d;
                mapnYnZX(arg0: Matrix4d): Matrix4d;
                mapnYnZnX(): Matrix4d;
                mapnYnZnX(arg0: Matrix4d): Matrix4d;
                mapnZXY(): Matrix4d;
                mapnZXY(arg0: Matrix4d): Matrix4d;
                mapnZXnY(): Matrix4d;
                mapnZXnY(arg0: Matrix4d): Matrix4d;
                mapnZYX(): Matrix4d;
                mapnZYX(arg0: Matrix4d): Matrix4d;
                mapnZYnX(): Matrix4d;
                mapnZYnX(arg0: Matrix4d): Matrix4d;
                mapnZnXY(): Matrix4d;
                mapnZnXY(arg0: Matrix4d): Matrix4d;
                mapnZnXnY(): Matrix4d;
                mapnZnXnY(arg0: Matrix4d): Matrix4d;
                mapnZnYX(): Matrix4d;
                mapnZnYX(arg0: Matrix4d): Matrix4d;
                mapnZnYnX(): Matrix4d;
                mapnZnYnX(arg0: Matrix4d): Matrix4d;
                negateX(): Matrix4d;
                negateX(arg0: Matrix4d): Matrix4d;
                negateY(): Matrix4d;
                negateY(arg0: Matrix4d): Matrix4d;
                negateZ(): Matrix4d;
                negateZ(arg0: Matrix4d): Matrix4d;
                isFinite(): boolean;
                clone(): any;

            }

            const Vector4d: JavaClassStatics<Vector4d, Vector4d$$constructor> & {

                lengthSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;
                length(arg0: double, arg1: double, arg2: double, arg3: double): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): number;

            }
            interface Vector4d$$constructor extends SuppressProperties {

                new (): Vector4d;
                new (arg0: Vector4dc): Vector4d;
                new (arg0: Vector4ic): Vector4d;
                new (arg0: Vector3dc, arg1: double): Vector4d;
                new (arg0: Vector3ic, arg1: double): Vector4d;
                new (arg0: Vector2dc, arg1: double, arg2: double): Vector4d;
                new (arg0: Vector2ic, arg1: double, arg2: double): Vector4d;
                new (arg0: double): Vector4d;
                new (arg0: Vector4fc): Vector4d;
                new (arg0: Vector3fc, arg1: double): Vector4d;
                new (arg0: Vector2fc, arg1: double, arg2: double): Vector4d;
                new (arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                new (arg0: float[]): Vector4d;
                new (arg0: double[]): Vector4d;
                new (arg0: java.nio.ByteBuffer): Vector4d;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector4d;
                new (arg0: java.nio.DoubleBuffer): Vector4d;
                new (arg0: int, arg1: java.nio.DoubleBuffer): Vector4d;

            }
            interface Vector4d extends java.io.Externalizable, java.lang.Cloneable, Vector4dc {
                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                set(arg0: Vector4dc): Vector4d;
                set(arg0: Vector4fc): Vector4d;
                set(arg0: Vector4ic): Vector4d;
                set(arg0: Vector3dc, arg1: double): Vector4d;
                set(arg0: Vector3ic, arg1: double): Vector4d;
                set(arg0: Vector3fc, arg1: double): Vector4d;
                set(arg0: Vector2dc, arg1: double, arg2: double): Vector4d;
                set(arg0: Vector2ic, arg1: double, arg2: double): Vector4d;
                set(arg0: double): Vector4d;
                set(arg0: Vector2fc, arg1: double, arg2: double): Vector4d;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                set(arg0: double, arg1: double, arg2: double): Vector4d;
                set(arg0: double[]): Vector4d;
                set(arg0: float[]): Vector4d;
                set(arg0: java.nio.ByteBuffer): Vector4d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector4d;
                set(arg0: java.nio.DoubleBuffer): Vector4d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Vector4d;
                setFromAddress(arg0: long): Vector4d;
                setComponent(arg0: int, arg1: double): Vector4d;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getf(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getf(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getToAddress(arg0: long): Vector4dc;
                sub(arg0: Vector4dc): Vector4d;
                sub(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                sub(arg0: Vector4fc): Vector4d;
                sub(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                sub(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                sub(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                add(arg0: Vector4dc): Vector4d;
                add(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                add(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                add(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                add(arg0: Vector4fc): Vector4d;
                fma(arg0: Vector4dc, arg1: Vector4dc): Vector4d;
                fma(arg0: double, arg1: Vector4dc): Vector4d;
                fma(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                fma(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mulAdd(arg0: Vector4dc, arg1: Vector4dc): Vector4d;
                mulAdd(arg0: double, arg1: Vector4dc): Vector4d;
                mulAdd(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mulAdd(arg0: double, arg1: Vector4dc, arg2: Vector4d): Vector4d;
                mul(arg0: Vector4dc): Vector4d;
                mul(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                div(arg0: Vector4dc): Vector4d;
                div(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Vector4fc): Vector4d;
                mul(arg0: Vector4fc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4dc): Vector4d;
                mul(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulTranspose(arg0: Matrix4dc): Vector4d;
                mulTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffine(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulAffineTranspose(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3dc): Vector4d;
                mul(arg0: Matrix4x3dc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4x3fc): Vector4d;
                mul(arg0: Matrix4x3fc, arg1: Vector4d): Vector4d;
                mul(arg0: Matrix4fc): Vector4d;
                mul(arg0: Matrix4fc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector4d): Vector4d;
                mulProject(arg0: Matrix4dc): Vector4d;
                mulProject(arg0: Matrix4dc, arg1: Vector3d): Vector3d;
                mul(arg0: double): Vector4d;
                mul(arg0: double, arg1: Vector4d): Vector4d;
                div(arg0: double): Vector4d;
                div(arg0: double, arg1: Vector4d): Vector4d;
                rotate(arg0: Quaterniondc): Vector4d;
                rotate(arg0: Quaterniondc, arg1: Vector4d): Vector4d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double): Vector4d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Vector4d): Vector4d;
                rotateX(arg0: double): Vector4d;
                rotateX(arg0: double, arg1: Vector4d): Vector4d;
                rotateY(arg0: double): Vector4d;
                rotateY(arg0: double, arg1: Vector4d): Vector4d;
                rotateZ(arg0: double): Vector4d;
                rotateZ(arg0: double, arg1: Vector4d): Vector4d;
                lengthSquared(): number;
                length(): number;
                normalize(): Vector4d;
                normalize(arg0: Vector4d): Vector4d;
                normalize(arg0: double): Vector4d;
                normalize(arg0: double, arg1: Vector4d): Vector4d;
                normalize3(): Vector4d;
                normalize3(arg0: Vector4d): Vector4d;
                distance(arg0: Vector4dc): number;
                distance(arg0: double, arg1: double, arg2: double, arg3: double): number;
                distanceSquared(arg0: Vector4dc): number;
                distanceSquared(arg0: double, arg1: double, arg2: double, arg3: double): number;
                dot(arg0: Vector4dc): number;
                dot(arg0: double, arg1: double, arg2: double, arg3: double): number;
                angleCos(arg0: Vector4dc): number;
                angle(arg0: Vector4dc): number;
                zero(): Vector4d;
                negate(): Vector4d;
                negate(arg0: Vector4d): Vector4d;
                min(arg0: Vector4dc): Vector4d;
                min(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                max(arg0: Vector4dc): Vector4d;
                max(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                equals(arg0: Vector4dc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: any): boolean;
                smoothStep(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                hermite(arg0: Vector4dc, arg1: Vector4dc, arg2: Vector4dc, arg3: double, arg4: Vector4d): Vector4d;
                lerp(arg0: Vector4dc, arg1: double): Vector4d;
                lerp(arg0: Vector4dc, arg1: double, arg2: Vector4d): Vector4d;
                get(arg0: int): number;
                get(arg0: int, arg1: Vector4i): Vector4i;
                get(arg0: Vector4f): Vector4f;
                get(arg0: Vector4d): Vector4d;
                maxComponent(): number;
                minComponent(): number;
                floor(): Vector4d;
                floor(arg0: Vector4d): Vector4d;
                ceil(): Vector4d;
                ceil(arg0: Vector4d): Vector4d;
                round(): Vector4d;
                round(arg0: Vector4d): Vector4d;
                isFinite(): boolean;
                absolute(): Vector4d;
                absolute(arg0: Vector4d): Vector4d;
                clone(): any;

            }

            const Matrix4x3d: JavaClassStatics<Matrix4x3d, Matrix4x3d$$constructor>;
            interface Matrix4x3d$$constructor extends SuppressProperties {

                new (): Matrix4x3d;
                new (arg0: Matrix4x3dc): Matrix4x3d;
                new (arg0: Matrix4x3fc): Matrix4x3d;
                new (arg0: Matrix3dc): Matrix4x3d;
                new (arg0: Matrix3fc): Matrix4x3d;
                new (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double): Matrix4x3d;
                new (arg0: java.nio.DoubleBuffer): Matrix4x3d;

            }
            interface Matrix4x3d extends java.io.Externalizable, java.lang.Cloneable, Matrix4x3dc {

                assume(arg0: int): Matrix4x3d;
                determineProperties(): Matrix4x3d;
                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                m00(arg0: double): Matrix4x3d;
                m01(arg0: double): Matrix4x3d;
                m02(arg0: double): Matrix4x3d;
                m10(arg0: double): Matrix4x3d;
                m11(arg0: double): Matrix4x3d;
                m12(arg0: double): Matrix4x3d;
                m20(arg0: double): Matrix4x3d;
                m21(arg0: double): Matrix4x3d;
                m22(arg0: double): Matrix4x3d;
                m30(arg0: double): Matrix4x3d;
                m31(arg0: double): Matrix4x3d;
                m32(arg0: double): Matrix4x3d;
                identity(): Matrix4x3d;
                set(arg0: Matrix4x3dc): Matrix4x3d;
                set(arg0: Matrix4x3fc): Matrix4x3d;
                set(arg0: Matrix4dc): Matrix4x3d;
                get(arg0: Matrix4d): Matrix4d;
                set(arg0: Matrix3dc): Matrix4x3d;
                set(arg0: Matrix3fc): Matrix4x3d;
                set(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Vector3dc): Matrix4x3d;
                set3x3(arg0: Matrix4x3dc): Matrix4x3d;
                set(arg0: AxisAngle4f): Matrix4x3d;
                set(arg0: AxisAngle4d): Matrix4x3d;
                set(arg0: Quaternionfc): Matrix4x3d;
                set(arg0: Quaterniondc): Matrix4x3d;
                mul(arg0: Matrix4x3dc): Matrix4x3d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul(arg0: Matrix4x3fc): Matrix4x3d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulOrtho(arg0: Matrix4x3dc): Matrix4x3d;
                mulOrtho(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3dc, arg1: double): Matrix4x3d;
                fma(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3fc, arg1: double): Matrix4x3d;
                fma(arg0: Matrix4x3fc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3dc): Matrix4x3d;
                add(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3fc): Matrix4x3d;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3dc): Matrix4x3d;
                sub(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3fc): Matrix4x3d;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulComponentWise(arg0: Matrix4x3dc): Matrix4x3d;
                mulComponentWise(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: double, arg11: double): Matrix4x3d;
                set(arg0: double[], arg1: int): Matrix4x3d;
                set(arg0: double[]): Matrix4x3d;
                set(arg0: float[], arg1: int): Matrix4x3d;
                set(arg0: float[]): Matrix4x3d;
                set(arg0: java.nio.DoubleBuffer): Matrix4x3d;
                set(arg0: java.nio.FloatBuffer): Matrix4x3d;
                set(arg0: java.nio.ByteBuffer): Matrix4x3d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix4x3d;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix4x3d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix4x3d;
                setFloats(arg0: java.nio.ByteBuffer): Matrix4x3d;
                setFloats(arg0: int, arg1: java.nio.ByteBuffer): Matrix4x3d;
                setFromAddress(arg0: long): Matrix4x3d;
                determinant(): number;
                invert(): Matrix4x3d;
                invert(arg0: Matrix4x3d): Matrix4x3d;
                invertOrtho(arg0: Matrix4x3d): Matrix4x3d;
                invertOrtho(): Matrix4x3d;
                transpose3x3(): Matrix4x3d;
                transpose3x3(arg0: Matrix4x3d): Matrix4x3d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                translation(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                translation(arg0: Vector3fc): Matrix4x3d;
                translation(arg0: Vector3dc): Matrix4x3d;
                setTranslation(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setTranslation(arg0: Vector3dc): Matrix4x3d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: double[], arg1: int): JavaArray<number>;
                getTransposed(arg0: double[]): JavaArray<number>;
                zero(): Matrix4x3d;
                scaling(arg0: double): Matrix4x3d;
                scaling(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                scaling(arg0: Vector3dc): Matrix4x3d;
                rotation(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotationX(arg0: double): Matrix4x3d;
                rotationY(arg0: double): Matrix4x3d;
                rotationZ(arg0: double): Matrix4x3d;
                rotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotationZYX(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setRotationXYZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setRotationZYX(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                setRotationYXZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotation(arg0: double, arg1: Vector3dc): Matrix4x3d;
                rotation(arg0: double, arg1: Vector3fc): Matrix4x3d;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                set3x3(arg0: Matrix3dc): Matrix4x3d;
                set3x3(arg0: Matrix3fc): Matrix4x3d;
                scale(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                scale(arg0: Vector3dc): Matrix4x3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                scale(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                scale(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                scale(arg0: double): Matrix4x3d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                scaleXY(arg0: double, arg1: double): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                scaleLocal(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotationAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                rotateLocalX(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocalX(arg0: double): Matrix4x3d;
                rotateLocalY(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocalY(arg0: double): Matrix4x3d;
                rotateLocalZ(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocalZ(arg0: double): Matrix4x3d;
                translate(arg0: Vector3dc): Matrix4x3d;
                translate(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: Vector3fc): Matrix4x3d;
                translate(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                translate(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                translateLocal(arg0: Vector3fc): Matrix4x3d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: Vector3dc): Matrix4x3d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotateX(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateX(arg0: double): Matrix4x3d;
                rotateY(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateY(arg0: double): Matrix4x3d;
                rotateZ(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateZ(arg0: double): Matrix4x3d;
                rotateXYZ(arg0: Vector3d): Matrix4x3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateZYX(arg0: Vector3d): Matrix4x3d;
                rotateZYX(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateYXZ(arg0: Vector3d): Matrix4x3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double): Matrix4x3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotation(arg0: AxisAngle4f): Matrix4x3d;
                rotation(arg0: AxisAngle4d): Matrix4x3d;
                rotation(arg0: Quaterniondc): Matrix4x3d;
                rotation(arg0: Quaternionfc): Matrix4x3d;
                translationRotateScale(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): Matrix4x3d;
                translationRotateScale(arg0: Vector3fc, arg1: Quaternionfc, arg2: Vector3fc): Matrix4x3d;
                translationRotateScale(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc): Matrix4x3d;
                translationRotateScaleMul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double, arg10: Matrix4x3dc): Matrix4x3d;
                translationRotateScaleMul(arg0: Vector3dc, arg1: Quaterniondc, arg2: Vector3dc, arg3: Matrix4x3dc): Matrix4x3d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: Quaterniondc): Matrix4x3d;
                translationRotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4x3d;
                translationRotate(arg0: Vector3dc, arg1: Quaterniondc): Matrix4x3d;
                translationRotateMul(arg0: double, arg1: double, arg2: double, arg3: Quaternionfc, arg4: Matrix4x3dc): Matrix4x3d;
                translationRotateMul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: Matrix4x3dc): Matrix4x3d;
                translationRotateInvert(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): Matrix4x3d;
                translationRotateInvert(arg0: Vector3dc, arg1: Quaterniondc): Matrix4x3d;
                rotate(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaterniondc): Matrix4x3d;
                rotate(arg0: Quaternionfc): Matrix4x3d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaterniondc): Matrix4x3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaternionfc): Matrix4x3d;
                rotate(arg0: AxisAngle4f): Matrix4x3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: AxisAngle4d): Matrix4x3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3dc): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3fc): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4x3d): Matrix4x3d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                setRow(arg0: int, arg1: Vector4dc): Matrix4x3d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                setColumn(arg0: int, arg1: Vector3dc): Matrix4x3d;
                normal(): Matrix4x3d;
                normal(arg0: Matrix4x3d): Matrix4x3d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(): Matrix4x3d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(): Matrix4x3d;
                normalize3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc): Matrix4x3d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                reflection(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                reflection(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                reflection(arg0: Quaterniondc, arg1: Vector3dc): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                setOrtho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean): Matrix4x3d;
                setOrthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                setOrthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean): Matrix4x3d;
                setOrthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrtho2D(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                setOrtho2DLH(arg0: double, arg1: double, arg2: double, arg3: double): Matrix4x3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setLookAlong(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                setLookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                setLookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                setLookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                setLookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                setLookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4x3d): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: Matrix4x3dc, arg2: Matrix4x3d): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: Matrix4x3dc): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3dc, arg5: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3dc): Matrix4x3d;
                billboardCylindrical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                billboardSpherical(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                equals(arg0: Matrix4x3dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4x3d): Matrix4x3d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[]): Matrix4x3d;
                swap(arg0: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double): Matrix4x3d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4x3d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4x3d;
                lerp(arg0: Matrix4x3dc, arg1: double): Matrix4x3d;
                lerp(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                rotationTowards(arg0: Vector3dc, arg1: Vector3dc): Matrix4x3d;
                rotationTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix4x3d;
                translationRotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc): Matrix4x3d;
                translationRotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): Matrix4x3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double): Matrix4x3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                mapXZY(): Matrix4x3d;
                mapXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXZnY(): Matrix4x3d;
                mapXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnYnZ(): Matrix4x3d;
                mapXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZY(): Matrix4x3d;
                mapXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZnY(): Matrix4x3d;
                mapXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapYXZ(): Matrix4x3d;
                mapYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYXnZ(): Matrix4x3d;
                mapYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYZX(): Matrix4x3d;
                mapYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYZnX(): Matrix4x3d;
                mapYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXZ(): Matrix4x3d;
                mapYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXnZ(): Matrix4x3d;
                mapYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZX(): Matrix4x3d;
                mapYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZnX(): Matrix4x3d;
                mapYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZXY(): Matrix4x3d;
                mapZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZXnY(): Matrix4x3d;
                mapZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZYX(): Matrix4x3d;
                mapZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZYnX(): Matrix4x3d;
                mapZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXY(): Matrix4x3d;
                mapZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXnY(): Matrix4x3d;
                mapZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYX(): Matrix4x3d;
                mapZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYnX(): Matrix4x3d;
                mapZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnXYnZ(): Matrix4x3d;
                mapnXYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZY(): Matrix4x3d;
                mapnXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZnY(): Matrix4x3d;
                mapnXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYZ(): Matrix4x3d;
                mapnXnYZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYnZ(): Matrix4x3d;
                mapnXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZY(): Matrix4x3d;
                mapnXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZnY(): Matrix4x3d;
                mapnXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXZ(): Matrix4x3d;
                mapnYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXnZ(): Matrix4x3d;
                mapnYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZX(): Matrix4x3d;
                mapnYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZnX(): Matrix4x3d;
                mapnYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXZ(): Matrix4x3d;
                mapnYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXnZ(): Matrix4x3d;
                mapnYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZX(): Matrix4x3d;
                mapnYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZnX(): Matrix4x3d;
                mapnYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXY(): Matrix4x3d;
                mapnZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXnY(): Matrix4x3d;
                mapnZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYX(): Matrix4x3d;
                mapnZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYnX(): Matrix4x3d;
                mapnZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXY(): Matrix4x3d;
                mapnZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXnY(): Matrix4x3d;
                mapnZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYX(): Matrix4x3d;
                mapnZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYnX(): Matrix4x3d;
                mapnZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                negateX(): Matrix4x3d;
                negateX(arg0: Matrix4x3d): Matrix4x3d;
                negateY(): Matrix4x3d;
                negateY(arg0: Matrix4x3d): Matrix4x3d;
                negateZ(): Matrix4x3d;
                negateZ(arg0: Matrix4x3d): Matrix4x3d;
                isFinite(): boolean;
                clone(): any;

            }

            const Matrix4x3dc: JavaInterfaceStatics<Matrix4x3dc> & {
                readonly PLANE_NX: number;
                readonly PLANE_PX: number;
                readonly PLANE_NY: number;
                readonly PLANE_PY: number;
                readonly PLANE_NZ: number;
                readonly PLANE_PZ: number;
                readonly PROPERTY_IDENTITY: number;
                readonly PROPERTY_TRANSLATION: number;
                readonly PROPERTY_ORTHONORMAL: number;
            }
            interface Matrix4x3dc extends JavaObject {

                properties(): number;
                m00(): number;
                m01(): number;
                m02(): number;
                m10(): number;
                m11(): number;
                m12(): number;
                m20(): number;
                m21(): number;
                m22(): number;
                m30(): number;
                m31(): number;
                m32(): number;
                get(arg0: Matrix4d): Matrix4d;
                mul(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mulTranslation(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulOrtho(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                mul3x3(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                fma(arg0: Matrix4x3fc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                add(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                sub(arg0: Matrix4x3fc, arg1: Matrix4x3d): Matrix4x3d;
                mulComponentWise(arg0: Matrix4x3dc, arg1: Matrix4x3d): Matrix4x3d;
                determinant(): number;
                invert(arg0: Matrix4x3d): Matrix4x3d;
                invertOrtho(arg0: Matrix4x3d): Matrix4x3d;
                transpose3x3(arg0: Matrix4x3d): Matrix4x3d;
                transpose3x3(arg0: Matrix3d): Matrix3d;
                getTranslation(arg0: Vector3d): Vector3d;
                getScale(arg0: Vector3d): Vector3d;
                get(arg0: Matrix4x3d): Matrix4x3d;
                getUnnormalizedRotation(arg0: Quaternionf): Quaternionf;
                getNormalizedRotation(arg0: Quaternionf): Quaternionf;
                getUnnormalizedRotation(arg0: Quaterniond): Quaterniond;
                getNormalizedRotation(arg0: Quaterniond): Quaterniond;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix4x3dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                get4x4(arg0: float[], arg1: int): JavaArray<number>;
                get4x4(arg0: float[]): JavaArray<number>;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: double[], arg1: int): JavaArray<number>;
                getTransposed(arg0: double[]): JavaArray<number>;
                transform(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformPosition(arg0: Vector3d): Vector3d;
                transformPosition(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformDirection(arg0: Vector3d): Vector3d;
                transformDirection(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                scale(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                scale(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                scale(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                scaleXY(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                scaleLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateAround(arg0: Quaterniondc, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                translate(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translate(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: Vector3fc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: Vector3dc, arg1: Matrix4x3d): Matrix4x3d;
                translateLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateX(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateY(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateZ(arg0: double, arg1: Matrix4x3d): Matrix4x3d;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateTranslation(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaterniondc, arg1: Matrix4x3d): Matrix4x3d;
                rotateLocal(arg0: Quaternionfc, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: AxisAngle4f, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: AxisAngle4d, arg1: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotate(arg0: double, arg1: Vector3fc, arg2: Matrix4x3d): Matrix4x3d;
                getRow(arg0: int, arg1: Vector4d): Vector4d;
                getColumn(arg0: int, arg1: Vector3d): Vector3d;
                normal(arg0: Matrix4x3d): Matrix4x3d;
                normal(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix3d): Matrix3d;
                cofactor3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(arg0: Matrix4x3d): Matrix4x3d;
                normalize3x3(arg0: Matrix3d): Matrix3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                reflect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Quaterniondc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                reflect(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                ortho(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: boolean, arg7: Matrix4x3d): Matrix4x3d;
                orthoLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetric(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: boolean, arg5: Matrix4x3d): Matrix4x3d;
                orthoSymmetricLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2D(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                ortho2DLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAt(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3dc, arg3: Matrix4x3d): Matrix4x3d;
                lookAtLH(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: Matrix4x3d): Matrix4x3d;
                frustumPlane(arg0: int, arg1: Vector4d): Vector4d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                origin(arg0: Vector3d): Vector3d;
                shadow(arg0: Vector4dc, arg1: double, arg2: double, arg3: double, arg4: double, arg5: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: Matrix4x3d): Matrix4x3d;
                shadow(arg0: Vector4dc, arg1: Matrix4x3dc, arg2: Matrix4x3d): Matrix4x3d;
                shadow(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix4x3dc, arg5: Matrix4x3d): Matrix4x3d;
                pick(arg0: double, arg1: double, arg2: double, arg3: double, arg4: int[], arg5: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                arcball(arg0: double, arg1: Vector3dc, arg2: double, arg3: double, arg4: Matrix4x3d): Matrix4x3d;
                transformAab(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Vector3d, arg7: Vector3d): Matrix4x3d;
                transformAab(arg0: Vector3dc, arg1: Vector3dc, arg2: Vector3d, arg3: Vector3d): Matrix4x3d;
                lerp(arg0: Matrix4x3dc, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: Vector3dc, arg1: Vector3dc, arg2: Matrix4x3d): Matrix4x3d;
                rotateTowards(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Matrix4x3d): Matrix4x3d;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                obliqueZ(arg0: double, arg1: double, arg2: Matrix4x3d): Matrix4x3d;
                mapXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnXYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnYnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZY(arg0: Matrix4x3d): Matrix4x3d;
                mapnXnZnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnXnZ(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZX(arg0: Matrix4x3d): Matrix4x3d;
                mapnYnZnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZYnX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnXnY(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYX(arg0: Matrix4x3d): Matrix4x3d;
                mapnZnYnX(arg0: Matrix4x3d): Matrix4x3d;
                negateX(arg0: Matrix4x3d): Matrix4x3d;
                negateY(arg0: Matrix4x3d): Matrix4x3d;
                negateZ(arg0: Matrix4x3d): Matrix4x3d;
                equals(arg0: Matrix4x3dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            const Quaterniondc: JavaInterfaceStatics<Quaterniondc>;
            interface Quaterniondc extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                normalize(arg0: Quaterniond): Quaterniond;
                add(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                add(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                dot(arg0: Quaterniondc): number;
                angle(): number;
                get(arg0: Matrix3d): Matrix3d;
                get(arg0: Matrix3f): Matrix3f;
                get(arg0: Matrix4d): Matrix4d;
                get(arg0: Matrix4f): Matrix4f;
                get(arg0: AxisAngle4f): AxisAngle4f;
                get(arg0: AxisAngle4d): AxisAngle4d;
                get(arg0: Quaterniond): Quaterniond;
                get(arg0: Quaternionf): Quaternionf;
                mul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                mul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                mul(arg0: double, arg1: Quaterniond): Quaterniond;
                premul(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                premul(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                transform(arg0: Vector3d): Vector3d;
                transformInverse(arg0: Vector3d): Vector3d;
                transformUnit(arg0: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector3d): Vector3d;
                transformPositiveX(arg0: Vector4d): Vector4d;
                transformUnitPositiveX(arg0: Vector3d): Vector3d;
                transformUnitPositiveX(arg0: Vector4d): Vector4d;
                transformPositiveY(arg0: Vector3d): Vector3d;
                transformPositiveY(arg0: Vector4d): Vector4d;
                transformUnitPositiveY(arg0: Vector3d): Vector3d;
                transformUnitPositiveY(arg0: Vector4d): Vector4d;
                transformPositiveZ(arg0: Vector3d): Vector3d;
                transformPositiveZ(arg0: Vector4d): Vector4d;
                transformUnitPositiveZ(arg0: Vector3d): Vector3d;
                transformUnitPositiveZ(arg0: Vector4d): Vector4d;
                transform(arg0: Vector4d): Vector4d;
                transformInverse(arg0: Vector4d): Vector4d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverse(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transform(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverse(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transform(arg0: Vector3f): Vector3f;
                transformInverse(arg0: Vector3f): Vector3f;
                transformUnit(arg0: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4d): Vector4d;
                transformUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformInverseUnit(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformInverseUnit(arg0: Vector4dc, arg1: Vector4d): Vector4d;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4d): Vector4d;
                transformUnit(arg0: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector3f): Vector3f;
                transformPositiveX(arg0: Vector4f): Vector4f;
                transformUnitPositiveX(arg0: Vector3f): Vector3f;
                transformUnitPositiveX(arg0: Vector4f): Vector4f;
                transformPositiveY(arg0: Vector3f): Vector3f;
                transformPositiveY(arg0: Vector4f): Vector4f;
                transformUnitPositiveY(arg0: Vector3f): Vector3f;
                transformUnitPositiveY(arg0: Vector4f): Vector4f;
                transformPositiveZ(arg0: Vector3f): Vector3f;
                transformPositiveZ(arg0: Vector4f): Vector4f;
                transformUnitPositiveZ(arg0: Vector3f): Vector3f;
                transformUnitPositiveZ(arg0: Vector4f): Vector4f;
                transform(arg0: Vector4f): Vector4f;
                transformInverse(arg0: Vector4f): Vector4f;
                transform(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverse(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transform(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverse(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverse(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformUnit(arg0: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4f): Vector4f;
                transformUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformInverseUnit(arg0: Vector3fc, arg1: Vector3f): Vector3f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector3f): Vector3f;
                transformUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformInverseUnit(arg0: Vector4fc, arg1: Vector4f): Vector4f;
                transformUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                transformInverseUnit(arg0: double, arg1: double, arg2: double, arg3: Vector4f): Vector4f;
                invert(arg0: Quaterniond): Quaterniond;
                div(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                conjugate(arg0: Quaterniond): Quaterniond;
                lengthSquared(): number;
                slerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                scale(arg0: double, arg1: Quaterniond): Quaterniond;
                integrate(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                nlerp(arg0: Quaterniondc, arg1: double, arg2: Quaterniond): Quaterniond;
                nlerpIterative(arg0: Quaterniondc, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                lookAlong(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                lookAlong(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                difference(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                rotateTo(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: Quaterniond): Quaterniond;
                rotateTo(arg0: Vector3dc, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                rotateX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalX(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalY(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateLocalZ(arg0: double, arg1: Quaterniond): Quaterniond;
                rotateXYZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateZYX(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                rotateYXZ(arg0: double, arg1: double, arg2: double, arg3: Quaterniond): Quaterniond;
                getEulerAnglesXYZ(arg0: Vector3d): Vector3d;
                getEulerAnglesZYX(arg0: Vector3d): Vector3d;
                getEulerAnglesZXY(arg0: Vector3d): Vector3d;
                getEulerAnglesYXZ(arg0: Vector3d): Vector3d;
                rotateAxis(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Quaterniond): Quaterniond;
                rotateAxis(arg0: double, arg1: Vector3dc, arg2: Quaterniond): Quaterniond;
                positiveX(arg0: Vector3d): Vector3d;
                normalizedPositiveX(arg0: Vector3d): Vector3d;
                positiveY(arg0: Vector3d): Vector3d;
                normalizedPositiveY(arg0: Vector3d): Vector3d;
                positiveZ(arg0: Vector3d): Vector3d;
                normalizedPositiveZ(arg0: Vector3d): Vector3d;
                conjugateBy(arg0: Quaterniondc, arg1: Quaterniond): Quaterniond;
                isFinite(): boolean;
                equals(arg0: Quaterniondc, arg1: double): boolean;
                equals(arg0: double, arg1: double, arg2: double, arg3: double): boolean;

            }

            const Matrix3x2dc: JavaInterfaceStatics<Matrix3x2dc>;
            interface Matrix3x2dc extends JavaObject {

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                mul(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                mulLocal(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                determinant(): number;
                invert(arg0: Matrix3x2d): Matrix3x2d;
                translate(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                translate(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get3x3(arg0: double[], arg1: int): JavaArray<number>;
                get3x3(arg0: double[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                scale(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scale(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: Vector2fc, arg1: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                scale(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformPosition(arg0: Vector2d): Vector2d;
                transformPosition(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformPosition(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformDirection(arg0: Vector2d): Vector2d;
                transformDirection(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformDirection(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                rotate(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateAbout(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                rotateTo(arg0: Vector2dc, arg1: Vector2dc, arg2: Matrix3x2d): Matrix3x2d;
                view(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                origin(arg0: Vector2d): Vector2d;
                viewArea(arg0: double[]): JavaArray<number>;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                unproject(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                unprojectInv(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                testPoint(arg0: double, arg1: double): boolean;
                testCircle(arg0: double, arg1: double, arg2: double): boolean;
                testAar(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: Matrix3x2dc, arg1: double): boolean;
                isFinite(): boolean;

            }

            const Vector4ic: JavaInterfaceStatics<Vector4ic>;
            interface Vector4ic extends JavaObject {

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4ic;
                sub(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                sub(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                add(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                add(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                mul(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                div(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                mul(arg0: int, arg1: Vector4i): Vector4i;
                div(arg0: float, arg1: Vector4i): Vector4i;
                div(arg0: int, arg1: Vector4i): Vector4i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector4ic): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                gridDistance(arg0: Vector4ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                distanceSquared(arg0: Vector4ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                dot(arg0: Vector4ic): number;
                negate(arg0: Vector4i): Vector4i;
                min(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                max(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                get(arg0: int): number;
                maxComponent(): number;
                minComponent(): number;
                absolute(arg0: Vector4i): Vector4i;
                equals(arg0: int, arg1: int, arg2: int, arg3: int): boolean;

            }

            const Matrix3x2d: JavaClassStatics<Matrix3x2d, Matrix3x2d$$constructor>;
            interface Matrix3x2d$$constructor extends SuppressProperties {

                new (): Matrix3x2d;
                new (arg0: Matrix2dc): Matrix3x2d;
                new (arg0: Matrix2fc): Matrix3x2d;
                new (arg0: Matrix3x2dc): Matrix3x2d;
                new (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3x2d;
                new (arg0: java.nio.DoubleBuffer): Matrix3x2d;

            }
            interface Matrix3x2d extends Matrix3x2dc, java.lang.Cloneable, java.io.Externalizable {
                m00: number;
                m01: number;
                m10: number;
                m11: number;
                m20: number;
                m21: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m20(): number;
                m21(): number;
                set(arg0: Matrix3x2dc): Matrix3x2d;
                set(arg0: Matrix2dc): Matrix3x2d;
                set(arg0: Matrix2fc): Matrix3x2d;
                mul(arg0: Matrix3x2dc): Matrix3x2d;
                mul(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                mulLocal(arg0: Matrix3x2dc): Matrix3x2d;
                mulLocal(arg0: Matrix3x2dc, arg1: Matrix3x2d): Matrix3x2d;
                set(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3x2d;
                set(arg0: double[]): Matrix3x2d;
                determinant(): number;
                invert(): Matrix3x2d;
                invert(arg0: Matrix3x2d): Matrix3x2d;
                translation(arg0: double, arg1: double): Matrix3x2d;
                translation(arg0: Vector2dc): Matrix3x2d;
                setTranslation(arg0: double, arg1: double): Matrix3x2d;
                setTranslation(arg0: Vector2dc): Matrix3x2d;
                translate(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                translate(arg0: double, arg1: double): Matrix3x2d;
                translate(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translate(arg0: Vector2dc): Matrix3x2d;
                translateLocal(arg0: Vector2dc): Matrix3x2d;
                translateLocal(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                translateLocal(arg0: double, arg1: double): Matrix3x2d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get3x3(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get3x3(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get4x4(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get4x4(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix3x2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                get3x3(arg0: double[], arg1: int): JavaArray<number>;
                get3x3(arg0: double[]): JavaArray<number>;
                get4x4(arg0: double[], arg1: int): JavaArray<number>;
                get4x4(arg0: double[]): JavaArray<number>;
                set(arg0: java.nio.DoubleBuffer): Matrix3x2d;
                set(arg0: java.nio.ByteBuffer): Matrix3x2d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix3x2d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix3x2d;
                setFromAddress(arg0: long): Matrix3x2d;
                zero(): Matrix3x2d;
                identity(): Matrix3x2d;
                scale(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scale(arg0: double, arg1: double): Matrix3x2d;
                scale(arg0: Vector2dc): Matrix3x2d;
                scale(arg0: Vector2dc, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: Vector2fc): Matrix3x2d;
                scale(arg0: Vector2fc, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scale(arg0: double): Matrix3x2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double, arg1: double): Matrix3x2d;
                scaleLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                scaleLocal(arg0: double): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                scaleAround(arg0: double, arg1: double, arg2: double): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): Matrix3x2d;
                scaleAroundLocal(arg0: double, arg1: double, arg2: double): Matrix3x2d;
                scaling(arg0: double): Matrix3x2d;
                scaling(arg0: double, arg1: double): Matrix3x2d;
                rotation(arg0: double): Matrix3x2d;
                transform(arg0: Vector3d): Vector3d;
                transform(arg0: Vector3dc, arg1: Vector3d): Vector3d;
                transform(arg0: double, arg1: double, arg2: double, arg3: Vector3d): Vector3d;
                transformPosition(arg0: Vector2d): Vector2d;
                transformPosition(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformPosition(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformDirection(arg0: Vector2d): Vector2d;
                transformDirection(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformDirection(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: double): Matrix3x2d;
                rotate(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateLocal(arg0: double, arg1: Matrix3x2d): Matrix3x2d;
                rotateLocal(arg0: double): Matrix3x2d;
                rotateAbout(arg0: double, arg1: double, arg2: double): Matrix3x2d;
                rotateAbout(arg0: double, arg1: double, arg2: double, arg3: Matrix3x2d): Matrix3x2d;
                rotateTo(arg0: Vector2dc, arg1: Vector2dc, arg2: Matrix3x2d): Matrix3x2d;
                rotateTo(arg0: Vector2dc, arg1: Vector2dc): Matrix3x2d;
                view(arg0: double, arg1: double, arg2: double, arg3: double, arg4: Matrix3x2d): Matrix3x2d;
                view(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3x2d;
                setView(arg0: double, arg1: double, arg2: double, arg3: double): Matrix3x2d;
                origin(arg0: Vector2d): Vector2d;
                viewArea(arg0: double[]): JavaArray<number>;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                unproject(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                unprojectInv(arg0: double, arg1: double, arg2: int[], arg3: Vector2d): Vector2d;
                span(arg0: Vector2d, arg1: Vector2d, arg2: Vector2d): Matrix3x2d;
                testPoint(arg0: double, arg1: double): boolean;
                testCircle(arg0: double, arg1: double, arg2: double): boolean;
                testAar(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                equals(arg0: Matrix3x2dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                isFinite(): boolean;
                clone(): any;

            }

            const Vector4i: JavaClassStatics<Vector4i, Vector4i$$constructor> & {

                lengthSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                length(arg0: int, arg1: int, arg2: int, arg3: int): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int): number;

            }
            interface Vector4i$$constructor extends SuppressProperties {

                new (): Vector4i;
                new (arg0: Vector4ic): Vector4i;
                new (arg0: Vector3ic, arg1: int): Vector4i;
                new (arg0: Vector2ic, arg1: int, arg2: int): Vector4i;
                new (arg0: Vector3fc, arg1: float, arg2: int): Vector4i;
                new (arg0: Vector4fc, arg1: int): Vector4i;
                new (arg0: Vector4dc, arg1: int): Vector4i;
                new (arg0: int): Vector4i;
                new (arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                new (arg0: int[]): Vector4i;
                new (arg0: java.nio.ByteBuffer): Vector4i;
                new (arg0: int, arg1: java.nio.ByteBuffer): Vector4i;
                new (arg0: java.nio.IntBuffer): Vector4i;
                new (arg0: int, arg1: java.nio.IntBuffer): Vector4i;

            }
            interface Vector4i extends java.io.Externalizable, java.lang.Cloneable, Vector4ic {
                x: number;
                y: number;
                z: number;
                w: number;

                x(): number;
                y(): number;
                z(): number;
                w(): number;
                set(arg0: Vector4ic): Vector4i;
                set(arg0: Vector4dc): Vector4i;
                set(arg0: Vector4dc, arg1: int): Vector4i;
                set(arg0: Vector4fc, arg1: int): Vector4i;
                set(arg0: Vector3ic, arg1: int): Vector4i;
                set(arg0: Vector2ic, arg1: int, arg2: int): Vector4i;
                set(arg0: int): Vector4i;
                set(arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                set(arg0: int[]): Vector4i;
                set(arg0: java.nio.ByteBuffer): Vector4i;
                set(arg0: int, arg1: java.nio.ByteBuffer): Vector4i;
                set(arg0: java.nio.IntBuffer): Vector4i;
                set(arg0: int, arg1: java.nio.IntBuffer): Vector4i;
                setFromAddress(arg0: long): Vector4i;
                get(arg0: int): number;
                maxComponent(): number;
                minComponent(): number;
                setComponent(arg0: int, arg1: int): Vector4i;
                get(arg0: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: int, arg1: java.nio.IntBuffer): java.nio.IntBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Vector4ic;
                sub(arg0: Vector4ic): Vector4i;
                sub(arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                sub(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                sub(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                add(arg0: Vector4ic): Vector4i;
                add(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                add(arg0: int, arg1: int, arg2: int, arg3: int): Vector4i;
                add(arg0: int, arg1: int, arg2: int, arg3: int, arg4: Vector4i): Vector4i;
                mul(arg0: Vector4ic): Vector4i;
                mul(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                div(arg0: Vector4ic): Vector4i;
                div(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                mul(arg0: int): Vector4i;
                mul(arg0: int, arg1: Vector4i): Vector4i;
                div(arg0: float): Vector4i;
                div(arg0: float, arg1: Vector4i): Vector4i;
                div(arg0: int): Vector4i;
                div(arg0: int, arg1: Vector4i): Vector4i;
                lengthSquared(): number;
                length(): number;
                distance(arg0: Vector4ic): number;
                distance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                gridDistance(arg0: Vector4ic): number;
                gridDistance(arg0: int, arg1: int, arg2: int, arg3: int): number;
                distanceSquared(arg0: Vector4ic): number;
                distanceSquared(arg0: int, arg1: int, arg2: int, arg3: int): number;
                dot(arg0: Vector4ic): number;
                zero(): Vector4i;
                negate(): Vector4i;
                negate(arg0: Vector4i): Vector4i;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                min(arg0: Vector4ic): Vector4i;
                min(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                max(arg0: Vector4ic): Vector4i;
                max(arg0: Vector4ic, arg1: Vector4i): Vector4i;
                absolute(): Vector4i;
                absolute(arg0: Vector4i): Vector4i;
                equals(arg0: int, arg1: int, arg2: int, arg3: int): boolean;
                equals(arg0: any): boolean;
                clone(): any;

            }

            const Matrix2f: JavaClassStatics<Matrix2f, Matrix2f$$constructor>;
            interface Matrix2f$$constructor extends SuppressProperties {

                new (): Matrix2f;
                new (arg0: Matrix2fc): Matrix2f;
                new (arg0: Matrix3fc): Matrix2f;
                new (arg0: float, arg1: float, arg2: float, arg3: float): Matrix2f;
                new (arg0: java.nio.FloatBuffer): Matrix2f;
                new (arg0: Vector2fc, arg1: Vector2fc): Matrix2f;

            }
            interface Matrix2f extends java.io.Externalizable, java.lang.Cloneable, Matrix2fc {
                m00: number;
                m01: number;
                m10: number;
                m11: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m00(arg0: float): Matrix2f;
                m01(arg0: float): Matrix2f;
                m10(arg0: float): Matrix2f;
                m11(arg0: float): Matrix2f;
                set(arg0: Matrix2fc): Matrix2f;
                set(arg0: Matrix3x2fc): Matrix2f;
                set(arg0: Matrix3fc): Matrix2f;
                mul(arg0: Matrix2fc): Matrix2f;
                mul(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulLocal(arg0: Matrix2fc): Matrix2f;
                mulLocal(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                set(arg0: float, arg1: float, arg2: float, arg3: float): Matrix2f;
                set(arg0: float[]): Matrix2f;
                set(arg0: Vector2fc, arg1: Vector2fc): Matrix2f;
                determinant(): number;
                invert(): Matrix2f;
                invert(arg0: Matrix2f): Matrix2f;
                transpose(): Matrix2f;
                transpose(arg0: Matrix2f): Matrix2f;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix2f): Matrix2f;
                get(arg0: Matrix3x2f): Matrix3x2f;
                get(arg0: Matrix3f): Matrix3f;
                getRotation(): number;
                get(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2fc;
                get(arg0: float[], arg1: int): JavaArray<number>;
                get(arg0: float[]): JavaArray<number>;
                set(arg0: java.nio.FloatBuffer): Matrix2f;
                set(arg0: java.nio.ByteBuffer): Matrix2f;
                set(arg0: int, arg1: java.nio.FloatBuffer): Matrix2f;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix2f;
                setFromAddress(arg0: long): Matrix2f;
                zero(): Matrix2f;
                identity(): Matrix2f;
                scale(arg0: Vector2fc, arg1: Matrix2f): Matrix2f;
                scale(arg0: Vector2fc): Matrix2f;
                scale(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                scale(arg0: float, arg1: float): Matrix2f;
                scale(arg0: float, arg1: Matrix2f): Matrix2f;
                scale(arg0: float): Matrix2f;
                scaleLocal(arg0: float, arg1: float, arg2: Matrix2f): Matrix2f;
                scaleLocal(arg0: float, arg1: float): Matrix2f;
                scaling(arg0: float): Matrix2f;
                scaling(arg0: float, arg1: float): Matrix2f;
                scaling(arg0: Vector2fc): Matrix2f;
                rotation(arg0: float): Matrix2f;
                transform(arg0: Vector2f): Vector2f;
                transform(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transform(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2f): Vector2f;
                transformTranspose(arg0: Vector2fc, arg1: Vector2f): Vector2f;
                transformTranspose(arg0: float, arg1: float, arg2: Vector2f): Vector2f;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: float): Matrix2f;
                rotate(arg0: float, arg1: Matrix2f): Matrix2f;
                rotateLocal(arg0: float): Matrix2f;
                rotateLocal(arg0: float, arg1: Matrix2f): Matrix2f;
                getRow(arg0: int, arg1: Vector2f): Vector2f;
                setRow(arg0: int, arg1: Vector2fc): Matrix2f;
                setRow(arg0: int, arg1: float, arg2: float): Matrix2f;
                getColumn(arg0: int, arg1: Vector2f): Vector2f;
                setColumn(arg0: int, arg1: Vector2fc): Matrix2f;
                setColumn(arg0: int, arg1: float, arg2: float): Matrix2f;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: float): Matrix2f;
                normal(): Matrix2f;
                normal(arg0: Matrix2f): Matrix2f;
                getScale(arg0: Vector2f): Vector2f;
                positiveX(arg0: Vector2f): Vector2f;
                normalizedPositiveX(arg0: Vector2f): Vector2f;
                positiveY(arg0: Vector2f): Vector2f;
                normalizedPositiveY(arg0: Vector2f): Vector2f;
                equals(arg0: Matrix2fc, arg1: float): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix2f): Matrix2f;
                add(arg0: Matrix2fc): Matrix2f;
                add(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                sub(arg0: Matrix2fc): Matrix2f;
                sub(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                mulComponentWise(arg0: Matrix2fc): Matrix2f;
                mulComponentWise(arg0: Matrix2fc, arg1: Matrix2f): Matrix2f;
                lerp(arg0: Matrix2fc, arg1: float): Matrix2f;
                lerp(arg0: Matrix2fc, arg1: float, arg2: Matrix2f): Matrix2f;
                isFinite(): boolean;
                clone(): any;

            }

            const Matrix2d: JavaClassStatics<Matrix2d, Matrix2d$$constructor>;
            interface Matrix2d$$constructor extends SuppressProperties {

                new (): Matrix2d;
                new (arg0: Matrix2dc): Matrix2d;
                new (arg0: Matrix2fc): Matrix2d;
                new (arg0: Matrix3dc): Matrix2d;
                new (arg0: Matrix3fc): Matrix2d;
                new (arg0: double, arg1: double, arg2: double, arg3: double): Matrix2d;
                new (arg0: java.nio.DoubleBuffer): Matrix2d;
                new (arg0: Vector2dc, arg1: Vector2dc): Matrix2d;

            }
            interface Matrix2d extends java.io.Externalizable, java.lang.Cloneable, Matrix2dc {
                m00: number;
                m01: number;
                m10: number;
                m11: number;

                m00(): number;
                m01(): number;
                m10(): number;
                m11(): number;
                m00(arg0: double): Matrix2d;
                m01(arg0: double): Matrix2d;
                m10(arg0: double): Matrix2d;
                m11(arg0: double): Matrix2d;
                set(arg0: Matrix2dc): Matrix2d;
                set(arg0: Matrix2fc): Matrix2d;
                set(arg0: Matrix3x2dc): Matrix2d;
                set(arg0: Matrix3x2fc): Matrix2d;
                set(arg0: Matrix3dc): Matrix2d;
                set(arg0: Matrix3fc): Matrix2d;
                mul(arg0: Matrix2dc): Matrix2d;
                mul(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mul(arg0: Matrix2fc): Matrix2d;
                mul(arg0: Matrix2fc, arg1: Matrix2d): Matrix2d;
                mulLocal(arg0: Matrix2dc): Matrix2d;
                mulLocal(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                set(arg0: double, arg1: double, arg2: double, arg3: double): Matrix2d;
                set(arg0: double[]): Matrix2d;
                set(arg0: Vector2dc, arg1: Vector2dc): Matrix2d;
                determinant(): number;
                invert(): Matrix2d;
                invert(arg0: Matrix2d): Matrix2d;
                transpose(): Matrix2d;
                transpose(arg0: Matrix2d): Matrix2d;
                toString(arg0: java.text.NumberFormat): string;
                toString(): string;
                get(arg0: Matrix2d): Matrix2d;
                get(arg0: Matrix3x2d): Matrix3x2d;
                get(arg0: Matrix3d): Matrix3d;
                getRotation(): number;
                get(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                get(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                get(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: int, arg1: java.nio.DoubleBuffer): java.nio.DoubleBuffer;
                getTransposed(arg0: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: int, arg1: java.nio.FloatBuffer): java.nio.FloatBuffer;
                getTransposed(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposed(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getTransposedFloats(arg0: int, arg1: java.nio.ByteBuffer): java.nio.ByteBuffer;
                getToAddress(arg0: long): Matrix2dc;
                get(arg0: double[], arg1: int): JavaArray<number>;
                get(arg0: double[]): JavaArray<number>;
                set(arg0: java.nio.DoubleBuffer): Matrix2d;
                set(arg0: java.nio.ByteBuffer): Matrix2d;
                set(arg0: int, arg1: java.nio.DoubleBuffer): Matrix2d;
                set(arg0: int, arg1: java.nio.ByteBuffer): Matrix2d;
                setFromAddress(arg0: long): Matrix2d;
                zero(): Matrix2d;
                identity(): Matrix2d;
                scale(arg0: Vector2dc, arg1: Matrix2d): Matrix2d;
                scale(arg0: Vector2dc): Matrix2d;
                scale(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                scale(arg0: double, arg1: double): Matrix2d;
                scale(arg0: double, arg1: Matrix2d): Matrix2d;
                scale(arg0: double): Matrix2d;
                scaleLocal(arg0: double, arg1: double, arg2: Matrix2d): Matrix2d;
                scaleLocal(arg0: double, arg1: double): Matrix2d;
                scaling(arg0: double): Matrix2d;
                scaling(arg0: double, arg1: double): Matrix2d;
                scaling(arg0: Vector2dc): Matrix2d;
                rotation(arg0: double): Matrix2d;
                transform(arg0: Vector2d): Vector2d;
                transform(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transform(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2d): Vector2d;
                transformTranspose(arg0: Vector2dc, arg1: Vector2d): Vector2d;
                transformTranspose(arg0: double, arg1: double, arg2: Vector2d): Vector2d;
                writeExternal(arg0: java.io.ObjectOutput): void;
                readExternal(arg0: java.io.ObjectInput): void;
                rotate(arg0: double): Matrix2d;
                rotate(arg0: double, arg1: Matrix2d): Matrix2d;
                rotateLocal(arg0: double): Matrix2d;
                rotateLocal(arg0: double, arg1: Matrix2d): Matrix2d;
                getRow(arg0: int, arg1: Vector2d): Vector2d;
                setRow(arg0: int, arg1: Vector2dc): Matrix2d;
                setRow(arg0: int, arg1: double, arg2: double): Matrix2d;
                getColumn(arg0: int, arg1: Vector2d): Vector2d;
                setColumn(arg0: int, arg1: Vector2dc): Matrix2d;
                setColumn(arg0: int, arg1: double, arg2: double): Matrix2d;
                get(arg0: int, arg1: int): number;
                set(arg0: int, arg1: int, arg2: double): Matrix2d;
                normal(): Matrix2d;
                normal(arg0: Matrix2d): Matrix2d;
                getScale(arg0: Vector2d): Vector2d;
                positiveX(arg0: Vector2d): Vector2d;
                normalizedPositiveX(arg0: Vector2d): Vector2d;
                positiveY(arg0: Vector2d): Vector2d;
                normalizedPositiveY(arg0: Vector2d): Vector2d;
                equals(arg0: Matrix2dc, arg1: double): boolean;
                equals(arg0: any): boolean;
                swap(arg0: Matrix2d): Matrix2d;
                add(arg0: Matrix2dc): Matrix2d;
                add(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                sub(arg0: Matrix2dc): Matrix2d;
                sub(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                mulComponentWise(arg0: Matrix2dc): Matrix2d;
                mulComponentWise(arg0: Matrix2dc, arg1: Matrix2d): Matrix2d;
                lerp(arg0: Matrix2dc, arg1: double): Matrix2d;
                lerp(arg0: Matrix2dc, arg1: double, arg2: Matrix2d): Matrix2d;
                isFinite(): boolean;
                clone(): any;

            }

            export {
                Vector3f,
                Matrix4dc,
                Vector3i,
                Matrix4fc,
                Matrix3dc,
                Vector3fc,
                Matrix3fc,
                Quaternionfc,
                Vector2ic,
                Quaternionf,
                Vector3d,
                Vector3ic,
                Vector2fc,
                Matrix3x2fc,
                Matrix4x3fc,
                Vector2dc,
                Vector3dc,
                AxisAngle4d,
                AxisAngle4f,
                Matrix2dc,
                Matrix4x3f,
                Vector2f,
                Quaterniond,
                Vector4dc,
                Vector4f,
                Vector4fc,
                Vector2i,
                Matrix2fc,
                Matrix3d,
                Matrix3x2f,
                Matrix3f,
                Vector2d,
                Matrix4f,
                Matrix4d,
                Vector4d,
                Matrix4x3d,
                Matrix4x3dc,
                Quaterniondc,
                Matrix3x2dc,
                Vector4ic,
                Matrix3x2d,
                Vector4i,
                Matrix2f,
                Matrix2d
            }

        }

    }

    namespace java {

        namespace io {

            const InputStream: JavaClassStatics<InputStream, InputStream$$constructor> & {

                nullInputStream(): InputStream;

            }
            interface InputStream$$constructor extends SuppressProperties {

                new (): InputStream;

            }
            interface InputStream extends Closeable {

                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                readAllBytes(): JavaArray<number>;
                readNBytes(arg0: int): JavaArray<number>;
                readNBytes(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                skipNBytes(arg0: long): void;
                available(): number;
                close(): void;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;
                transferTo(arg0: OutputStream): number;

            }

            const IOException: JavaClassStatics<IOException, IOException$$constructor>;
            interface IOException$$constructor extends SuppressProperties {

                new (): IOException;
                new (arg0: string): IOException;
                new (arg0: string, arg1: java.lang.Throwable): IOException;
                new (arg0: java.lang.Throwable): IOException;

            }
            interface IOException extends java.lang.Exception {}

            const Closeable: JavaInterfaceStatics<Closeable>;
            interface Closeable extends java.lang.AutoCloseable {

                close(): void;

            }

            const OutputStream: JavaClassStatics<OutputStream, OutputStream$$constructor> & {

                nullOutputStream(): OutputStream;

            }
            interface OutputStream$$constructor extends SuppressProperties {

                new (): OutputStream;

            }
            interface OutputStream extends Closeable, Flushable {

                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                flush(): void;
                close(): void;

            }

            const Flushable: JavaInterfaceStatics<Flushable>;
            interface Flushable extends JavaObject {

                flush(): void;

            }

            const Externalizable: JavaInterfaceStatics<Externalizable>;
            interface Externalizable extends Serializable {

                writeExternal(arg0: ObjectOutput): void;
                readExternal(arg0: ObjectInput): void;

            }

            const Reader: JavaClassStatics<Reader> & NoConstructor & {

                nullReader(): Reader;

            }
            interface Reader extends java.lang.Readable, Closeable {

                read(arg0: java.nio.CharBuffer): number;
                read(): number;
                read(arg0: char[]): number;
                read(arg0: char[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                ready(): boolean;
                markSupported(): boolean;
                mark(arg0: int): void;
                reset(): void;
                close(): void;
                transferTo(arg0: Writer): number;

            }

            const ObjectOutput: JavaInterfaceStatics<ObjectOutput>;
            interface ObjectOutput extends DataOutput, java.lang.AutoCloseable {

                writeObject(arg0: any): void;
                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                flush(): void;
                close(): void;

            }

            const PrintStream: JavaClassStatics<PrintStream, PrintStream$$constructor>;
            interface PrintStream$$constructor extends SuppressProperties {

                new (arg0: OutputStream): PrintStream;
                new (arg0: OutputStream, arg1: boolean): PrintStream;
                new (arg0: OutputStream, arg1: boolean, arg2: string): PrintStream;
                new (arg0: OutputStream, arg1: boolean, arg2: java.nio.charset.Charset): PrintStream;
                new (arg0: string): PrintStream;
                new (arg0: string, arg1: string): PrintStream;
                new (arg0: string, arg1: java.nio.charset.Charset): PrintStream;
                new (arg0: File): PrintStream;
                new (arg0: File, arg1: string): PrintStream;
                new (arg0: File, arg1: java.nio.charset.Charset): PrintStream;

            }
            interface PrintStream extends FilterOutputStream, java.lang.Appendable, Closeable {

                flush(): void;
                close(): void;
                checkError(): boolean;
                write(arg0: int): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                write(arg0: byte[]): void;
                writeBytes(arg0: byte[]): void;
                print(arg0: boolean): void;
                print(arg0: char): void;
                print(arg0: int): void;
                print(arg0: long): void;
                print(arg0: float): void;
                print(arg0: double): void;
                print(arg0: char[]): void;
                print(arg0: string): void;
                print(arg0: any): void;
                println(): void;
                println(arg0: boolean): void;
                println(arg0: char): void;
                println(arg0: int): void;
                println(arg0: long): void;
                println(arg0: float): void;
                println(arg0: double): void;
                println(arg0: char[]): void;
                println(arg0: string): void;
                println(arg0: any): void;
                printf(arg0: string, ...arg1: any[]): PrintStream;
                printf(arg0: java.util.Locale, arg1: string, ...arg2: any[]): PrintStream;
                format(arg0: string, ...arg1: any[]): PrintStream;
                format(arg0: java.util.Locale, arg1: string, ...arg2: any[]): PrintStream;
                append(arg0: java.lang.CharSequence): PrintStream;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): PrintStream;
                append(arg0: char): PrintStream;

            }

            const ObjectInput: JavaInterfaceStatics<ObjectInput>;
            interface ObjectInput extends DataInput, java.lang.AutoCloseable {

                readObject(): any;
                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                available(): number;
                close(): void;

            }

            const PrintWriter: JavaClassStatics<PrintWriter, PrintWriter$$constructor>;
            interface PrintWriter$$constructor extends SuppressProperties {

                new (arg0: Writer): PrintWriter;
                new (arg0: Writer, arg1: boolean): PrintWriter;
                new (arg0: OutputStream): PrintWriter;
                new (arg0: OutputStream, arg1: boolean): PrintWriter;
                new (arg0: OutputStream, arg1: boolean, arg2: java.nio.charset.Charset): PrintWriter;
                new (arg0: string): PrintWriter;
                new (arg0: string, arg1: string): PrintWriter;
                new (arg0: string, arg1: java.nio.charset.Charset): PrintWriter;
                new (arg0: File): PrintWriter;
                new (arg0: File, arg1: string): PrintWriter;
                new (arg0: File, arg1: java.nio.charset.Charset): PrintWriter;

            }
            interface PrintWriter extends Writer {

                flush(): void;
                close(): void;
                checkError(): boolean;
                write(arg0: int): void;
                write(arg0: char[], arg1: int, arg2: int): void;
                write(arg0: char[]): void;
                write(arg0: string, arg1: int, arg2: int): void;
                write(arg0: string): void;
                print(arg0: boolean): void;
                print(arg0: char): void;
                print(arg0: int): void;
                print(arg0: long): void;
                print(arg0: float): void;
                print(arg0: double): void;
                print(arg0: char[]): void;
                print(arg0: string): void;
                print(arg0: any): void;
                println(): void;
                println(arg0: boolean): void;
                println(arg0: char): void;
                println(arg0: int): void;
                println(arg0: long): void;
                println(arg0: float): void;
                println(arg0: double): void;
                println(arg0: char[]): void;
                println(arg0: string): void;
                println(arg0: any): void;
                printf(arg0: string, ...arg1: any[]): PrintWriter;
                printf(arg0: java.util.Locale, arg1: string, ...arg2: any[]): PrintWriter;
                format(arg0: string, ...arg1: any[]): PrintWriter;
                format(arg0: java.util.Locale, arg1: string, ...arg2: any[]): PrintWriter;
                append(arg0: java.lang.CharSequence): PrintWriter;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): PrintWriter;
                append(arg0: char): PrintWriter;

            }

            const DataInput: JavaInterfaceStatics<DataInput>;
            interface DataInput extends JavaObject {

                readFully(arg0: byte[]): void;
                readFully(arg0: byte[], arg1: int, arg2: int): void;
                skipBytes(arg0: int): number;
                readBoolean(): boolean;
                readByte(): number;
                readUnsignedByte(): number;
                readShort(): number;
                readUnsignedShort(): number;
                readChar(): number;
                readInt(): number;
                readLong(): number;
                readFloat(): number;
                readDouble(): number;
                readLine(): string;
                readUTF(): string;

            }

            const DataOutput: JavaInterfaceStatics<DataOutput>;
            interface DataOutput extends JavaObject {

                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                writeBoolean(arg0: boolean): void;
                writeByte(arg0: int): void;
                writeShort(arg0: int): void;
                writeChar(arg0: int): void;
                writeInt(arg0: int): void;
                writeLong(arg0: long): void;
                writeFloat(arg0: float): void;
                writeDouble(arg0: double): void;
                writeBytes(arg0: string): void;
                writeChars(arg0: string): void;
                writeUTF(arg0: string): void;

            }

            const Writer: JavaClassStatics<Writer> & NoConstructor & {

                nullWriter(): Writer;

            }
            interface Writer extends java.lang.Appendable, Closeable, Flushable {

                write(arg0: int): void;
                write(arg0: char[]): void;
                write(arg0: char[], arg1: int, arg2: int): void;
                write(arg0: string): void;
                write(arg0: string, arg1: int, arg2: int): void;
                append(arg0: java.lang.CharSequence): Writer;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): Writer;
                append(arg0: char): Writer;
                flush(): void;
                close(): void;

            }

            const FilterOutputStream: JavaClassStatics<FilterOutputStream, FilterOutputStream$$constructor>;
            interface FilterOutputStream$$constructor extends SuppressProperties {

                new (arg0: OutputStream): FilterOutputStream;

            }
            interface FilterOutputStream extends OutputStream {

                write(arg0: int): void;
                write(arg0: byte[]): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                flush(): void;
                close(): void;

            }

            const DataInputStream: JavaClassStatics<DataInputStream, DataInputStream$$constructor> & {

                readUTF(arg0: DataInput): string;

            }
            interface DataInputStream$$constructor extends SuppressProperties {

                new (arg0: InputStream): DataInputStream;

            }
            interface DataInputStream extends FilterInputStream, DataInput {

                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                read(): number;
                readFully(arg0: byte[]): void;
                readFully(arg0: byte[], arg1: int, arg2: int): void;
                skipBytes(arg0: int): number;
                readBoolean(): boolean;
                readByte(): number;
                readUnsignedByte(): number;
                readShort(): number;
                readUnsignedShort(): number;
                readChar(): number;
                readInt(): number;
                readLong(): number;
                readFloat(): number;
                readDouble(): number;
                /** @deprecated */
                readLine(): string;
                readUTF(): string;

            }

            const DataOutputStream: JavaClassStatics<DataOutputStream, DataOutputStream$$constructor>;
            interface DataOutputStream$$constructor extends SuppressProperties {

                new (arg0: OutputStream): DataOutputStream;

            }
            interface DataOutputStream extends FilterOutputStream, DataOutput {

                write(arg0: int): void;
                write(arg0: byte[], arg1: int, arg2: int): void;
                write(arg0: byte[]): void;
                flush(): void;
                writeBoolean(arg0: boolean): void;
                writeByte(arg0: int): void;
                writeShort(arg0: int): void;
                writeChar(arg0: int): void;
                writeInt(arg0: int): void;
                writeLong(arg0: long): void;
                writeFloat(arg0: float): void;
                writeDouble(arg0: double): void;
                writeBytes(arg0: string): void;
                writeChars(arg0: string): void;
                writeUTF(arg0: string): void;
                size(): number;

            }

            const FilterInputStream: JavaClassStatics<FilterInputStream> & NoConstructor;
            interface FilterInputStream extends InputStream {

                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                available(): number;
                close(): void;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;

            }

            export {
                InputStream,
                IOException,
                Closeable,
                OutputStream,
                Flushable,
                Externalizable,
                Reader,
                ObjectOutput,
                PrintStream,
                ObjectInput,
                PrintWriter,
                DataInput,
                DataOutput,
                Writer,
                FilterOutputStream,
                DataInputStream,
                DataOutputStream,
                FilterInputStream
            }

        }

        namespace util {

            const Map$Entry: JavaInterfaceStatics<Map$Entry<any, any>> & {

                comparingByKey<K extends java.lang.Comparable<any>, V>(): Comparator<Map$Entry<K, V>>;
                comparingByValue<K, V extends java.lang.Comparable<any>>(): Comparator<Map$Entry<K, V>>;
                comparingByKey<K, V>(arg0: Comparator<any>): Comparator<Map$Entry<K, V>>;
                comparingByValue<K, V>(arg0: Comparator<any>): Comparator<Map$Entry<K, V>>;
                copyOf<K, V>(arg0: Map$Entry<any, any>): Map$Entry<K, V>;

            }
            interface Map$Entry<K, V> extends JavaObject {

                getKey(): K;
                getValue(): V;
                setValue(arg0: V): V;

            }

            const SplittableRandom: JavaClassStatics<SplittableRandom, SplittableRandom$$constructor>;
            interface SplittableRandom$$constructor extends SuppressProperties {

                new (arg0: long): SplittableRandom;
                new (): SplittableRandom;

            }
            interface SplittableRandom extends java.util.random.RandomGenerator, java.util.random.RandomGenerator$SplittableGenerator {

                split(): SplittableRandom;
                split(arg0: java.util.random.RandomGenerator$SplittableGenerator): SplittableRandom;
                nextInt(): number;
                nextInt(arg0: int): number;
                nextInt(arg0: int, arg1: int): number;
                nextLong(): number;
                nextLong(arg0: long): number;
                nextLong(arg0: long, arg1: long): number;
                nextBytes(arg0: byte[]): void;
                splits(): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                splits(arg0: long): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                splits(arg0: java.util.random.RandomGenerator$SplittableGenerator): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                splits(arg0: long, arg1: java.util.random.RandomGenerator$SplittableGenerator): java.util.stream.Stream<java.util.random.RandomGenerator$SplittableGenerator>;
                ints(arg0: long): java.util.stream.IntStream;
                ints(): java.util.stream.IntStream;
                ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream;
                ints(arg0: int, arg1: int): java.util.stream.IntStream;
                longs(arg0: long): java.util.stream.LongStream;
                longs(): java.util.stream.LongStream;
                longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream;
                longs(arg0: long, arg1: long): java.util.stream.LongStream;
                doubles(arg0: long): java.util.stream.DoubleStream;
                doubles(): java.util.stream.DoubleStream;
                doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream;
                doubles(arg0: double, arg1: double): java.util.stream.DoubleStream;

            }

            const UUID: JavaClassStatics<UUID, UUID$$constructor> & {

                randomUUID(): UUID;
                nameUUIDFromBytes(arg0: byte[]): UUID;
                fromString(arg0: string): UUID;

            }
            interface UUID$$constructor extends SuppressProperties {

                new (arg0: long, arg1: long): UUID;

            }
            interface UUID extends java.io.Serializable, java.lang.Comparable<UUID> {

                getLeastSignificantBits(): number;
                getMostSignificantBits(): number;
                version(): number;
                variant(): number;
                timestamp(): number;
                clockSequence(): number;
                node(): number;
                compareTo(arg0: UUID): number;

            }

            const ArrayList: JavaClassStatics<ArrayList<any>, ArrayList$$constructor>;
            interface ArrayList$$constructor extends SuppressProperties {

                new <E>(arg0: int): ArrayList<E>;
                new <E>(): ArrayList<E>;
                new <E>(arg0: JavaCollection<any>): ArrayList<E>;

            }
            interface ArrayList<E> extends AbstractList<E>, JavaList<E>, RandomAccess, java.lang.Cloneable, java.io.Serializable {

                trimToSize(): void;
                ensureCapacity(arg0: int): void;
                size(): number;
                isEmpty(): boolean;
                contains(arg0: any): boolean;
                indexOf(arg0: any): number;
                lastIndexOf(arg0: any): number;
                clone(): any;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                get(arg0: int): E;
                set(arg0: int, arg1: E): E;
                add(arg0: E): boolean;
                add(arg0: int, arg1: E): void;
                remove(arg0: int): E;
                remove(arg0: any): boolean;
                clear(): void;
                addAll(arg0: JavaCollection<any>): boolean;
                addAll(arg0: int, arg1: JavaCollection<any>): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                listIterator(arg0: int): ListIterator<E>;
                listIterator(): ListIterator<E>;
                iterator(): Iterator<E>;
                subList(arg0: int, arg1: int): JavaList<E>;
                forEach(arg0: java.util.function.Consumer<any>): void;
                spliterator(): Spliterator<E>;
                removeIf(arg0: java.util.function.Predicate<any>): boolean;
                replaceAll(arg0: java.util.function.UnaryOperator<E>): void;
                sort(arg0: Comparator<any>): void;

            }

            const HashSet: JavaClassStatics<HashSet<any>, HashSet$$constructor>;
            interface HashSet$$constructor extends SuppressProperties {

                new <E>(): HashSet<E>;
                new <E>(arg0: JavaCollection<any>): HashSet<E>;
                new <E>(arg0: int, arg1: float): HashSet<E>;
                new <E>(arg0: int): HashSet<E>;

            }
            interface HashSet<E> extends AbstractSet<E>, JavaSet<E>, java.lang.Cloneable, java.io.Serializable {

                iterator(): Iterator<E>;
                size(): number;
                isEmpty(): boolean;
                contains(arg0: any): boolean;
                add(arg0: E): boolean;
                remove(arg0: any): boolean;
                clear(): void;
                clone(): any;
                spliterator(): Spliterator<E>;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;

            }

            const Enumeration: JavaInterfaceStatics<Enumeration<any>>;
            interface Enumeration<E> extends JavaObject {

                hasMoreElements(): boolean;
                nextElement(): E;
                asIterator(): Iterator<E>;

            }

            const HashMap: JavaClassStatics<HashMap<any, any>, HashMap$$constructor>;
            interface HashMap$$constructor extends SuppressProperties {

                new <K, V>(arg0: int, arg1: float): HashMap<K, V>;
                new <K, V>(arg0: int): HashMap<K, V>;
                new <K, V>(): HashMap<K, V>;
                new <K, V>(arg0: JavaMap<any, any>): HashMap<K, V>;

            }
            interface HashMap<K, V> extends AbstractMap<K, V>, JavaMap<K, V>, java.lang.Cloneable, java.io.Serializable {

                size(): number;
                isEmpty(): boolean;
                get(arg0: any): V;
                containsKey(arg0: any): boolean;
                put(arg0: K, arg1: V): V;
                putAll(arg0: JavaMap<any, any>): void;
                remove(arg0: any): V;
                clear(): void;
                containsValue(arg0: any): boolean;
                keySet(): JavaSet<K>;
                values(): JavaCollection<V>;
                entrySet(): JavaSet<Map$Entry<K, V>>;
                getOrDefault(arg0: any, arg1: V): V;
                putIfAbsent(arg0: K, arg1: V): V;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: K, arg1: V, arg2: V): boolean;
                replace(arg0: K, arg1: V): V;
                computeIfAbsent(arg0: K, arg1: java.util.function.Function<any, any>): V;
                computeIfPresent(arg0: K, arg1: java.util.function.BiFunction<any, any, any>): V;
                compute(arg0: K, arg1: java.util.function.BiFunction<any, any, any>): V;
                merge(arg0: K, arg1: V, arg2: java.util.function.BiFunction<any, any, any>): V;
                forEach(arg0: java.util.function.BiConsumer<any, any>): void;
                replaceAll(arg0: java.util.function.BiFunction<any, any, any>): void;
                clone(): any;

            }

            const Locale: JavaClassStatics<Locale, Locale$$constructor> & {
                readonly ENGLISH: Locale;
                readonly FRENCH: Locale;
                readonly GERMAN: Locale;
                readonly ITALIAN: Locale;
                readonly JAPANESE: Locale;
                readonly KOREAN: Locale;
                readonly CHINESE: Locale;
                readonly SIMPLIFIED_CHINESE: Locale;
                readonly TRADITIONAL_CHINESE: Locale;
                readonly FRANCE: Locale;
                readonly GERMANY: Locale;
                readonly ITALY: Locale;
                readonly JAPAN: Locale;
                readonly KOREA: Locale;
                readonly UK: Locale;
                readonly US: Locale;
                readonly CANADA: Locale;
                readonly CANADA_FRENCH: Locale;
                readonly ROOT: Locale;
                readonly CHINA: Locale;
                readonly PRC: Locale;
                readonly TAIWAN: Locale;
                readonly PRIVATE_USE_EXTENSION: number;
                readonly UNICODE_LOCALE_EXTENSION: number;

                getDefault(): Locale;
                getDefault(arg0: Locale$Category): Locale;
                setDefault(arg0: Locale): void;
                setDefault(arg0: Locale$Category, arg1: Locale): void;
                getAvailableLocales(): JavaArray<Locale>;
                getISOCountries(): JavaArray<string>;
                getISOCountries(arg0: Locale$IsoCountryCode): JavaSet<string>;
                getISOLanguages(): JavaArray<string>;
                forLanguageTag(arg0: string): Locale;
                filter(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<Locale>, arg2: Locale$FilteringMode): JavaList<Locale>;
                filter(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<Locale>): JavaList<Locale>;
                filterTags(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<string>, arg2: Locale$FilteringMode): JavaList<string>;
                filterTags(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<string>): JavaList<string>;
                lookup(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<Locale>): Locale;
                lookupTag(arg0: JavaList<Locale$LanguageRange>, arg1: JavaCollection<string>): string;

            }
            interface Locale$$constructor extends SuppressProperties {

                new (arg0: string, arg1: string, arg2: string): Locale;
                new (arg0: string, arg1: string): Locale;
                new (arg0: string): Locale;

            }
            interface Locale extends java.lang.Cloneable, java.io.Serializable {

                getLanguage(): string;
                getScript(): string;
                getCountry(): string;
                getVariant(): string;
                hasExtensions(): boolean;
                stripExtensions(): Locale;
                getExtension(arg0: char): string;
                getExtensionKeys(): JavaSet<number>;
                getUnicodeLocaleAttributes(): JavaSet<string>;
                getUnicodeLocaleType(arg0: string): string;
                getUnicodeLocaleKeys(): JavaSet<string>;
                toLanguageTag(): string;
                getISO3Language(): string;
                getISO3Country(): string;
                getDisplayLanguage(): string;
                getDisplayLanguage(arg0: Locale): string;
                getDisplayScript(): string;
                getDisplayScript(arg0: Locale): string;
                getDisplayCountry(): string;
                getDisplayCountry(arg0: Locale): string;
                getDisplayVariant(): string;
                getDisplayVariant(arg0: Locale): string;
                getDisplayName(): string;
                getDisplayName(arg0: Locale): string;
                clone(): any;

            }

            const BitSet: JavaClassStatics<BitSet, BitSet$$constructor> & {

                valueOf(arg0: long[]): BitSet;
                valueOf(arg0: java.nio.LongBuffer): BitSet;
                valueOf(arg0: byte[]): BitSet;
                valueOf(arg0: java.nio.ByteBuffer): BitSet;

            }
            interface BitSet$$constructor extends SuppressProperties {

                new (): BitSet;
                new (arg0: int): BitSet;

            }
            interface BitSet extends java.lang.Cloneable, java.io.Serializable {

                toByteArray(): JavaArray<number>;
                toLongArray(): JavaArray<number>;
                flip(arg0: int): void;
                flip(arg0: int, arg1: int): void;
                set(arg0: int): void;
                set(arg0: int, arg1: boolean): void;
                set(arg0: int, arg1: int): void;
                set(arg0: int, arg1: int, arg2: boolean): void;
                clear(arg0: int): void;
                clear(arg0: int, arg1: int): void;
                clear(): void;
                get(arg0: int): boolean;
                get(arg0: int, arg1: int): BitSet;
                nextSetBit(arg0: int): number;
                nextClearBit(arg0: int): number;
                previousSetBit(arg0: int): number;
                previousClearBit(arg0: int): number;
                length(): number;
                isEmpty(): boolean;
                intersects(arg0: BitSet): boolean;
                cardinality(): number;
                and(arg0: BitSet): void;
                or(arg0: BitSet): void;
                xor(arg0: BitSet): void;
                andNot(arg0: BitSet): void;
                size(): number;
                clone(): any;
                stream(): java.util.stream.IntStream;

            }

            const Comparator: JavaInterfaceStatics<Comparator<any>> & {

                reverseOrder<T extends java.lang.Comparable<any>>(): Comparator<T>;
                naturalOrder<T extends java.lang.Comparable<any>>(): Comparator<T>;
                nullsFirst<T>(arg0: Comparator<any>): Comparator<T>;
                nullsLast<T>(arg0: Comparator<any>): Comparator<T>;
                comparing<T, U>(arg0: java.util.function.Function<any, any>, arg1: Comparator<any>): Comparator<T>;
                comparing<T, U extends java.lang.Comparable<any>>(arg0: java.util.function.Function<any, any>): Comparator<T>;
                comparingInt<T>(arg0: java.util.function.ToIntFunction<any>): Comparator<T>;
                comparingLong<T>(arg0: java.util.function.ToLongFunction<any>): Comparator<T>;
                comparingDouble<T>(arg0: java.util.function.ToDoubleFunction<any>): Comparator<T>;

            }
            interface Comparator<T> extends JavaObject {

                compare(arg0: T, arg1: T): number;
                reversed(): Comparator<T>;
                thenComparing(arg0: Comparator<any>): Comparator<T>;
                thenComparing<U>(arg0: java.util.function.Function<any, any>, arg1: Comparator<any>): Comparator<T>;
                thenComparing<U extends java.lang.Comparable<any>>(arg0: java.util.function.Function<any, any>): Comparator<T>;
                thenComparingInt(arg0: java.util.function.ToIntFunction<any>): Comparator<T>;
                thenComparingLong(arg0: java.util.function.ToLongFunction<any>): Comparator<T>;
                thenComparingDouble(arg0: java.util.function.ToDoubleFunction<any>): Comparator<T>;

            }

            const Iterator: JavaInterfaceStatics<Iterator<any>>;
            interface Iterator<E> extends JavaObject {

                hasNext(): boolean;
                next(): E;
                remove(): void;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const Date: JavaClassStatics<Date, Date$$constructor> & {

                /** @deprecated */
                UTC(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): number;
                /** @deprecated */
                parse(arg0: string): number;
                from(arg0: java.time.Instant): Date;

            }
            interface Date$$constructor extends SuppressProperties {

                new (): Date;
                new (arg0: long): Date;
                /** @deprecated */
                new (arg0: int, arg1: int, arg2: int): Date;
                /** @deprecated */
                new (arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): Date;
                /** @deprecated */
                new (arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): Date;
                /** @deprecated */
                new (arg0: string): Date;

            }
            interface Date extends java.io.Serializable, java.lang.Cloneable, java.lang.Comparable<Date> {

                clone(): any;
                /** @deprecated */
                getYear(): number;
                /** @deprecated */
                setYear(arg0: int): void;
                /** @deprecated */
                getMonth(): number;
                /** @deprecated */
                setMonth(arg0: int): void;
                /** @deprecated */
                getDate(): number;
                /** @deprecated */
                setDate(arg0: int): void;
                /** @deprecated */
                getDay(): number;
                /** @deprecated */
                getHours(): number;
                /** @deprecated */
                setHours(arg0: int): void;
                /** @deprecated */
                getMinutes(): number;
                /** @deprecated */
                setMinutes(arg0: int): void;
                /** @deprecated */
                getSeconds(): number;
                /** @deprecated */
                setSeconds(arg0: int): void;
                getTime(): number;
                setTime(arg0: long): void;
                before(arg0: Date): boolean;
                after(arg0: Date): boolean;
                compareTo(arg0: Date): number;
                /** @deprecated */
                toLocaleString(): string;
                /** @deprecated */
                toGMTString(): string;
                /** @deprecated */
                getTimezoneOffset(): number;
                toInstant(): java.time.Instant;

            }

            const Optional: JavaClassStatics<Optional<any>> & NoConstructor & {

                empty<T>(): Optional<T>;
                of<T>(arg0: T): Optional<T>;
                ofNullable<T>(arg0: T): Optional<T>;

            }
            interface Optional<T> extends JavaObject {

                get(): T;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.Consumer<any>): void;
                ifPresentOrElse(arg0: java.util.function.Consumer<any>, arg1: java.lang.Runnable): void;
                filter(arg0: java.util.function.Predicate<any>): Optional<T>;
                map<U>(arg0: java.util.function.Function<any, any>): Optional<U>;
                flatMap<U>(arg0: java.util.function.Function<any, any>): Optional<U>;
                or(arg0: java.util.function.Supplier<any>): Optional<T>;
                stream(): java.util.stream.Stream<T>;
                orElse(arg0: T): T;
                orElseGet(arg0: java.util.function.Supplier<any>): T;
                orElseThrow(): T;
                orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function.Supplier<any>): T;

            }

            const Spliterator$OfLong: JavaInterfaceStatics<Spliterator$OfLong>;
            interface Spliterator$OfLong extends Spliterator$OfPrimitive<number, java.util.function.LongConsumer, Spliterator$OfLong> {

                trySplit(): Spliterator$OfLong;
                tryAdvance(arg0: java.util.function.LongConsumer): boolean;
                forEachRemaining(arg0: java.util.function.LongConsumer): void;
                tryAdvance(arg0: java.util.function.Consumer<any>): boolean;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const AbstractMap: JavaClassStatics<AbstractMap<any, any>> & NoConstructor;
            interface AbstractMap<K, V> extends JavaMap<K, V> {

                size(): number;
                isEmpty(): boolean;
                containsValue(arg0: any): boolean;
                containsKey(arg0: any): boolean;
                get(arg0: any): V;
                put(arg0: K, arg1: V): V;
                remove(arg0: any): V;
                remove(arg0: any, arg1: any): boolean;
                putAll(arg0: JavaMap<any, any>): void;
                clear(): void;
                keySet(): JavaSet<K>;
                values(): JavaCollection<V>;
                entrySet(): JavaSet<Map$Entry<K, V>>;

            }

            const PrimitiveIterator$OfInt: JavaInterfaceStatics<PrimitiveIterator$OfInt>;
            interface PrimitiveIterator$OfInt extends PrimitiveIterator<number, java.util.function.IntConsumer> {

                nextInt(): number;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                next(): number;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const AbstractCollection: JavaClassStatics<AbstractCollection<any>> & NoConstructor;
            interface AbstractCollection<E> extends JavaCollection<E> {

                iterator(): Iterator<E>;
                size(): number;
                isEmpty(): boolean;
                contains(arg0: any): boolean;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                add(arg0: E): boolean;
                remove(arg0: any): boolean;
                containsAll(arg0: JavaCollection<any>): boolean;
                addAll(arg0: JavaCollection<any>): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                clear(): void;

            }

            const Spliterator: JavaInterfaceStatics<Spliterator<any>> & {
                readonly ORDERED: number;
                readonly DISTINCT: number;
                readonly SORTED: number;
                readonly SIZED: number;
                readonly NONNULL: number;
                readonly IMMUTABLE: number;
                readonly CONCURRENT: number;
                readonly SUBSIZED: number;
            }
            interface Spliterator<T> extends JavaObject {

                tryAdvance(arg0: java.util.function.Consumer<any>): boolean;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;
                trySplit(): Spliterator<T>;
                estimateSize(): number;
                getExactSizeIfKnown(): number;
                characteristics(): number;
                hasCharacteristics(arg0: int): boolean;
                getComparator(): Comparator<any>;

            }

            const PrimitiveIterator$OfLong: JavaInterfaceStatics<PrimitiveIterator$OfLong>;
            interface PrimitiveIterator$OfLong extends PrimitiveIterator<number, java.util.function.LongConsumer> {

                nextLong(): number;
                forEachRemaining(arg0: java.util.function.LongConsumer): void;
                next(): number;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const AbstractList: JavaClassStatics<AbstractList<any>> & NoConstructor;
            interface AbstractList<E> extends AbstractCollection<E>, JavaList<E> {

                add(arg0: E): boolean;
                get(arg0: int): E;
                set(arg0: int, arg1: E): E;
                add(arg0: int, arg1: E): void;
                remove(arg0: int): E;
                remove(arg0: any): boolean;
                indexOf(arg0: any): number;
                lastIndexOf(arg0: any): number;
                clear(): void;
                addAll(arg0: int, arg1: JavaCollection<any>): boolean;
                addAll(arg0: JavaCollection<any>): boolean;
                iterator(): Iterator<E>;
                listIterator(): ListIterator<E>;
                listIterator(arg0: int): ListIterator<E>;
                subList(arg0: int, arg1: int): JavaList<E>;

            }

            const OptionalDouble: JavaClassStatics<OptionalDouble> & NoConstructor & {

                empty(): OptionalDouble;
                of(arg0: double): OptionalDouble;

            }
            interface OptionalDouble extends JavaObject {

                getAsDouble(): number;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.DoubleConsumer): void;
                ifPresentOrElse(arg0: java.util.function.DoubleConsumer, arg1: java.lang.Runnable): void;
                stream(): java.util.stream.DoubleStream;
                orElse(arg0: double): number;
                orElseGet(arg0: java.util.function.DoubleSupplier): number;
                orElseThrow(): number;
                orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function.Supplier<any>): number;

            }

            const PrimitiveIterator$OfDouble: JavaInterfaceStatics<PrimitiveIterator$OfDouble>;
            interface PrimitiveIterator$OfDouble extends PrimitiveIterator<number, java.util.function.DoubleConsumer> {

                nextDouble(): number;
                forEachRemaining(arg0: java.util.function.DoubleConsumer): void;
                next(): number;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const ListIterator: JavaInterfaceStatics<ListIterator<any>>;
            interface ListIterator<E> extends Iterator<E> {

                hasNext(): boolean;
                next(): E;
                hasPrevious(): boolean;
                previous(): E;
                nextIndex(): number;
                previousIndex(): number;
                remove(): void;
                set(arg0: E): void;
                add(arg0: E): void;

            }

            const OptionalInt: JavaClassStatics<OptionalInt> & NoConstructor & {

                empty(): OptionalInt;
                of(arg0: int): OptionalInt;

            }
            interface OptionalInt extends JavaObject {

                getAsInt(): number;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.IntConsumer): void;
                ifPresentOrElse(arg0: java.util.function.IntConsumer, arg1: java.lang.Runnable): void;
                stream(): java.util.stream.IntStream;
                orElse(arg0: int): number;
                orElseGet(arg0: java.util.function.IntSupplier): number;
                orElseThrow(): number;
                orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function.Supplier<any>): number;

            }

            const RandomAccess: JavaInterfaceStatics<RandomAccess>;
            interface RandomAccess extends JavaObject {}

            const AbstractSet: JavaClassStatics<AbstractSet<any>> & NoConstructor;
            interface AbstractSet<E> extends AbstractCollection<E>, JavaSet<E> {

                removeAll(arg0: JavaCollection<any>): boolean;

            }

            const IntSummaryStatistics: JavaClassStatics<IntSummaryStatistics, IntSummaryStatistics$$constructor>;
            interface IntSummaryStatistics$$constructor extends SuppressProperties {

                new (): IntSummaryStatistics;
                new (arg0: long, arg1: int, arg2: int, arg3: long): IntSummaryStatistics;

            }
            interface IntSummaryStatistics extends java.util.function.IntConsumer {

                accept(arg0: int): void;
                combine(arg0: IntSummaryStatistics): void;
                getCount(): number;
                getSum(): number;
                getMin(): number;
                getMax(): number;
                getAverage(): number;

            }

            const Locale$LanguageRange: JavaClassStatics<Locale$LanguageRange, Locale$LanguageRange$$constructor> & {
                readonly MAX_WEIGHT: number;
                readonly MIN_WEIGHT: number;

                parse(arg0: string): JavaList<Locale$LanguageRange>;
                parse(arg0: string, arg1: JavaMap<string, JavaList<string>>): JavaList<Locale$LanguageRange>;
                mapEquivalents(arg0: JavaList<Locale$LanguageRange>, arg1: JavaMap<string, JavaList<string>>): JavaList<Locale$LanguageRange>;

            }
            interface Locale$LanguageRange$$constructor extends SuppressProperties {

                new (arg0: string): Locale$LanguageRange;
                new (arg0: string, arg1: double): Locale$LanguageRange;

            }
            interface Locale$LanguageRange extends JavaObject {

                getRange(): string;
                getWeight(): number;

            }

            const Locale$Category: JavaClassStatics<Locale$Category> & NoConstructor & {
                readonly DISPLAY: Locale$Category;
                readonly FORMAT: Locale$Category;

                values(): JavaArray<Locale$Category>;
                valueOf(arg0: string): Locale$Category;

            }
            interface Locale$Category extends java.lang.Enum<Locale$Category> {}

            const OptionalLong: JavaClassStatics<OptionalLong> & NoConstructor & {

                empty(): OptionalLong;
                of(arg0: long): OptionalLong;

            }
            interface OptionalLong extends JavaObject {

                getAsLong(): number;
                isPresent(): boolean;
                isEmpty(): boolean;
                ifPresent(arg0: java.util.function.LongConsumer): void;
                ifPresentOrElse(arg0: java.util.function.LongConsumer, arg1: java.lang.Runnable): void;
                stream(): java.util.stream.LongStream;
                orElse(arg0: long): number;
                orElseGet(arg0: java.util.function.LongSupplier): number;
                orElseThrow(): number;
                orElseThrow<X extends java.lang.Throwable>(arg0: java.util.function.Supplier<any>): number;

            }

            const Locale$IsoCountryCode: JavaClassStatics<Locale$IsoCountryCode> & NoConstructor & {
                readonly PART1_ALPHA2: Locale$IsoCountryCode;
                readonly PART1_ALPHA3: Locale$IsoCountryCode;
                readonly PART3: Locale$IsoCountryCode;

                values(): JavaArray<Locale$IsoCountryCode>;
                valueOf(arg0: string): Locale$IsoCountryCode;

            }
            interface Locale$IsoCountryCode extends java.lang.Enum<Locale$IsoCountryCode> {}

            const Locale$FilteringMode: JavaClassStatics<Locale$FilteringMode> & NoConstructor & {
                readonly AUTOSELECT_FILTERING: Locale$FilteringMode;
                readonly EXTENDED_FILTERING: Locale$FilteringMode;
                readonly IGNORE_EXTENDED_RANGES: Locale$FilteringMode;
                readonly MAP_EXTENDED_RANGES: Locale$FilteringMode;
                readonly REJECT_EXTENDED_RANGES: Locale$FilteringMode;

                values(): JavaArray<Locale$FilteringMode>;
                valueOf(arg0: string): Locale$FilteringMode;

            }
            interface Locale$FilteringMode extends java.lang.Enum<Locale$FilteringMode> {}

            const DoubleSummaryStatistics: JavaClassStatics<DoubleSummaryStatistics, DoubleSummaryStatistics$$constructor>;
            interface DoubleSummaryStatistics$$constructor extends SuppressProperties {

                new (): DoubleSummaryStatistics;
                new (arg0: long, arg1: double, arg2: double, arg3: double): DoubleSummaryStatistics;

            }
            interface DoubleSummaryStatistics extends java.util.function.DoubleConsumer {

                accept(arg0: double): void;
                combine(arg0: DoubleSummaryStatistics): void;
                getCount(): number;
                getSum(): number;
                getMin(): number;
                getMax(): number;
                getAverage(): number;

            }

            const Spliterator$OfDouble: JavaInterfaceStatics<Spliterator$OfDouble>;
            interface Spliterator$OfDouble extends Spliterator$OfPrimitive<number, java.util.function.DoubleConsumer, Spliterator$OfDouble> {

                trySplit(): Spliterator$OfDouble;
                tryAdvance(arg0: java.util.function.DoubleConsumer): boolean;
                forEachRemaining(arg0: java.util.function.DoubleConsumer): void;
                tryAdvance(arg0: java.util.function.Consumer<any>): boolean;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const Spliterator$OfInt: JavaInterfaceStatics<Spliterator$OfInt>;
            interface Spliterator$OfInt extends Spliterator$OfPrimitive<number, java.util.function.IntConsumer, Spliterator$OfInt> {

                trySplit(): Spliterator$OfInt;
                tryAdvance(arg0: java.util.function.IntConsumer): boolean;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                tryAdvance(arg0: java.util.function.Consumer<any>): boolean;
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;

            }

            const LongSummaryStatistics: JavaClassStatics<LongSummaryStatistics, LongSummaryStatistics$$constructor>;
            interface LongSummaryStatistics$$constructor extends SuppressProperties {

                new (): LongSummaryStatistics;
                new (arg0: long, arg1: long, arg2: long, arg3: long): LongSummaryStatistics;

            }
            interface LongSummaryStatistics extends java.util.function.LongConsumer, java.util.function.IntConsumer {

                accept(arg0: int): void;
                accept(arg0: long): void;
                combine(arg0: LongSummaryStatistics): void;
                getCount(): number;
                getSum(): number;
                getMin(): number;
                getMax(): number;
                getAverage(): number;

            }

            const PrimitiveIterator: JavaInterfaceStatics<PrimitiveIterator<any, any>>;
            interface PrimitiveIterator<T, T_CONS> extends Iterator<T> {

                forEachRemaining(arg0: T_CONS): void;

            }

            const Spliterator$OfPrimitive: JavaInterfaceStatics<Spliterator$OfPrimitive<any, any, any>>;
            interface Spliterator$OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator$OfPrimitive<T, T_CONS, T_SPLITR>> extends Spliterator<T> {

                trySplit(): T_SPLITR;
                tryAdvance(arg0: T_CONS): boolean;
                tryAdvance(arg0: java.util.function.Consumer<any>): boolean;
                forEachRemaining(arg0: T_CONS): void;

            }

            const EventListener: JavaInterfaceStatics<EventListener>;
            interface EventListener extends JavaObject {}

            const ResourceBundle: JavaClassStatics<ResourceBundle, ResourceBundle$$constructor> & {

                getBundle(arg0: string): ResourceBundle;
                getBundle(arg0: string, arg1: ResourceBundle$Control): ResourceBundle;
                getBundle(arg0: string, arg1: Locale): ResourceBundle;
                getBundle(arg0: string, arg1: java.lang.Module): ResourceBundle;
                getBundle(arg0: string, arg1: Locale, arg2: java.lang.Module): ResourceBundle;
                getBundle(arg0: string, arg1: Locale, arg2: ResourceBundle$Control): ResourceBundle;
                getBundle(arg0: string, arg1: Locale, arg2: java.lang.ClassLoader): ResourceBundle;
                getBundle(arg0: string, arg1: Locale, arg2: java.lang.ClassLoader, arg3: ResourceBundle$Control): ResourceBundle;
                clearCache(): void;
                clearCache(arg0: java.lang.ClassLoader): void;

            }
            interface ResourceBundle$$constructor extends SuppressProperties {

                new (): ResourceBundle;

            }
            interface ResourceBundle extends JavaObject {

                getBaseBundleName(): string;
                getString(arg0: string): string;
                getStringArray(arg0: string): JavaArray<string>;
                getObject(arg0: string): any;
                getLocale(): Locale;
                getKeys(): Enumeration<string>;
                containsKey(arg0: string): boolean;
                keySet(): JavaSet<string>;

            }

            const Vector: JavaClassStatics<Vector<any>, Vector$$constructor>;
            interface Vector$$constructor extends SuppressProperties {

                new <E>(arg0: int, arg1: int): Vector<E>;
                new <E>(arg0: int): Vector<E>;
                new <E>(): Vector<E>;
                new <E>(arg0: JavaCollection<any>): Vector<E>;

            }
            interface Vector<E> extends AbstractList<E>, JavaList<E>, RandomAccess, java.lang.Cloneable, java.io.Serializable {

                copyInto(arg0: any[]): void;
                trimToSize(): void;
                ensureCapacity(arg0: int): void;
                setSize(arg0: int): void;
                capacity(): number;
                size(): number;
                isEmpty(): boolean;
                elements(): Enumeration<E>;
                contains(arg0: any): boolean;
                indexOf(arg0: any): number;
                indexOf(arg0: any, arg1: int): number;
                lastIndexOf(arg0: any): number;
                lastIndexOf(arg0: any, arg1: int): number;
                elementAt(arg0: int): E;
                firstElement(): E;
                lastElement(): E;
                setElementAt(arg0: E, arg1: int): void;
                removeElementAt(arg0: int): void;
                insertElementAt(arg0: E, arg1: int): void;
                addElement(arg0: E): void;
                removeElement(arg0: any): boolean;
                removeAllElements(): void;
                clone(): any;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                get(arg0: int): E;
                set(arg0: int, arg1: E): E;
                add(arg0: E): boolean;
                remove(arg0: any): boolean;
                add(arg0: int, arg1: E): void;
                remove(arg0: int): E;
                clear(): void;
                containsAll(arg0: JavaCollection<any>): boolean;
                addAll(arg0: JavaCollection<any>): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                removeIf(arg0: java.util.function.Predicate<any>): boolean;
                addAll(arg0: int, arg1: JavaCollection<any>): boolean;
                subList(arg0: int, arg1: int): JavaList<E>;
                listIterator(arg0: int): ListIterator<E>;
                listIterator(): ListIterator<E>;
                iterator(): Iterator<E>;
                forEach(arg0: java.util.function.Consumer<any>): void;
                replaceAll(arg0: java.util.function.UnaryOperator<E>): void;
                sort(arg0: Comparator<any>): void;
                spliterator(): Spliterator<E>;

            }

            const EventObject: JavaClassStatics<EventObject, EventObject$$constructor>;
            interface EventObject$$constructor extends SuppressProperties {

                new (arg0: any): EventObject;

            }
            interface EventObject extends java.io.Serializable {

                getSource(): any;

            }

            const SortedMap: JavaInterfaceStatics<SortedMap<any, any>>;
            interface SortedMap<K, V> extends JavaMap<K, V> {

                comparator(): Comparator<any>;
                subMap(arg0: K, arg1: K): SortedMap<K, V>;
                headMap(arg0: K): SortedMap<K, V>;
                tailMap(arg0: K): SortedMap<K, V>;
                firstKey(): K;
                lastKey(): K;
                keySet(): JavaSet<K>;
                values(): JavaCollection<V>;
                entrySet(): JavaSet<Map$Entry<K, V>>;

            }

            const Hashtable: JavaClassStatics<Hashtable<any, any>, Hashtable$$constructor>;
            interface Hashtable$$constructor extends SuppressProperties {

                new <K, V>(arg0: int, arg1: float): Hashtable<K, V>;
                new <K, V>(arg0: int): Hashtable<K, V>;
                new <K, V>(): Hashtable<K, V>;
                new <K, V>(arg0: JavaMap<any, any>): Hashtable<K, V>;

            }
            interface Hashtable<K, V> extends Dictionary<K, V>, JavaMap<K, V>, java.lang.Cloneable, java.io.Serializable {

                size(): number;
                isEmpty(): boolean;
                keys(): Enumeration<K>;
                elements(): Enumeration<V>;
                contains(arg0: any): boolean;
                containsValue(arg0: any): boolean;
                containsKey(arg0: any): boolean;
                get(arg0: any): V;
                put(arg0: K, arg1: V): V;
                remove(arg0: any): V;
                putAll(arg0: JavaMap<any, any>): void;
                clear(): void;
                clone(): any;
                keySet(): JavaSet<K>;
                entrySet(): JavaSet<Map$Entry<K, V>>;
                values(): JavaCollection<V>;
                getOrDefault(arg0: any, arg1: V): V;
                forEach(arg0: java.util.function.BiConsumer<any, any>): void;
                replaceAll(arg0: java.util.function.BiFunction<any, any, any>): void;
                putIfAbsent(arg0: K, arg1: V): V;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: K, arg1: V, arg2: V): boolean;
                replace(arg0: K, arg1: V): V;
                computeIfAbsent(arg0: K, arg1: java.util.function.Function<any, any>): V;
                computeIfPresent(arg0: K, arg1: java.util.function.BiFunction<any, any, any>): V;
                compute(arg0: K, arg1: java.util.function.BiFunction<any, any, any>): V;
                merge(arg0: K, arg1: V, arg2: java.util.function.BiFunction<any, any, any>): V;

            }

            const Properties: JavaClassStatics<Properties, Properties$$constructor>;
            interface Properties$$constructor extends SuppressProperties {

                new (): Properties;
                new (arg0: int): Properties;
                new (arg0: Properties): Properties;

            }
            interface Properties extends Hashtable<any, any> {

                setProperty(arg0: string, arg1: string): any;
                load(arg0: java.io.Reader): void;
                load(arg0: java.io.InputStream): void;
                /** @deprecated */
                save(arg0: java.io.OutputStream, arg1: string): void;
                store(arg0: java.io.Writer, arg1: string): void;
                store(arg0: java.io.OutputStream, arg1: string): void;
                loadFromXML(arg0: java.io.InputStream): void;
                storeToXML(arg0: java.io.OutputStream, arg1: string): void;
                storeToXML(arg0: java.io.OutputStream, arg1: string, arg2: string): void;
                storeToXML(arg0: java.io.OutputStream, arg1: string, arg2: java.nio.charset.Charset): void;
                getProperty(arg0: string): string;
                getProperty(arg0: string, arg1: string): string;
                propertyNames(): Enumeration<any>;
                stringPropertyNames(): JavaSet<string>;
                list(arg0: java.io.PrintStream): void;
                list(arg0: java.io.PrintWriter): void;
                size(): number;
                isEmpty(): boolean;
                keys(): Enumeration<any>;
                elements(): Enumeration<any>;
                contains(arg0: any): boolean;
                containsValue(arg0: any): boolean;
                containsKey(arg0: any): boolean;
                get(arg0: any): any;
                put(arg0: any, arg1: any): any;
                remove(arg0: any): any;
                putAll(arg0: JavaMap<any, any>): void;
                clear(): void;
                keySet(): JavaSet<any>;
                values(): JavaCollection<any>;
                entrySet(): JavaSet<Map$Entry<any, any>>;
                getOrDefault(arg0: any, arg1: any): any;
                forEach(arg0: java.util.function.BiConsumer<any, any>): void;
                replaceAll(arg0: java.util.function.BiFunction<any, any, any>): void;
                putIfAbsent(arg0: any, arg1: any): any;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: any, arg1: any, arg2: any): boolean;
                replace(arg0: any, arg1: any): any;
                computeIfAbsent(arg0: any, arg1: java.util.function.Function<any, any>): any;
                computeIfPresent(arg0: any, arg1: java.util.function.BiFunction<any, any, any>): any;
                compute(arg0: any, arg1: java.util.function.BiFunction<any, any, any>): any;
                merge(arg0: any, arg1: any, arg2: java.util.function.BiFunction<any, any, any>): any;
                clone(): any;

            }

            const Dictionary: JavaClassStatics<Dictionary<any, any>, Dictionary$$constructor>;
            interface Dictionary$$constructor extends SuppressProperties {

                new <K, V>(): Dictionary<K, V>;

            }
            interface Dictionary<K, V> extends JavaObject {

                size(): number;
                isEmpty(): boolean;
                keys(): Enumeration<K>;
                elements(): Enumeration<V>;
                get(arg0: any): V;
                put(arg0: K, arg1: V): V;
                remove(arg0: any): V;

            }

            const ResourceBundle$Control: JavaClassStatics<ResourceBundle$Control> & NoConstructor & {
                readonly FORMAT_DEFAULT: JavaList<string>;
                readonly FORMAT_CLASS: JavaList<string>;
                readonly FORMAT_PROPERTIES: JavaList<string>;
                readonly TTL_DONT_CACHE: number;
                readonly TTL_NO_EXPIRATION_CONTROL: number;

                getControl(arg0: JavaList<string>): ResourceBundle$Control;
                getNoFallbackControl(arg0: JavaList<string>): ResourceBundle$Control;

            }
            interface ResourceBundle$Control extends JavaObject {

                getFormats(arg0: string): JavaList<string>;
                getCandidateLocales(arg0: string, arg1: Locale): JavaList<Locale>;
                getFallbackLocale(arg0: string, arg1: Locale): Locale;
                newBundle(arg0: string, arg1: Locale, arg2: string, arg3: java.lang.ClassLoader, arg4: boolean): ResourceBundle;
                getTimeToLive(arg0: string, arg1: Locale): number;
                needsReload(arg0: string, arg1: Locale, arg2: string, arg3: java.lang.ClassLoader, arg4: ResourceBundle, arg5: long): boolean;
                toBundleName(arg0: string, arg1: Locale): string;
                toResourceName(arg0: string, arg1: string): string;

            }

            const Random: JavaClassStatics<Random, Random$$constructor>;
            interface Random$$constructor extends SuppressProperties {

                new (): Random;
                new (arg0: long): Random;

            }
            interface Random extends java.util.random.RandomGenerator, java.io.Serializable {

                setSeed(arg0: long): void;
                nextBytes(arg0: byte[]): void;
                nextInt(): number;
                nextInt(arg0: int): number;
                nextInt(arg0: int, arg1: int): number;
                nextLong(): number;
                nextLong(arg0: long): number;
                nextLong(arg0: long, arg1: long): number;
                nextBoolean(): boolean;
                nextFloat(): number;
                nextFloat(arg0: float): number;
                nextFloat(arg0: float, arg1: float): number;
                nextDouble(): number;
                nextDouble(arg0: double): number;
                nextDouble(arg0: double, arg1: double): number;
                nextGaussian(): number;
                nextGaussian(arg0: double, arg1: double): number;
                ints(arg0: long): java.util.stream.IntStream;
                ints(): java.util.stream.IntStream;
                ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream;
                ints(arg0: int, arg1: int): java.util.stream.IntStream;
                longs(arg0: long): java.util.stream.LongStream;
                longs(): java.util.stream.LongStream;
                longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream;
                longs(arg0: long, arg1: long): java.util.stream.LongStream;
                doubles(arg0: long): java.util.stream.DoubleStream;
                doubles(): java.util.stream.DoubleStream;
                doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream;
                doubles(arg0: double, arg1: double): java.util.stream.DoubleStream;

            }

            const Currency: JavaClassStatics<Currency> & NoConstructor & {

                getInstance(arg0: string): Currency;
                getInstance(arg0: Locale): Currency;
                getAvailableCurrencies(): JavaSet<Currency>;

            }
            interface Currency extends java.io.Serializable {

                getCurrencyCode(): string;
                getSymbol(): string;
                getSymbol(arg0: Locale): string;
                getDefaultFractionDigits(): number;
                getNumericCode(): number;
                getNumericCodeAsString(): string;
                getDisplayName(): string;
                getDisplayName(arg0: Locale): string;

            }

            namespace _function {

                const BiFunction: JavaInterfaceStatics<BiFunction<any, any, any>>;
                interface BiFunction<T, U, R> extends JavaObject {

                    apply(arg0: T, arg1: U): R;
                    andThen<V>(arg0: Function<any, any>): BiFunction<T, U, V>;

                }

                const ToDoubleFunction: JavaInterfaceStatics<ToDoubleFunction<any>>;
                interface ToDoubleFunction<T> extends JavaObject {

                    applyAsDouble(arg0: T): number;

                }

                const Predicate: JavaInterfaceStatics<Predicate<any>> & {

                    isEqual<T>(arg0: any): Predicate<T>;
                    not<T>(arg0: Predicate<any>): Predicate<T>;

                }
                interface Predicate<T> extends JavaObject {

                    test(arg0: T): boolean;
                    and(arg0: Predicate<any>): Predicate<T>;
                    negate(): Predicate<T>;
                    or(arg0: Predicate<any>): Predicate<T>;

                }

                const BiPredicate: JavaInterfaceStatics<BiPredicate<any, any>>;
                interface BiPredicate<T, U> extends JavaObject {

                    test(arg0: T, arg1: U): boolean;
                    and(arg0: BiPredicate<any, any>): BiPredicate<T, U>;
                    negate(): BiPredicate<T, U>;
                    or(arg0: BiPredicate<any, any>): BiPredicate<T, U>;

                }

                const UnaryOperator: JavaInterfaceStatics<UnaryOperator<any>> & {

                    identity<T>(): UnaryOperator<T>;

                }
                interface UnaryOperator<T> extends Function<T, T> {}

                const ToIntFunction: JavaInterfaceStatics<ToIntFunction<any>>;
                interface ToIntFunction<T> extends JavaObject {

                    applyAsInt(arg0: T): number;

                }

                const IntFunction: JavaInterfaceStatics<IntFunction<any>>;
                interface IntFunction<R> extends JavaObject {

                    apply(arg0: int): R;

                }

                const Supplier: JavaInterfaceStatics<Supplier<any>>;
                interface Supplier<T> extends JavaObject {

                    get(): T;

                }

                const BiConsumer: JavaInterfaceStatics<BiConsumer<any, any>>;
                interface BiConsumer<T, U> extends JavaObject {

                    accept(arg0: T, arg1: U): void;
                    andThen(arg0: BiConsumer<any, any>): BiConsumer<T, U>;

                }

                const Function: JavaInterfaceStatics<Function<any, any>> & {

                    identity<T>(): Function<T, T>;

                }
                interface Function<T, R> extends JavaObject {

                    apply(arg0: T): R;
                    compose<V>(arg0: Function<any, any>): Function<V, R>;
                    andThen<V>(arg0: Function<any, any>): Function<T, V>;

                }

                const IntSupplier: JavaInterfaceStatics<IntSupplier>;
                interface IntSupplier extends JavaObject {

                    getAsInt(): number;

                }

                const ToLongFunction: JavaInterfaceStatics<ToLongFunction<any>>;
                interface ToLongFunction<T> extends JavaObject {

                    applyAsLong(arg0: T): number;

                }

                const Consumer: JavaInterfaceStatics<Consumer<any>>;
                interface Consumer<T> extends JavaObject {

                    accept(arg0: T): void;
                    andThen(arg0: Consumer<any>): Consumer<T>;

                }

                const ObjIntConsumer: JavaInterfaceStatics<ObjIntConsumer<any>>;
                interface ObjIntConsumer<T> extends JavaObject {

                    accept(arg0: T, arg1: int): void;

                }

                const ObjDoubleConsumer: JavaInterfaceStatics<ObjDoubleConsumer<any>>;
                interface ObjDoubleConsumer<T> extends JavaObject {

                    accept(arg0: T, arg1: double): void;

                }

                const LongBinaryOperator: JavaInterfaceStatics<LongBinaryOperator>;
                interface LongBinaryOperator extends JavaObject {

                    applyAsLong(arg0: long, arg1: long): number;

                }

                const IntUnaryOperator: JavaInterfaceStatics<IntUnaryOperator> & {

                    identity(): IntUnaryOperator;

                }
                interface IntUnaryOperator extends JavaObject {

                    applyAsInt(arg0: int): number;
                    compose(arg0: IntUnaryOperator): IntUnaryOperator;
                    andThen(arg0: IntUnaryOperator): IntUnaryOperator;

                }

                const DoubleConsumer: JavaInterfaceStatics<DoubleConsumer>;
                interface DoubleConsumer extends JavaObject {

                    accept(arg0: double): void;
                    andThen(arg0: DoubleConsumer): DoubleConsumer;

                }

                const DoubleToIntFunction: JavaInterfaceStatics<DoubleToIntFunction>;
                interface DoubleToIntFunction extends JavaObject {

                    applyAsInt(arg0: double): number;

                }

                const DoubleSupplier: JavaInterfaceStatics<DoubleSupplier>;
                interface DoubleSupplier extends JavaObject {

                    getAsDouble(): number;

                }

                const BinaryOperator: JavaInterfaceStatics<BinaryOperator<any>> & {

                    minBy<T>(arg0: java.util.Comparator<any>): BinaryOperator<T>;
                    maxBy<T>(arg0: java.util.Comparator<any>): BinaryOperator<T>;

                }
                interface BinaryOperator<T> extends BiFunction<T, T, T> {}

                const LongConsumer: JavaInterfaceStatics<LongConsumer>;
                interface LongConsumer extends JavaObject {

                    accept(arg0: long): void;
                    andThen(arg0: LongConsumer): LongConsumer;

                }

                const DoubleUnaryOperator: JavaInterfaceStatics<DoubleUnaryOperator> & {

                    identity(): DoubleUnaryOperator;

                }
                interface DoubleUnaryOperator extends JavaObject {

                    applyAsDouble(arg0: double): number;
                    compose(arg0: DoubleUnaryOperator): DoubleUnaryOperator;
                    andThen(arg0: DoubleUnaryOperator): DoubleUnaryOperator;

                }

                const LongToIntFunction: JavaInterfaceStatics<LongToIntFunction>;
                interface LongToIntFunction extends JavaObject {

                    applyAsInt(arg0: long): number;

                }

                const DoubleBinaryOperator: JavaInterfaceStatics<DoubleBinaryOperator>;
                interface DoubleBinaryOperator extends JavaObject {

                    applyAsDouble(arg0: double, arg1: double): number;

                }

                const IntBinaryOperator: JavaInterfaceStatics<IntBinaryOperator>;
                interface IntBinaryOperator extends JavaObject {

                    applyAsInt(arg0: int, arg1: int): number;

                }

                const IntToLongFunction: JavaInterfaceStatics<IntToLongFunction>;
                interface IntToLongFunction extends JavaObject {

                    applyAsLong(arg0: int): number;

                }

                const LongUnaryOperator: JavaInterfaceStatics<LongUnaryOperator> & {

                    identity(): LongUnaryOperator;

                }
                interface LongUnaryOperator extends JavaObject {

                    applyAsLong(arg0: long): number;
                    compose(arg0: LongUnaryOperator): LongUnaryOperator;
                    andThen(arg0: LongUnaryOperator): LongUnaryOperator;

                }

                const IntPredicate: JavaInterfaceStatics<IntPredicate>;
                interface IntPredicate extends JavaObject {

                    test(arg0: int): boolean;
                    and(arg0: IntPredicate): IntPredicate;
                    negate(): IntPredicate;
                    or(arg0: IntPredicate): IntPredicate;

                }

                const ObjLongConsumer: JavaInterfaceStatics<ObjLongConsumer<any>>;
                interface ObjLongConsumer<T> extends JavaObject {

                    accept(arg0: T, arg1: long): void;

                }

                const LongToDoubleFunction: JavaInterfaceStatics<LongToDoubleFunction>;
                interface LongToDoubleFunction extends JavaObject {

                    applyAsDouble(arg0: long): number;

                }

                const LongPredicate: JavaInterfaceStatics<LongPredicate>;
                interface LongPredicate extends JavaObject {

                    test(arg0: long): boolean;
                    and(arg0: LongPredicate): LongPredicate;
                    negate(): LongPredicate;
                    or(arg0: LongPredicate): LongPredicate;

                }

                const LongFunction: JavaInterfaceStatics<LongFunction<any>>;
                interface LongFunction<R> extends JavaObject {

                    apply(arg0: long): R;

                }

                const DoublePredicate: JavaInterfaceStatics<DoublePredicate>;
                interface DoublePredicate extends JavaObject {

                    test(arg0: double): boolean;
                    and(arg0: DoublePredicate): DoublePredicate;
                    negate(): DoublePredicate;
                    or(arg0: DoublePredicate): DoublePredicate;

                }

                const DoubleToLongFunction: JavaInterfaceStatics<DoubleToLongFunction>;
                interface DoubleToLongFunction extends JavaObject {

                    applyAsLong(arg0: double): number;

                }

                const DoubleFunction: JavaInterfaceStatics<DoubleFunction<any>>;
                interface DoubleFunction<R> extends JavaObject {

                    apply(arg0: double): R;

                }

                const IntToDoubleFunction: JavaInterfaceStatics<IntToDoubleFunction>;
                interface IntToDoubleFunction extends JavaObject {

                    applyAsDouble(arg0: int): number;

                }

                const LongSupplier: JavaInterfaceStatics<LongSupplier>;
                interface LongSupplier extends JavaObject {

                    getAsLong(): number;

                }

                const IntConsumer: JavaInterfaceStatics<IntConsumer>;
                interface IntConsumer extends JavaObject {

                    accept(arg0: int): void;
                    andThen(arg0: IntConsumer): IntConsumer;

                }

                export {
                    BiFunction,
                    ToDoubleFunction,
                    Predicate,
                    BiPredicate,
                    UnaryOperator,
                    ToIntFunction,
                    IntFunction,
                    Supplier,
                    BiConsumer,
                    Function,
                    IntSupplier,
                    ToLongFunction,
                    Consumer,
                    ObjIntConsumer,
                    ObjDoubleConsumer,
                    LongBinaryOperator,
                    IntUnaryOperator,
                    DoubleConsumer,
                    DoubleToIntFunction,
                    DoubleSupplier,
                    BinaryOperator,
                    LongConsumer,
                    DoubleUnaryOperator,
                    LongToIntFunction,
                    DoubleBinaryOperator,
                    IntBinaryOperator,
                    IntToLongFunction,
                    LongUnaryOperator,
                    IntPredicate,
                    ObjLongConsumer,
                    LongToDoubleFunction,
                    LongPredicate,
                    LongFunction,
                    DoublePredicate,
                    DoubleToLongFunction,
                    DoubleFunction,
                    IntToDoubleFunction,
                    LongSupplier,
                    IntConsumer
                }

            }

            export {
                Map$Entry,
                SplittableRandom,
                UUID,
                ArrayList,
                HashSet,
                Enumeration,
                HashMap,
                Locale,
                BitSet,
                Comparator,
                Iterator,
                Date,
                Optional,
                Spliterator$OfLong,
                AbstractMap,
                PrimitiveIterator$OfInt,
                AbstractCollection,
                Spliterator,
                PrimitiveIterator$OfLong,
                AbstractList,
                OptionalDouble,
                PrimitiveIterator$OfDouble,
                ListIterator,
                OptionalInt,
                RandomAccess,
                AbstractSet,
                IntSummaryStatistics,
                Locale$LanguageRange,
                Locale$Category,
                OptionalLong,
                Locale$IsoCountryCode,
                Locale$FilteringMode,
                DoubleSummaryStatistics,
                Spliterator$OfDouble,
                Spliterator$OfInt,
                LongSummaryStatistics,
                PrimitiveIterator,
                Spliterator$OfPrimitive,
                EventListener,
                ResourceBundle,
                Vector,
                EventObject,
                SortedMap,
                Hashtable,
                Properties,
                Dictionary,
                ResourceBundle$Control,
                Random,
                Currency,
                _function as function
            }

        }
        namespace util {

            namespace regex {

                const Pattern: JavaClassStatics<Pattern> & NoConstructor & {
                    readonly UNIX_LINES: number;
                    readonly CASE_INSENSITIVE: number;
                    readonly COMMENTS: number;
                    readonly MULTILINE: number;
                    readonly LITERAL: number;
                    readonly DOTALL: number;
                    readonly UNICODE_CASE: number;
                    readonly CANON_EQ: number;
                    readonly UNICODE_CHARACTER_CLASS: number;

                    compile(arg0: string): Pattern;
                    compile(arg0: string, arg1: int): Pattern;
                    matches(arg0: string, arg1: java.lang.CharSequence): boolean;
                    quote(arg0: string): string;

                }
                interface Pattern extends java.io.Serializable {

                    pattern(): string;
                    matcher(arg0: java.lang.CharSequence): Matcher;
                    flags(): number;
                    split(arg0: java.lang.CharSequence, arg1: int): JavaArray<string>;
                    split(arg0: java.lang.CharSequence): JavaArray<string>;
                    asPredicate(): java.util.function.Predicate<string>;
                    asMatchPredicate(): java.util.function.Predicate<string>;
                    splitAsStream(arg0: java.lang.CharSequence): java.util.stream.Stream<string>;

                }

                const Matcher: JavaClassStatics<Matcher> & NoConstructor & {

                    quoteReplacement(arg0: string): string;

                }
                interface Matcher extends MatchResult {

                    pattern(): Pattern;
                    toMatchResult(): MatchResult;
                    usePattern(arg0: Pattern): Matcher;
                    reset(): Matcher;
                    reset(arg0: java.lang.CharSequence): Matcher;
                    start(): number;
                    start(arg0: int): number;
                    start(arg0: string): number;
                    end(): number;
                    end(arg0: int): number;
                    end(arg0: string): number;
                    group(): string;
                    group(arg0: int): string;
                    group(arg0: string): string;
                    groupCount(): number;
                    matches(): boolean;
                    find(): boolean;
                    find(arg0: int): boolean;
                    lookingAt(): boolean;
                    appendReplacement(arg0: java.lang.StringBuffer, arg1: string): Matcher;
                    appendReplacement(arg0: java.lang.StringBuilder, arg1: string): Matcher;
                    appendTail(arg0: java.lang.StringBuffer): java.lang.StringBuffer;
                    appendTail(arg0: java.lang.StringBuilder): java.lang.StringBuilder;
                    replaceAll(arg0: string): string;
                    replaceAll(arg0: java.util.function.Function<MatchResult, string>): string;
                    results(): java.util.stream.Stream<MatchResult>;
                    replaceFirst(arg0: string): string;
                    replaceFirst(arg0: java.util.function.Function<MatchResult, string>): string;
                    region(arg0: int, arg1: int): Matcher;
                    regionStart(): number;
                    regionEnd(): number;
                    hasTransparentBounds(): boolean;
                    useTransparentBounds(arg0: boolean): Matcher;
                    hasAnchoringBounds(): boolean;
                    useAnchoringBounds(arg0: boolean): Matcher;
                    hitEnd(): boolean;
                    requireEnd(): boolean;

                }

                const MatchResult: JavaInterfaceStatics<MatchResult>;
                interface MatchResult extends JavaObject {

                    start(): number;
                    start(arg0: int): number;
                    end(): number;
                    end(arg0: int): number;
                    group(): string;
                    group(arg0: int): string;
                    groupCount(): number;

                }

                export { Pattern, Matcher, MatchResult }

            }

            namespace stream {

                const IntStream: JavaInterfaceStatics<IntStream> & {

                    builder(): IntStream$Builder;
                    empty(): IntStream;
                    of(arg0: int): IntStream;
                    of(...arg0: int[]): IntStream;
                    iterate(arg0: int, arg1: java.util.function.IntUnaryOperator): IntStream;
                    iterate(arg0: int, arg1: java.util.function.IntPredicate, arg2: java.util.function.IntUnaryOperator): IntStream;
                    generate(arg0: java.util.function.IntSupplier): IntStream;
                    range(arg0: int, arg1: int): IntStream;
                    rangeClosed(arg0: int, arg1: int): IntStream;
                    concat(arg0: IntStream, arg1: IntStream): IntStream;

                }
                interface IntStream extends BaseStream<number, IntStream> {

                    filter(arg0: java.util.function.IntPredicate): IntStream;
                    map(arg0: java.util.function.IntUnaryOperator): IntStream;
                    mapToObj<U>(arg0: java.util.function.IntFunction<any>): Stream<U>;
                    mapToLong(arg0: java.util.function.IntToLongFunction): LongStream;
                    mapToDouble(arg0: java.util.function.IntToDoubleFunction): DoubleStream;
                    flatMap(arg0: java.util.function.IntFunction<any>): IntStream;
                    mapMulti(arg0: IntStream$IntMapMultiConsumer): IntStream;
                    distinct(): IntStream;
                    sorted(): IntStream;
                    peek(arg0: java.util.function.IntConsumer): IntStream;
                    limit(arg0: long): IntStream;
                    skip(arg0: long): IntStream;
                    takeWhile(arg0: java.util.function.IntPredicate): IntStream;
                    dropWhile(arg0: java.util.function.IntPredicate): IntStream;
                    forEach(arg0: java.util.function.IntConsumer): void;
                    forEachOrdered(arg0: java.util.function.IntConsumer): void;
                    toArray(): JavaArray<number>;
                    reduce(arg0: int, arg1: java.util.function.IntBinaryOperator): number;
                    reduce(arg0: java.util.function.IntBinaryOperator): java.util.OptionalInt;
                    collect<R>(arg0: java.util.function.Supplier<R>, arg1: java.util.function.ObjIntConsumer<R>, arg2: java.util.function.BiConsumer<R, R>): R;
                    sum(): number;
                    min(): java.util.OptionalInt;
                    max(): java.util.OptionalInt;
                    count(): number;
                    average(): java.util.OptionalDouble;
                    summaryStatistics(): java.util.IntSummaryStatistics;
                    anyMatch(arg0: java.util.function.IntPredicate): boolean;
                    allMatch(arg0: java.util.function.IntPredicate): boolean;
                    noneMatch(arg0: java.util.function.IntPredicate): boolean;
                    findFirst(): java.util.OptionalInt;
                    findAny(): java.util.OptionalInt;
                    asLongStream(): LongStream;
                    asDoubleStream(): DoubleStream;
                    boxed(): Stream<number>;
                    sequential(): IntStream;
                    parallel(): IntStream;
                    iterator(): java.util.PrimitiveIterator$OfInt;
                    spliterator(): java.util.Spliterator$OfInt;

                }

                const Stream: JavaInterfaceStatics<Stream<any>> & {

                    builder<T>(): Stream$Builder<T>;
                    empty<T>(): Stream<T>;
                    of<T>(arg0: T): Stream<T>;
                    ofNullable<T>(arg0: T): Stream<T>;
                    of<T>(...arg0: T[]): Stream<T>;
                    iterate<T>(arg0: T, arg1: java.util.function.UnaryOperator<T>): Stream<T>;
                    iterate<T>(arg0: T, arg1: java.util.function.Predicate<any>, arg2: java.util.function.UnaryOperator<T>): Stream<T>;
                    generate<T>(arg0: java.util.function.Supplier<any>): Stream<T>;
                    concat<T>(arg0: Stream<any>, arg1: Stream<any>): Stream<T>;

                }
                interface Stream<T> extends BaseStream<T, Stream<T>> {

                    filter(arg0: java.util.function.Predicate<any>): Stream<T>;
                    map<R>(arg0: java.util.function.Function<any, any>): Stream<R>;
                    mapToInt(arg0: java.util.function.ToIntFunction<any>): IntStream;
                    mapToLong(arg0: java.util.function.ToLongFunction<any>): LongStream;
                    mapToDouble(arg0: java.util.function.ToDoubleFunction<any>): DoubleStream;
                    flatMap<R>(arg0: java.util.function.Function<any, any>): Stream<R>;
                    flatMapToInt(arg0: java.util.function.Function<any, any>): IntStream;
                    flatMapToLong(arg0: java.util.function.Function<any, any>): LongStream;
                    flatMapToDouble(arg0: java.util.function.Function<any, any>): DoubleStream;
                    mapMulti<R>(arg0: java.util.function.BiConsumer<any, any>): Stream<R>;
                    mapMultiToInt(arg0: java.util.function.BiConsumer<any, any>): IntStream;
                    mapMultiToLong(arg0: java.util.function.BiConsumer<any, any>): LongStream;
                    mapMultiToDouble(arg0: java.util.function.BiConsumer<any, any>): DoubleStream;
                    distinct(): Stream<T>;
                    sorted(): Stream<T>;
                    sorted(arg0: java.util.Comparator<any>): Stream<T>;
                    peek(arg0: java.util.function.Consumer<any>): Stream<T>;
                    limit(arg0: long): Stream<T>;
                    skip(arg0: long): Stream<T>;
                    takeWhile(arg0: java.util.function.Predicate<any>): Stream<T>;
                    dropWhile(arg0: java.util.function.Predicate<any>): Stream<T>;
                    forEach(arg0: java.util.function.Consumer<any>): void;
                    forEachOrdered(arg0: java.util.function.Consumer<any>): void;
                    toArray(): JavaArray<any>;
                    toArray<A>(arg0: java.util.function.IntFunction<A[]>): JavaArray<A>;
                    reduce(arg0: T, arg1: java.util.function.BinaryOperator<T>): T;
                    reduce(arg0: java.util.function.BinaryOperator<T>): java.util.Optional<T>;
                    reduce<U>(arg0: U, arg1: java.util.function.BiFunction<U, any, U>, arg2: java.util.function.BinaryOperator<U>): U;
                    collect<R>(arg0: java.util.function.Supplier<R>, arg1: java.util.function.BiConsumer<R, any>, arg2: java.util.function.BiConsumer<R, R>): R;
                    collect<R, A>(arg0: Collector<any, A, R>): R;
                    toList(): JavaList<T>;
                    min(arg0: java.util.Comparator<any>): java.util.Optional<T>;
                    max(arg0: java.util.Comparator<any>): java.util.Optional<T>;
                    count(): number;
                    anyMatch(arg0: java.util.function.Predicate<any>): boolean;
                    allMatch(arg0: java.util.function.Predicate<any>): boolean;
                    noneMatch(arg0: java.util.function.Predicate<any>): boolean;
                    findFirst(): java.util.Optional<T>;
                    findAny(): java.util.Optional<T>;

                }

                const LongStream: JavaInterfaceStatics<LongStream> & {

                    builder(): LongStream$Builder;
                    empty(): LongStream;
                    of(arg0: long): LongStream;
                    of(...arg0: long[]): LongStream;
                    iterate(arg0: long, arg1: java.util.function.LongUnaryOperator): LongStream;
                    iterate(arg0: long, arg1: java.util.function.LongPredicate, arg2: java.util.function.LongUnaryOperator): LongStream;
                    generate(arg0: java.util.function.LongSupplier): LongStream;
                    range(arg0: long, arg1: long): LongStream;
                    rangeClosed(arg0: long, arg1: long): LongStream;
                    concat(arg0: LongStream, arg1: LongStream): LongStream;

                }
                interface LongStream extends BaseStream<number, LongStream> {

                    filter(arg0: java.util.function.LongPredicate): LongStream;
                    map(arg0: java.util.function.LongUnaryOperator): LongStream;
                    mapToObj<U>(arg0: java.util.function.LongFunction<any>): Stream<U>;
                    mapToInt(arg0: java.util.function.LongToIntFunction): IntStream;
                    mapToDouble(arg0: java.util.function.LongToDoubleFunction): DoubleStream;
                    flatMap(arg0: java.util.function.LongFunction<any>): LongStream;
                    mapMulti(arg0: LongStream$LongMapMultiConsumer): LongStream;
                    distinct(): LongStream;
                    sorted(): LongStream;
                    peek(arg0: java.util.function.LongConsumer): LongStream;
                    limit(arg0: long): LongStream;
                    skip(arg0: long): LongStream;
                    takeWhile(arg0: java.util.function.LongPredicate): LongStream;
                    dropWhile(arg0: java.util.function.LongPredicate): LongStream;
                    forEach(arg0: java.util.function.LongConsumer): void;
                    forEachOrdered(arg0: java.util.function.LongConsumer): void;
                    toArray(): JavaArray<number>;
                    reduce(arg0: long, arg1: java.util.function.LongBinaryOperator): number;
                    reduce(arg0: java.util.function.LongBinaryOperator): java.util.OptionalLong;
                    collect<R>(arg0: java.util.function.Supplier<R>, arg1: java.util.function.ObjLongConsumer<R>, arg2: java.util.function.BiConsumer<R, R>): R;
                    sum(): number;
                    min(): java.util.OptionalLong;
                    max(): java.util.OptionalLong;
                    count(): number;
                    average(): java.util.OptionalDouble;
                    summaryStatistics(): java.util.LongSummaryStatistics;
                    anyMatch(arg0: java.util.function.LongPredicate): boolean;
                    allMatch(arg0: java.util.function.LongPredicate): boolean;
                    noneMatch(arg0: java.util.function.LongPredicate): boolean;
                    findFirst(): java.util.OptionalLong;
                    findAny(): java.util.OptionalLong;
                    asDoubleStream(): DoubleStream;
                    boxed(): Stream<number>;
                    sequential(): LongStream;
                    parallel(): LongStream;
                    iterator(): java.util.PrimitiveIterator$OfLong;
                    spliterator(): java.util.Spliterator$OfLong;

                }

                const DoubleStream: JavaInterfaceStatics<DoubleStream> & {

                    builder(): DoubleStream$Builder;
                    empty(): DoubleStream;
                    of(arg0: double): DoubleStream;
                    of(...arg0: double[]): DoubleStream;
                    iterate(arg0: double, arg1: java.util.function.DoubleUnaryOperator): DoubleStream;
                    iterate(arg0: double, arg1: java.util.function.DoublePredicate, arg2: java.util.function.DoubleUnaryOperator): DoubleStream;
                    generate(arg0: java.util.function.DoubleSupplier): DoubleStream;
                    concat(arg0: DoubleStream, arg1: DoubleStream): DoubleStream;

                }
                interface DoubleStream extends BaseStream<number, DoubleStream> {

                    filter(arg0: java.util.function.DoublePredicate): DoubleStream;
                    map(arg0: java.util.function.DoubleUnaryOperator): DoubleStream;
                    mapToObj<U>(arg0: java.util.function.DoubleFunction<any>): Stream<U>;
                    mapToInt(arg0: java.util.function.DoubleToIntFunction): IntStream;
                    mapToLong(arg0: java.util.function.DoubleToLongFunction): LongStream;
                    flatMap(arg0: java.util.function.DoubleFunction<any>): DoubleStream;
                    mapMulti(arg0: DoubleStream$DoubleMapMultiConsumer): DoubleStream;
                    distinct(): DoubleStream;
                    sorted(): DoubleStream;
                    peek(arg0: java.util.function.DoubleConsumer): DoubleStream;
                    limit(arg0: long): DoubleStream;
                    skip(arg0: long): DoubleStream;
                    takeWhile(arg0: java.util.function.DoublePredicate): DoubleStream;
                    dropWhile(arg0: java.util.function.DoublePredicate): DoubleStream;
                    forEach(arg0: java.util.function.DoubleConsumer): void;
                    forEachOrdered(arg0: java.util.function.DoubleConsumer): void;
                    toArray(): JavaArray<number>;
                    reduce(arg0: double, arg1: java.util.function.DoubleBinaryOperator): number;
                    reduce(arg0: java.util.function.DoubleBinaryOperator): java.util.OptionalDouble;
                    collect<R>(arg0: java.util.function.Supplier<R>, arg1: java.util.function.ObjDoubleConsumer<R>, arg2: java.util.function.BiConsumer<R, R>): R;
                    sum(): number;
                    min(): java.util.OptionalDouble;
                    max(): java.util.OptionalDouble;
                    count(): number;
                    average(): java.util.OptionalDouble;
                    summaryStatistics(): java.util.DoubleSummaryStatistics;
                    anyMatch(arg0: java.util.function.DoublePredicate): boolean;
                    allMatch(arg0: java.util.function.DoublePredicate): boolean;
                    noneMatch(arg0: java.util.function.DoublePredicate): boolean;
                    findFirst(): java.util.OptionalDouble;
                    findAny(): java.util.OptionalDouble;
                    boxed(): Stream<number>;
                    sequential(): DoubleStream;
                    parallel(): DoubleStream;
                    iterator(): java.util.PrimitiveIterator$OfDouble;
                    spliterator(): java.util.Spliterator$OfDouble;

                }

                const LongStream$Builder: JavaInterfaceStatics<LongStream$Builder>;
                interface LongStream$Builder extends java.util.function.LongConsumer {

                    accept(arg0: long): void;
                    add(arg0: long): LongStream$Builder;
                    build(): LongStream;

                }

                const Collector: JavaInterfaceStatics<Collector<any, any, any>> & {

                    of<T, R>(arg0: java.util.function.Supplier<R>, arg1: java.util.function.BiConsumer<R, T>, arg2: java.util.function.BinaryOperator<R>, ...arg3: Collector$Characteristics[]): Collector<T, R, R>;
                    of<T, A, R>(arg0: java.util.function.Supplier<A>, arg1: java.util.function.BiConsumer<A, T>, arg2: java.util.function.BinaryOperator<A>, arg3: java.util.function.Function<A, R>, ...arg4: Collector$Characteristics[]): Collector<T, A, R>;

                }
                interface Collector<T, A, R> extends JavaObject {

                    supplier(): java.util.function.Supplier<A>;
                    accumulator(): java.util.function.BiConsumer<A, T>;
                    combiner(): java.util.function.BinaryOperator<A>;
                    finisher(): java.util.function.Function<A, R>;
                    characteristics(): JavaSet<Collector$Characteristics>;

                }

                const IntStream$Builder: JavaInterfaceStatics<IntStream$Builder>;
                interface IntStream$Builder extends java.util.function.IntConsumer {

                    accept(arg0: int): void;
                    add(arg0: int): IntStream$Builder;
                    build(): IntStream;

                }

                const LongStream$LongMapMultiConsumer: JavaInterfaceStatics<LongStream$LongMapMultiConsumer>;
                interface LongStream$LongMapMultiConsumer extends JavaObject {

                    accept(arg0: long, arg1: java.util.function.LongConsumer): void;

                }

                const DoubleStream$DoubleMapMultiConsumer: JavaInterfaceStatics<DoubleStream$DoubleMapMultiConsumer>;
                interface DoubleStream$DoubleMapMultiConsumer extends JavaObject {

                    accept(arg0: double, arg1: java.util.function.DoubleConsumer): void;

                }

                const DoubleStream$Builder: JavaInterfaceStatics<DoubleStream$Builder>;
                interface DoubleStream$Builder extends java.util.function.DoubleConsumer {

                    accept(arg0: double): void;
                    add(arg0: double): DoubleStream$Builder;
                    build(): DoubleStream;

                }

                const IntStream$IntMapMultiConsumer: JavaInterfaceStatics<IntStream$IntMapMultiConsumer>;
                interface IntStream$IntMapMultiConsumer extends JavaObject {

                    accept(arg0: int, arg1: java.util.function.IntConsumer): void;

                }

                const Stream$Builder: JavaInterfaceStatics<Stream$Builder<any>>;
                interface Stream$Builder<T> extends java.util.function.Consumer<T> {

                    accept(arg0: T): void;
                    add(arg0: T): Stream$Builder<T>;
                    build(): Stream<T>;

                }

                const BaseStream: JavaInterfaceStatics<BaseStream<any, any>>;
                interface BaseStream<T, S extends BaseStream<T, S>> extends java.lang.AutoCloseable {

                    iterator(): java.util.Iterator<T>;
                    spliterator(): java.util.Spliterator<T>;
                    isParallel(): boolean;
                    sequential(): S;
                    parallel(): S;
                    unordered(): S;
                    onClose(arg0: java.lang.Runnable): S;
                    close(): void;

                }

                const Collector$Characteristics: JavaClassStatics<Collector$Characteristics> & NoConstructor & {
                    readonly CONCURRENT: Collector$Characteristics;
                    readonly UNORDERED: Collector$Characteristics;
                    readonly IDENTITY_FINISH: Collector$Characteristics;

                    values(): JavaArray<Collector$Characteristics>;
                    valueOf(arg0: string): Collector$Characteristics;

                }
                interface Collector$Characteristics extends java.lang.Enum<Collector$Characteristics> {}

                export {
                    IntStream,
                    Stream,
                    LongStream,
                    DoubleStream,
                    LongStream$Builder,
                    Collector,
                    IntStream$Builder,
                    LongStream$LongMapMultiConsumer,
                    DoubleStream$DoubleMapMultiConsumer,
                    DoubleStream$Builder,
                    IntStream$IntMapMultiConsumer,
                    Stream$Builder,
                    BaseStream,
                    Collector$Characteristics
                }

            }

            namespace random {

                const RandomGenerator$StreamableGenerator: JavaInterfaceStatics<RandomGenerator$StreamableGenerator> & {

                    of(arg0: string): RandomGenerator$StreamableGenerator;

                }
                interface RandomGenerator$StreamableGenerator extends RandomGenerator {

                    rngs(): java.util.stream.Stream<RandomGenerator>;
                    rngs(arg0: long): java.util.stream.Stream<RandomGenerator>;

                }

                const RandomGenerator: JavaInterfaceStatics<RandomGenerator> & {

                    of(arg0: string): RandomGenerator;
                    getDefault(): RandomGenerator;

                }
                interface RandomGenerator extends JavaObject {

                    isDeprecated(): boolean;
                    doubles(): java.util.stream.DoubleStream;
                    doubles(arg0: double, arg1: double): java.util.stream.DoubleStream;
                    doubles(arg0: long): java.util.stream.DoubleStream;
                    doubles(arg0: long, arg1: double, arg2: double): java.util.stream.DoubleStream;
                    ints(): java.util.stream.IntStream;
                    ints(arg0: int, arg1: int): java.util.stream.IntStream;
                    ints(arg0: long): java.util.stream.IntStream;
                    ints(arg0: long, arg1: int, arg2: int): java.util.stream.IntStream;
                    longs(): java.util.stream.LongStream;
                    longs(arg0: long, arg1: long): java.util.stream.LongStream;
                    longs(arg0: long): java.util.stream.LongStream;
                    longs(arg0: long, arg1: long, arg2: long): java.util.stream.LongStream;
                    nextBoolean(): boolean;
                    nextBytes(arg0: byte[]): void;
                    nextFloat(): number;
                    nextFloat(arg0: float): number;
                    nextFloat(arg0: float, arg1: float): number;
                    nextDouble(): number;
                    nextDouble(arg0: double): number;
                    nextDouble(arg0: double, arg1: double): number;
                    nextInt(): number;
                    nextInt(arg0: int): number;
                    nextInt(arg0: int, arg1: int): number;
                    nextLong(): number;
                    nextLong(arg0: long): number;
                    nextLong(arg0: long, arg1: long): number;
                    nextGaussian(): number;
                    nextGaussian(arg0: double, arg1: double): number;
                    nextExponential(): number;

                }

                const RandomGenerator$SplittableGenerator: JavaInterfaceStatics<RandomGenerator$SplittableGenerator> & {

                    of(arg0: string): RandomGenerator$SplittableGenerator;

                }
                interface RandomGenerator$SplittableGenerator extends RandomGenerator$StreamableGenerator {

                    split(): RandomGenerator$SplittableGenerator;
                    split(arg0: RandomGenerator$SplittableGenerator): RandomGenerator$SplittableGenerator;
                    splits(): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    splits(arg0: long): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    splits(arg0: RandomGenerator$SplittableGenerator): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    splits(arg0: long, arg1: RandomGenerator$SplittableGenerator): java.util.stream.Stream<RandomGenerator$SplittableGenerator>;
                    rngs(): java.util.stream.Stream<RandomGenerator>;
                    rngs(arg0: long): java.util.stream.Stream<RandomGenerator>;

                }

                export {
                    RandomGenerator$StreamableGenerator,
                    RandomGenerator,
                    RandomGenerator$SplittableGenerator
                }

            }

            namespace concurrent {

                const TimeUnit: JavaClassStatics<TimeUnit> & NoConstructor & {
                    readonly NANOSECONDS: TimeUnit;
                    readonly MICROSECONDS: TimeUnit;
                    readonly MILLISECONDS: TimeUnit;
                    readonly SECONDS: TimeUnit;
                    readonly MINUTES: TimeUnit;
                    readonly HOURS: TimeUnit;
                    readonly DAYS: TimeUnit;

                    values(): JavaArray<TimeUnit>;
                    valueOf(arg0: string): TimeUnit;
                    of(arg0: java.time.temporal.ChronoUnit): TimeUnit;

                }
                interface TimeUnit extends java.lang.Enum<TimeUnit> {

                    convert(arg0: long, arg1: TimeUnit): number;
                    convert(arg0: java.time.Duration): number;
                    toNanos(arg0: long): number;
                    toMicros(arg0: long): number;
                    toMillis(arg0: long): number;
                    toSeconds(arg0: long): number;
                    toMinutes(arg0: long): number;
                    toHours(arg0: long): number;
                    toDays(arg0: long): number;
                    timedWait(arg0: any, arg1: long): void;
                    timedJoin(arg0: java.lang.Thread, arg1: long): void;
                    sleep(arg0: long): void;
                    toChronoUnit(): java.time.temporal.ChronoUnit;

                }

                const Future: JavaInterfaceStatics<Future<any>>;
                interface Future<V> extends JavaObject {

                    cancel(arg0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): V;
                    get(arg0: long, arg1: TimeUnit): V;

                }

                const ExecutorService: JavaInterfaceStatics<ExecutorService>;
                interface ExecutorService extends Executor {

                    shutdown(): void;
                    shutdownNow(): JavaList<java.lang.Runnable>;
                    isShutdown(): boolean;
                    isTerminated(): boolean;
                    awaitTermination(arg0: long, arg1: TimeUnit): boolean;
                    submit<T>(arg0: Callable<T>): Future<T>;
                    submit<T>(arg0: java.lang.Runnable, arg1: T): Future<T>;
                    submit(arg0: java.lang.Runnable): Future<any>;
                    invokeAll<T>(arg0: JavaCollection<any>): JavaList<Future<T>>;
                    invokeAll<T>(arg0: JavaCollection<any>, arg1: long, arg2: TimeUnit): JavaList<Future<T>>;
                    invokeAny<T>(arg0: JavaCollection<any>): T;
                    invokeAny<T>(arg0: JavaCollection<any>, arg1: long, arg2: TimeUnit): T;

                }

                const Callable: JavaInterfaceStatics<Callable<any>>;
                interface Callable<V> extends JavaObject {

                    call(): V;

                }

                const Executor: JavaInterfaceStatics<Executor>;
                interface Executor extends JavaObject {

                    execute(arg0: java.lang.Runnable): void;

                }

                const CompletableFuture: JavaClassStatics<CompletableFuture<any>, CompletableFuture$$constructor> & {

                    supplyAsync<U>(arg0: java.util.function.Supplier<U>): CompletableFuture<U>;
                    supplyAsync<U>(arg0: java.util.function.Supplier<U>, arg1: Executor): CompletableFuture<U>;
                    runAsync(arg0: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    runAsync(arg0: java.lang.Runnable, arg1: Executor): CompletableFuture<java.lang.Void>;
                    completedFuture<U>(arg0: U): CompletableFuture<U>;
                    allOf(...arg0: CompletableFuture<any>[]): CompletableFuture<java.lang.Void>;
                    anyOf(...arg0: CompletableFuture<any>[]): CompletableFuture<any>;
                    delayedExecutor(arg0: long, arg1: TimeUnit, arg2: Executor): Executor;
                    delayedExecutor(arg0: long, arg1: TimeUnit): Executor;
                    completedStage<U>(arg0: U): CompletionStage<U>;
                    failedFuture<U>(arg0: java.lang.Throwable): CompletableFuture<U>;
                    failedStage<U>(arg0: java.lang.Throwable): CompletionStage<U>;

                }
                interface CompletableFuture$$constructor extends SuppressProperties {

                    new <T>(): CompletableFuture<T>;

                }
                interface CompletableFuture<T> extends Future<T>, CompletionStage<T> {

                    isDone(): boolean;
                    get(): T;
                    get(arg0: long, arg1: TimeUnit): T;
                    join(): T;
                    getNow(arg0: T): T;
                    complete(arg0: T): boolean;
                    completeExceptionally(arg0: java.lang.Throwable): boolean;
                    thenApply<U>(arg0: java.util.function.Function<any, any>): CompletableFuture<U>;
                    thenApplyAsync<U>(arg0: java.util.function.Function<any, any>): CompletableFuture<U>;
                    thenApplyAsync<U>(arg0: java.util.function.Function<any, any>, arg1: Executor): CompletableFuture<U>;
                    thenAccept(arg0: java.util.function.Consumer<any>): CompletableFuture<java.lang.Void>;
                    thenAcceptAsync(arg0: java.util.function.Consumer<any>): CompletableFuture<java.lang.Void>;
                    thenAcceptAsync(arg0: java.util.function.Consumer<any>, arg1: Executor): CompletableFuture<java.lang.Void>;
                    thenRun(arg0: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    thenRunAsync(arg0: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    thenRunAsync(arg0: java.lang.Runnable, arg1: Executor): CompletableFuture<java.lang.Void>;
                    thenCombine<U, V>(arg0: CompletionStage<any>, arg1: java.util.function.BiFunction<any, any, any>): CompletableFuture<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<any>, arg1: java.util.function.BiFunction<any, any, any>): CompletableFuture<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<any>, arg1: java.util.function.BiFunction<any, any, any>, arg2: Executor): CompletableFuture<V>;
                    thenAcceptBoth<U>(arg0: CompletionStage<any>, arg1: java.util.function.BiConsumer<any, any>): CompletableFuture<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.BiConsumer<any, any>): CompletableFuture<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.BiConsumer<any, any>, arg2: Executor): CompletableFuture<java.lang.Void>;
                    runAfterBoth(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable, arg2: Executor): CompletableFuture<java.lang.Void>;
                    applyToEither<U>(arg0: CompletionStage<any>, arg1: java.util.function.Function<any, U>): CompletableFuture<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.Function<any, U>): CompletableFuture<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.Function<any, U>, arg2: Executor): CompletableFuture<U>;
                    acceptEither(arg0: CompletionStage<any>, arg1: java.util.function.Consumer<any>): CompletableFuture<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<any>, arg1: java.util.function.Consumer<any>): CompletableFuture<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<any>, arg1: java.util.function.Consumer<any>, arg2: Executor): CompletableFuture<java.lang.Void>;
                    runAfterEither(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletableFuture<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable, arg2: Executor): CompletableFuture<java.lang.Void>;
                    thenCompose<U>(arg0: java.util.function.Function<any, any>): CompletableFuture<U>;
                    thenComposeAsync<U>(arg0: java.util.function.Function<any, any>): CompletableFuture<U>;
                    thenComposeAsync<U>(arg0: java.util.function.Function<any, any>, arg1: Executor): CompletableFuture<U>;
                    whenComplete(arg0: java.util.function.BiConsumer<any, any>): CompletableFuture<T>;
                    whenCompleteAsync(arg0: java.util.function.BiConsumer<any, any>): CompletableFuture<T>;
                    whenCompleteAsync(arg0: java.util.function.BiConsumer<any, any>, arg1: Executor): CompletableFuture<T>;
                    handle<U>(arg0: java.util.function.BiFunction<any, java.lang.Throwable, any>): CompletableFuture<U>;
                    handleAsync<U>(arg0: java.util.function.BiFunction<any, java.lang.Throwable, any>): CompletableFuture<U>;
                    handleAsync<U>(arg0: java.util.function.BiFunction<any, java.lang.Throwable, any>, arg1: Executor): CompletableFuture<U>;
                    toCompletableFuture(): CompletableFuture<T>;
                    exceptionally(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletableFuture<T>;
                    exceptionallyAsync(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletableFuture<T>;
                    exceptionallyAsync(arg0: java.util.function.Function<java.lang.Throwable, any>, arg1: Executor): CompletableFuture<T>;
                    exceptionallyCompose(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletableFuture<T>;
                    exceptionallyComposeAsync(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletableFuture<T>;
                    exceptionallyComposeAsync(arg0: java.util.function.Function<java.lang.Throwable, any>, arg1: Executor): CompletableFuture<T>;
                    cancel(arg0: boolean): boolean;
                    isCancelled(): boolean;
                    isCompletedExceptionally(): boolean;
                    obtrudeValue(arg0: T): void;
                    obtrudeException(arg0: java.lang.Throwable): void;
                    getNumberOfDependents(): number;
                    newIncompleteFuture<U>(): CompletableFuture<U>;
                    defaultExecutor(): Executor;
                    copy(): CompletableFuture<T>;
                    minimalCompletionStage(): CompletionStage<T>;
                    completeAsync(arg0: java.util.function.Supplier<any>, arg1: Executor): CompletableFuture<T>;
                    completeAsync(arg0: java.util.function.Supplier<any>): CompletableFuture<T>;
                    orTimeout(arg0: long, arg1: TimeUnit): CompletableFuture<T>;
                    completeOnTimeout(arg0: T, arg1: long, arg2: TimeUnit): CompletableFuture<T>;

                }

                const CompletionStage: JavaInterfaceStatics<CompletionStage<any>>;
                interface CompletionStage<T> extends JavaObject {

                    thenApply<U>(arg0: java.util.function.Function<any, any>): CompletionStage<U>;
                    thenApplyAsync<U>(arg0: java.util.function.Function<any, any>): CompletionStage<U>;
                    thenApplyAsync<U>(arg0: java.util.function.Function<any, any>, arg1: Executor): CompletionStage<U>;
                    thenAccept(arg0: java.util.function.Consumer<any>): CompletionStage<java.lang.Void>;
                    thenAcceptAsync(arg0: java.util.function.Consumer<any>): CompletionStage<java.lang.Void>;
                    thenAcceptAsync(arg0: java.util.function.Consumer<any>, arg1: Executor): CompletionStage<java.lang.Void>;
                    thenRun(arg0: java.lang.Runnable): CompletionStage<java.lang.Void>;
                    thenRunAsync(arg0: java.lang.Runnable): CompletionStage<java.lang.Void>;
                    thenRunAsync(arg0: java.lang.Runnable, arg1: Executor): CompletionStage<java.lang.Void>;
                    thenCombine<U, V>(arg0: CompletionStage<any>, arg1: java.util.function.BiFunction<any, any, any>): CompletionStage<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<any>, arg1: java.util.function.BiFunction<any, any, any>): CompletionStage<V>;
                    thenCombineAsync<U, V>(arg0: CompletionStage<any>, arg1: java.util.function.BiFunction<any, any, any>, arg2: Executor): CompletionStage<V>;
                    thenAcceptBoth<U>(arg0: CompletionStage<any>, arg1: java.util.function.BiConsumer<any, any>): CompletionStage<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.BiConsumer<any, any>): CompletionStage<java.lang.Void>;
                    thenAcceptBothAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.BiConsumer<any, any>, arg2: Executor): CompletionStage<java.lang.Void>;
                    runAfterBoth(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletionStage<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletionStage<java.lang.Void>;
                    runAfterBothAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable, arg2: Executor): CompletionStage<java.lang.Void>;
                    applyToEither<U>(arg0: CompletionStage<any>, arg1: java.util.function.Function<any, U>): CompletionStage<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.Function<any, U>): CompletionStage<U>;
                    applyToEitherAsync<U>(arg0: CompletionStage<any>, arg1: java.util.function.Function<any, U>, arg2: Executor): CompletionStage<U>;
                    acceptEither(arg0: CompletionStage<any>, arg1: java.util.function.Consumer<any>): CompletionStage<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<any>, arg1: java.util.function.Consumer<any>): CompletionStage<java.lang.Void>;
                    acceptEitherAsync(arg0: CompletionStage<any>, arg1: java.util.function.Consumer<any>, arg2: Executor): CompletionStage<java.lang.Void>;
                    runAfterEither(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletionStage<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable): CompletionStage<java.lang.Void>;
                    runAfterEitherAsync(arg0: CompletionStage<any>, arg1: java.lang.Runnable, arg2: Executor): CompletionStage<java.lang.Void>;
                    thenCompose<U>(arg0: java.util.function.Function<any, any>): CompletionStage<U>;
                    thenComposeAsync<U>(arg0: java.util.function.Function<any, any>): CompletionStage<U>;
                    thenComposeAsync<U>(arg0: java.util.function.Function<any, any>, arg1: Executor): CompletionStage<U>;
                    handle<U>(arg0: java.util.function.BiFunction<any, java.lang.Throwable, any>): CompletionStage<U>;
                    handleAsync<U>(arg0: java.util.function.BiFunction<any, java.lang.Throwable, any>): CompletionStage<U>;
                    handleAsync<U>(arg0: java.util.function.BiFunction<any, java.lang.Throwable, any>, arg1: Executor): CompletionStage<U>;
                    whenComplete(arg0: java.util.function.BiConsumer<any, any>): CompletionStage<T>;
                    whenCompleteAsync(arg0: java.util.function.BiConsumer<any, any>): CompletionStage<T>;
                    whenCompleteAsync(arg0: java.util.function.BiConsumer<any, any>, arg1: Executor): CompletionStage<T>;
                    exceptionally(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletionStage<T>;
                    exceptionallyAsync(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletionStage<T>;
                    exceptionallyAsync(arg0: java.util.function.Function<java.lang.Throwable, any>, arg1: Executor): CompletionStage<T>;
                    exceptionallyCompose(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletionStage<T>;
                    exceptionallyComposeAsync(arg0: java.util.function.Function<java.lang.Throwable, any>): CompletionStage<T>;
                    exceptionallyComposeAsync(arg0: java.util.function.Function<java.lang.Throwable, any>, arg1: Executor): CompletionStage<T>;
                    toCompletableFuture(): CompletableFuture<T>;

                }

                export {
                    TimeUnit,
                    Future,
                    ExecutorService,
                    Callable,
                    Executor,
                    CompletableFuture,
                    CompletionStage
                }

            }

        }

        namespace nio {

            const ByteBuffer: JavaClassStatics<ByteBuffer> & NoConstructor & {

                allocateDirect(arg0: int): ByteBuffer;
                allocate(arg0: int): ByteBuffer;
                wrap(arg0: byte[], arg1: int, arg2: int): ByteBuffer;
                wrap(arg0: byte[]): ByteBuffer;

            }
            interface ByteBuffer extends Buffer, java.lang.Comparable<ByteBuffer> {

                slice(): ByteBuffer;
                slice(arg0: int, arg1: int): ByteBuffer;
                duplicate(): ByteBuffer;
                asReadOnlyBuffer(): ByteBuffer;
                get(): number;
                put(arg0: byte): ByteBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: byte): ByteBuffer;
                get(arg0: byte[], arg1: int, arg2: int): ByteBuffer;
                get(arg0: byte[]): ByteBuffer;
                get(arg0: int, arg1: byte[], arg2: int, arg3: int): ByteBuffer;
                get(arg0: int, arg1: byte[]): ByteBuffer;
                put(arg0: ByteBuffer): ByteBuffer;
                put(arg0: int, arg1: ByteBuffer, arg2: int, arg3: int): ByteBuffer;
                put(arg0: byte[], arg1: int, arg2: int): ByteBuffer;
                put(arg0: byte[]): ByteBuffer;
                put(arg0: int, arg1: byte[], arg2: int, arg3: int): ByteBuffer;
                put(arg0: int, arg1: byte[]): ByteBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): ByteBuffer;
                position(): number;
                limit(arg0: int): ByteBuffer;
                limit(): number;
                mark(): ByteBuffer;
                reset(): ByteBuffer;
                clear(): ByteBuffer;
                flip(): ByteBuffer;
                rewind(): ByteBuffer;
                compact(): ByteBuffer;
                isDirect(): boolean;
                compareTo(arg0: ByteBuffer): number;
                mismatch(arg0: ByteBuffer): number;
                order(): ByteOrder;
                order(arg0: ByteOrder): ByteBuffer;
                alignmentOffset(arg0: int, arg1: int): number;
                alignedSlice(arg0: int): ByteBuffer;
                getChar(): number;
                putChar(arg0: char): ByteBuffer;
                getChar(arg0: int): number;
                putChar(arg0: int, arg1: char): ByteBuffer;
                asCharBuffer(): CharBuffer;
                getShort(): number;
                putShort(arg0: short): ByteBuffer;
                getShort(arg0: int): number;
                putShort(arg0: int, arg1: short): ByteBuffer;
                asShortBuffer(): ShortBuffer;
                getInt(): number;
                putInt(arg0: int): ByteBuffer;
                getInt(arg0: int): number;
                putInt(arg0: int, arg1: int): ByteBuffer;
                asIntBuffer(): IntBuffer;
                getLong(): number;
                putLong(arg0: long): ByteBuffer;
                getLong(arg0: int): number;
                putLong(arg0: int, arg1: long): ByteBuffer;
                asLongBuffer(): LongBuffer;
                getFloat(): number;
                putFloat(arg0: float): ByteBuffer;
                getFloat(arg0: int): number;
                putFloat(arg0: int, arg1: float): ByteBuffer;
                asFloatBuffer(): FloatBuffer;
                getDouble(): number;
                putDouble(arg0: double): ByteBuffer;
                getDouble(arg0: int): number;
                putDouble(arg0: int, arg1: double): ByteBuffer;
                asDoubleBuffer(): DoubleBuffer;

            }

            const LongBuffer: JavaClassStatics<LongBuffer> & NoConstructor & {

                allocate(arg0: int): LongBuffer;
                wrap(arg0: long[], arg1: int, arg2: int): LongBuffer;
                wrap(arg0: long[]): LongBuffer;

            }
            interface LongBuffer extends Buffer, java.lang.Comparable<LongBuffer> {

                slice(): LongBuffer;
                slice(arg0: int, arg1: int): LongBuffer;
                duplicate(): LongBuffer;
                asReadOnlyBuffer(): LongBuffer;
                get(): number;
                put(arg0: long): LongBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: long): LongBuffer;
                get(arg0: long[], arg1: int, arg2: int): LongBuffer;
                get(arg0: long[]): LongBuffer;
                get(arg0: int, arg1: long[], arg2: int, arg3: int): LongBuffer;
                get(arg0: int, arg1: long[]): LongBuffer;
                put(arg0: LongBuffer): LongBuffer;
                put(arg0: int, arg1: LongBuffer, arg2: int, arg3: int): LongBuffer;
                put(arg0: long[], arg1: int, arg2: int): LongBuffer;
                put(arg0: long[]): LongBuffer;
                put(arg0: int, arg1: long[], arg2: int, arg3: int): LongBuffer;
                put(arg0: int, arg1: long[]): LongBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): LongBuffer;
                position(): number;
                limit(arg0: int): LongBuffer;
                limit(): number;
                mark(): LongBuffer;
                reset(): LongBuffer;
                clear(): LongBuffer;
                flip(): LongBuffer;
                rewind(): LongBuffer;
                compact(): LongBuffer;
                isDirect(): boolean;
                compareTo(arg0: LongBuffer): number;
                mismatch(arg0: LongBuffer): number;
                order(): ByteOrder;

            }

            const DoubleBuffer: JavaClassStatics<DoubleBuffer> & NoConstructor & {

                allocate(arg0: int): DoubleBuffer;
                wrap(arg0: double[], arg1: int, arg2: int): DoubleBuffer;
                wrap(arg0: double[]): DoubleBuffer;

            }
            interface DoubleBuffer extends Buffer, java.lang.Comparable<DoubleBuffer> {

                slice(): DoubleBuffer;
                slice(arg0: int, arg1: int): DoubleBuffer;
                duplicate(): DoubleBuffer;
                asReadOnlyBuffer(): DoubleBuffer;
                get(): number;
                put(arg0: double): DoubleBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: double): DoubleBuffer;
                get(arg0: double[], arg1: int, arg2: int): DoubleBuffer;
                get(arg0: double[]): DoubleBuffer;
                get(arg0: int, arg1: double[], arg2: int, arg3: int): DoubleBuffer;
                get(arg0: int, arg1: double[]): DoubleBuffer;
                put(arg0: DoubleBuffer): DoubleBuffer;
                put(arg0: int, arg1: DoubleBuffer, arg2: int, arg3: int): DoubleBuffer;
                put(arg0: double[], arg1: int, arg2: int): DoubleBuffer;
                put(arg0: double[]): DoubleBuffer;
                put(arg0: int, arg1: double[], arg2: int, arg3: int): DoubleBuffer;
                put(arg0: int, arg1: double[]): DoubleBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): DoubleBuffer;
                position(): number;
                limit(arg0: int): DoubleBuffer;
                limit(): number;
                mark(): DoubleBuffer;
                reset(): DoubleBuffer;
                clear(): DoubleBuffer;
                flip(): DoubleBuffer;
                rewind(): DoubleBuffer;
                compact(): DoubleBuffer;
                isDirect(): boolean;
                compareTo(arg0: DoubleBuffer): number;
                mismatch(arg0: DoubleBuffer): number;
                order(): ByteOrder;

            }

            const Buffer: JavaClassStatics<Buffer> & NoConstructor;
            interface Buffer extends JavaObject {

                capacity(): number;
                position(): number;
                position(arg0: int): Buffer;
                limit(): number;
                limit(arg0: int): Buffer;
                mark(): Buffer;
                reset(): Buffer;
                clear(): Buffer;
                flip(): Buffer;
                rewind(): Buffer;
                remaining(): number;
                hasRemaining(): boolean;
                isReadOnly(): boolean;
                hasArray(): boolean;
                array(): any;
                arrayOffset(): number;
                isDirect(): boolean;
                slice(): Buffer;
                slice(arg0: int, arg1: int): Buffer;
                duplicate(): Buffer;

            }

            const IntBuffer: JavaClassStatics<IntBuffer> & NoConstructor & {

                allocate(arg0: int): IntBuffer;
                wrap(arg0: int[], arg1: int, arg2: int): IntBuffer;
                wrap(arg0: int[]): IntBuffer;

            }
            interface IntBuffer extends Buffer, java.lang.Comparable<IntBuffer> {

                slice(): IntBuffer;
                slice(arg0: int, arg1: int): IntBuffer;
                duplicate(): IntBuffer;
                asReadOnlyBuffer(): IntBuffer;
                get(): number;
                put(arg0: int): IntBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: int): IntBuffer;
                get(arg0: int[], arg1: int, arg2: int): IntBuffer;
                get(arg0: int[]): IntBuffer;
                get(arg0: int, arg1: int[], arg2: int, arg3: int): IntBuffer;
                get(arg0: int, arg1: int[]): IntBuffer;
                put(arg0: IntBuffer): IntBuffer;
                put(arg0: int, arg1: IntBuffer, arg2: int, arg3: int): IntBuffer;
                put(arg0: int[], arg1: int, arg2: int): IntBuffer;
                put(arg0: int[]): IntBuffer;
                put(arg0: int, arg1: int[], arg2: int, arg3: int): IntBuffer;
                put(arg0: int, arg1: int[]): IntBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): IntBuffer;
                position(): number;
                limit(arg0: int): IntBuffer;
                limit(): number;
                mark(): IntBuffer;
                reset(): IntBuffer;
                clear(): IntBuffer;
                flip(): IntBuffer;
                rewind(): IntBuffer;
                compact(): IntBuffer;
                isDirect(): boolean;
                compareTo(arg0: IntBuffer): number;
                mismatch(arg0: IntBuffer): number;
                order(): ByteOrder;

            }

            const ByteOrder: JavaClassStatics<ByteOrder> & NoConstructor & {
                readonly BIG_ENDIAN: ByteOrder;
                readonly LITTLE_ENDIAN: ByteOrder;

                nativeOrder(): ByteOrder;

            }
            interface ByteOrder extends JavaObject {}

            const CharBuffer: JavaClassStatics<CharBuffer> & NoConstructor & {

                allocate(arg0: int): CharBuffer;
                wrap(arg0: char[], arg1: int, arg2: int): CharBuffer;
                wrap(arg0: char[]): CharBuffer;
                wrap(arg0: java.lang.CharSequence, arg1: int, arg2: int): CharBuffer;
                wrap(arg0: java.lang.CharSequence): CharBuffer;

            }
            interface CharBuffer extends Buffer, java.lang.Comparable<CharBuffer>, java.lang.Appendable, java.lang.CharSequence, java.lang.Readable {

                read(arg0: CharBuffer): number;
                slice(): CharBuffer;
                slice(arg0: int, arg1: int): CharBuffer;
                duplicate(): CharBuffer;
                asReadOnlyBuffer(): CharBuffer;
                get(): number;
                put(arg0: char): CharBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: char): CharBuffer;
                get(arg0: char[], arg1: int, arg2: int): CharBuffer;
                get(arg0: char[]): CharBuffer;
                get(arg0: int, arg1: char[], arg2: int, arg3: int): CharBuffer;
                get(arg0: int, arg1: char[]): CharBuffer;
                put(arg0: CharBuffer): CharBuffer;
                put(arg0: int, arg1: CharBuffer, arg2: int, arg3: int): CharBuffer;
                put(arg0: char[], arg1: int, arg2: int): CharBuffer;
                put(arg0: char[]): CharBuffer;
                put(arg0: int, arg1: char[], arg2: int, arg3: int): CharBuffer;
                put(arg0: int, arg1: char[]): CharBuffer;
                put(arg0: string, arg1: int, arg2: int): CharBuffer;
                put(arg0: string): CharBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): CharBuffer;
                position(): number;
                limit(arg0: int): CharBuffer;
                limit(): number;
                mark(): CharBuffer;
                reset(): CharBuffer;
                clear(): CharBuffer;
                flip(): CharBuffer;
                rewind(): CharBuffer;
                compact(): CharBuffer;
                isDirect(): boolean;
                compareTo(arg0: CharBuffer): number;
                mismatch(arg0: CharBuffer): number;
                length(): number;
                isEmpty(): boolean;
                charAt(arg0: int): number;
                subSequence(arg0: int, arg1: int): CharBuffer;
                append(arg0: java.lang.CharSequence): CharBuffer;
                append(arg0: java.lang.CharSequence, arg1: int, arg2: int): CharBuffer;
                append(arg0: char): CharBuffer;
                order(): ByteOrder;
                chars(): java.util.stream.IntStream;

            }

            const ShortBuffer: JavaClassStatics<ShortBuffer> & NoConstructor & {

                allocate(arg0: int): ShortBuffer;
                wrap(arg0: short[], arg1: int, arg2: int): ShortBuffer;
                wrap(arg0: short[]): ShortBuffer;

            }
            interface ShortBuffer extends Buffer, java.lang.Comparable<ShortBuffer> {

                slice(): ShortBuffer;
                slice(arg0: int, arg1: int): ShortBuffer;
                duplicate(): ShortBuffer;
                asReadOnlyBuffer(): ShortBuffer;
                get(): number;
                put(arg0: short): ShortBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: short): ShortBuffer;
                get(arg0: short[], arg1: int, arg2: int): ShortBuffer;
                get(arg0: short[]): ShortBuffer;
                get(arg0: int, arg1: short[], arg2: int, arg3: int): ShortBuffer;
                get(arg0: int, arg1: short[]): ShortBuffer;
                put(arg0: ShortBuffer): ShortBuffer;
                put(arg0: int, arg1: ShortBuffer, arg2: int, arg3: int): ShortBuffer;
                put(arg0: short[], arg1: int, arg2: int): ShortBuffer;
                put(arg0: short[]): ShortBuffer;
                put(arg0: int, arg1: short[], arg2: int, arg3: int): ShortBuffer;
                put(arg0: int, arg1: short[]): ShortBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): ShortBuffer;
                position(): number;
                limit(arg0: int): ShortBuffer;
                limit(): number;
                mark(): ShortBuffer;
                reset(): ShortBuffer;
                clear(): ShortBuffer;
                flip(): ShortBuffer;
                rewind(): ShortBuffer;
                compact(): ShortBuffer;
                isDirect(): boolean;
                compareTo(arg0: ShortBuffer): number;
                mismatch(arg0: ShortBuffer): number;
                order(): ByteOrder;

            }

            const FloatBuffer: JavaClassStatics<FloatBuffer> & NoConstructor & {

                allocate(arg0: int): FloatBuffer;
                wrap(arg0: float[], arg1: int, arg2: int): FloatBuffer;
                wrap(arg0: float[]): FloatBuffer;

            }
            interface FloatBuffer extends Buffer, java.lang.Comparable<FloatBuffer> {

                slice(): FloatBuffer;
                slice(arg0: int, arg1: int): FloatBuffer;
                duplicate(): FloatBuffer;
                asReadOnlyBuffer(): FloatBuffer;
                get(): number;
                put(arg0: float): FloatBuffer;
                get(arg0: int): number;
                put(arg0: int, arg1: float): FloatBuffer;
                get(arg0: float[], arg1: int, arg2: int): FloatBuffer;
                get(arg0: float[]): FloatBuffer;
                get(arg0: int, arg1: float[], arg2: int, arg3: int): FloatBuffer;
                get(arg0: int, arg1: float[]): FloatBuffer;
                put(arg0: FloatBuffer): FloatBuffer;
                put(arg0: int, arg1: FloatBuffer, arg2: int, arg3: int): FloatBuffer;
                put(arg0: float[], arg1: int, arg2: int): FloatBuffer;
                put(arg0: float[]): FloatBuffer;
                put(arg0: int, arg1: float[], arg2: int, arg3: int): FloatBuffer;
                put(arg0: int, arg1: float[]): FloatBuffer;
                hasArray(): boolean;
                array(): JavaArray<number>;
                arrayOffset(): number;
                position(arg0: int): FloatBuffer;
                position(): number;
                limit(arg0: int): FloatBuffer;
                limit(): number;
                mark(): FloatBuffer;
                reset(): FloatBuffer;
                clear(): FloatBuffer;
                flip(): FloatBuffer;
                rewind(): FloatBuffer;
                compact(): FloatBuffer;
                isDirect(): boolean;
                compareTo(arg0: FloatBuffer): number;
                mismatch(arg0: FloatBuffer): number;
                order(): ByteOrder;

            }

            const MappedByteBuffer: JavaClassStatics<MappedByteBuffer> & NoConstructor;
            interface MappedByteBuffer extends ByteBuffer {

                isLoaded(): boolean;
                load(): MappedByteBuffer;
                force(): MappedByteBuffer;
                force(arg0: int, arg1: int): MappedByteBuffer;
                position(arg0: int): MappedByteBuffer;
                position(): number;
                limit(arg0: int): MappedByteBuffer;
                limit(): number;
                mark(): MappedByteBuffer;
                reset(): MappedByteBuffer;
                clear(): MappedByteBuffer;
                flip(): MappedByteBuffer;
                rewind(): MappedByteBuffer;
                slice(): MappedByteBuffer;
                slice(arg0: int, arg1: int): MappedByteBuffer;
                duplicate(): MappedByteBuffer;
                compact(): MappedByteBuffer;

            }

            export {
                ByteBuffer,
                LongBuffer,
                DoubleBuffer,
                Buffer,
                IntBuffer,
                ByteOrder,
                CharBuffer,
                ShortBuffer,
                FloatBuffer,
                MappedByteBuffer
            }

        }
        namespace nio {

            namespace file {

                const Path: JavaInterfaceStatics<Path> & {

                    of(arg0: string, ...arg1: string[]): Path;
                    of(arg0: java.net.URI): Path;

                }
                interface Path extends java.lang.Comparable<Path>, java.lang.Iterable<Path>, Watchable {

                    getFileSystem(): FileSystem;
                    isAbsolute(): boolean;
                    getRoot(): Path;
                    getFileName(): Path;
                    getParent(): Path;
                    getNameCount(): number;
                    getName(arg0: int): Path;
                    subpath(arg0: int, arg1: int): Path;
                    startsWith(arg0: Path): boolean;
                    startsWith(arg0: string): boolean;
                    endsWith(arg0: Path): boolean;
                    endsWith(arg0: string): boolean;
                    normalize(): Path;
                    resolve(arg0: Path): Path;
                    resolve(arg0: string): Path;
                    resolveSibling(arg0: Path): Path;
                    resolveSibling(arg0: string): Path;
                    relativize(arg0: Path): Path;
                    toUri(): java.net.URI;
                    toAbsolutePath(): Path;
                    toRealPath(...arg0: LinkOption[]): Path;
                    toFile(): java.io.File;
                    register(arg0: WatchService, arg1: WatchEvent$Kind<any>[], ...arg2: WatchEvent$Modifier[]): WatchKey;
                    register(arg0: WatchService, ...arg1: WatchEvent$Kind<any>[]): WatchKey;
                    iterator(): java.util.Iterator<Path>;
                    compareTo(arg0: Path): number;

                }

                const WatchKey: JavaInterfaceStatics<WatchKey>;
                interface WatchKey extends JavaObject {

                    isValid(): boolean;
                    pollEvents(): JavaList<WatchEvent<any>>;
                    reset(): boolean;
                    cancel(): void;
                    watchable(): Watchable;

                }

                const LinkOption: JavaClassStatics<LinkOption> & NoConstructor & {
                    readonly NOFOLLOW_LINKS: LinkOption;

                    values(): JavaArray<LinkOption>;
                    valueOf(arg0: string): LinkOption;

                }
                interface LinkOption extends java.lang.Enum<LinkOption>, OpenOption, CopyOption {}

                const Watchable: JavaInterfaceStatics<Watchable>;
                interface Watchable extends JavaObject {

                    register(arg0: WatchService, arg1: WatchEvent$Kind<any>[], ...arg2: WatchEvent$Modifier[]): WatchKey;
                    register(arg0: WatchService, ...arg1: WatchEvent$Kind<any>[]): WatchKey;

                }

                const WatchEvent$Kind: JavaInterfaceStatics<WatchEvent$Kind<any>>;
                interface WatchEvent$Kind<T> extends JavaObject {

                    name(): string;
                    type(): JavaClass<T>;

                }

                const FileSystem: JavaClassStatics<FileSystem> & NoConstructor;
                interface FileSystem extends java.io.Closeable {

                    provider(): java.nio.file.spi.FileSystemProvider;
                    close(): void;
                    isOpen(): boolean;
                    isReadOnly(): boolean;
                    getSeparator(): string;
                    getRootDirectories(): java.lang.Iterable<Path>;
                    getFileStores(): java.lang.Iterable<FileStore>;
                    supportedFileAttributeViews(): JavaSet<string>;
                    getPath(arg0: string, ...arg1: string[]): Path;
                    getPathMatcher(arg0: string): PathMatcher;
                    getUserPrincipalLookupService(): java.nio.file.attribute.UserPrincipalLookupService;
                    newWatchService(): WatchService;

                }

                const WatchEvent$Modifier: JavaInterfaceStatics<WatchEvent$Modifier>;
                interface WatchEvent$Modifier extends JavaObject {

                    name(): string;

                }

                const WatchService: JavaInterfaceStatics<WatchService>;
                interface WatchService extends java.io.Closeable {

                    close(): void;
                    poll(): WatchKey;
                    poll(arg0: long, arg1: java.util.concurrent.TimeUnit): WatchKey;
                    take(): WatchKey;

                }

                const DirectoryStream: JavaInterfaceStatics<DirectoryStream<any>>;
                interface DirectoryStream<T> extends java.io.Closeable, java.lang.Iterable<T> {

                    iterator(): java.util.Iterator<T>;

                }

                const CopyOption: JavaInterfaceStatics<CopyOption>;
                interface CopyOption extends JavaObject {}

                const AccessMode: JavaClassStatics<AccessMode> & NoConstructor & {
                    readonly READ: AccessMode;
                    readonly WRITE: AccessMode;
                    readonly EXECUTE: AccessMode;

                    values(): JavaArray<AccessMode>;
                    valueOf(arg0: string): AccessMode;

                }
                interface AccessMode extends java.lang.Enum<AccessMode> {}

                const WatchEvent: JavaInterfaceStatics<WatchEvent<any>>;
                interface WatchEvent<T> extends JavaObject {

                    kind(): WatchEvent$Kind<T>;
                    count(): number;
                    context(): T;

                }

                const DirectoryStream$Filter: JavaInterfaceStatics<DirectoryStream$Filter<any>>;
                interface DirectoryStream$Filter<T> extends JavaObject {

                    accept(arg0: T): boolean;

                }

                const OpenOption: JavaInterfaceStatics<OpenOption>;
                interface OpenOption extends JavaObject {}

                const FileStore: JavaClassStatics<FileStore> & NoConstructor;
                interface FileStore extends JavaObject {

                    name(): string;
                    type(): string;
                    isReadOnly(): boolean;
                    getTotalSpace(): number;
                    getUsableSpace(): number;
                    getUnallocatedSpace(): number;
                    getBlockSize(): number;
                    supportsFileAttributeView(arg0: JavaClassArg<any>): boolean;
                    supportsFileAttributeView(arg0: string): boolean;
                    getFileStoreAttributeView<V extends java.nio.file.attribute.FileStoreAttributeView>(arg0: JavaClassArg<V>): V;
                    getAttribute(arg0: string): any;

                }

                const PathMatcher: JavaInterfaceStatics<PathMatcher>;
                interface PathMatcher extends JavaObject {

                    matches(arg0: Path): boolean;

                }

                export {
                    Path,
                    WatchKey,
                    LinkOption,
                    Watchable,
                    WatchEvent$Kind,
                    FileSystem,
                    WatchEvent$Modifier,
                    WatchService,
                    DirectoryStream,
                    CopyOption,
                    AccessMode,
                    WatchEvent,
                    DirectoryStream$Filter,
                    OpenOption,
                    FileStore,
                    PathMatcher
                }

            }
            namespace file {

                namespace attribute {

                    const BasicFileAttributes: JavaInterfaceStatics<BasicFileAttributes>;
                    interface BasicFileAttributes extends JavaObject {

                        lastModifiedTime(): FileTime;
                        lastAccessTime(): FileTime;
                        creationTime(): FileTime;
                        isRegularFile(): boolean;
                        isDirectory(): boolean;
                        isSymbolicLink(): boolean;
                        isOther(): boolean;
                        size(): number;
                        fileKey(): any;

                    }

                    const FileTime: JavaClassStatics<FileTime> & NoConstructor & {

                        from(arg0: long, arg1: java.util.concurrent.TimeUnit): FileTime;
                        fromMillis(arg0: long): FileTime;
                        from(arg0: java.time.Instant): FileTime;

                    }
                    interface FileTime extends java.lang.Comparable<FileTime> {

                        to(arg0: java.util.concurrent.TimeUnit): number;
                        toMillis(): number;
                        toInstant(): java.time.Instant;
                        compareTo(arg0: FileTime): number;

                    }

                    const FileAttributeView: JavaInterfaceStatics<FileAttributeView>;
                    interface FileAttributeView extends AttributeView {}

                    const UserPrincipalLookupService: JavaClassStatics<UserPrincipalLookupService> & NoConstructor;
                    interface UserPrincipalLookupService extends JavaObject {

                        lookupPrincipalByName(arg0: string): UserPrincipal;
                        lookupPrincipalByGroupName(arg0: string): GroupPrincipal;

                    }

                    const FileAttribute: JavaInterfaceStatics<FileAttribute<any>>;
                    interface FileAttribute<T> extends JavaObject {

                        name(): string;
                        value(): T;

                    }

                    const UserPrincipal: JavaInterfaceStatics<UserPrincipal>;
                    interface UserPrincipal extends java.security.Principal {}

                    const AttributeView: JavaInterfaceStatics<AttributeView>;
                    interface AttributeView extends JavaObject {

                        name(): string;

                    }

                    const GroupPrincipal: JavaInterfaceStatics<GroupPrincipal>;
                    interface GroupPrincipal extends UserPrincipal {}

                    const FileStoreAttributeView: JavaInterfaceStatics<FileStoreAttributeView>;
                    interface FileStoreAttributeView extends AttributeView {}

                    export {
                        BasicFileAttributes,
                        FileTime,
                        FileAttributeView,
                        UserPrincipalLookupService,
                        FileAttribute,
                        UserPrincipal,
                        AttributeView,
                        GroupPrincipal,
                        FileStoreAttributeView
                    }

                }

                namespace spi {

                    const FileSystemProvider: JavaClassStatics<FileSystemProvider> & NoConstructor & {

                        installedProviders(): JavaList<FileSystemProvider>;

                    }
                    interface FileSystemProvider extends JavaObject {

                        getScheme(): string;
                        newFileSystem(arg0: java.net.URI, arg1: JavaMap<string, any>): java.nio.file.FileSystem;
                        getFileSystem(arg0: java.net.URI): java.nio.file.FileSystem;
                        getPath(arg0: java.net.URI): java.nio.file.Path;
                        newFileSystem(arg0: java.nio.file.Path, arg1: JavaMap<string, any>): java.nio.file.FileSystem;
                        newInputStream(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.InputStream;
                        newOutputStream(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): java.io.OutputStream;
                        newFileChannel(arg0: java.nio.file.Path, arg1: JavaSet<any>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.FileChannel;
                        newAsynchronousFileChannel(arg0: java.nio.file.Path, arg1: JavaSet<any>, arg2: java.util.concurrent.ExecutorService, ...arg3: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.AsynchronousFileChannel;
                        newByteChannel(arg0: java.nio.file.Path, arg1: JavaSet<any>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): java.nio.channels.SeekableByteChannel;
                        newDirectoryStream(arg0: java.nio.file.Path, arg1: java.nio.file.DirectoryStream$Filter<any>): java.nio.file.DirectoryStream<java.nio.file.Path>;
                        createDirectory(arg0: java.nio.file.Path, ...arg1: java.nio.file.attribute.FileAttribute<any>[]): void;
                        createSymbolicLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): void;
                        createLink(arg0: java.nio.file.Path, arg1: java.nio.file.Path): void;
                        delete(arg0: java.nio.file.Path): void;
                        deleteIfExists(arg0: java.nio.file.Path): boolean;
                        readSymbolicLink(arg0: java.nio.file.Path): java.nio.file.Path;
                        copy(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): void;
                        move(arg0: java.nio.file.Path, arg1: java.nio.file.Path, ...arg2: java.nio.file.CopyOption[]): void;
                        isSameFile(arg0: java.nio.file.Path, arg1: java.nio.file.Path): boolean;
                        isHidden(arg0: java.nio.file.Path): boolean;
                        getFileStore(arg0: java.nio.file.Path): java.nio.file.FileStore;
                        checkAccess(arg0: java.nio.file.Path, ...arg1: java.nio.file.AccessMode[]): void;
                        getFileAttributeView<V extends java.nio.file.attribute.FileAttributeView>(arg0: java.nio.file.Path, arg1: JavaClassArg<V>, ...arg2: java.nio.file.LinkOption[]): V;
                        readAttributes<A extends java.nio.file.attribute.BasicFileAttributes>(arg0: java.nio.file.Path, arg1: JavaClassArg<A>, ...arg2: java.nio.file.LinkOption[]): A;
                        readAttributes(arg0: java.nio.file.Path, arg1: string, ...arg2: java.nio.file.LinkOption[]): JavaMap<string, any>;
                        setAttribute(arg0: java.nio.file.Path, arg1: string, arg2: any, ...arg3: java.nio.file.LinkOption[]): void;

                    }

                    export { FileSystemProvider }

                }

            }

            namespace charset {

                const Charset: JavaClassStatics<Charset> & NoConstructor & {

                    isSupported(arg0: string): boolean;
                    forName(arg0: string): Charset;
                    availableCharsets(): java.util.SortedMap<string, Charset>;
                    defaultCharset(): Charset;

                }
                interface Charset extends java.lang.Comparable<Charset> {

                    name(): string;
                    aliases(): JavaSet<string>;
                    displayName(): string;
                    isRegistered(): boolean;
                    displayName(arg0: java.util.Locale): string;
                    contains(arg0: Charset): boolean;
                    newDecoder(): CharsetDecoder;
                    newEncoder(): CharsetEncoder;
                    canEncode(): boolean;
                    decode(arg0: java.nio.ByteBuffer): java.nio.CharBuffer;
                    encode(arg0: java.nio.CharBuffer): java.nio.ByteBuffer;
                    encode(arg0: string): java.nio.ByteBuffer;
                    compareTo(arg0: Charset): number;

                }

                const CharsetDecoder: JavaClassStatics<CharsetDecoder> & NoConstructor;
                interface CharsetDecoder extends JavaObject {

                    charset(): Charset;
                    replacement(): string;
                    replaceWith(arg0: string): CharsetDecoder;
                    malformedInputAction(): CodingErrorAction;
                    onMalformedInput(arg0: CodingErrorAction): CharsetDecoder;
                    unmappableCharacterAction(): CodingErrorAction;
                    onUnmappableCharacter(arg0: CodingErrorAction): CharsetDecoder;
                    averageCharsPerByte(): number;
                    maxCharsPerByte(): number;
                    decode(arg0: java.nio.ByteBuffer, arg1: java.nio.CharBuffer, arg2: boolean): CoderResult;
                    flush(arg0: java.nio.CharBuffer): CoderResult;
                    reset(): CharsetDecoder;
                    decode(arg0: java.nio.ByteBuffer): java.nio.CharBuffer;
                    isAutoDetecting(): boolean;
                    isCharsetDetected(): boolean;
                    detectedCharset(): Charset;

                }

                const CharsetEncoder: JavaClassStatics<CharsetEncoder> & NoConstructor;
                interface CharsetEncoder extends JavaObject {

                    charset(): Charset;
                    replacement(): JavaArray<number>;
                    replaceWith(arg0: byte[]): CharsetEncoder;
                    isLegalReplacement(arg0: byte[]): boolean;
                    malformedInputAction(): CodingErrorAction;
                    onMalformedInput(arg0: CodingErrorAction): CharsetEncoder;
                    unmappableCharacterAction(): CodingErrorAction;
                    onUnmappableCharacter(arg0: CodingErrorAction): CharsetEncoder;
                    averageBytesPerChar(): number;
                    maxBytesPerChar(): number;
                    encode(arg0: java.nio.CharBuffer, arg1: java.nio.ByteBuffer, arg2: boolean): CoderResult;
                    flush(arg0: java.nio.ByteBuffer): CoderResult;
                    reset(): CharsetEncoder;
                    encode(arg0: java.nio.CharBuffer): java.nio.ByteBuffer;
                    canEncode(arg0: char): boolean;
                    canEncode(arg0: java.lang.CharSequence): boolean;

                }

                const CoderResult: JavaClassStatics<CoderResult> & NoConstructor & {
                    readonly UNDERFLOW: CoderResult;
                    readonly OVERFLOW: CoderResult;

                    malformedForLength(arg0: int): CoderResult;
                    unmappableForLength(arg0: int): CoderResult;

                }
                interface CoderResult extends JavaObject {

                    isUnderflow(): boolean;
                    isOverflow(): boolean;
                    isError(): boolean;
                    isMalformed(): boolean;
                    isUnmappable(): boolean;
                    length(): number;
                    throwException(): void;

                }

                const CodingErrorAction: JavaClassStatics<CodingErrorAction> & NoConstructor & {
                    readonly IGNORE: CodingErrorAction;
                    readonly REPLACE: CodingErrorAction;
                    readonly REPORT: CodingErrorAction;
                }
                interface CodingErrorAction extends JavaObject {}

                export {
                    Charset,
                    CharsetDecoder,
                    CharsetEncoder,
                    CoderResult,
                    CodingErrorAction
                }

            }

            namespace channels {

                const AsynchronousFileChannel: JavaClassStatics<AsynchronousFileChannel> & NoConstructor & {

                    open(arg0: java.nio.file.Path, arg1: JavaSet<any>, arg2: java.util.concurrent.ExecutorService, ...arg3: java.nio.file.attribute.FileAttribute<any>[]): AsynchronousFileChannel;
                    open(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): AsynchronousFileChannel;

                }
                interface AsynchronousFileChannel extends AsynchronousChannel {

                    size(): number;
                    truncate(arg0: long): AsynchronousFileChannel;
                    force(arg0: boolean): void;
                    lock<A>(arg0: long, arg1: long, arg2: boolean, arg3: A, arg4: CompletionHandler<FileLock, any>): void;
                    lock<A>(arg0: A, arg1: CompletionHandler<FileLock, any>): void;
                    lock(arg0: long, arg1: long, arg2: boolean): java.util.concurrent.Future<FileLock>;
                    lock(): java.util.concurrent.Future<FileLock>;
                    tryLock(arg0: long, arg1: long, arg2: boolean): FileLock;
                    tryLock(): FileLock;
                    read<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: CompletionHandler<int, any>): void;
                    read(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<number>;
                    write<A>(arg0: java.nio.ByteBuffer, arg1: long, arg2: A, arg3: CompletionHandler<int, any>): void;
                    write(arg0: java.nio.ByteBuffer, arg1: long): java.util.concurrent.Future<number>;

                }

                const SeekableByteChannel: JavaInterfaceStatics<SeekableByteChannel>;
                interface SeekableByteChannel extends ByteChannel {

                    read(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    position(): number;
                    position(arg0: long): SeekableByteChannel;
                    size(): number;
                    truncate(arg0: long): SeekableByteChannel;

                }

                const FileChannel: JavaClassStatics<FileChannel> & NoConstructor & {

                    open(arg0: java.nio.file.Path, arg1: JavaSet<any>, ...arg2: java.nio.file.attribute.FileAttribute<any>[]): FileChannel;
                    open(arg0: java.nio.file.Path, ...arg1: java.nio.file.OpenOption[]): FileChannel;

                }
                interface FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel, SeekableByteChannel, GatheringByteChannel, ScatteringByteChannel {

                    read(arg0: java.nio.ByteBuffer): number;
                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    position(): number;
                    position(arg0: long): FileChannel;
                    size(): number;
                    truncate(arg0: long): FileChannel;
                    force(arg0: boolean): void;
                    transferTo(arg0: long, arg1: long, arg2: WritableByteChannel): number;
                    transferFrom(arg0: ReadableByteChannel, arg1: long, arg2: long): number;
                    read(arg0: java.nio.ByteBuffer, arg1: long): number;
                    write(arg0: java.nio.ByteBuffer, arg1: long): number;
                    map(arg0: FileChannel$MapMode, arg1: long, arg2: long): java.nio.MappedByteBuffer;
                    lock(arg0: long, arg1: long, arg2: boolean): FileLock;
                    lock(): FileLock;
                    tryLock(arg0: long, arg1: long, arg2: boolean): FileLock;
                    tryLock(): FileLock;

                }

                const WritableByteChannel: JavaInterfaceStatics<WritableByteChannel>;
                interface WritableByteChannel extends Channel {

                    write(arg0: java.nio.ByteBuffer): number;

                }

                const FileChannel$MapMode: JavaClassStatics<FileChannel$MapMode> & NoConstructor & {
                    readonly READ_ONLY: FileChannel$MapMode;
                    readonly READ_WRITE: FileChannel$MapMode;
                    readonly PRIVATE: FileChannel$MapMode;
                }
                interface FileChannel$MapMode extends JavaObject {}

                const FileLock: JavaClassStatics<FileLock> & NoConstructor;
                interface FileLock extends java.lang.AutoCloseable {

                    channel(): FileChannel;
                    acquiredBy(): Channel;
                    position(): number;
                    size(): number;
                    isShared(): boolean;
                    overlaps(arg0: long, arg1: long): boolean;
                    isValid(): boolean;
                    release(): void;
                    close(): void;

                }

                const ScatteringByteChannel: JavaInterfaceStatics<ScatteringByteChannel>;
                interface ScatteringByteChannel extends ReadableByteChannel {

                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;

                }

                const CompletionHandler: JavaInterfaceStatics<CompletionHandler<any, any>>;
                interface CompletionHandler<V, A> extends JavaObject {

                    completed(arg0: V, arg1: A): void;
                    failed(arg0: java.lang.Throwable, arg1: A): void;

                }

                const ReadableByteChannel: JavaInterfaceStatics<ReadableByteChannel>;
                interface ReadableByteChannel extends Channel {

                    read(arg0: java.nio.ByteBuffer): number;

                }

                const ByteChannel: JavaInterfaceStatics<ByteChannel>;
                interface ByteChannel extends ReadableByteChannel, WritableByteChannel {}

                const Channel: JavaInterfaceStatics<Channel>;
                interface Channel extends java.io.Closeable {

                    isOpen(): boolean;
                    close(): void;

                }

                const InterruptibleChannel: JavaInterfaceStatics<InterruptibleChannel>;
                interface InterruptibleChannel extends Channel {

                    close(): void;

                }

                const AsynchronousChannel: JavaInterfaceStatics<AsynchronousChannel>;
                interface AsynchronousChannel extends Channel {

                    close(): void;

                }

                const GatheringByteChannel: JavaInterfaceStatics<GatheringByteChannel>;
                interface GatheringByteChannel extends WritableByteChannel {

                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;

                }

                const SocketChannel: JavaClassStatics<SocketChannel> & NoConstructor & {

                    open(): SocketChannel;
                    open(arg0: java.net.ProtocolFamily): SocketChannel;
                    open(arg0: java.net.SocketAddress): SocketChannel;

                }
                interface SocketChannel extends java.nio.channels.spi.AbstractSelectableChannel, ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel {

                    validOps(): number;
                    bind(arg0: java.net.SocketAddress): SocketChannel;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): SocketChannel;
                    shutdownInput(): SocketChannel;
                    shutdownOutput(): SocketChannel;
                    socket(): java.net.Socket;
                    isConnected(): boolean;
                    isConnectionPending(): boolean;
                    connect(arg0: java.net.SocketAddress): boolean;
                    finishConnect(): boolean;
                    getRemoteAddress(): java.net.SocketAddress;
                    read(arg0: java.nio.ByteBuffer): number;
                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    getLocalAddress(): java.net.SocketAddress;

                }

                const DatagramChannel: JavaClassStatics<DatagramChannel> & NoConstructor & {

                    open(): DatagramChannel;
                    open(arg0: java.net.ProtocolFamily): DatagramChannel;

                }
                interface DatagramChannel extends java.nio.channels.spi.AbstractSelectableChannel, ByteChannel, ScatteringByteChannel, GatheringByteChannel, MulticastChannel {

                    validOps(): number;
                    bind(arg0: java.net.SocketAddress): DatagramChannel;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): DatagramChannel;
                    socket(): java.net.DatagramSocket;
                    isConnected(): boolean;
                    connect(arg0: java.net.SocketAddress): DatagramChannel;
                    disconnect(): DatagramChannel;
                    getRemoteAddress(): java.net.SocketAddress;
                    receive(arg0: java.nio.ByteBuffer): java.net.SocketAddress;
                    send(arg0: java.nio.ByteBuffer, arg1: java.net.SocketAddress): number;
                    read(arg0: java.nio.ByteBuffer): number;
                    read(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    read(arg0: java.nio.ByteBuffer[]): number;
                    write(arg0: java.nio.ByteBuffer): number;
                    write(arg0: java.nio.ByteBuffer[], arg1: int, arg2: int): number;
                    write(arg0: java.nio.ByteBuffer[]): number;
                    getLocalAddress(): java.net.SocketAddress;

                }

                const Selector: JavaClassStatics<Selector> & NoConstructor & {

                    open(): Selector;

                }
                interface Selector extends java.io.Closeable {

                    isOpen(): boolean;
                    provider(): java.nio.channels.spi.SelectorProvider;
                    keys(): JavaSet<SelectionKey>;
                    selectedKeys(): JavaSet<SelectionKey>;
                    selectNow(): number;
                    select(arg0: long): number;
                    select(): number;
                    select(arg0: java.util.function.Consumer<SelectionKey>, arg1: long): number;
                    select(arg0: java.util.function.Consumer<SelectionKey>): number;
                    selectNow(arg0: java.util.function.Consumer<SelectionKey>): number;
                    wakeup(): Selector;
                    close(): void;

                }

                const NetworkChannel: JavaInterfaceStatics<NetworkChannel>;
                interface NetworkChannel extends Channel {

                    bind(arg0: java.net.SocketAddress): NetworkChannel;
                    getLocalAddress(): java.net.SocketAddress;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): NetworkChannel;
                    getOption<T>(arg0: java.net.SocketOption<T>): T;
                    supportedOptions(): JavaSet<java.net.SocketOption<any>>;

                }

                const Pipe: JavaClassStatics<Pipe> & NoConstructor & {

                    open(): Pipe;

                }
                interface Pipe extends JavaObject {

                    source(): Pipe$SourceChannel;
                    sink(): Pipe$SinkChannel;

                }

                const ServerSocketChannel: JavaClassStatics<ServerSocketChannel> & NoConstructor & {

                    open(): ServerSocketChannel;
                    open(arg0: java.net.ProtocolFamily): ServerSocketChannel;

                }
                interface ServerSocketChannel extends java.nio.channels.spi.AbstractSelectableChannel, NetworkChannel {

                    validOps(): number;
                    bind(arg0: java.net.SocketAddress): ServerSocketChannel;
                    bind(arg0: java.net.SocketAddress, arg1: int): ServerSocketChannel;
                    setOption<T>(arg0: java.net.SocketOption<T>, arg1: T): ServerSocketChannel;
                    socket(): java.net.ServerSocket;
                    accept(): SocketChannel;
                    getLocalAddress(): java.net.SocketAddress;

                }

                const SelectionKey: JavaClassStatics<SelectionKey> & NoConstructor & {
                    readonly OP_READ: number;
                    readonly OP_WRITE: number;
                    readonly OP_CONNECT: number;
                    readonly OP_ACCEPT: number;
                }
                interface SelectionKey extends JavaObject {

                    channel(): SelectableChannel;
                    selector(): Selector;
                    isValid(): boolean;
                    cancel(): void;
                    interestOps(): number;
                    interestOps(arg0: int): SelectionKey;
                    interestOpsOr(arg0: int): number;
                    interestOpsAnd(arg0: int): number;
                    readyOps(): number;
                    isReadable(): boolean;
                    isWritable(): boolean;
                    isConnectable(): boolean;
                    isAcceptable(): boolean;
                    attach(arg0: any): any;
                    attachment(): any;

                }

                const SelectableChannel: JavaClassStatics<SelectableChannel> & NoConstructor;
                interface SelectableChannel extends java.nio.channels.spi.AbstractInterruptibleChannel, Channel {

                    provider(): java.nio.channels.spi.SelectorProvider;
                    validOps(): number;
                    isRegistered(): boolean;
                    keyFor(arg0: Selector): SelectionKey;
                    register(arg0: Selector, arg1: int, arg2: any): SelectionKey;
                    register(arg0: Selector, arg1: int): SelectionKey;
                    configureBlocking(arg0: boolean): SelectableChannel;
                    isBlocking(): boolean;
                    blockingLock(): any;

                }

                const MulticastChannel: JavaInterfaceStatics<MulticastChannel>;
                interface MulticastChannel extends NetworkChannel {

                    close(): void;
                    join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface): MembershipKey;
                    join(arg0: java.net.InetAddress, arg1: java.net.NetworkInterface, arg2: java.net.InetAddress): MembershipKey;

                }

                const Pipe$SinkChannel: JavaClassStatics<Pipe$SinkChannel> & NoConstructor;
                interface Pipe$SinkChannel extends java.nio.channels.spi.AbstractSelectableChannel, WritableByteChannel, GatheringByteChannel {

                    validOps(): number;

                }

                const Pipe$SourceChannel: JavaClassStatics<Pipe$SourceChannel> & NoConstructor;
                interface Pipe$SourceChannel extends java.nio.channels.spi.AbstractSelectableChannel, ReadableByteChannel, ScatteringByteChannel {

                    validOps(): number;

                }

                const MembershipKey: JavaClassStatics<MembershipKey> & NoConstructor;
                interface MembershipKey extends JavaObject {

                    isValid(): boolean;
                    drop(): void;
                    block(arg0: java.net.InetAddress): MembershipKey;
                    unblock(arg0: java.net.InetAddress): MembershipKey;
                    channel(): MulticastChannel;
                    group(): java.net.InetAddress;
                    networkInterface(): java.net.NetworkInterface;
                    sourceAddress(): java.net.InetAddress;

                }

                export {
                    AsynchronousFileChannel,
                    SeekableByteChannel,
                    FileChannel,
                    WritableByteChannel,
                    FileChannel$MapMode,
                    FileLock,
                    ScatteringByteChannel,
                    CompletionHandler,
                    ReadableByteChannel,
                    ByteChannel,
                    Channel,
                    InterruptibleChannel,
                    AsynchronousChannel,
                    GatheringByteChannel,
                    SocketChannel,
                    DatagramChannel,
                    Selector,
                    NetworkChannel,
                    Pipe,
                    ServerSocketChannel,
                    SelectionKey,
                    SelectableChannel,
                    MulticastChannel,
                    Pipe$SinkChannel,
                    Pipe$SourceChannel,
                    MembershipKey
                }

            }
            namespace channels {

                namespace spi {

                    const AbstractInterruptibleChannel: JavaClassStatics<AbstractInterruptibleChannel> & NoConstructor;
                    interface AbstractInterruptibleChannel extends java.nio.channels.Channel, java.nio.channels.InterruptibleChannel {

                        close(): void;
                        isOpen(): boolean;

                    }

                    const AbstractSelectableChannel: JavaClassStatics<AbstractSelectableChannel> & NoConstructor;
                    interface AbstractSelectableChannel extends java.nio.channels.SelectableChannel {

                        provider(): SelectorProvider;
                        isRegistered(): boolean;
                        keyFor(arg0: java.nio.channels.Selector): java.nio.channels.SelectionKey;
                        register(arg0: java.nio.channels.Selector, arg1: int, arg2: any): java.nio.channels.SelectionKey;
                        register(arg0: java.nio.channels.Selector, arg1: int): java.nio.channels.SelectionKey;
                        isBlocking(): boolean;
                        blockingLock(): any;
                        configureBlocking(arg0: boolean): java.nio.channels.SelectableChannel;

                    }

                    const SelectorProvider: JavaClassStatics<SelectorProvider> & NoConstructor & {

                        provider(): SelectorProvider;

                    }
                    interface SelectorProvider extends JavaObject {

                        openDatagramChannel(): java.nio.channels.DatagramChannel;
                        openDatagramChannel(arg0: java.net.ProtocolFamily): java.nio.channels.DatagramChannel;
                        openPipe(): java.nio.channels.Pipe;
                        openSelector(): AbstractSelector;
                        openServerSocketChannel(): java.nio.channels.ServerSocketChannel;
                        openSocketChannel(): java.nio.channels.SocketChannel;
                        inheritedChannel(): java.nio.channels.Channel;
                        openSocketChannel(arg0: java.net.ProtocolFamily): java.nio.channels.SocketChannel;
                        openServerSocketChannel(arg0: java.net.ProtocolFamily): java.nio.channels.ServerSocketChannel;

                    }

                    const AbstractSelector: JavaClassStatics<AbstractSelector> & NoConstructor;
                    interface AbstractSelector extends java.nio.channels.Selector {

                        close(): void;
                        isOpen(): boolean;
                        provider(): SelectorProvider;

                    }

                    export {
                        AbstractInterruptibleChannel,
                        AbstractSelectableChannel,
                        SelectorProvider,
                        AbstractSelector
                    }

                }

            }

        }

        namespace lang {

            const Enum: JavaClassStatics<Enum<any>> & NoConstructor & {

                valueOf<T extends Enum<T>>(arg0: JavaClassArg<T>, arg1: String): T;

            }
            interface Enum<E extends Enum<E>> extends Object, java.lang.constant.Constable, Comparable<E>, java.io.Serializable {

                name(): String;
                ordinal(): number;
                compareTo(arg0: E): number;
                getDeclaringClass(): JavaClass<E>;
                describeConstable(): java.util.Optional<Enum$EnumDesc<E>>;

            }

            const Thread: JavaClassStatics<Thread, Thread$$constructor> & {
                readonly MIN_PRIORITY: number;
                readonly NORM_PRIORITY: number;
                readonly MAX_PRIORITY: number;

                currentThread(): Thread;
                yield(): void;
                sleep(arg0: long): void;
                sleep(arg0: long, arg1: int): void;
                onSpinWait(): void;
                interrupted(): boolean;
                activeCount(): number;
                enumerate(arg0: Thread[]): number;
                dumpStack(): void;
                holdsLock(arg0: Object): boolean;
                getAllStackTraces(): JavaMap<Thread, JavaArray<StackTraceElement>>;
                setDefaultUncaughtExceptionHandler(arg0: Thread$UncaughtExceptionHandler): void;
                getDefaultUncaughtExceptionHandler(): Thread$UncaughtExceptionHandler;

            }
            interface Thread$$constructor extends SuppressProperties {

                new (): Thread;
                new (arg0: Runnable): Thread;
                new (arg0: ThreadGroup, arg1: Runnable): Thread;
                new (arg0: String): Thread;
                new (arg0: ThreadGroup, arg1: String): Thread;
                new (arg0: Runnable, arg1: String): Thread;
                new (arg0: ThreadGroup, arg1: Runnable, arg2: String): Thread;
                new (arg0: ThreadGroup, arg1: Runnable, arg2: String, arg3: long): Thread;
                new (arg0: ThreadGroup, arg1: Runnable, arg2: String, arg3: long, arg4: boolean): Thread;

            }
            interface Thread extends Object, Runnable {

                start(): void;
                run(): void;
                /** @deprecated */
                stop(): void;
                interrupt(): void;
                isInterrupted(): boolean;
                isAlive(): boolean;
                /** @deprecated */
                suspend(): void;
                /** @deprecated */
                resume(): void;
                setPriority(arg0: int): void;
                getPriority(): number;
                setName(arg0: String): void;
                getName(): String;
                getThreadGroup(): ThreadGroup;
                /** @deprecated */
                countStackFrames(): number;
                join(arg0: long): void;
                join(arg0: long, arg1: int): void;
                join(): void;
                setDaemon(arg0: boolean): void;
                isDaemon(): boolean;
                /** @deprecated */
                checkAccess(): void;
                getContextClassLoader(): ClassLoader;
                setContextClassLoader(arg0: ClassLoader): void;
                getStackTrace(): JavaArray<StackTraceElement>;
                getId(): number;
                getState(): Thread$State;
                getUncaughtExceptionHandler(): Thread$UncaughtExceptionHandler;
                setUncaughtExceptionHandler(arg0: Thread$UncaughtExceptionHandler): void;

            }

            const Exception: JavaClassStatics<Exception, Exception$$constructor>;
            interface Exception$$constructor extends SuppressProperties {

                new (): Exception;
                new (arg0: String): Exception;
                new (arg0: String, arg1: Throwable): Exception;
                new (arg0: Throwable): Exception;

            }
            interface Exception extends Throwable {}

            const Number: JavaClassStatics<Number, Number$$constructor>;
            interface Number$$constructor extends SuppressProperties {

                new (): Number;

            }
            interface Number extends Object, java.io.Serializable {

                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                byteValue(): number;
                shortValue(): number;

            }

            const Comparable: JavaInterfaceStatics<Comparable<any>>;
            interface Comparable<T extends Object> extends JavaObject {

                compareTo(arg0: T): number;

            }

            const AutoCloseable: JavaInterfaceStatics<AutoCloseable>;
            interface AutoCloseable extends JavaObject {

                close(): void;

            }

            const Runnable: JavaInterfaceStatics<Runnable>;
            interface Runnable extends JavaObject {

                run(): void;

            }

            const Enum$EnumDesc: JavaClassStatics<Enum$EnumDesc<any>> & NoConstructor & {

                of<E extends Enum<E>>(arg0: java.lang.constant.ClassDesc, arg1: String): Enum$EnumDesc<E>;

            }
            interface Enum$EnumDesc<E extends Enum<E>> extends java.lang.constant.DynamicConstantDesc<E> {

                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): E;

            }

            const ThreadGroup: JavaClassStatics<ThreadGroup, ThreadGroup$$constructor>;
            interface ThreadGroup$$constructor extends SuppressProperties {

                new (arg0: String): ThreadGroup;
                new (arg0: ThreadGroup, arg1: String): ThreadGroup;

            }
            interface ThreadGroup extends Object, Thread$UncaughtExceptionHandler {

                getName(): String;
                getParent(): ThreadGroup;
                getMaxPriority(): number;
                /** @deprecated */
                isDaemon(): boolean;
                /** @deprecated */
                isDestroyed(): boolean;
                /** @deprecated */
                setDaemon(arg0: boolean): void;
                setMaxPriority(arg0: int): void;
                parentOf(arg0: ThreadGroup): boolean;
                /** @deprecated */
                checkAccess(): void;
                activeCount(): number;
                enumerate(arg0: Thread[]): number;
                enumerate(arg0: Thread[], arg1: boolean): number;
                activeGroupCount(): number;
                enumerate(arg0: ThreadGroup[]): number;
                enumerate(arg0: ThreadGroup[], arg1: boolean): number;
                /** @deprecated */
                stop(): void;
                interrupt(): void;
                /** @deprecated */
                suspend(): void;
                /** @deprecated */
                resume(): void;
                /** @deprecated */
                destroy(): void;
                list(): void;
                uncaughtException(arg0: Thread, arg1: Throwable): void;
                /** @deprecated */
                allowThreadSuspension(arg0: boolean): boolean;

            }

            const ClassLoader: JavaClassStatics<ClassLoader> & NoConstructor & {

                getSystemResource(arg0: String): java.net.URL;
                getSystemResources(arg0: String): java.util.Enumeration<java.net.URL>;
                getSystemResourceAsStream(arg0: String): java.io.InputStream;
                getPlatformClassLoader(): ClassLoader;
                getSystemClassLoader(): ClassLoader;

            }
            interface ClassLoader extends Object {

                getName(): String;
                loadClass(arg0: String): JavaClass<any>;
                getResource(arg0: String): java.net.URL;
                getResources(arg0: String): java.util.Enumeration<java.net.URL>;
                resources(arg0: String): java.util.stream.Stream<java.net.URL>;
                isRegisteredAsParallelCapable(): boolean;
                getResourceAsStream(arg0: String): java.io.InputStream;
                getParent(): ClassLoader;
                getUnnamedModule(): Module;
                getDefinedPackage(arg0: String): Package;
                getDefinedPackages(): JavaArray<Package>;
                setDefaultAssertionStatus(arg0: boolean): void;
                setPackageAssertionStatus(arg0: String, arg1: boolean): void;
                setClassAssertionStatus(arg0: String, arg1: boolean): void;
                clearAssertionStatus(): void;

            }

            const Thread$State: JavaClassStatics<Thread$State> & NoConstructor & {
                readonly NEW: Thread$State;
                readonly RUNNABLE: Thread$State;
                readonly BLOCKED: Thread$State;
                readonly WAITING: Thread$State;
                readonly TIMED_WAITING: Thread$State;
                readonly TERMINATED: Thread$State;

                values(): JavaArray<Thread$State>;
                valueOf(arg0: String): Thread$State;

            }
            interface Thread$State extends Enum<Thread$State> {}

            const Thread$UncaughtExceptionHandler: JavaInterfaceStatics<Thread$UncaughtExceptionHandler>;
            interface Thread$UncaughtExceptionHandler extends JavaObject {

                uncaughtException(arg0: Thread, arg1: Throwable): void;

            }

            const String: JavaClassStatics<String, String$$constructor> & {
                readonly CASE_INSENSITIVE_ORDER: java.util.Comparator<String>;

                join(arg0: CharSequence, ...arg1: CharSequence[]): String;
                join(arg0: CharSequence, arg1: Iterable<any>): String;
                format(arg0: String, ...arg1: Object[]): String;
                format(arg0: java.util.Locale, arg1: String, ...arg2: Object[]): String;
                valueOf(arg0: Object): String;
                valueOf(arg0: char[]): String;
                valueOf(arg0: char[], arg1: int, arg2: int): String;
                copyValueOf(arg0: char[], arg1: int, arg2: int): String;
                copyValueOf(arg0: char[]): String;
                valueOf(arg0: boolean): String;
                valueOf(arg0: char): String;
                valueOf(arg0: int): String;
                valueOf(arg0: long): String;
                valueOf(arg0: float): String;
                valueOf(arg0: double): String;

            }
            interface String$$constructor extends SuppressProperties {

                new (): String;
                new (arg0: String): String;
                new (arg0: char[]): String;
                new (arg0: char[], arg1: int, arg2: int): String;
                new (arg0: int[], arg1: int, arg2: int): String;
                /** @deprecated */
                new (arg0: byte[], arg1: int, arg2: int, arg3: int): String;
                /** @deprecated */
                new (arg0: byte[], arg1: int): String;
                new (arg0: byte[], arg1: int, arg2: int, arg3: String): String;
                new (arg0: byte[], arg1: int, arg2: int, arg3: java.nio.charset.Charset): String;
                new (arg0: byte[], arg1: String): String;
                new (arg0: byte[], arg1: java.nio.charset.Charset): String;
                new (arg0: byte[], arg1: int, arg2: int): String;
                new (arg0: byte[]): String;
                new (arg0: StringBuffer): String;
                new (arg0: StringBuilder): String;

            }
            interface String extends Object, java.io.Serializable, Comparable<String>, CharSequence, java.lang.constant.Constable, java.lang.constant.ConstantDesc {

                length(): number;
                isEmpty(): boolean;
                charAt(arg0: int): number;
                codePointAt(arg0: int): number;
                codePointBefore(arg0: int): number;
                codePointCount(arg0: int, arg1: int): number;
                offsetByCodePoints(arg0: int, arg1: int): number;
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void;
                /** @deprecated */
                getBytes(arg0: int, arg1: int, arg2: byte[], arg3: int): void;
                getBytes(arg0: String): JavaArray<number>;
                getBytes(arg0: java.nio.charset.Charset): JavaArray<number>;
                getBytes(): JavaArray<number>;
                contentEquals(arg0: StringBuffer): boolean;
                contentEquals(arg0: CharSequence): boolean;
                equalsIgnoreCase(arg0: String): boolean;
                compareTo(arg0: String): number;
                compareToIgnoreCase(arg0: String): number;
                regionMatches(arg0: int, arg1: String, arg2: int, arg3: int): boolean;
                regionMatches(arg0: boolean, arg1: int, arg2: String, arg3: int, arg4: int): boolean;
                startsWith(arg0: String, arg1: int): boolean;
                startsWith(arg0: String): boolean;
                endsWith(arg0: String): boolean;
                indexOf(arg0: int): number;
                indexOf(arg0: int, arg1: int): number;
                lastIndexOf(arg0: int): number;
                lastIndexOf(arg0: int, arg1: int): number;
                indexOf(arg0: String): number;
                indexOf(arg0: String, arg1: int): number;
                lastIndexOf(arg0: String): number;
                lastIndexOf(arg0: String, arg1: int): number;
                substring(arg0: int): String;
                substring(arg0: int, arg1: int): String;
                subSequence(arg0: int, arg1: int): CharSequence;
                concat(arg0: String): String;
                replace(arg0: char, arg1: char): String;
                matches(arg0: String): boolean;
                contains(arg0: CharSequence): boolean;
                replaceFirst(arg0: String, arg1: String): String;
                replaceAll(arg0: String, arg1: String): String;
                replace(arg0: CharSequence, arg1: CharSequence): String;
                split(arg0: String, arg1: int): JavaArray<String>;
                split(arg0: String): JavaArray<String>;
                toLowerCase(arg0: java.util.Locale): String;
                toLowerCase(): String;
                toUpperCase(arg0: java.util.Locale): String;
                toUpperCase(): String;
                trim(): String;
                strip(): String;
                stripLeading(): String;
                stripTrailing(): String;
                isBlank(): boolean;
                lines(): java.util.stream.Stream<String>;
                indent(arg0: int): String;
                stripIndent(): String;
                translateEscapes(): String;
                transform<R extends Object>(arg0: java.util.function.Function<any, any>): R;
                chars(): java.util.stream.IntStream;
                codePoints(): java.util.stream.IntStream;
                toCharArray(): JavaArray<number>;
                formatted(...arg0: Object[]): String;
                intern(): String;
                repeat(arg0: int): String;
                describeConstable(): java.util.Optional<String>;
                resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): String;

            }

            const StringBuilder: JavaClassStatics<StringBuilder, StringBuilder$$constructor>;
            interface StringBuilder$$constructor extends SuppressProperties {

                new (): StringBuilder;
                new (arg0: int): StringBuilder;
                new (arg0: String): StringBuilder;
                new (arg0: CharSequence): StringBuilder;

            }
            interface StringBuilder extends AbstractStringBuilder, java.io.Serializable, Comparable<StringBuilder>, CharSequence {

                compareTo(arg0: StringBuilder): number;
                append(arg0: Object): StringBuilder;
                append(arg0: String): StringBuilder;
                append(arg0: StringBuffer): StringBuilder;
                append(arg0: CharSequence): StringBuilder;
                append(arg0: CharSequence, arg1: int, arg2: int): StringBuilder;
                append(arg0: char[]): StringBuilder;
                append(arg0: char[], arg1: int, arg2: int): StringBuilder;
                append(arg0: boolean): StringBuilder;
                append(arg0: char): StringBuilder;
                append(arg0: int): StringBuilder;
                append(arg0: long): StringBuilder;
                append(arg0: float): StringBuilder;
                append(arg0: double): StringBuilder;
                appendCodePoint(arg0: int): StringBuilder;
                delete(arg0: int, arg1: int): StringBuilder;
                deleteCharAt(arg0: int): StringBuilder;
                replace(arg0: int, arg1: int, arg2: String): StringBuilder;
                insert(arg0: int, arg1: char[], arg2: int, arg3: int): StringBuilder;
                insert(arg0: int, arg1: Object): StringBuilder;
                insert(arg0: int, arg1: String): StringBuilder;
                insert(arg0: int, arg1: char[]): StringBuilder;
                insert(arg0: int, arg1: CharSequence): StringBuilder;
                insert(arg0: int, arg1: CharSequence, arg2: int, arg3: int): StringBuilder;
                insert(arg0: int, arg1: boolean): StringBuilder;
                insert(arg0: int, arg1: char): StringBuilder;
                insert(arg0: int, arg1: int): StringBuilder;
                insert(arg0: int, arg1: long): StringBuilder;
                insert(arg0: int, arg1: float): StringBuilder;
                insert(arg0: int, arg1: double): StringBuilder;
                indexOf(arg0: String): number;
                indexOf(arg0: String, arg1: int): number;
                lastIndexOf(arg0: String): number;
                lastIndexOf(arg0: String, arg1: int): number;
                reverse(): StringBuilder;

            }

            const StringBuffer: JavaClassStatics<StringBuffer, StringBuffer$$constructor>;
            interface StringBuffer$$constructor extends SuppressProperties {

                new (): StringBuffer;
                new (arg0: int): StringBuffer;
                new (arg0: String): StringBuffer;
                new (arg0: CharSequence): StringBuffer;

            }
            interface StringBuffer extends AbstractStringBuilder, java.io.Serializable, Comparable<StringBuffer>, CharSequence {

                compareTo(arg0: StringBuffer): number;
                length(): number;
                capacity(): number;
                ensureCapacity(arg0: int): void;
                trimToSize(): void;
                setLength(arg0: int): void;
                charAt(arg0: int): number;
                codePointAt(arg0: int): number;
                codePointBefore(arg0: int): number;
                codePointCount(arg0: int, arg1: int): number;
                offsetByCodePoints(arg0: int, arg1: int): number;
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void;
                setCharAt(arg0: int, arg1: char): void;
                append(arg0: Object): StringBuffer;
                append(arg0: String): StringBuffer;
                append(arg0: StringBuffer): StringBuffer;
                append(arg0: CharSequence): StringBuffer;
                append(arg0: CharSequence, arg1: int, arg2: int): StringBuffer;
                append(arg0: char[]): StringBuffer;
                append(arg0: char[], arg1: int, arg2: int): StringBuffer;
                append(arg0: boolean): StringBuffer;
                append(arg0: char): StringBuffer;
                append(arg0: int): StringBuffer;
                appendCodePoint(arg0: int): StringBuffer;
                append(arg0: long): StringBuffer;
                append(arg0: float): StringBuffer;
                append(arg0: double): StringBuffer;
                delete(arg0: int, arg1: int): StringBuffer;
                deleteCharAt(arg0: int): StringBuffer;
                replace(arg0: int, arg1: int, arg2: String): StringBuffer;
                substring(arg0: int): String;
                subSequence(arg0: int, arg1: int): CharSequence;
                substring(arg0: int, arg1: int): String;
                insert(arg0: int, arg1: char[], arg2: int, arg3: int): StringBuffer;
                insert(arg0: int, arg1: Object): StringBuffer;
                insert(arg0: int, arg1: String): StringBuffer;
                insert(arg0: int, arg1: char[]): StringBuffer;
                insert(arg0: int, arg1: CharSequence): StringBuffer;
                insert(arg0: int, arg1: CharSequence, arg2: int, arg3: int): StringBuffer;
                insert(arg0: int, arg1: boolean): StringBuffer;
                insert(arg0: int, arg1: char): StringBuffer;
                insert(arg0: int, arg1: int): StringBuffer;
                insert(arg0: int, arg1: long): StringBuffer;
                insert(arg0: int, arg1: float): StringBuffer;
                insert(arg0: int, arg1: double): StringBuffer;
                indexOf(arg0: String): number;
                indexOf(arg0: String, arg1: int): number;
                lastIndexOf(arg0: String): number;
                lastIndexOf(arg0: String, arg1: int): number;
                reverse(): StringBuffer;

            }

            const CharSequence: JavaInterfaceStatics<CharSequence> & {

                compare(arg0: CharSequence, arg1: CharSequence): number;

            }
            interface CharSequence extends JavaObject {

                length(): number;
                charAt(arg0: int): number;
                isEmpty(): boolean;
                subSequence(arg0: int, arg1: int): CharSequence;
                chars(): java.util.stream.IntStream;
                codePoints(): java.util.stream.IntStream;

            }

            const Module: JavaClassStatics<Module> & NoConstructor;
            interface Module extends Object, java.lang.reflect.AnnotatedElement {

                isNamed(): boolean;
                getName(): String;
                getClassLoader(): ClassLoader;
                getDescriptor(): java.lang.module.ModuleDescriptor;
                getLayer(): ModuleLayer;
                canRead(arg0: Module): boolean;
                addReads(arg0: Module): Module;
                isExported(arg0: String, arg1: Module): boolean;
                isOpen(arg0: String, arg1: Module): boolean;
                isExported(arg0: String): boolean;
                isOpen(arg0: String): boolean;
                addExports(arg0: String, arg1: Module): Module;
                addOpens(arg0: String, arg1: Module): Module;
                addUses(arg0: JavaClassArg<any>): Module;
                canUse(arg0: JavaClassArg<any>): boolean;
                getPackages(): JavaSet<String>;
                getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                getResourceAsStream(arg0: String): java.io.InputStream;

            }

            const Package: JavaClassStatics<Package> & NoConstructor & {

                /** @deprecated */
                getPackage(arg0: String): Package;
                getPackages(): JavaArray<Package>;

            }
            interface Package extends NamedPackage, java.lang.reflect.AnnotatedElement {

                getName(): String;
                getSpecificationTitle(): String;
                getSpecificationVersion(): String;
                getSpecificationVendor(): String;
                getImplementationTitle(): String;
                getImplementationVersion(): String;
                getImplementationVendor(): String;
                isSealed(): boolean;
                isSealed(arg0: java.net.URL): boolean;
                isCompatibleWith(arg0: String): boolean;
                getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                isAnnotationPresent(arg0: JavaClassArg<any>): boolean;
                getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                getDeclaredAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                getDeclaredAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

            }

            const ModuleLayer: JavaClassStatics<ModuleLayer> & NoConstructor & {

                defineModulesWithOneLoader(arg0: java.lang.module.Configuration, arg1: JavaList<ModuleLayer>, arg2: ClassLoader): ModuleLayer$Controller;
                defineModulesWithManyLoaders(arg0: java.lang.module.Configuration, arg1: JavaList<ModuleLayer>, arg2: ClassLoader): ModuleLayer$Controller;
                defineModules(arg0: java.lang.module.Configuration, arg1: JavaList<ModuleLayer>, arg2: java.util.function.Function<String, ClassLoader>): ModuleLayer$Controller;
                empty(): ModuleLayer;
                boot(): ModuleLayer;

            }
            interface ModuleLayer extends Object {

                defineModulesWithOneLoader(arg0: java.lang.module.Configuration, arg1: ClassLoader): ModuleLayer;
                defineModulesWithManyLoaders(arg0: java.lang.module.Configuration, arg1: ClassLoader): ModuleLayer;
                defineModules(arg0: java.lang.module.Configuration, arg1: java.util.function.Function<String, ClassLoader>): ModuleLayer;
                configuration(): java.lang.module.Configuration;
                parents(): JavaList<ModuleLayer>;
                modules(): JavaSet<Module>;
                findModule(arg0: String): java.util.Optional<Module>;
                findLoader(arg0: String): ClassLoader;

            }

            const AbstractStringBuilder: JavaClassStatics<AbstractStringBuilder> & NoConstructor;
            interface AbstractStringBuilder extends Object, Appendable, CharSequence {

                length(): number;
                capacity(): number;
                ensureCapacity(arg0: int): void;
                trimToSize(): void;
                setLength(arg0: int): void;
                charAt(arg0: int): number;
                codePointAt(arg0: int): number;
                codePointBefore(arg0: int): number;
                codePointCount(arg0: int, arg1: int): number;
                offsetByCodePoints(arg0: int, arg1: int): number;
                getChars(arg0: int, arg1: int, arg2: char[], arg3: int): void;
                setCharAt(arg0: int, arg1: char): void;
                append(arg0: Object): AbstractStringBuilder;
                append(arg0: String): AbstractStringBuilder;
                append(arg0: StringBuffer): AbstractStringBuilder;
                append(arg0: CharSequence): AbstractStringBuilder;
                append(arg0: CharSequence, arg1: int, arg2: int): AbstractStringBuilder;
                append(arg0: char[]): AbstractStringBuilder;
                append(arg0: char[], arg1: int, arg2: int): AbstractStringBuilder;
                append(arg0: boolean): AbstractStringBuilder;
                append(arg0: char): AbstractStringBuilder;
                append(arg0: int): AbstractStringBuilder;
                append(arg0: long): AbstractStringBuilder;
                append(arg0: float): AbstractStringBuilder;
                append(arg0: double): AbstractStringBuilder;
                delete(arg0: int, arg1: int): AbstractStringBuilder;
                appendCodePoint(arg0: int): AbstractStringBuilder;
                deleteCharAt(arg0: int): AbstractStringBuilder;
                replace(arg0: int, arg1: int, arg2: String): AbstractStringBuilder;
                substring(arg0: int): String;
                subSequence(arg0: int, arg1: int): CharSequence;
                substring(arg0: int, arg1: int): String;
                insert(arg0: int, arg1: char[], arg2: int, arg3: int): AbstractStringBuilder;
                insert(arg0: int, arg1: Object): AbstractStringBuilder;
                insert(arg0: int, arg1: String): AbstractStringBuilder;
                insert(arg0: int, arg1: char[]): AbstractStringBuilder;
                insert(arg0: int, arg1: CharSequence): AbstractStringBuilder;
                insert(arg0: int, arg1: CharSequence, arg2: int, arg3: int): AbstractStringBuilder;
                insert(arg0: int, arg1: boolean): AbstractStringBuilder;
                insert(arg0: int, arg1: char): AbstractStringBuilder;
                insert(arg0: int, arg1: int): AbstractStringBuilder;
                insert(arg0: int, arg1: long): AbstractStringBuilder;
                insert(arg0: int, arg1: float): AbstractStringBuilder;
                insert(arg0: int, arg1: double): AbstractStringBuilder;
                indexOf(arg0: String): number;
                indexOf(arg0: String, arg1: int): number;
                lastIndexOf(arg0: String): number;
                lastIndexOf(arg0: String, arg1: int): number;
                reverse(): AbstractStringBuilder;
                chars(): java.util.stream.IntStream;
                codePoints(): java.util.stream.IntStream;

            }

            const Appendable: JavaInterfaceStatics<Appendable>;
            interface Appendable extends JavaObject {

                append(arg0: CharSequence): Appendable;
                append(arg0: CharSequence, arg1: int, arg2: int): Appendable;
                append(arg0: char): Appendable;

            }

            const NamedPackage: JavaClassStatics<NamedPackage> & NoConstructor;
            interface NamedPackage extends Object {}

            const ModuleLayer$Controller: JavaClassStatics<ModuleLayer$Controller> & NoConstructor;
            interface ModuleLayer$Controller extends Object {

                layer(): ModuleLayer;
                addReads(arg0: Module, arg1: Module): ModuleLayer$Controller;
                addExports(arg0: Module, arg1: String, arg2: Module): ModuleLayer$Controller;
                addOpens(arg0: Module, arg1: String, arg2: Module): ModuleLayer$Controller;

            }

            const Cloneable: JavaInterfaceStatics<Cloneable>;
            interface Cloneable extends JavaObject {}

            const Readable: JavaInterfaceStatics<Readable>;
            interface Readable extends JavaObject {

                read(arg0: java.nio.CharBuffer): number;

            }

            const Character$Subset: JavaClassStatics<Character$Subset> & NoConstructor;
            interface Character$Subset extends Object {}

            const Void: JavaClassStatics<Void> & NoConstructor & {
                readonly TYPE: JavaClass<Void>;
            }
            interface Void extends Object {}

            export {
                Enum,
                Thread,
                Exception,
                Number,
                Comparable,
                AutoCloseable,
                Runnable,
                Enum$EnumDesc,
                ThreadGroup,
                ClassLoader,
                Thread$State,
                Thread$UncaughtExceptionHandler,
                String,
                StringBuilder,
                StringBuffer,
                CharSequence,
                Module,
                Package,
                ModuleLayer,
                AbstractStringBuilder,
                Appendable,
                NamedPackage,
                ModuleLayer$Controller,
                Cloneable,
                Readable,
                Character$Subset,
                Void
            }

        }
        namespace lang {

            namespace reflect {

                const Field: JavaClassStatics<Field> & NoConstructor;
                interface Field extends AccessibleObject, Member {

                    setAccessible(arg0: boolean): void;
                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    isEnumConstant(): boolean;
                    isSynthetic(): boolean;
                    getType(): JavaClass<any>;
                    getGenericType(): Type;
                    toGenericString(): string;
                    get(arg0: any): any;
                    getBoolean(arg0: any): boolean;
                    getByte(arg0: any): number;
                    getChar(arg0: any): number;
                    getShort(arg0: any): number;
                    getInt(arg0: any): number;
                    getLong(arg0: any): number;
                    getFloat(arg0: any): number;
                    getDouble(arg0: any): number;
                    set(arg0: any, arg1: any): void;
                    setBoolean(arg0: any, arg1: boolean): void;
                    setByte(arg0: any, arg1: byte): void;
                    setChar(arg0: any, arg1: char): void;
                    setShort(arg0: any, arg1: short): void;
                    setInt(arg0: any, arg1: int): void;
                    setLong(arg0: any, arg1: long): void;
                    setFloat(arg0: any, arg1: float): void;
                    setDouble(arg0: any, arg1: double): void;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getAnnotatedType(): AnnotatedType;

                }

                const Method: JavaClassStatics<Method> & NoConstructor;
                interface Method extends Executable {

                    setAccessible(arg0: boolean): void;
                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    getTypeParameters(): JavaArray<TypeVariable<Method>>;
                    getReturnType(): JavaClass<any>;
                    getGenericReturnType(): Type;
                    getParameterTypes(): JavaArray<JavaClass<any>>;
                    getParameterCount(): number;
                    getGenericParameterTypes(): JavaArray<Type>;
                    getExceptionTypes(): JavaArray<JavaClass<any>>;
                    getGenericExceptionTypes(): JavaArray<Type>;
                    toGenericString(): string;
                    invoke(arg0: any, ...arg1: any[]): any;
                    isBridge(): boolean;
                    isVarArgs(): boolean;
                    isSynthetic(): boolean;
                    isDefault(): boolean;
                    getDefaultValue(): any;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getParameterAnnotations(): JavaArray<JavaArray<java.lang.annotation.Annotation>>;
                    getAnnotatedReturnType(): AnnotatedType;

                }

                const Executable: JavaClassStatics<Executable> & NoConstructor;
                interface Executable extends AccessibleObject, Member, GenericDeclaration {

                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    getTypeParameters(): JavaArray<TypeVariable<any>>;
                    getParameterTypes(): JavaArray<JavaClass<any>>;
                    getParameterCount(): number;
                    getGenericParameterTypes(): JavaArray<Type>;
                    getParameters(): JavaArray<Parameter>;
                    getExceptionTypes(): JavaArray<JavaClass<any>>;
                    getGenericExceptionTypes(): JavaArray<Type>;
                    toGenericString(): string;
                    isVarArgs(): boolean;
                    isSynthetic(): boolean;
                    getParameterAnnotations(): JavaArray<JavaArray<java.lang.annotation.Annotation>>;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getAnnotatedReturnType(): AnnotatedType;
                    getAnnotatedReceiverType(): AnnotatedType;
                    getAnnotatedParameterTypes(): JavaArray<AnnotatedType>;
                    getAnnotatedExceptionTypes(): JavaArray<AnnotatedType>;

                }

                const TypeVariable: JavaInterfaceStatics<TypeVariable<any>>;
                interface TypeVariable<D extends GenericDeclaration> extends Type, AnnotatedElement {

                    getBounds(): JavaArray<Type>;
                    getGenericDeclaration(): D;
                    getName(): string;
                    getAnnotatedBounds(): JavaArray<AnnotatedType>;

                }

                const Member: JavaInterfaceStatics<Member> & {
                    readonly PUBLIC: number;
                    readonly DECLARED: number;
                }
                interface Member extends JavaObject {

                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getModifiers(): number;
                    isSynthetic(): boolean;

                }

                const GenericDeclaration: JavaInterfaceStatics<GenericDeclaration>;
                interface GenericDeclaration extends AnnotatedElement {

                    getTypeParameters(): JavaArray<TypeVariable<any>>;

                }

                const Type: JavaInterfaceStatics<Type>;
                interface Type extends JavaObject {

                    getTypeName(): string;

                }

                const AccessibleObject: JavaClassStatics<AccessibleObject> & NoConstructor & {

                    setAccessible(arg0: AccessibleObject[], arg1: boolean): void;

                }
                interface AccessibleObject extends AnnotatedElement {

                    setAccessible(arg0: boolean): void;
                    trySetAccessible(): boolean;
                    /** @deprecated */
                    isAccessible(): boolean;
                    canAccess(arg0: any): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    isAnnotationPresent(arg0: JavaClassArg<any>): boolean;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                const AnnotatedType: JavaInterfaceStatics<AnnotatedType>;
                interface AnnotatedType extends AnnotatedElement {

                    getAnnotatedOwnerType(): AnnotatedType;
                    getType(): Type;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                const AnnotatedElement: JavaInterfaceStatics<AnnotatedElement>;
                interface AnnotatedElement extends JavaObject {

                    isAnnotationPresent(arg0: JavaClassArg<any>): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                const Parameter: JavaClassStatics<Parameter> & NoConstructor;
                interface Parameter extends AnnotatedElement {

                    isNamePresent(): boolean;
                    getDeclaringExecutable(): Executable;
                    getModifiers(): number;
                    getName(): string;
                    getParameterizedType(): Type;
                    getType(): JavaClass<any>;
                    getAnnotatedType(): AnnotatedType;
                    isImplicit(): boolean;
                    isSynthetic(): boolean;
                    isVarArgs(): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getDeclaredAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotationsByType<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): JavaArray<T>;
                    getAnnotations(): JavaArray<java.lang.annotation.Annotation>;

                }

                const Constructor: JavaClassStatics<Constructor<any>> & NoConstructor;
                interface Constructor<T> extends Executable {

                    setAccessible(arg0: boolean): void;
                    getDeclaringClass(): JavaClass<T>;
                    getName(): string;
                    getModifiers(): number;
                    getTypeParameters(): JavaArray<TypeVariable<Constructor<T>>>;
                    getParameterTypes(): JavaArray<JavaClass<any>>;
                    getParameterCount(): number;
                    getGenericParameterTypes(): JavaArray<Type>;
                    getExceptionTypes(): JavaArray<JavaClass<any>>;
                    getGenericExceptionTypes(): JavaArray<Type>;
                    toGenericString(): string;
                    newInstance(...arg0: any[]): T;
                    isVarArgs(): boolean;
                    isSynthetic(): boolean;
                    getAnnotation<T extends java.lang.annotation.Annotation>(arg0: JavaClassArg<T>): T;
                    getDeclaredAnnotations(): JavaArray<java.lang.annotation.Annotation>;
                    getParameterAnnotations(): JavaArray<JavaArray<java.lang.annotation.Annotation>>;
                    getAnnotatedReturnType(): AnnotatedType;
                    getAnnotatedReceiverType(): AnnotatedType;

                }

                export {
                    Field,
                    Method,
                    Executable,
                    TypeVariable,
                    Member,
                    GenericDeclaration,
                    Type,
                    AccessibleObject,
                    AnnotatedType,
                    AnnotatedElement,
                    Parameter,
                    Constructor
                }

            }

            namespace constant {

                const Constable: JavaInterfaceStatics<Constable>;
                interface Constable extends JavaObject {

                    describeConstable(): java.util.Optional<any>;

                }

                const ClassDesc: JavaInterfaceStatics<ClassDesc> & {

                    of(arg0: string): ClassDesc;
                    of(arg0: string, arg1: string): ClassDesc;
                    ofDescriptor(arg0: string): ClassDesc;

                }
                interface ClassDesc extends ConstantDesc, java.lang.invoke.TypeDescriptor$OfField<ClassDesc> {

                    arrayType(): ClassDesc;
                    arrayType(arg0: int): ClassDesc;
                    nested(arg0: string): ClassDesc;
                    nested(arg0: string, ...arg1: string[]): ClassDesc;
                    isArray(): boolean;
                    isPrimitive(): boolean;
                    isClassOrInterface(): boolean;
                    componentType(): ClassDesc;
                    packageName(): string;
                    displayName(): string;
                    descriptorString(): string;

                }

                const ConstantDesc: JavaInterfaceStatics<ConstantDesc>;
                interface ConstantDesc extends JavaObject {

                    resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): any;

                }

                const DynamicConstantDesc: JavaClassStatics<DynamicConstantDesc<any>> & NoConstructor & {

                    ofCanonical<T>(arg0: DirectMethodHandleDesc, arg1: string, arg2: ClassDesc, arg3: ConstantDesc[]): ConstantDesc;
                    ofNamed<T>(arg0: DirectMethodHandleDesc, arg1: string, arg2: ClassDesc, ...arg3: ConstantDesc[]): DynamicConstantDesc<T>;
                    of<T>(arg0: DirectMethodHandleDesc, ...arg1: ConstantDesc[]): DynamicConstantDesc<T>;
                    of<T>(arg0: DirectMethodHandleDesc): DynamicConstantDesc<T>;

                }
                interface DynamicConstantDesc<T> extends ConstantDesc {

                    constantName(): string;
                    constantType(): ClassDesc;
                    bootstrapMethod(): DirectMethodHandleDesc;
                    bootstrapArgs(): JavaArray<ConstantDesc>;
                    bootstrapArgsList(): JavaList<ConstantDesc>;
                    resolveConstantDesc(arg0: java.lang.invoke.MethodHandles$Lookup): T;

                }

                const DirectMethodHandleDesc: JavaInterfaceStatics<DirectMethodHandleDesc>;
                interface DirectMethodHandleDesc extends MethodHandleDesc {

                    kind(): DirectMethodHandleDesc$Kind;
                    refKind(): number;
                    isOwnerInterface(): boolean;
                    owner(): ClassDesc;
                    methodName(): string;
                    lookupDescriptor(): string;

                }

                const MethodHandleDesc: JavaInterfaceStatics<MethodHandleDesc> & {

                    of(arg0: DirectMethodHandleDesc$Kind, arg1: ClassDesc, arg2: string, arg3: string): DirectMethodHandleDesc;
                    ofMethod(arg0: DirectMethodHandleDesc$Kind, arg1: ClassDesc, arg2: string, arg3: MethodTypeDesc): DirectMethodHandleDesc;
                    ofField(arg0: DirectMethodHandleDesc$Kind, arg1: ClassDesc, arg2: string, arg3: ClassDesc): DirectMethodHandleDesc;
                    ofConstructor(arg0: ClassDesc, ...arg1: ClassDesc[]): DirectMethodHandleDesc;

                }
                interface MethodHandleDesc extends ConstantDesc {

                    asType(arg0: MethodTypeDesc): MethodHandleDesc;
                    invocationType(): MethodTypeDesc;

                }

                const DirectMethodHandleDesc$Kind: JavaClassStatics<DirectMethodHandleDesc$Kind> & NoConstructor & {
                    readonly STATIC: DirectMethodHandleDesc$Kind;
                    readonly INTERFACE_STATIC: DirectMethodHandleDesc$Kind;
                    readonly VIRTUAL: DirectMethodHandleDesc$Kind;
                    readonly INTERFACE_VIRTUAL: DirectMethodHandleDesc$Kind;
                    readonly SPECIAL: DirectMethodHandleDesc$Kind;
                    readonly INTERFACE_SPECIAL: DirectMethodHandleDesc$Kind;
                    readonly CONSTRUCTOR: DirectMethodHandleDesc$Kind;
                    readonly GETTER: DirectMethodHandleDesc$Kind;
                    readonly SETTER: DirectMethodHandleDesc$Kind;
                    readonly STATIC_GETTER: DirectMethodHandleDesc$Kind;
                    readonly STATIC_SETTER: DirectMethodHandleDesc$Kind;

                    values(): JavaArray<DirectMethodHandleDesc$Kind>;
                    valueOf(arg0: string): DirectMethodHandleDesc$Kind;
                    valueOf(arg0: int): DirectMethodHandleDesc$Kind;
                    valueOf(arg0: int, arg1: boolean): DirectMethodHandleDesc$Kind;

                }
                interface DirectMethodHandleDesc$Kind extends java.lang.Enum<DirectMethodHandleDesc$Kind> {
                    readonly refKind: number;
                    readonly isInterface: boolean;
                }

                const MethodTypeDesc: JavaInterfaceStatics<MethodTypeDesc> & {

                    ofDescriptor(arg0: string): MethodTypeDesc;
                    of(arg0: ClassDesc, ...arg1: ClassDesc[]): MethodTypeDesc;

                }
                interface MethodTypeDesc extends ConstantDesc, java.lang.invoke.TypeDescriptor$OfMethod<ClassDesc, MethodTypeDesc> {

                    returnType(): ClassDesc;
                    parameterCount(): number;
                    parameterType(arg0: int): ClassDesc;
                    parameterList(): JavaList<ClassDesc>;
                    parameterArray(): JavaArray<ClassDesc>;
                    changeReturnType(arg0: ClassDesc): MethodTypeDesc;
                    changeParameterType(arg0: int, arg1: ClassDesc): MethodTypeDesc;
                    dropParameterTypes(arg0: int, arg1: int): MethodTypeDesc;
                    insertParameterTypes(arg0: int, ...arg1: ClassDesc[]): MethodTypeDesc;
                    descriptorString(): string;
                    displayDescriptor(): string;

                }

                export {
                    Constable,
                    ClassDesc,
                    ConstantDesc,
                    DynamicConstantDesc,
                    DirectMethodHandleDesc,
                    MethodHandleDesc,
                    DirectMethodHandleDesc$Kind,
                    MethodTypeDesc
                }

            }

            namespace ref {

                const WeakReference: JavaClassStatics<WeakReference<any>, WeakReference$$constructor>;
                interface WeakReference$$constructor extends SuppressProperties {

                    new <T>(arg0: T): WeakReference<T>;
                    new <T>(arg0: T, arg1: ReferenceQueue<any>): WeakReference<T>;

                }
                interface WeakReference<T> extends Reference<T> {}

                const ReferenceQueue: JavaClassStatics<ReferenceQueue<any>, ReferenceQueue$$constructor>;
                interface ReferenceQueue$$constructor extends SuppressProperties {

                    new <T>(): ReferenceQueue<T>;

                }
                interface ReferenceQueue<T> extends JavaObject {

                    poll(): Reference<any>;
                    remove(arg0: long): Reference<any>;
                    remove(): Reference<any>;

                }

                const Reference: JavaClassStatics<Reference<any>> & NoConstructor & {

                    reachabilityFence(arg0: any): void;

                }
                interface Reference<T> extends JavaObject {

                    get(): T;
                    refersTo(arg0: T): boolean;
                    clear(): void;
                    /** @deprecated */
                    isEnqueued(): boolean;
                    enqueue(): boolean;

                }

                export { WeakReference, ReferenceQueue, Reference }

            }

            namespace annotation {

                const Annotation: JavaInterfaceStatics<Annotation>;
                interface Annotation extends JavaObject {

                    annotationType(): JavaClass<any>;

                }

                export { Annotation }

            }

            namespace invoke {

                const TypeDescriptor$OfMethod: JavaInterfaceStatics<TypeDescriptor$OfMethod<any, any>>;
                interface TypeDescriptor$OfMethod<F extends TypeDescriptor$OfField<F>, M extends TypeDescriptor$OfMethod<F, M>> extends TypeDescriptor {

                    parameterCount(): number;
                    parameterType(arg0: int): F;
                    returnType(): F;
                    parameterArray(): JavaArray<F>;
                    parameterList(): JavaList<F>;
                    changeReturnType(arg0: F): M;
                    changeParameterType(arg0: int, arg1: F): M;
                    dropParameterTypes(arg0: int, arg1: int): M;
                    insertParameterTypes(arg0: int, ...arg1: F[]): M;

                }

                const MethodHandles$Lookup: JavaClassStatics<MethodHandles$Lookup> & NoConstructor & {
                    readonly PUBLIC: number;
                    readonly PRIVATE: number;
                    readonly PROTECTED: number;
                    readonly PACKAGE: number;
                    readonly MODULE: number;
                    readonly UNCONDITIONAL: number;
                    readonly ORIGINAL: number;
                }
                interface MethodHandles$Lookup extends JavaObject {

                    lookupClass(): JavaClass<any>;
                    previousLookupClass(): JavaClass<any>;
                    lookupModes(): number;
                    in(arg0: JavaClassArg<any>): MethodHandles$Lookup;
                    dropLookupMode(arg0: int): MethodHandles$Lookup;
                    defineClass(arg0: byte[]): JavaClass<any>;
                    defineHiddenClass(arg0: byte[], arg1: boolean, ...arg2: MethodHandles$Lookup$ClassOption[]): MethodHandles$Lookup;
                    defineHiddenClassWithClassData(arg0: byte[], arg1: any, arg2: boolean, ...arg3: MethodHandles$Lookup$ClassOption[]): MethodHandles$Lookup;
                    findStatic(arg0: JavaClassArg<any>, arg1: string, arg2: MethodType): MethodHandle;
                    findVirtual(arg0: JavaClassArg<any>, arg1: string, arg2: MethodType): MethodHandle;
                    findConstructor(arg0: JavaClassArg<any>, arg1: MethodType): MethodHandle;
                    findClass(arg0: string): JavaClass<any>;
                    ensureInitialized(arg0: JavaClassArg<any>): JavaClass<any>;
                    accessClass(arg0: JavaClassArg<any>): JavaClass<any>;
                    findSpecial(arg0: JavaClassArg<any>, arg1: string, arg2: MethodType, arg3: JavaClassArg<any>): MethodHandle;
                    findGetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findSetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findVarHandle(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): VarHandle;
                    findStaticGetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findStaticSetter(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): MethodHandle;
                    findStaticVarHandle(arg0: JavaClassArg<any>, arg1: string, arg2: JavaClassArg<any>): VarHandle;
                    bind(arg0: any, arg1: string, arg2: MethodType): MethodHandle;
                    unreflect(arg0: java.lang.reflect.Method): MethodHandle;
                    unreflectSpecial(arg0: java.lang.reflect.Method, arg1: JavaClassArg<any>): MethodHandle;
                    unreflectConstructor(arg0: java.lang.reflect.Constructor<any>): MethodHandle;
                    unreflectGetter(arg0: java.lang.reflect.Field): MethodHandle;
                    unreflectSetter(arg0: java.lang.reflect.Field): MethodHandle;
                    unreflectVarHandle(arg0: java.lang.reflect.Field): VarHandle;
                    revealDirect(arg0: MethodHandle): MethodHandleInfo;
                    /** @deprecated */
                    hasPrivateAccess(): boolean;
                    hasFullPrivilegeAccess(): boolean;

                }

                const TypeDescriptor: JavaInterfaceStatics<TypeDescriptor>;
                interface TypeDescriptor extends JavaObject {

                    descriptorString(): string;

                }

                const TypeDescriptor$OfField: JavaInterfaceStatics<TypeDescriptor$OfField<any>>;
                interface TypeDescriptor$OfField<F extends TypeDescriptor$OfField<F>> extends TypeDescriptor {

                    isArray(): boolean;
                    isPrimitive(): boolean;
                    componentType(): F;
                    arrayType(): F;

                }

                const MethodType: JavaClassStatics<MethodType> & NoConstructor & {

                    methodType(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>[]): MethodType;
                    methodType(arg0: JavaClassArg<any>, arg1: JavaList<JavaClassArg<any>>): MethodType;
                    methodType(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>, ...arg2: JavaClassArg<any>[]): MethodType;
                    methodType(arg0: JavaClassArg<any>): MethodType;
                    methodType(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>): MethodType;
                    methodType(arg0: JavaClassArg<any>, arg1: MethodType): MethodType;
                    genericMethodType(arg0: int, arg1: boolean): MethodType;
                    genericMethodType(arg0: int): MethodType;
                    fromMethodDescriptorString(arg0: string, arg1: java.lang.ClassLoader): MethodType;

                }
                interface MethodType extends java.lang.constant.Constable, TypeDescriptor$OfMethod<JavaClass<any>, MethodType>, java.io.Serializable {

                    changeParameterType(arg0: int, arg1: JavaClassArg<any>): MethodType;
                    insertParameterTypes(arg0: int, ...arg1: JavaClassArg<any>[]): MethodType;
                    appendParameterTypes(...arg0: JavaClassArg<any>[]): MethodType;
                    insertParameterTypes(arg0: int, arg1: JavaList<JavaClassArg<any>>): MethodType;
                    appendParameterTypes(arg0: JavaList<JavaClassArg<any>>): MethodType;
                    dropParameterTypes(arg0: int, arg1: int): MethodType;
                    changeReturnType(arg0: JavaClassArg<any>): MethodType;
                    hasPrimitives(): boolean;
                    hasWrappers(): boolean;
                    erase(): MethodType;
                    generic(): MethodType;
                    wrap(): MethodType;
                    unwrap(): MethodType;
                    parameterType(arg0: int): JavaClass<any>;
                    parameterCount(): number;
                    returnType(): JavaClass<any>;
                    parameterList(): JavaList<JavaClass<any>>;
                    lastParameterType(): JavaClass<any>;
                    parameterArray(): JavaArray<JavaClass<any>>;
                    toMethodDescriptorString(): string;
                    descriptorString(): string;
                    describeConstable(): java.util.Optional<java.lang.constant.MethodTypeDesc>;

                }

                const MethodHandles$Lookup$ClassOption: JavaClassStatics<MethodHandles$Lookup$ClassOption> & NoConstructor & {
                    readonly NESTMATE: MethodHandles$Lookup$ClassOption;
                    readonly STRONG: MethodHandles$Lookup$ClassOption;

                    values(): JavaArray<MethodHandles$Lookup$ClassOption>;
                    valueOf(arg0: string): MethodHandles$Lookup$ClassOption;

                }
                interface MethodHandles$Lookup$ClassOption extends java.lang.Enum<MethodHandles$Lookup$ClassOption> {}

                const MethodHandleInfo: JavaInterfaceStatics<MethodHandleInfo> & {
                    readonly REF_getField: number;
                    readonly REF_getStatic: number;
                    readonly REF_putField: number;
                    readonly REF_putStatic: number;
                    readonly REF_invokeVirtual: number;
                    readonly REF_invokeStatic: number;
                    readonly REF_invokeSpecial: number;
                    readonly REF_newInvokeSpecial: number;
                    readonly REF_invokeInterface: number;

                    referenceKindToString(arg0: int): string;
                    toString(arg0: int, arg1: JavaClassArg<any>, arg2: string, arg3: MethodType): string;

                }
                interface MethodHandleInfo extends JavaObject {

                    getReferenceKind(): number;
                    getDeclaringClass(): JavaClass<any>;
                    getName(): string;
                    getMethodType(): MethodType;
                    reflectAs<T extends java.lang.reflect.Member>(arg0: JavaClassArg<T>, arg1: MethodHandles$Lookup): T;
                    getModifiers(): number;
                    isVarArgs(): boolean;

                }

                const MethodHandle: JavaClassStatics<MethodHandle> & NoConstructor;
                interface MethodHandle extends java.lang.constant.Constable {

                    type(): MethodType;
                    invokeExact(...arg0: any[]): any;
                    invoke(...arg0: any[]): any;
                    invokeWithArguments(...arg0: any[]): any;
                    invokeWithArguments(arg0: JavaList<any>): any;
                    asType(arg0: MethodType): MethodHandle;
                    asSpreader(arg0: JavaClassArg<any>, arg1: int): MethodHandle;
                    asSpreader(arg0: int, arg1: JavaClassArg<any>, arg2: int): MethodHandle;
                    withVarargs(arg0: boolean): MethodHandle;
                    asCollector(arg0: JavaClassArg<any>, arg1: int): MethodHandle;
                    asCollector(arg0: int, arg1: JavaClassArg<any>, arg2: int): MethodHandle;
                    asVarargsCollector(arg0: JavaClassArg<any>): MethodHandle;
                    isVarargsCollector(): boolean;
                    asFixedArity(): MethodHandle;
                    bindTo(arg0: any): MethodHandle;
                    describeConstable(): java.util.Optional<java.lang.constant.MethodHandleDesc>;

                }

                const VarHandle: JavaClassStatics<VarHandle> & NoConstructor & {

                    fullFence(): void;
                    acquireFence(): void;
                    releaseFence(): void;
                    loadLoadFence(): void;
                    storeStoreFence(): void;

                }
                interface VarHandle extends java.lang.constant.Constable {

                    hasInvokeExactBehavior(): boolean;
                    get(...arg0: any[]): any;
                    set(...arg0: any[]): void;
                    getVolatile(...arg0: any[]): any;
                    setVolatile(...arg0: any[]): void;
                    getOpaque(...arg0: any[]): any;
                    setOpaque(...arg0: any[]): void;
                    getAcquire(...arg0: any[]): any;
                    setRelease(...arg0: any[]): void;
                    compareAndSet(...arg0: any[]): boolean;
                    compareAndExchange(...arg0: any[]): any;
                    compareAndExchangeAcquire(...arg0: any[]): any;
                    compareAndExchangeRelease(...arg0: any[]): any;
                    weakCompareAndSetPlain(...arg0: any[]): boolean;
                    weakCompareAndSet(...arg0: any[]): boolean;
                    weakCompareAndSetAcquire(...arg0: any[]): boolean;
                    weakCompareAndSetRelease(...arg0: any[]): boolean;
                    getAndSet(...arg0: any[]): any;
                    getAndSetAcquire(...arg0: any[]): any;
                    getAndSetRelease(...arg0: any[]): any;
                    getAndAdd(...arg0: any[]): any;
                    getAndAddAcquire(...arg0: any[]): any;
                    getAndAddRelease(...arg0: any[]): any;
                    getAndBitwiseOr(...arg0: any[]): any;
                    getAndBitwiseOrAcquire(...arg0: any[]): any;
                    getAndBitwiseOrRelease(...arg0: any[]): any;
                    getAndBitwiseAnd(...arg0: any[]): any;
                    getAndBitwiseAndAcquire(...arg0: any[]): any;
                    getAndBitwiseAndRelease(...arg0: any[]): any;
                    getAndBitwiseXor(...arg0: any[]): any;
                    getAndBitwiseXorAcquire(...arg0: any[]): any;
                    getAndBitwiseXorRelease(...arg0: any[]): any;
                    withInvokeExactBehavior(): VarHandle;
                    withInvokeBehavior(): VarHandle;
                    varType(): JavaClass<any>;
                    coordinateTypes(): JavaList<JavaClass<any>>;
                    accessModeType(arg0: VarHandle$AccessMode): MethodType;
                    isAccessModeSupported(arg0: VarHandle$AccessMode): boolean;
                    toMethodHandle(arg0: VarHandle$AccessMode): MethodHandle;
                    describeConstable(): java.util.Optional<VarHandle$VarHandleDesc>;

                }

                const VarHandle$AccessMode: JavaClassStatics<VarHandle$AccessMode> & NoConstructor & {
                    readonly GET: VarHandle$AccessMode;
                    readonly SET: VarHandle$AccessMode;
                    readonly GET_VOLATILE: VarHandle$AccessMode;
                    readonly SET_VOLATILE: VarHandle$AccessMode;
                    readonly GET_ACQUIRE: VarHandle$AccessMode;
                    readonly SET_RELEASE: VarHandle$AccessMode;
                    readonly GET_OPAQUE: VarHandle$AccessMode;
                    readonly SET_OPAQUE: VarHandle$AccessMode;
                    readonly COMPARE_AND_SET: VarHandle$AccessMode;
                    readonly COMPARE_AND_EXCHANGE: VarHandle$AccessMode;
                    readonly COMPARE_AND_EXCHANGE_ACQUIRE: VarHandle$AccessMode;
                    readonly COMPARE_AND_EXCHANGE_RELEASE: VarHandle$AccessMode;
                    readonly WEAK_COMPARE_AND_SET_PLAIN: VarHandle$AccessMode;
                    readonly WEAK_COMPARE_AND_SET: VarHandle$AccessMode;
                    readonly WEAK_COMPARE_AND_SET_ACQUIRE: VarHandle$AccessMode;
                    readonly WEAK_COMPARE_AND_SET_RELEASE: VarHandle$AccessMode;
                    readonly GET_AND_SET: VarHandle$AccessMode;
                    readonly GET_AND_SET_ACQUIRE: VarHandle$AccessMode;
                    readonly GET_AND_SET_RELEASE: VarHandle$AccessMode;
                    readonly GET_AND_ADD: VarHandle$AccessMode;
                    readonly GET_AND_ADD_ACQUIRE: VarHandle$AccessMode;
                    readonly GET_AND_ADD_RELEASE: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_OR: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_OR_RELEASE: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_OR_ACQUIRE: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_AND: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_AND_RELEASE: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_AND_ACQUIRE: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_XOR: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_XOR_RELEASE: VarHandle$AccessMode;
                    readonly GET_AND_BITWISE_XOR_ACQUIRE: VarHandle$AccessMode;

                    values(): JavaArray<VarHandle$AccessMode>;
                    valueOf(arg0: string): VarHandle$AccessMode;
                    valueFromMethodName(arg0: string): VarHandle$AccessMode;

                }
                interface VarHandle$AccessMode extends java.lang.Enum<VarHandle$AccessMode> {

                    methodName(): string;

                }

                const VarHandle$VarHandleDesc: JavaClassStatics<VarHandle$VarHandleDesc> & NoConstructor & {

                    ofField(arg0: java.lang.constant.ClassDesc, arg1: string, arg2: java.lang.constant.ClassDesc): VarHandle$VarHandleDesc;
                    ofStaticField(arg0: java.lang.constant.ClassDesc, arg1: string, arg2: java.lang.constant.ClassDesc): VarHandle$VarHandleDesc;
                    ofArray(arg0: java.lang.constant.ClassDesc): VarHandle$VarHandleDesc;

                }
                interface VarHandle$VarHandleDesc extends java.lang.constant.DynamicConstantDesc<VarHandle> {

                    varType(): java.lang.constant.ClassDesc;
                    resolveConstantDesc(arg0: MethodHandles$Lookup): VarHandle;

                }

                export {
                    TypeDescriptor$OfMethod,
                    MethodHandles$Lookup,
                    TypeDescriptor,
                    TypeDescriptor$OfField,
                    MethodType,
                    MethodHandles$Lookup$ClassOption,
                    MethodHandleInfo,
                    MethodHandle,
                    VarHandle,
                    VarHandle$AccessMode,
                    VarHandle$VarHandleDesc
                }

            }

            namespace module {

                const ModuleDescriptor: JavaClassStatics<ModuleDescriptor> & NoConstructor & {

                    newModule(arg0: string, arg1: JavaSet<ModuleDescriptor$Modifier>): ModuleDescriptor$Builder;
                    newModule(arg0: string): ModuleDescriptor$Builder;
                    newOpenModule(arg0: string): ModuleDescriptor$Builder;
                    newAutomaticModule(arg0: string): ModuleDescriptor$Builder;
                    read(arg0: java.io.InputStream, arg1: java.util.function.Supplier<JavaSet<string>>): ModuleDescriptor;
                    read(arg0: java.io.InputStream): ModuleDescriptor;
                    read(arg0: java.nio.ByteBuffer, arg1: java.util.function.Supplier<JavaSet<string>>): ModuleDescriptor;
                    read(arg0: java.nio.ByteBuffer): ModuleDescriptor;

                }
                interface ModuleDescriptor extends java.lang.Comparable<ModuleDescriptor> {

                    name(): string;
                    modifiers(): JavaSet<ModuleDescriptor$Modifier>;
                    isOpen(): boolean;
                    isAutomatic(): boolean;
                    requires(): JavaSet<ModuleDescriptor$Requires>;
                    exports(): JavaSet<ModuleDescriptor$Exports>;
                    opens(): JavaSet<ModuleDescriptor$Opens>;
                    uses(): JavaSet<string>;
                    provides(): JavaSet<ModuleDescriptor$Provides>;
                    version(): java.util.Optional<ModuleDescriptor$Version>;
                    rawVersion(): java.util.Optional<string>;
                    toNameAndVersion(): string;
                    mainClass(): java.util.Optional<string>;
                    packages(): JavaSet<string>;
                    compareTo(arg0: ModuleDescriptor): number;

                }

                const ModuleDescriptor$Provides: JavaClassStatics<ModuleDescriptor$Provides> & NoConstructor;
                interface ModuleDescriptor$Provides extends java.lang.Comparable<ModuleDescriptor$Provides> {

                    service(): string;
                    providers(): JavaList<string>;
                    compareTo(arg0: ModuleDescriptor$Provides): number;

                }

                const ModuleDescriptor$Exports: JavaClassStatics<ModuleDescriptor$Exports> & NoConstructor;
                interface ModuleDescriptor$Exports extends java.lang.Comparable<ModuleDescriptor$Exports> {

                    modifiers(): JavaSet<ModuleDescriptor$Exports$Modifier>;
                    isQualified(): boolean;
                    source(): string;
                    targets(): JavaSet<string>;
                    compareTo(arg0: ModuleDescriptor$Exports): number;

                }

                const ModuleDescriptor$Opens: JavaClassStatics<ModuleDescriptor$Opens> & NoConstructor;
                interface ModuleDescriptor$Opens extends java.lang.Comparable<ModuleDescriptor$Opens> {

                    modifiers(): JavaSet<ModuleDescriptor$Opens$Modifier>;
                    isQualified(): boolean;
                    source(): string;
                    targets(): JavaSet<string>;
                    compareTo(arg0: ModuleDescriptor$Opens): number;

                }

                const ModuleDescriptor$Requires: JavaClassStatics<ModuleDescriptor$Requires> & NoConstructor;
                interface ModuleDescriptor$Requires extends java.lang.Comparable<ModuleDescriptor$Requires> {

                    modifiers(): JavaSet<ModuleDescriptor$Requires$Modifier>;
                    name(): string;
                    compiledVersion(): java.util.Optional<ModuleDescriptor$Version>;
                    rawCompiledVersion(): java.util.Optional<string>;
                    compareTo(arg0: ModuleDescriptor$Requires): number;

                }

                const ModuleDescriptor$Builder: JavaClassStatics<ModuleDescriptor$Builder> & NoConstructor;
                interface ModuleDescriptor$Builder extends JavaObject {

                    requires(arg0: ModuleDescriptor$Requires): ModuleDescriptor$Builder;
                    requires(arg0: JavaSet<ModuleDescriptor$Requires$Modifier>, arg1: string, arg2: ModuleDescriptor$Version): ModuleDescriptor$Builder;
                    requires(arg0: JavaSet<ModuleDescriptor$Requires$Modifier>, arg1: string): ModuleDescriptor$Builder;
                    requires(arg0: string): ModuleDescriptor$Builder;
                    exports(arg0: ModuleDescriptor$Exports): ModuleDescriptor$Builder;
                    exports(arg0: JavaSet<ModuleDescriptor$Exports$Modifier>, arg1: string, arg2: JavaSet<string>): ModuleDescriptor$Builder;
                    exports(arg0: JavaSet<ModuleDescriptor$Exports$Modifier>, arg1: string): ModuleDescriptor$Builder;
                    exports(arg0: string, arg1: JavaSet<string>): ModuleDescriptor$Builder;
                    exports(arg0: string): ModuleDescriptor$Builder;
                    opens(arg0: ModuleDescriptor$Opens): ModuleDescriptor$Builder;
                    opens(arg0: JavaSet<ModuleDescriptor$Opens$Modifier>, arg1: string, arg2: JavaSet<string>): ModuleDescriptor$Builder;
                    opens(arg0: JavaSet<ModuleDescriptor$Opens$Modifier>, arg1: string): ModuleDescriptor$Builder;
                    opens(arg0: string, arg1: JavaSet<string>): ModuleDescriptor$Builder;
                    opens(arg0: string): ModuleDescriptor$Builder;
                    uses(arg0: string): ModuleDescriptor$Builder;
                    provides(arg0: ModuleDescriptor$Provides): ModuleDescriptor$Builder;
                    provides(arg0: string, arg1: JavaList<string>): ModuleDescriptor$Builder;
                    packages(arg0: JavaSet<string>): ModuleDescriptor$Builder;
                    version(arg0: ModuleDescriptor$Version): ModuleDescriptor$Builder;
                    version(arg0: string): ModuleDescriptor$Builder;
                    mainClass(arg0: string): ModuleDescriptor$Builder;
                    build(): ModuleDescriptor;

                }

                const ModuleDescriptor$Version: JavaClassStatics<ModuleDescriptor$Version> & NoConstructor & {

                    parse(arg0: string): ModuleDescriptor$Version;

                }
                interface ModuleDescriptor$Version extends java.lang.Comparable<ModuleDescriptor$Version> {

                    compareTo(arg0: ModuleDescriptor$Version): number;

                }

                const ModuleDescriptor$Modifier: JavaClassStatics<ModuleDescriptor$Modifier> & NoConstructor & {
                    readonly OPEN: ModuleDescriptor$Modifier;
                    readonly AUTOMATIC: ModuleDescriptor$Modifier;
                    readonly SYNTHETIC: ModuleDescriptor$Modifier;
                    readonly MANDATED: ModuleDescriptor$Modifier;

                    values(): JavaArray<ModuleDescriptor$Modifier>;
                    valueOf(arg0: string): ModuleDescriptor$Modifier;

                }
                interface ModuleDescriptor$Modifier extends java.lang.Enum<ModuleDescriptor$Modifier> {}

                const ModuleDescriptor$Opens$Modifier: JavaClassStatics<ModuleDescriptor$Opens$Modifier> & NoConstructor & {
                    readonly SYNTHETIC: ModuleDescriptor$Opens$Modifier;
                    readonly MANDATED: ModuleDescriptor$Opens$Modifier;

                    values(): JavaArray<ModuleDescriptor$Opens$Modifier>;
                    valueOf(arg0: string): ModuleDescriptor$Opens$Modifier;

                }
                interface ModuleDescriptor$Opens$Modifier extends java.lang.Enum<ModuleDescriptor$Opens$Modifier> {}

                const ModuleDescriptor$Requires$Modifier: JavaClassStatics<ModuleDescriptor$Requires$Modifier> & NoConstructor & {
                    readonly TRANSITIVE: ModuleDescriptor$Requires$Modifier;
                    readonly STATIC: ModuleDescriptor$Requires$Modifier;
                    readonly SYNTHETIC: ModuleDescriptor$Requires$Modifier;
                    readonly MANDATED: ModuleDescriptor$Requires$Modifier;

                    values(): JavaArray<ModuleDescriptor$Requires$Modifier>;
                    valueOf(arg0: string): ModuleDescriptor$Requires$Modifier;

                }
                interface ModuleDescriptor$Requires$Modifier extends java.lang.Enum<ModuleDescriptor$Requires$Modifier> {}

                const ModuleDescriptor$Exports$Modifier: JavaClassStatics<ModuleDescriptor$Exports$Modifier> & NoConstructor & {
                    readonly SYNTHETIC: ModuleDescriptor$Exports$Modifier;
                    readonly MANDATED: ModuleDescriptor$Exports$Modifier;

                    values(): JavaArray<ModuleDescriptor$Exports$Modifier>;
                    valueOf(arg0: string): ModuleDescriptor$Exports$Modifier;

                }
                interface ModuleDescriptor$Exports$Modifier extends java.lang.Enum<ModuleDescriptor$Exports$Modifier> {}

                const Configuration: JavaClassStatics<Configuration> & NoConstructor & {

                    resolve(arg0: ModuleFinder, arg1: JavaList<Configuration>, arg2: ModuleFinder, arg3: JavaCollection<string>): Configuration;
                    resolveAndBind(arg0: ModuleFinder, arg1: JavaList<Configuration>, arg2: ModuleFinder, arg3: JavaCollection<string>): Configuration;
                    empty(): Configuration;

                }
                interface Configuration extends JavaObject {

                    resolve(arg0: ModuleFinder, arg1: ModuleFinder, arg2: JavaCollection<string>): Configuration;
                    resolveAndBind(arg0: ModuleFinder, arg1: ModuleFinder, arg2: JavaCollection<string>): Configuration;
                    parents(): JavaList<Configuration>;
                    modules(): JavaSet<ResolvedModule>;
                    findModule(arg0: string): java.util.Optional<ResolvedModule>;

                }

                const ResolvedModule: JavaClassStatics<ResolvedModule> & NoConstructor;
                interface ResolvedModule extends JavaObject {

                    configuration(): Configuration;
                    reference(): ModuleReference;
                    name(): string;
                    reads(): JavaSet<ResolvedModule>;

                }

                const ModuleFinder: JavaInterfaceStatics<ModuleFinder> & {

                    ofSystem(): ModuleFinder;
                    of(...arg0: java.nio.file.Path[]): ModuleFinder;
                    compose(...arg0: ModuleFinder[]): ModuleFinder;

                }
                interface ModuleFinder extends JavaObject {

                    find(arg0: string): java.util.Optional<ModuleReference>;
                    findAll(): JavaSet<ModuleReference>;

                }

                const ModuleReference: JavaClassStatics<ModuleReference> & NoConstructor;
                interface ModuleReference extends JavaObject {

                    descriptor(): ModuleDescriptor;
                    location(): java.util.Optional<java.net.URI>;
                    open(): ModuleReader;

                }

                const ModuleReader: JavaInterfaceStatics<ModuleReader>;
                interface ModuleReader extends java.io.Closeable {

                    find(arg0: string): java.util.Optional<java.net.URI>;
                    open(arg0: string): java.util.Optional<java.io.InputStream>;
                    read(arg0: string): java.util.Optional<java.nio.ByteBuffer>;
                    release(arg0: java.nio.ByteBuffer): void;
                    list(): java.util.stream.Stream<string>;
                    close(): void;

                }

                export {
                    ModuleDescriptor,
                    ModuleDescriptor$Provides,
                    ModuleDescriptor$Exports,
                    ModuleDescriptor$Opens,
                    ModuleDescriptor$Requires,
                    ModuleDescriptor$Builder,
                    ModuleDescriptor$Version,
                    ModuleDescriptor$Modifier,
                    ModuleDescriptor$Opens$Modifier,
                    ModuleDescriptor$Requires$Modifier,
                    ModuleDescriptor$Exports$Modifier,
                    Configuration,
                    ResolvedModule,
                    ModuleFinder,
                    ModuleReference,
                    ModuleReader
                }

            }

        }

        namespace awt {

            const Rectangle: JavaClassStatics<Rectangle, Rectangle$$constructor>;
            interface Rectangle$$constructor extends SuppressProperties {

                new (): Rectangle;
                new (arg0: Rectangle): Rectangle;
                new (arg0: int, arg1: int, arg2: int, arg3: int): Rectangle;
                new (arg0: int, arg1: int): Rectangle;
                new (arg0: Point, arg1: Dimension): Rectangle;
                new (arg0: Point): Rectangle;
                new (arg0: Dimension): Rectangle;

            }
            interface Rectangle extends java.awt.geom.Rectangle2D, Shape, java.io.Serializable {
                x: number;
                y: number;
                width: number;
                height: number;

                getX(): number;
                getY(): number;
                getWidth(): number;
                getHeight(): number;
                getBounds(): Rectangle;
                getBounds2D(): java.awt.geom.Rectangle2D;
                setBounds(arg0: Rectangle): void;
                setBounds(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setRect(arg0: double, arg1: double, arg2: double, arg3: double): void;
                setRect(arg0: java.awt.geom.Rectangle2D): void;
                /** @deprecated */
                reshape(arg0: int, arg1: int, arg2: int, arg3: int): void;
                getLocation(): Point;
                setLocation(arg0: Point): void;
                setLocation(arg0: int, arg1: int): void;
                /** @deprecated */
                move(arg0: int, arg1: int): void;
                translate(arg0: int, arg1: int): void;
                getSize(): Dimension;
                setSize(arg0: Dimension): void;
                setSize(arg0: int, arg1: int): void;
                /** @deprecated */
                resize(arg0: int, arg1: int): void;
                contains(arg0: Point): boolean;
                contains(arg0: int, arg1: int): boolean;
                contains(arg0: Rectangle): boolean;
                contains(arg0: int, arg1: int, arg2: int, arg3: int): boolean;
                contains(arg0: double, arg1: double): boolean;
                contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                contains(arg0: java.awt.geom.Point2D): boolean;
                contains(arg0: java.awt.geom.Rectangle2D): boolean;
                /** @deprecated */
                inside(arg0: int, arg1: int): boolean;
                intersects(arg0: Rectangle): boolean;
                intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                intersects(arg0: java.awt.geom.Rectangle2D): boolean;
                intersection(arg0: Rectangle): Rectangle;
                union(arg0: Rectangle): Rectangle;
                add(arg0: int, arg1: int): void;
                add(arg0: Point): void;
                add(arg0: Rectangle): void;
                add(arg0: double, arg1: double): void;
                add(arg0: java.awt.geom.Point2D): void;
                add(arg0: java.awt.geom.Rectangle2D): void;
                grow(arg0: int, arg1: int): void;
                isEmpty(): boolean;
                outcode(arg0: double, arg1: double): number;
                outcode(arg0: java.awt.geom.Point2D): number;
                createIntersection(arg0: java.awt.geom.Rectangle2D): java.awt.geom.Rectangle2D;
                createUnion(arg0: java.awt.geom.Rectangle2D): java.awt.geom.Rectangle2D;

            }

            const Image: JavaClassStatics<Image> & NoConstructor & {
                readonly UndefinedProperty: any;
                readonly SCALE_DEFAULT: number;
                readonly SCALE_FAST: number;
                readonly SCALE_SMOOTH: number;
                readonly SCALE_REPLICATE: number;
                readonly SCALE_AREA_AVERAGING: number;
            }
            interface Image extends JavaObject {

                getWidth(arg0: java.awt.image.ImageObserver): number;
                getHeight(arg0: java.awt.image.ImageObserver): number;
                getSource(): java.awt.image.ImageProducer;
                getGraphics(): Graphics;
                getProperty(arg0: string, arg1: java.awt.image.ImageObserver): any;
                getScaledInstance(arg0: int, arg1: int, arg2: int): Image;
                flush(): void;
                getCapabilities(arg0: GraphicsConfiguration): ImageCapabilities;
                setAccelerationPriority(arg0: float): void;
                getAccelerationPriority(): number;

            }

            const Shape: JavaInterfaceStatics<Shape>;
            interface Shape extends JavaObject {

                getBounds(): Rectangle;
                getBounds2D(): java.awt.geom.Rectangle2D;
                contains(arg0: double, arg1: double): boolean;
                contains(arg0: java.awt.geom.Point2D): boolean;
                intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                intersects(arg0: java.awt.geom.Rectangle2D): boolean;
                contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                contains(arg0: java.awt.geom.Rectangle2D): boolean;
                getPathIterator(arg0: java.awt.geom.AffineTransform): java.awt.geom.PathIterator;
                getPathIterator(arg0: java.awt.geom.AffineTransform, arg1: double): java.awt.geom.PathIterator;

            }

            const Dimension: JavaClassStatics<Dimension, Dimension$$constructor>;
            interface Dimension$$constructor extends SuppressProperties {

                new (): Dimension;
                new (arg0: Dimension): Dimension;
                new (arg0: int, arg1: int): Dimension;

            }
            interface Dimension extends java.awt.geom.Dimension2D, java.io.Serializable {
                width: number;
                height: number;

                getWidth(): number;
                getHeight(): number;
                setSize(arg0: double, arg1: double): void;
                setSize(arg0: java.awt.geom.Dimension2D): void;
                getSize(): Dimension;
                setSize(arg0: Dimension): void;
                setSize(arg0: int, arg1: int): void;

            }

            const GraphicsConfiguration: JavaClassStatics<GraphicsConfiguration> & NoConstructor;
            interface GraphicsConfiguration extends JavaObject {

                getDevice(): GraphicsDevice;
                createCompatibleImage(arg0: int, arg1: int): java.awt.image.BufferedImage;
                createCompatibleImage(arg0: int, arg1: int, arg2: int): java.awt.image.BufferedImage;
                createCompatibleVolatileImage(arg0: int, arg1: int): java.awt.image.VolatileImage;
                createCompatibleVolatileImage(arg0: int, arg1: int, arg2: int): java.awt.image.VolatileImage;
                createCompatibleVolatileImage(arg0: int, arg1: int, arg2: ImageCapabilities): java.awt.image.VolatileImage;
                createCompatibleVolatileImage(arg0: int, arg1: int, arg2: ImageCapabilities, arg3: int): java.awt.image.VolatileImage;
                getColorModel(): java.awt.image.ColorModel;
                getColorModel(arg0: int): java.awt.image.ColorModel;
                getDefaultTransform(): java.awt.geom.AffineTransform;
                getNormalizingTransform(): java.awt.geom.AffineTransform;
                getBounds(): Rectangle;
                getBufferCapabilities(): BufferCapabilities;
                getImageCapabilities(): ImageCapabilities;
                isTranslucencyCapable(): boolean;

            }

            const ImageCapabilities: JavaClassStatics<ImageCapabilities, ImageCapabilities$$constructor>;
            interface ImageCapabilities$$constructor extends SuppressProperties {

                new (arg0: boolean): ImageCapabilities;

            }
            interface ImageCapabilities extends java.lang.Cloneable {

                isAccelerated(): boolean;
                isTrueVolatile(): boolean;
                clone(): any;

            }

            const Transparency: JavaInterfaceStatics<Transparency> & {
                readonly OPAQUE: number;
                readonly BITMASK: number;
                readonly TRANSLUCENT: number;
            }
            interface Transparency extends JavaObject {

                getTransparency(): number;

            }

            const Point: JavaClassStatics<Point, Point$$constructor>;
            interface Point$$constructor extends SuppressProperties {

                new (): Point;
                new (arg0: Point): Point;
                new (arg0: int, arg1: int): Point;

            }
            interface Point extends java.awt.geom.Point2D, java.io.Serializable {
                x: number;
                y: number;

                getX(): number;
                getY(): number;
                getLocation(): Point;
                setLocation(arg0: Point): void;
                setLocation(arg0: int, arg1: int): void;
                setLocation(arg0: double, arg1: double): void;
                setLocation(arg0: java.awt.geom.Point2D): void;
                move(arg0: int, arg1: int): void;
                translate(arg0: int, arg1: int): void;

            }

            const Graphics2D: JavaClassStatics<Graphics2D> & NoConstructor;
            interface Graphics2D extends Graphics {

                draw3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                fill3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                draw(arg0: Shape): void;
                drawImage(arg0: Image, arg1: java.awt.geom.AffineTransform, arg2: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: java.awt.image.BufferedImage, arg1: java.awt.image.BufferedImageOp, arg2: int, arg3: int): void;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: Color, arg4: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: Color, arg6: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: Color, arg10: java.awt.image.ImageObserver): boolean;
                drawRenderedImage(arg0: java.awt.image.RenderedImage, arg1: java.awt.geom.AffineTransform): void;
                drawRenderableImage(arg0: java.awt.image.renderable.RenderableImage, arg1: java.awt.geom.AffineTransform): void;
                drawString(arg0: string, arg1: int, arg2: int): void;
                drawString(arg0: string, arg1: float, arg2: float): void;
                drawString(arg0: java.text.AttributedCharacterIterator, arg1: int, arg2: int): void;
                drawString(arg0: java.text.AttributedCharacterIterator, arg1: float, arg2: float): void;
                drawGlyphVector(arg0: java.awt.font.GlyphVector, arg1: float, arg2: float): void;
                fill(arg0: Shape): void;
                hit(arg0: Rectangle, arg1: Shape, arg2: boolean): boolean;
                getDeviceConfiguration(): GraphicsConfiguration;
                setComposite(arg0: Composite): void;
                setPaint(arg0: Paint): void;
                setStroke(arg0: Stroke): void;
                setRenderingHint(arg0: RenderingHints$Key, arg1: any): void;
                getRenderingHint(arg0: RenderingHints$Key): any;
                setRenderingHints(arg0: JavaMap<any, any>): void;
                addRenderingHints(arg0: JavaMap<any, any>): void;
                getRenderingHints(): RenderingHints;
                translate(arg0: int, arg1: int): void;
                translate(arg0: double, arg1: double): void;
                rotate(arg0: double): void;
                rotate(arg0: double, arg1: double, arg2: double): void;
                scale(arg0: double, arg1: double): void;
                shear(arg0: double, arg1: double): void;
                transform(arg0: java.awt.geom.AffineTransform): void;
                setTransform(arg0: java.awt.geom.AffineTransform): void;
                getTransform(): java.awt.geom.AffineTransform;
                getPaint(): Paint;
                getComposite(): Composite;
                setBackground(arg0: Color): void;
                getBackground(): Color;
                getStroke(): Stroke;
                clip(arg0: Shape): void;
                getFontRenderContext(): java.awt.font.FontRenderContext;

            }

            const Graphics: JavaClassStatics<Graphics> & NoConstructor;
            interface Graphics extends JavaObject {

                create(): Graphics;
                create(arg0: int, arg1: int, arg2: int, arg3: int): Graphics;
                translate(arg0: int, arg1: int): void;
                getColor(): Color;
                setColor(arg0: Color): void;
                setPaintMode(): void;
                setXORMode(arg0: Color): void;
                getFont(): Font;
                setFont(arg0: Font): void;
                getFontMetrics(): FontMetrics;
                getFontMetrics(arg0: Font): FontMetrics;
                getClipBounds(): Rectangle;
                clipRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setClip(arg0: int, arg1: int, arg2: int, arg3: int): void;
                getClip(): Shape;
                setClip(arg0: Shape): void;
                copyArea(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                drawLine(arg0: int, arg1: int, arg2: int, arg3: int): void;
                fillRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                drawRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                clearRect(arg0: int, arg1: int, arg2: int, arg3: int): void;
                drawRoundRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                fillRoundRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                draw3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                fill3DRect(arg0: int, arg1: int, arg2: int, arg3: int, arg4: boolean): void;
                drawOval(arg0: int, arg1: int, arg2: int, arg3: int): void;
                fillOval(arg0: int, arg1: int, arg2: int, arg3: int): void;
                drawArc(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                fillArc(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): void;
                drawPolyline(arg0: int[], arg1: int[], arg2: int): void;
                drawPolygon(arg0: int[], arg1: int[], arg2: int): void;
                drawPolygon(arg0: Polygon): void;
                fillPolygon(arg0: int[], arg1: int[], arg2: int): void;
                fillPolygon(arg0: Polygon): void;
                drawString(arg0: string, arg1: int, arg2: int): void;
                drawString(arg0: java.text.AttributedCharacterIterator, arg1: int, arg2: int): void;
                drawChars(arg0: char[], arg1: int, arg2: int, arg3: int, arg4: int): void;
                drawBytes(arg0: byte[], arg1: int, arg2: int, arg3: int, arg4: int): void;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: Color, arg4: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: Color, arg6: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: java.awt.image.ImageObserver): boolean;
                drawImage(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: Color, arg10: java.awt.image.ImageObserver): boolean;
                dispose(): void;
                /** @deprecated */
                finalize(): void;
                /** @deprecated */
                getClipRect(): Rectangle;
                hitClip(arg0: int, arg1: int, arg2: int, arg3: int): boolean;
                getClipBounds(arg0: Rectangle): Rectangle;

            }

            const Stroke: JavaInterfaceStatics<Stroke>;
            interface Stroke extends JavaObject {

                createStrokedShape(arg0: Shape): Shape;

            }

            const Composite: JavaInterfaceStatics<Composite>;
            interface Composite extends JavaObject {

                createContext(arg0: java.awt.image.ColorModel, arg1: java.awt.image.ColorModel, arg2: RenderingHints): CompositeContext;

            }

            const GraphicsDevice: JavaClassStatics<GraphicsDevice> & NoConstructor & {
                readonly TYPE_RASTER_SCREEN: number;
                readonly TYPE_PRINTER: number;
                readonly TYPE_IMAGE_BUFFER: number;
            }
            interface GraphicsDevice extends JavaObject {

                getType(): number;
                getIDstring(): string;
                getConfigurations(): JavaArray<GraphicsConfiguration>;
                getDefaultConfiguration(): GraphicsConfiguration;
                getBestConfiguration(arg0: GraphicsConfigTemplate): GraphicsConfiguration;
                isFullScreenSupported(): boolean;
                setFullScreenWindow(arg0: Window): void;
                getFullScreenWindow(): Window;
                isDisplayChangeSupported(): boolean;
                setDisplayMode(arg0: DisplayMode): void;
                getDisplayMode(): DisplayMode;
                getDisplayModes(): JavaArray<DisplayMode>;
                getAvailableAcceleratedMemory(): number;
                isWindowTranslucencySupported(arg0: GraphicsDevice$WindowTranslucency): boolean;

            }

            const RenderingHints: JavaClassStatics<RenderingHints, RenderingHints$$constructor> & {
                readonly KEY_ANTIALIASING: RenderingHints$Key;
                readonly VALUE_ANTIALIAS_ON: any;
                readonly VALUE_ANTIALIAS_OFF: any;
                readonly VALUE_ANTIALIAS_DEFAULT: any;
                readonly KEY_RENDERING: RenderingHints$Key;
                readonly VALUE_RENDER_SPEED: any;
                readonly VALUE_RENDER_QUALITY: any;
                readonly VALUE_RENDER_DEFAULT: any;
                readonly KEY_DITHERING: RenderingHints$Key;
                readonly VALUE_DITHER_DISABLE: any;
                readonly VALUE_DITHER_ENABLE: any;
                readonly VALUE_DITHER_DEFAULT: any;
                readonly KEY_TEXT_ANTIALIASING: RenderingHints$Key;
                readonly VALUE_TEXT_ANTIALIAS_ON: any;
                readonly VALUE_TEXT_ANTIALIAS_OFF: any;
                readonly VALUE_TEXT_ANTIALIAS_DEFAULT: any;
                readonly VALUE_TEXT_ANTIALIAS_GASP: any;
                readonly VALUE_TEXT_ANTIALIAS_LCD_HRGB: any;
                readonly VALUE_TEXT_ANTIALIAS_LCD_HBGR: any;
                readonly VALUE_TEXT_ANTIALIAS_LCD_VRGB: any;
                readonly VALUE_TEXT_ANTIALIAS_LCD_VBGR: any;
                readonly KEY_TEXT_LCD_CONTRAST: RenderingHints$Key;
                readonly KEY_FRACTIONALMETRICS: RenderingHints$Key;
                readonly VALUE_FRACTIONALMETRICS_OFF: any;
                readonly VALUE_FRACTIONALMETRICS_ON: any;
                readonly VALUE_FRACTIONALMETRICS_DEFAULT: any;
                readonly KEY_INTERPOLATION: RenderingHints$Key;
                readonly VALUE_INTERPOLATION_NEAREST_NEIGHBOR: any;
                readonly VALUE_INTERPOLATION_BILINEAR: any;
                readonly VALUE_INTERPOLATION_BICUBIC: any;
                readonly KEY_ALPHA_INTERPOLATION: RenderingHints$Key;
                readonly VALUE_ALPHA_INTERPOLATION_SPEED: any;
                readonly VALUE_ALPHA_INTERPOLATION_QUALITY: any;
                readonly VALUE_ALPHA_INTERPOLATION_DEFAULT: any;
                readonly KEY_COLOR_RENDERING: RenderingHints$Key;
                readonly VALUE_COLOR_RENDER_SPEED: any;
                readonly VALUE_COLOR_RENDER_QUALITY: any;
                readonly VALUE_COLOR_RENDER_DEFAULT: any;
                readonly KEY_STROKE_CONTROL: RenderingHints$Key;
                readonly VALUE_STROKE_DEFAULT: any;
                readonly VALUE_STROKE_NORMALIZE: any;
                readonly VALUE_STROKE_PURE: any;
                readonly KEY_RESOLUTION_VARIANT: RenderingHints$Key;
                readonly VALUE_RESOLUTION_VARIANT_DEFAULT: any;
                readonly VALUE_RESOLUTION_VARIANT_BASE: any;
                readonly VALUE_RESOLUTION_VARIANT_SIZE_FIT: any;
                readonly VALUE_RESOLUTION_VARIANT_DPI_FIT: any;
            }
            interface RenderingHints$$constructor extends SuppressProperties {

                new (arg0: JavaMap<RenderingHints$Key, any>): RenderingHints;
                new (arg0: RenderingHints$Key, arg1: any): RenderingHints;

            }
            interface RenderingHints extends JavaMap<any, any>, java.lang.Cloneable {

                size(): number;
                isEmpty(): boolean;
                containsKey(arg0: any): boolean;
                containsValue(arg0: any): boolean;
                get(arg0: any): any;
                put(arg0: any, arg1: any): any;
                add(arg0: RenderingHints): void;
                clear(): void;
                remove(arg0: any): any;
                remove(arg0: any, arg1: any): boolean;
                putAll(arg0: JavaMap<any, any>): void;
                keySet(): JavaSet<any>;
                values(): JavaCollection<any>;
                entrySet(): JavaSet<java.util.Map$Entry<any, any>>;
                clone(): any;

            }

            const RenderingHints$Key: JavaClassStatics<RenderingHints$Key> & NoConstructor;
            interface RenderingHints$Key extends JavaObject {

                isCompatibleValue(arg0: any): boolean;

            }

            const Color: JavaClassStatics<Color, Color$$constructor> & {
                readonly white: Color;
                readonly WHITE: Color;
                readonly lightGray: Color;
                readonly LIGHT_GRAY: Color;
                readonly gray: Color;
                readonly GRAY: Color;
                readonly darkGray: Color;
                readonly DARK_GRAY: Color;
                readonly black: Color;
                readonly BLACK: Color;
                readonly red: Color;
                readonly RED: Color;
                readonly pink: Color;
                readonly PINK: Color;
                readonly orange: Color;
                readonly ORANGE: Color;
                readonly yellow: Color;
                readonly YELLOW: Color;
                readonly green: Color;
                readonly GREEN: Color;
                readonly magenta: Color;
                readonly MAGENTA: Color;
                readonly cyan: Color;
                readonly CYAN: Color;
                readonly blue: Color;
                readonly BLUE: Color;

                decode(arg0: string): Color;
                getColor(arg0: string): Color;
                getColor(arg0: string, arg1: Color): Color;
                getColor(arg0: string, arg1: int): Color;
                HSBtoRGB(arg0: float, arg1: float, arg2: float): number;
                RGBtoHSB(arg0: int, arg1: int, arg2: int, arg3: float[]): JavaArray<number>;
                getHSBColor(arg0: float, arg1: float, arg2: float): Color;

            }
            interface Color$$constructor extends SuppressProperties {

                new (arg0: int, arg1: int, arg2: int): Color;
                new (arg0: int, arg1: int, arg2: int, arg3: int): Color;
                new (arg0: int): Color;
                new (arg0: int, arg1: boolean): Color;
                new (arg0: float, arg1: float, arg2: float): Color;
                new (arg0: float, arg1: float, arg2: float, arg3: float): Color;
                new (arg0: java.awt.color.ColorSpace, arg1: float[], arg2: float): Color;

            }
            interface Color extends Paint, java.io.Serializable {

                getRed(): number;
                getGreen(): number;
                getBlue(): number;
                getAlpha(): number;
                getRGB(): number;
                brighter(): Color;
                darker(): Color;
                getRGBComponents(arg0: float[]): JavaArray<number>;
                getRGBColorComponents(arg0: float[]): JavaArray<number>;
                getComponents(arg0: float[]): JavaArray<number>;
                getColorComponents(arg0: float[]): JavaArray<number>;
                getComponents(arg0: java.awt.color.ColorSpace, arg1: float[]): JavaArray<number>;
                getColorComponents(arg0: java.awt.color.ColorSpace, arg1: float[]): JavaArray<number>;
                getColorSpace(): java.awt.color.ColorSpace;
                createContext(arg0: java.awt.image.ColorModel, arg1: Rectangle, arg2: java.awt.geom.Rectangle2D, arg3: java.awt.geom.AffineTransform, arg4: RenderingHints): PaintContext;
                getTransparency(): number;

            }

            const Paint: JavaInterfaceStatics<Paint>;
            interface Paint extends Transparency {

                createContext(arg0: java.awt.image.ColorModel, arg1: Rectangle, arg2: java.awt.geom.Rectangle2D, arg3: java.awt.geom.AffineTransform, arg4: RenderingHints): PaintContext;

            }

            const Font: JavaClassStatics<Font, Font$$constructor> & {
                readonly DIALOG: string;
                readonly DIALOG_INPUT: string;
                readonly SANS_SERIF: string;
                readonly SERIF: string;
                readonly MONOSPACED: string;
                readonly PLAIN: number;
                readonly BOLD: number;
                readonly ITALIC: number;
                readonly ROMAN_BASELINE: number;
                readonly CENTER_BASELINE: number;
                readonly HANGING_BASELINE: number;
                readonly TRUETYPE_FONT: number;
                readonly TYPE1_FONT: number;
                readonly LAYOUT_LEFT_TO_RIGHT: number;
                readonly LAYOUT_RIGHT_TO_LEFT: number;
                readonly LAYOUT_NO_START_CONTEXT: number;
                readonly LAYOUT_NO_LIMIT_CONTEXT: number;

                textRequiresLayout(arg0: char[], arg1: int, arg2: int): boolean;
                getFont(arg0: JavaMap<any, any>): Font;
                createFonts(arg0: java.io.InputStream): JavaArray<Font>;
                createFonts(arg0: java.io.File): JavaArray<Font>;
                createFont(arg0: int, arg1: java.io.InputStream): Font;
                createFont(arg0: int, arg1: java.io.File): Font;
                getFont(arg0: string): Font;
                decode(arg0: string): Font;
                getFont(arg0: string, arg1: Font): Font;

            }
            interface Font$$constructor extends SuppressProperties {

                new (arg0: string, arg1: int, arg2: int): Font;
                new (arg0: JavaMap<any, any>): Font;

            }
            interface Font extends java.io.Serializable {

                getTransform(): java.awt.geom.AffineTransform;
                getFamily(): string;
                getFamily(arg0: java.util.Locale): string;
                getPSName(): string;
                getName(): string;
                getFontName(): string;
                getFontName(arg0: java.util.Locale): string;
                getStyle(): number;
                getSize(): number;
                getSize2D(): number;
                isPlain(): boolean;
                isBold(): boolean;
                isItalic(): boolean;
                isTransformed(): boolean;
                hasLayoutAttributes(): boolean;
                getNumGlyphs(): number;
                getMissingGlyphCode(): number;
                getBaselineFor(arg0: char): number;
                getAttributes(): JavaMap<java.awt.font.TextAttribute, any>;
                getAvailableAttributes(): JavaArray<java.text.AttributedCharacterIterator$Attribute>;
                deriveFont(arg0: int, arg1: float): Font;
                deriveFont(arg0: int, arg1: java.awt.geom.AffineTransform): Font;
                deriveFont(arg0: float): Font;
                deriveFont(arg0: java.awt.geom.AffineTransform): Font;
                deriveFont(arg0: int): Font;
                deriveFont(arg0: JavaMap<any, any>): Font;
                canDisplay(arg0: char): boolean;
                canDisplay(arg0: int): boolean;
                canDisplayUpTo(arg0: string): number;
                canDisplayUpTo(arg0: char[], arg1: int, arg2: int): number;
                canDisplayUpTo(arg0: java.text.CharacterIterator, arg1: int, arg2: int): number;
                getItalicAngle(): number;
                hasUniformLineMetrics(): boolean;
                getLineMetrics(arg0: string, arg1: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getLineMetrics(arg0: string, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getLineMetrics(arg0: char[], arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getLineMetrics(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.font.LineMetrics;
                getStringBounds(arg0: string, arg1: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: string, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: char[], arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                getMaxCharBounds(arg0: java.awt.font.FontRenderContext): java.awt.geom.Rectangle2D;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: string): java.awt.font.GlyphVector;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: char[]): java.awt.font.GlyphVector;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: java.text.CharacterIterator): java.awt.font.GlyphVector;
                createGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: int[]): java.awt.font.GlyphVector;
                layoutGlyphVector(arg0: java.awt.font.FontRenderContext, arg1: char[], arg2: int, arg3: int, arg4: int): java.awt.font.GlyphVector;

            }

            const Polygon: JavaClassStatics<Polygon, Polygon$$constructor>;
            interface Polygon$$constructor extends SuppressProperties {

                new (): Polygon;
                new (arg0: int[], arg1: int[], arg2: int): Polygon;

            }
            interface Polygon extends Shape, java.io.Serializable {
                npoints: number;
                xpoints: JavaArray<number>;
                ypoints: JavaArray<number>;

                reset(): void;
                invalidate(): void;
                translate(arg0: int, arg1: int): void;
                addPoint(arg0: int, arg1: int): void;
                getBounds(): Rectangle;
                /** @deprecated */
                getBoundingBox(): Rectangle;
                contains(arg0: Point): boolean;
                contains(arg0: int, arg1: int): boolean;
                /** @deprecated */
                inside(arg0: int, arg1: int): boolean;
                getBounds2D(): java.awt.geom.Rectangle2D;
                contains(arg0: double, arg1: double): boolean;
                contains(arg0: java.awt.geom.Point2D): boolean;
                intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                intersects(arg0: java.awt.geom.Rectangle2D): boolean;
                contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                contains(arg0: java.awt.geom.Rectangle2D): boolean;
                getPathIterator(arg0: java.awt.geom.AffineTransform): java.awt.geom.PathIterator;
                getPathIterator(arg0: java.awt.geom.AffineTransform, arg1: double): java.awt.geom.PathIterator;

            }

            const BufferCapabilities: JavaClassStatics<BufferCapabilities, BufferCapabilities$$constructor>;
            interface BufferCapabilities$$constructor extends SuppressProperties {

                new (arg0: ImageCapabilities, arg1: ImageCapabilities, arg2: BufferCapabilities$FlipContents): BufferCapabilities;

            }
            interface BufferCapabilities extends java.lang.Cloneable {

                getFrontBufferCapabilities(): ImageCapabilities;
                getBackBufferCapabilities(): ImageCapabilities;
                isPageFlipping(): boolean;
                getFlipContents(): BufferCapabilities$FlipContents;
                isFullScreenRequired(): boolean;
                isMultiBufferAvailable(): boolean;
                clone(): any;

            }

            const FontMetrics: JavaClassStatics<FontMetrics> & NoConstructor;
            interface FontMetrics extends java.io.Serializable {

                getFont(): Font;
                getFontRenderContext(): java.awt.font.FontRenderContext;
                getLeading(): number;
                getAscent(): number;
                getDescent(): number;
                getHeight(): number;
                getMaxAscent(): number;
                getMaxDescent(): number;
                /** @deprecated */
                getMaxDecent(): number;
                getMaxAdvance(): number;
                charWidth(arg0: int): number;
                charWidth(arg0: char): number;
                stringWidth(arg0: string): number;
                charsWidth(arg0: char[], arg1: int, arg2: int): number;
                bytesWidth(arg0: byte[], arg1: int, arg2: int): number;
                getWidths(): JavaArray<number>;
                hasUniformLineMetrics(): boolean;
                getLineMetrics(arg0: string, arg1: Graphics): java.awt.font.LineMetrics;
                getLineMetrics(arg0: string, arg1: int, arg2: int, arg3: Graphics): java.awt.font.LineMetrics;
                getLineMetrics(arg0: char[], arg1: int, arg2: int, arg3: Graphics): java.awt.font.LineMetrics;
                getLineMetrics(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: Graphics): java.awt.font.LineMetrics;
                getStringBounds(arg0: string, arg1: Graphics): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: string, arg1: int, arg2: int, arg3: Graphics): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: char[], arg1: int, arg2: int, arg3: Graphics): java.awt.geom.Rectangle2D;
                getStringBounds(arg0: java.text.CharacterIterator, arg1: int, arg2: int, arg3: Graphics): java.awt.geom.Rectangle2D;
                getMaxCharBounds(arg0: Graphics): java.awt.geom.Rectangle2D;

            }

            const PaintContext: JavaInterfaceStatics<PaintContext>;
            interface PaintContext extends JavaObject {

                dispose(): void;
                getColorModel(): java.awt.image.ColorModel;
                getRaster(arg0: int, arg1: int, arg2: int, arg3: int): java.awt.image.Raster;

            }

            const DisplayMode: JavaClassStatics<DisplayMode, DisplayMode$$constructor> & {
                readonly BIT_DEPTH_MULTI: number;
                readonly REFRESH_RATE_UNKNOWN: number;
            }
            interface DisplayMode$$constructor extends SuppressProperties {

                new (arg0: int, arg1: int, arg2: int, arg3: int): DisplayMode;

            }
            interface DisplayMode extends JavaObject {

                getHeight(): number;
                getWidth(): number;
                getBitDepth(): number;
                getRefreshRate(): number;
                equals(arg0: DisplayMode): boolean;

            }

            const Window: JavaClassStatics<Window, Window$$constructor> & {

                getWindows(): JavaArray<Window>;
                getOwnerlessWindows(): JavaArray<Window>;

            }
            interface Window$$constructor extends SuppressProperties {

                new (arg0: Frame): Window;
                new (arg0: Window): Window;
                new (arg0: Window, arg1: GraphicsConfiguration): Window;

            }
            interface Window extends Container, javax.accessibility.Accessible {

                getIconImages(): JavaList<Image>;
                setIconImages(arg0: JavaList<any>): void;
                setIconImage(arg0: Image): void;
                addNotify(): void;
                removeNotify(): void;
                pack(): void;
                setMinimumSize(arg0: Dimension): void;
                setSize(arg0: Dimension): void;
                setSize(arg0: int, arg1: int): void;
                setLocation(arg0: int, arg1: int): void;
                setLocation(arg0: Point): void;
                /** @deprecated */
                reshape(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setVisible(arg0: boolean): void;
                /** @deprecated */
                show(): void;
                /** @deprecated */
                show(arg0: boolean): void;
                /** @deprecated */
                hide(): void;
                dispose(): void;
                toFront(): void;
                toBack(): void;
                getToolkit(): Toolkit;
                getWarningString(): string;
                getLocale(): java.util.Locale;
                getInputContext(): java.awt.im.InputContext;
                setCursor(arg0: Cursor): void;
                getOwner(): Window;
                getOwnedWindows(): JavaArray<Window>;
                setModalExclusionType(arg0: Dialog$ModalExclusionType): void;
                getModalExclusionType(): Dialog$ModalExclusionType;
                addWindowListener(arg0: java.awt.event.WindowListener): void;
                addWindowStateListener(arg0: java.awt.event.WindowStateListener): void;
                addWindowFocusListener(arg0: java.awt.event.WindowFocusListener): void;
                removeWindowListener(arg0: java.awt.event.WindowListener): void;
                removeWindowStateListener(arg0: java.awt.event.WindowStateListener): void;
                removeWindowFocusListener(arg0: java.awt.event.WindowFocusListener): void;
                getWindowListeners(): JavaArray<java.awt.event.WindowListener>;
                getWindowFocusListeners(): JavaArray<java.awt.event.WindowFocusListener>;
                getWindowStateListeners(): JavaArray<java.awt.event.WindowStateListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                setAlwaysOnTop(arg0: boolean): void;
                isAlwaysOnTopSupported(): boolean;
                isAlwaysOnTop(): boolean;
                getFocusOwner(): Component;
                getMostRecentFocusOwner(): Component;
                isActive(): boolean;
                isFocused(): boolean;
                getFocusTraversalKeys(arg0: int): JavaSet<AWTKeyStroke>;
                setFocusCycleRoot(arg0: boolean): void;
                isFocusCycleRoot(): boolean;
                isFocusCycleRoot(arg0: Container): boolean;
                getFocusCycleRootAncestor(): Container;
                isFocusableWindow(): boolean;
                getFocusableWindowState(): boolean;
                setFocusableWindowState(arg0: boolean): void;
                setAutoRequestFocus(arg0: boolean): void;
                isAutoRequestFocus(): boolean;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                isValidateRoot(): boolean;
                /** @deprecated */
                postEvent(arg0: Event): boolean;
                isShowing(): boolean;
                /** @deprecated */
                applyResourceBundle(arg0: java.util.ResourceBundle): void;
                /** @deprecated */
                applyResourceBundle(arg0: string): void;
                setType(arg0: Window$Type): void;
                getType(): Window$Type;
                getAccessibleContext(): javax.accessibility.AccessibleContext;
                setLocationRelativeTo(arg0: Component): void;
                createBufferStrategy(arg0: int): void;
                createBufferStrategy(arg0: int, arg1: BufferCapabilities): void;
                getBufferStrategy(): java.awt.image.BufferStrategy;
                setLocationByPlatform(arg0: boolean): void;
                isLocationByPlatform(): boolean;
                setBounds(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setBounds(arg0: Rectangle): void;
                getOpacity(): number;
                setOpacity(arg0: float): void;
                getShape(): Shape;
                setShape(arg0: Shape): void;
                getBackground(): Color;
                setBackground(arg0: Color): void;
                isOpaque(): boolean;
                paint(arg0: Graphics): void;

            }

            const GraphicsDevice$WindowTranslucency: JavaClassStatics<GraphicsDevice$WindowTranslucency> & NoConstructor & {
                readonly PERPIXEL_TRANSPARENT: GraphicsDevice$WindowTranslucency;
                readonly TRANSLUCENT: GraphicsDevice$WindowTranslucency;
                readonly PERPIXEL_TRANSLUCENT: GraphicsDevice$WindowTranslucency;

                values(): JavaArray<GraphicsDevice$WindowTranslucency>;
                valueOf(arg0: string): GraphicsDevice$WindowTranslucency;

            }
            interface GraphicsDevice$WindowTranslucency extends java.lang.Enum<GraphicsDevice$WindowTranslucency> {}

            const CompositeContext: JavaInterfaceStatics<CompositeContext>;
            interface CompositeContext extends JavaObject {

                dispose(): void;
                compose(arg0: java.awt.image.Raster, arg1: java.awt.image.Raster, arg2: java.awt.image.WritableRaster): void;

            }

            const GraphicsConfigTemplate: JavaClassStatics<GraphicsConfigTemplate, GraphicsConfigTemplate$$constructor> & {
                readonly REQUIRED: number;
                readonly PREFERRED: number;
                readonly UNNECESSARY: number;
            }
            interface GraphicsConfigTemplate$$constructor extends SuppressProperties {

                new (): GraphicsConfigTemplate;

            }
            interface GraphicsConfigTemplate extends java.io.Serializable {

                getBestConfiguration(arg0: GraphicsConfiguration[]): GraphicsConfiguration;
                isGraphicsConfigSupported(arg0: GraphicsConfiguration): boolean;

            }

            const BufferCapabilities$FlipContents: JavaClassStatics<BufferCapabilities$FlipContents> & NoConstructor & {
                readonly UNDEFINED: BufferCapabilities$FlipContents;
                readonly BACKGROUND: BufferCapabilities$FlipContents;
                readonly PRIOR: BufferCapabilities$FlipContents;
                readonly COPIED: BufferCapabilities$FlipContents;
            }
            interface BufferCapabilities$FlipContents extends AttributeValue {}

            const Dialog$ModalExclusionType: JavaClassStatics<Dialog$ModalExclusionType> & NoConstructor & {
                readonly NO_EXCLUDE: Dialog$ModalExclusionType;
                readonly APPLICATION_EXCLUDE: Dialog$ModalExclusionType;
                readonly TOOLKIT_EXCLUDE: Dialog$ModalExclusionType;

                values(): JavaArray<Dialog$ModalExclusionType>;
                valueOf(arg0: string): Dialog$ModalExclusionType;

            }
            interface Dialog$ModalExclusionType extends java.lang.Enum<Dialog$ModalExclusionType> {}

            const AWTKeyStroke: JavaClassStatics<AWTKeyStroke> & NoConstructor & {

                getAWTKeyStroke(arg0: char): AWTKeyStroke;
                getAWTKeyStroke(arg0: char, arg1: int): AWTKeyStroke;
                getAWTKeyStroke(arg0: int, arg1: int, arg2: boolean): AWTKeyStroke;
                getAWTKeyStroke(arg0: int, arg1: int): AWTKeyStroke;
                getAWTKeyStrokeForEvent(arg0: java.awt.event.KeyEvent): AWTKeyStroke;
                getAWTKeyStroke(arg0: string): AWTKeyStroke;

            }
            interface AWTKeyStroke extends java.io.Serializable {

                getKeyChar(): number;
                getKeyCode(): number;
                getModifiers(): number;
                isOnKeyRelease(): boolean;
                getKeyEventType(): number;

            }

            const Toolkit: JavaClassStatics<Toolkit> & NoConstructor & {

                getDefaultToolkit(): Toolkit;
                getProperty(arg0: string, arg1: string): string;

            }
            interface Toolkit extends JavaObject {

                setDynamicLayout(arg0: boolean): void;
                isDynamicLayoutActive(): boolean;
                getScreenSize(): Dimension;
                getScreenResolution(): number;
                getScreenInsets(arg0: GraphicsConfiguration): Insets;
                getColorModel(): java.awt.image.ColorModel;
                /** @deprecated */
                getFontList(): JavaArray<string>;
                /** @deprecated */
                getFontMetrics(arg0: Font): FontMetrics;
                sync(): void;
                getImage(arg0: string): Image;
                getImage(arg0: java.net.URL): Image;
                createImage(arg0: string): Image;
                createImage(arg0: java.net.URL): Image;
                prepareImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                checkImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): number;
                createImage(arg0: java.awt.image.ImageProducer): Image;
                createImage(arg0: byte[]): Image;
                createImage(arg0: byte[], arg1: int, arg2: int): Image;
                getPrintJob(arg0: Frame, arg1: string, arg2: java.util.Properties): PrintJob;
                getPrintJob(arg0: Frame, arg1: string, arg2: JobAttributes, arg3: PageAttributes): PrintJob;
                beep(): void;
                getSystemClipboard(): java.awt.datatransfer.Clipboard;
                getSystemSelection(): java.awt.datatransfer.Clipboard;
                /** @deprecated */
                getMenuShortcutKeyMask(): number;
                getMenuShortcutKeyMaskEx(): number;
                getLockingKeyState(arg0: int): boolean;
                setLockingKeyState(arg0: int, arg1: boolean): void;
                createCustomCursor(arg0: Image, arg1: Point, arg2: string): Cursor;
                getBestCursorSize(arg0: int, arg1: int): Dimension;
                getMaximumCursorColors(): number;
                isFrameStateSupported(arg0: int): boolean;
                getSystemEventQueue(): EventQueue;
                createDragGestureRecognizer<T extends java.awt.dnd.DragGestureRecognizer>(arg0: JavaClassArg<T>, arg1: java.awt.dnd.DragSource, arg2: Component, arg3: int, arg4: java.awt.dnd.DragGestureListener): T;
                getDesktopProperty(arg0: string): any;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                getPropertyChangeListeners(): JavaArray<java.beans.PropertyChangeListener>;
                getPropertyChangeListeners(arg0: string): JavaArray<java.beans.PropertyChangeListener>;
                isAlwaysOnTopSupported(): boolean;
                isModalityTypeSupported(arg0: Dialog$ModalityType): boolean;
                isModalExclusionTypeSupported(arg0: Dialog$ModalExclusionType): boolean;
                addAWTEventListener(arg0: java.awt.event.AWTEventListener, arg1: long): void;
                removeAWTEventListener(arg0: java.awt.event.AWTEventListener): void;
                getAWTEventListeners(): JavaArray<java.awt.event.AWTEventListener>;
                getAWTEventListeners(arg0: long): JavaArray<java.awt.event.AWTEventListener>;
                mapInputMethodHighlight(arg0: java.awt.im.InputMethodHighlight): JavaMap<java.awt.font.TextAttribute, any>;
                areExtraMouseButtonsEnabled(): boolean;

            }

            const Component: JavaClassStatics<Component> & NoConstructor & {
                readonly TOP_ALIGNMENT: number;
                readonly CENTER_ALIGNMENT: number;
                readonly BOTTOM_ALIGNMENT: number;
                readonly LEFT_ALIGNMENT: number;
                readonly RIGHT_ALIGNMENT: number;
            }
            interface Component extends java.awt.image.ImageObserver, MenuContainer, java.io.Serializable {

                getName(): string;
                setName(arg0: string): void;
                getParent(): Container;
                setDropTarget(arg0: java.awt.dnd.DropTarget): void;
                getDropTarget(): java.awt.dnd.DropTarget;
                getGraphicsConfiguration(): GraphicsConfiguration;
                getTreeLock(): any;
                getToolkit(): Toolkit;
                isValid(): boolean;
                isDisplayable(): boolean;
                isVisible(): boolean;
                getMousePosition(): Point;
                isShowing(): boolean;
                isEnabled(): boolean;
                setEnabled(arg0: boolean): void;
                /** @deprecated */
                enable(): void;
                /** @deprecated */
                enable(arg0: boolean): void;
                /** @deprecated */
                disable(): void;
                isDoubleBuffered(): boolean;
                enableInputMethods(arg0: boolean): void;
                setVisible(arg0: boolean): void;
                /** @deprecated */
                show(): void;
                /** @deprecated */
                show(arg0: boolean): void;
                /** @deprecated */
                hide(): void;
                getForeground(): Color;
                setForeground(arg0: Color): void;
                isForegroundSet(): boolean;
                getBackground(): Color;
                setBackground(arg0: Color): void;
                isBackgroundSet(): boolean;
                getFont(): Font;
                setFont(arg0: Font): void;
                isFontSet(): boolean;
                getLocale(): java.util.Locale;
                setLocale(arg0: java.util.Locale): void;
                getColorModel(): java.awt.image.ColorModel;
                getLocation(): Point;
                getLocationOnScreen(): Point;
                /** @deprecated */
                location(): Point;
                setLocation(arg0: int, arg1: int): void;
                /** @deprecated */
                move(arg0: int, arg1: int): void;
                setLocation(arg0: Point): void;
                getSize(): Dimension;
                /** @deprecated */
                size(): Dimension;
                setSize(arg0: int, arg1: int): void;
                /** @deprecated */
                resize(arg0: int, arg1: int): void;
                setSize(arg0: Dimension): void;
                /** @deprecated */
                resize(arg0: Dimension): void;
                getBounds(): Rectangle;
                /** @deprecated */
                bounds(): Rectangle;
                setBounds(arg0: int, arg1: int, arg2: int, arg3: int): void;
                /** @deprecated */
                reshape(arg0: int, arg1: int, arg2: int, arg3: int): void;
                setBounds(arg0: Rectangle): void;
                getX(): number;
                getY(): number;
                getWidth(): number;
                getHeight(): number;
                getBounds(arg0: Rectangle): Rectangle;
                getSize(arg0: Dimension): Dimension;
                getLocation(arg0: Point): Point;
                isOpaque(): boolean;
                isLightweight(): boolean;
                setPreferredSize(arg0: Dimension): void;
                isPreferredSizeSet(): boolean;
                getPreferredSize(): Dimension;
                /** @deprecated */
                preferredSize(): Dimension;
                setMinimumSize(arg0: Dimension): void;
                isMinimumSizeSet(): boolean;
                getMinimumSize(): Dimension;
                /** @deprecated */
                minimumSize(): Dimension;
                setMaximumSize(arg0: Dimension): void;
                isMaximumSizeSet(): boolean;
                getMaximumSize(): Dimension;
                getAlignmentX(): number;
                getAlignmentY(): number;
                getBaseline(arg0: int, arg1: int): number;
                getBaselineResizeBehavior(): Component$BaselineResizeBehavior;
                doLayout(): void;
                /** @deprecated */
                layout(): void;
                validate(): void;
                invalidate(): void;
                revalidate(): void;
                getGraphics(): Graphics;
                getFontMetrics(arg0: Font): FontMetrics;
                setCursor(arg0: Cursor): void;
                getCursor(): Cursor;
                isCursorSet(): boolean;
                paint(arg0: Graphics): void;
                update(arg0: Graphics): void;
                paintAll(arg0: Graphics): void;
                repaint(): void;
                repaint(arg0: long): void;
                repaint(arg0: int, arg1: int, arg2: int, arg3: int): void;
                repaint(arg0: long, arg1: int, arg2: int, arg3: int, arg4: int): void;
                print(arg0: Graphics): void;
                printAll(arg0: Graphics): void;
                imageUpdate(arg0: Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): boolean;
                createImage(arg0: java.awt.image.ImageProducer): Image;
                createImage(arg0: int, arg1: int): Image;
                createVolatileImage(arg0: int, arg1: int): java.awt.image.VolatileImage;
                createVolatileImage(arg0: int, arg1: int, arg2: ImageCapabilities): java.awt.image.VolatileImage;
                prepareImage(arg0: Image, arg1: java.awt.image.ImageObserver): boolean;
                prepareImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): boolean;
                checkImage(arg0: Image, arg1: java.awt.image.ImageObserver): number;
                checkImage(arg0: Image, arg1: int, arg2: int, arg3: java.awt.image.ImageObserver): number;
                setIgnoreRepaint(arg0: boolean): void;
                getIgnoreRepaint(): boolean;
                contains(arg0: int, arg1: int): boolean;
                /** @deprecated */
                inside(arg0: int, arg1: int): boolean;
                contains(arg0: Point): boolean;
                getComponentAt(arg0: int, arg1: int): Component;
                /** @deprecated */
                locate(arg0: int, arg1: int): Component;
                getComponentAt(arg0: Point): Component;
                /** @deprecated */
                deliverEvent(arg0: Event): void;
                dispatchEvent(arg0: AWTEvent): void;
                /** @deprecated */
                postEvent(arg0: Event): boolean;
                addComponentListener(arg0: java.awt.event.ComponentListener): void;
                removeComponentListener(arg0: java.awt.event.ComponentListener): void;
                getComponentListeners(): JavaArray<java.awt.event.ComponentListener>;
                addFocusListener(arg0: java.awt.event.FocusListener): void;
                removeFocusListener(arg0: java.awt.event.FocusListener): void;
                getFocusListeners(): JavaArray<java.awt.event.FocusListener>;
                addHierarchyListener(arg0: java.awt.event.HierarchyListener): void;
                removeHierarchyListener(arg0: java.awt.event.HierarchyListener): void;
                getHierarchyListeners(): JavaArray<java.awt.event.HierarchyListener>;
                addHierarchyBoundsListener(arg0: java.awt.event.HierarchyBoundsListener): void;
                removeHierarchyBoundsListener(arg0: java.awt.event.HierarchyBoundsListener): void;
                getHierarchyBoundsListeners(): JavaArray<java.awt.event.HierarchyBoundsListener>;
                addKeyListener(arg0: java.awt.event.KeyListener): void;
                removeKeyListener(arg0: java.awt.event.KeyListener): void;
                getKeyListeners(): JavaArray<java.awt.event.KeyListener>;
                addMouseListener(arg0: java.awt.event.MouseListener): void;
                removeMouseListener(arg0: java.awt.event.MouseListener): void;
                getMouseListeners(): JavaArray<java.awt.event.MouseListener>;
                addMouseMotionListener(arg0: java.awt.event.MouseMotionListener): void;
                removeMouseMotionListener(arg0: java.awt.event.MouseMotionListener): void;
                getMouseMotionListeners(): JavaArray<java.awt.event.MouseMotionListener>;
                addMouseWheelListener(arg0: java.awt.event.MouseWheelListener): void;
                removeMouseWheelListener(arg0: java.awt.event.MouseWheelListener): void;
                getMouseWheelListeners(): JavaArray<java.awt.event.MouseWheelListener>;
                addInputMethodListener(arg0: java.awt.event.InputMethodListener): void;
                removeInputMethodListener(arg0: java.awt.event.InputMethodListener): void;
                getInputMethodListeners(): JavaArray<java.awt.event.InputMethodListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                getInputMethodRequests(): java.awt.im.InputMethodRequests;
                getInputContext(): java.awt.im.InputContext;
                /** @deprecated */
                handleEvent(arg0: Event): boolean;
                /** @deprecated */
                mouseDown(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseDrag(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseUp(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseMove(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseEnter(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                mouseExit(arg0: Event, arg1: int, arg2: int): boolean;
                /** @deprecated */
                keyDown(arg0: Event, arg1: int): boolean;
                /** @deprecated */
                keyUp(arg0: Event, arg1: int): boolean;
                /** @deprecated */
                action(arg0: Event, arg1: any): boolean;
                addNotify(): void;
                removeNotify(): void;
                /** @deprecated */
                gotFocus(arg0: Event, arg1: any): boolean;
                /** @deprecated */
                lostFocus(arg0: Event, arg1: any): boolean;
                /** @deprecated */
                isFocusTraversable(): boolean;
                isFocusable(): boolean;
                setFocusable(arg0: boolean): void;
                setFocusTraversalKeys(arg0: int, arg1: JavaSet<any>): void;
                getFocusTraversalKeys(arg0: int): JavaSet<AWTKeyStroke>;
                areFocusTraversalKeysSet(arg0: int): boolean;
                setFocusTraversalKeysEnabled(arg0: boolean): void;
                getFocusTraversalKeysEnabled(): boolean;
                requestFocus(): void;
                requestFocus(arg0: java.awt.event.FocusEvent$Cause): void;
                requestFocusInWindow(): boolean;
                requestFocusInWindow(arg0: java.awt.event.FocusEvent$Cause): boolean;
                getFocusCycleRootAncestor(): Container;
                isFocusCycleRoot(arg0: Container): boolean;
                transferFocus(): void;
                /** @deprecated */
                nextFocus(): void;
                transferFocusBackward(): void;
                transferFocusUpCycle(): void;
                hasFocus(): boolean;
                isFocusOwner(): boolean;
                add(arg0: PopupMenu): void;
                remove(arg0: MenuComponent): void;
                list(): void;
                list(arg0: java.io.PrintStream): void;
                list(arg0: java.io.PrintStream, arg1: int): void;
                list(arg0: java.io.PrintWriter): void;
                list(arg0: java.io.PrintWriter, arg1: int): void;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                getPropertyChangeListeners(): JavaArray<java.beans.PropertyChangeListener>;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;
                getPropertyChangeListeners(arg0: string): JavaArray<java.beans.PropertyChangeListener>;
                firePropertyChange(arg0: string, arg1: byte, arg2: byte): void;
                firePropertyChange(arg0: string, arg1: char, arg2: char): void;
                firePropertyChange(arg0: string, arg1: short, arg2: short): void;
                firePropertyChange(arg0: string, arg1: long, arg2: long): void;
                firePropertyChange(arg0: string, arg1: float, arg2: float): void;
                firePropertyChange(arg0: string, arg1: double, arg2: double): void;
                setComponentOrientation(arg0: ComponentOrientation): void;
                getComponentOrientation(): ComponentOrientation;
                applyComponentOrientation(arg0: ComponentOrientation): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;
                setMixingCutoutShape(arg0: Shape): void;

            }

            const MenuContainer: JavaInterfaceStatics<MenuContainer>;
            interface MenuContainer extends JavaObject {

                getFont(): Font;
                remove(arg0: MenuComponent): void;
                /** @deprecated */
                postEvent(arg0: Event): boolean;

            }

            /** @deprecated */
            const Event: JavaClassStatics<Event, Event$$constructor> & {
                readonly SHIFT_MASK: number;
                readonly CTRL_MASK: number;
                readonly META_MASK: number;
                readonly ALT_MASK: number;
                readonly HOME: number;
                readonly END: number;
                readonly PGUP: number;
                readonly PGDN: number;
                readonly UP: number;
                readonly DOWN: number;
                readonly LEFT: number;
                readonly RIGHT: number;
                readonly F1: number;
                readonly F2: number;
                readonly F3: number;
                readonly F4: number;
                readonly F5: number;
                readonly F6: number;
                readonly F7: number;
                readonly F8: number;
                readonly F9: number;
                readonly F10: number;
                readonly F11: number;
                readonly F12: number;
                readonly PRINT_SCREEN: number;
                readonly SCROLL_LOCK: number;
                readonly CAPS_LOCK: number;
                readonly NUM_LOCK: number;
                readonly PAUSE: number;
                readonly INSERT: number;
                readonly ENTER: number;
                readonly BACK_SPACE: number;
                readonly TAB: number;
                readonly ESCAPE: number;
                readonly DELETE: number;
                readonly WINDOW_DESTROY: number;
                readonly WINDOW_EXPOSE: number;
                readonly WINDOW_ICONIFY: number;
                readonly WINDOW_DEICONIFY: number;
                readonly WINDOW_MOVED: number;
                readonly KEY_PRESS: number;
                readonly KEY_RELEASE: number;
                readonly KEY_ACTION: number;
                readonly KEY_ACTION_RELEASE: number;
                readonly MOUSE_DOWN: number;
                readonly MOUSE_UP: number;
                readonly MOUSE_MOVE: number;
                readonly MOUSE_ENTER: number;
                readonly MOUSE_EXIT: number;
                readonly MOUSE_DRAG: number;
                readonly SCROLL_LINE_UP: number;
                readonly SCROLL_LINE_DOWN: number;
                readonly SCROLL_PAGE_UP: number;
                readonly SCROLL_PAGE_DOWN: number;
                readonly SCROLL_ABSOLUTE: number;
                readonly SCROLL_BEGIN: number;
                readonly SCROLL_END: number;
                readonly LIST_SELECT: number;
                readonly LIST_DESELECT: number;
                readonly ACTION_EVENT: number;
                readonly LOAD_FILE: number;
                readonly SAVE_FILE: number;
                readonly GOT_FOCUS: number;
                readonly LOST_FOCUS: number;
            }
            interface Event$$constructor extends SuppressProperties {

                new (arg0: any, arg1: long, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: any): Event;
                new (arg0: any, arg1: long, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): Event;
                new (arg0: any, arg1: int, arg2: any): Event;

            }
            interface Event extends java.io.Serializable {
                target: any;
                when: number;
                id: number;
                x: number;
                y: number;
                key: number;
                modifiers: number;
                clickCount: number;
                arg: any;
                evt: Event;

                translate(arg0: int, arg1: int): void;
                shiftDown(): boolean;
                controlDown(): boolean;
                metaDown(): boolean;

            }

            const AWTEvent: JavaClassStatics<AWTEvent, AWTEvent$$constructor> & {
                readonly COMPONENT_EVENT_MASK: number;
                readonly CONTAINER_EVENT_MASK: number;
                readonly FOCUS_EVENT_MASK: number;
                readonly KEY_EVENT_MASK: number;
                readonly MOUSE_EVENT_MASK: number;
                readonly MOUSE_MOTION_EVENT_MASK: number;
                readonly WINDOW_EVENT_MASK: number;
                readonly ACTION_EVENT_MASK: number;
                readonly ADJUSTMENT_EVENT_MASK: number;
                readonly ITEM_EVENT_MASK: number;
                readonly TEXT_EVENT_MASK: number;
                readonly INPUT_METHOD_EVENT_MASK: number;
                readonly PAINT_EVENT_MASK: number;
                readonly INVOCATION_EVENT_MASK: number;
                readonly HIERARCHY_EVENT_MASK: number;
                readonly HIERARCHY_BOUNDS_EVENT_MASK: number;
                readonly MOUSE_WHEEL_EVENT_MASK: number;
                readonly WINDOW_STATE_EVENT_MASK: number;
                readonly WINDOW_FOCUS_EVENT_MASK: number;
                readonly RESERVED_ID_MAX: number;
            }
            interface AWTEvent$$constructor extends SuppressProperties {

                /** @deprecated */
                new (arg0: Event): AWTEvent;
                new (arg0: any, arg1: int): AWTEvent;

            }
            interface AWTEvent extends java.util.EventObject {

                setSource(arg0: any): void;
                getID(): number;
                paramString(): string;

            }

            const AttributeValue: JavaClassStatics<AttributeValue> & NoConstructor;
            interface AttributeValue extends JavaObject {}

            const Window$Type: JavaClassStatics<Window$Type> & NoConstructor & {
                readonly NORMAL: Window$Type;
                readonly UTILITY: Window$Type;
                readonly POPUP: Window$Type;

                values(): JavaArray<Window$Type>;
                valueOf(arg0: string): Window$Type;

            }
            interface Window$Type extends java.lang.Enum<Window$Type> {}

            const Frame: JavaClassStatics<Frame, Frame$$constructor> & {
                /** @deprecated */
                readonly DEFAULT_CURSOR: number;
                /** @deprecated */
                readonly CROSSHAIR_CURSOR: number;
                /** @deprecated */
                readonly TEXT_CURSOR: number;
                /** @deprecated */
                readonly WAIT_CURSOR: number;
                /** @deprecated */
                readonly SW_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly SE_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly NW_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly NE_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly N_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly S_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly W_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly E_RESIZE_CURSOR: number;
                /** @deprecated */
                readonly HAND_CURSOR: number;
                /** @deprecated */
                readonly MOVE_CURSOR: number;
                readonly NORMAL: number;
                readonly ICONIFIED: number;
                readonly MAXIMIZED_HORIZ: number;
                readonly MAXIMIZED_VERT: number;
                readonly MAXIMIZED_BOTH: number;

                getFrames(): JavaArray<Frame>;

            }
            interface Frame$$constructor extends SuppressProperties {

                new (): Frame;
                new (arg0: GraphicsConfiguration): Frame;
                new (arg0: string): Frame;
                new (arg0: string, arg1: GraphicsConfiguration): Frame;

            }
            interface Frame extends Window, MenuContainer {

                addNotify(): void;
                getTitle(): string;
                setTitle(arg0: string): void;
                getIconImage(): Image;
                setIconImage(arg0: Image): void;
                getMenuBar(): MenuBar;
                setMenuBar(arg0: MenuBar): void;
                isResizable(): boolean;
                setResizable(arg0: boolean): void;
                setState(arg0: int): void;
                setExtendedState(arg0: int): void;
                getState(): number;
                getExtendedState(): number;
                setMaximizedBounds(arg0: Rectangle): void;
                getMaximizedBounds(): Rectangle;
                setUndecorated(arg0: boolean): void;
                isUndecorated(): boolean;
                setOpacity(arg0: float): void;
                setShape(arg0: Shape): void;
                setBackground(arg0: Color): void;
                remove(arg0: MenuComponent): void;
                remove(arg0: int): void;
                remove(arg0: Component): void;
                removeNotify(): void;
                /** @deprecated */
                setCursor(arg0: int): void;
                setCursor(arg0: Cursor): void;
                /** @deprecated */
                getCursorType(): number;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            const Cursor: JavaClassStatics<Cursor, Cursor$$constructor> & {
                readonly DEFAULT_CURSOR: number;
                readonly CROSSHAIR_CURSOR: number;
                readonly TEXT_CURSOR: number;
                readonly WAIT_CURSOR: number;
                readonly SW_RESIZE_CURSOR: number;
                readonly SE_RESIZE_CURSOR: number;
                readonly NW_RESIZE_CURSOR: number;
                readonly NE_RESIZE_CURSOR: number;
                readonly N_RESIZE_CURSOR: number;
                readonly S_RESIZE_CURSOR: number;
                readonly W_RESIZE_CURSOR: number;
                readonly E_RESIZE_CURSOR: number;
                readonly HAND_CURSOR: number;
                readonly MOVE_CURSOR: number;
                readonly CUSTOM_CURSOR: number;

                getPredefinedCursor(arg0: int): Cursor;
                getSystemCustomCursor(arg0: string): Cursor;
                getDefaultCursor(): Cursor;

            }
            interface Cursor$$constructor extends SuppressProperties {

                new (arg0: int): Cursor;

            }
            interface Cursor extends java.io.Serializable {

                getType(): number;
                getName(): string;

            }

            const Container: JavaClassStatics<Container, Container$$constructor>;
            interface Container$$constructor extends SuppressProperties {

                new (): Container;

            }
            interface Container extends Component {

                getComponentCount(): number;
                /** @deprecated */
                countComponents(): number;
                getComponent(arg0: int): Component;
                getComponents(): JavaArray<Component>;
                getInsets(): Insets;
                /** @deprecated */
                insets(): Insets;
                add(arg0: Component): Component;
                add(arg0: string, arg1: Component): Component;
                add(arg0: Component, arg1: int): Component;
                add(arg0: PopupMenu): void;
                setComponentZOrder(arg0: Component, arg1: int): void;
                getComponentZOrder(arg0: Component): number;
                add(arg0: Component, arg1: any): void;
                add(arg0: Component, arg1: any, arg2: int): void;
                remove(arg0: int): void;
                remove(arg0: Component): void;
                remove(arg0: MenuComponent): void;
                removeAll(): void;
                getLayout(): LayoutManager;
                setLayout(arg0: LayoutManager): void;
                doLayout(): void;
                /** @deprecated */
                layout(): void;
                isValidateRoot(): boolean;
                invalidate(): void;
                validate(): void;
                setFont(arg0: Font): void;
                getPreferredSize(): Dimension;
                /** @deprecated */
                preferredSize(): Dimension;
                getMinimumSize(): Dimension;
                /** @deprecated */
                minimumSize(): Dimension;
                getMaximumSize(): Dimension;
                getAlignmentX(): number;
                getAlignmentY(): number;
                paint(arg0: Graphics): void;
                update(arg0: Graphics): void;
                print(arg0: Graphics): void;
                paintComponents(arg0: Graphics): void;
                printComponents(arg0: Graphics): void;
                addContainerListener(arg0: java.awt.event.ContainerListener): void;
                removeContainerListener(arg0: java.awt.event.ContainerListener): void;
                getContainerListeners(): JavaArray<java.awt.event.ContainerListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                /** @deprecated */
                deliverEvent(arg0: Event): void;
                getComponentAt(arg0: int, arg1: int): Component;
                /** @deprecated */
                locate(arg0: int, arg1: int): Component;
                getComponentAt(arg0: Point): Component;
                getMousePosition(arg0: boolean): Point;
                getMousePosition(): Point;
                findComponentAt(arg0: int, arg1: int): Component;
                findComponentAt(arg0: Point): Component;
                addNotify(): void;
                removeNotify(): void;
                isAncestorOf(arg0: Component): boolean;
                list(arg0: java.io.PrintStream, arg1: int): void;
                list(arg0: java.io.PrintWriter, arg1: int): void;
                list(): void;
                list(arg0: java.io.PrintStream): void;
                list(arg0: java.io.PrintWriter): void;
                setFocusTraversalKeys(arg0: int, arg1: JavaSet<any>): void;
                getFocusTraversalKeys(arg0: int): JavaSet<AWTKeyStroke>;
                areFocusTraversalKeysSet(arg0: int): boolean;
                isFocusCycleRoot(arg0: Container): boolean;
                setFocusTraversalPolicy(arg0: FocusTraversalPolicy): void;
                getFocusTraversalPolicy(): FocusTraversalPolicy;
                isFocusTraversalPolicySet(): boolean;
                setFocusCycleRoot(arg0: boolean): void;
                isFocusCycleRoot(): boolean;
                setFocusTraversalPolicyProvider(arg0: boolean): void;
                isFocusTraversalPolicyProvider(): boolean;
                transferFocusDownCycle(): void;
                applyComponentOrientation(arg0: ComponentOrientation): void;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                addPropertyChangeListener(arg0: string, arg1: java.beans.PropertyChangeListener): void;

            }

            const PageAttributes: JavaClassStatics<PageAttributes, PageAttributes$$constructor>;
            interface PageAttributes$$constructor extends SuppressProperties {

                new (): PageAttributes;
                new (arg0: PageAttributes): PageAttributes;
                new (arg0: PageAttributes$ColorType, arg1: PageAttributes$MediaType, arg2: PageAttributes$OrientationRequestedType, arg3: PageAttributes$OriginType, arg4: PageAttributes$PrintQualityType, arg5: int[]): PageAttributes;

            }
            interface PageAttributes extends java.lang.Cloneable {

                clone(): any;
                set(arg0: PageAttributes): void;
                getColor(): PageAttributes$ColorType;
                setColor(arg0: PageAttributes$ColorType): void;
                getMedia(): PageAttributes$MediaType;
                setMedia(arg0: PageAttributes$MediaType): void;
                setMediaToDefault(): void;
                getOrientationRequested(): PageAttributes$OrientationRequestedType;
                setOrientationRequested(arg0: PageAttributes$OrientationRequestedType): void;
                setOrientationRequested(arg0: int): void;
                setOrientationRequestedToDefault(): void;
                getOrigin(): PageAttributes$OriginType;
                setOrigin(arg0: PageAttributes$OriginType): void;
                getPrintQuality(): PageAttributes$PrintQualityType;
                setPrintQuality(arg0: PageAttributes$PrintQualityType): void;
                setPrintQuality(arg0: int): void;
                setPrintQualityToDefault(): void;
                getPrinterResolution(): JavaArray<number>;
                setPrinterResolution(arg0: int[]): void;
                setPrinterResolution(arg0: int): void;
                setPrinterResolutionToDefault(): void;

            }

            const JobAttributes: JavaClassStatics<JobAttributes, JobAttributes$$constructor>;
            interface JobAttributes$$constructor extends SuppressProperties {

                new (): JobAttributes;
                new (arg0: JobAttributes): JobAttributes;
                new (arg0: int, arg1: JobAttributes$DefaultSelectionType, arg2: JobAttributes$DestinationType, arg3: JobAttributes$DialogType, arg4: string, arg5: int, arg6: int, arg7: JobAttributes$MultipleDocumentHandlingType, arg8: int[][], arg9: string, arg10: JobAttributes$SidesType): JobAttributes;

            }
            interface JobAttributes extends java.lang.Cloneable {

                clone(): any;
                set(arg0: JobAttributes): void;
                getCopies(): number;
                setCopies(arg0: int): void;
                setCopiesToDefault(): void;
                getDefaultSelection(): JobAttributes$DefaultSelectionType;
                setDefaultSelection(arg0: JobAttributes$DefaultSelectionType): void;
                getDestination(): JobAttributes$DestinationType;
                setDestination(arg0: JobAttributes$DestinationType): void;
                getDialog(): JobAttributes$DialogType;
                setDialog(arg0: JobAttributes$DialogType): void;
                getFileName(): string;
                setFileName(arg0: string): void;
                getFromPage(): number;
                setFromPage(arg0: int): void;
                getMaxPage(): number;
                setMaxPage(arg0: int): void;
                getMinPage(): number;
                setMinPage(arg0: int): void;
                getMultipleDocumentHandling(): JobAttributes$MultipleDocumentHandlingType;
                setMultipleDocumentHandling(arg0: JobAttributes$MultipleDocumentHandlingType): void;
                setMultipleDocumentHandlingToDefault(): void;
                getPageRanges(): JavaArray<JavaArray<number>>;
                setPageRanges(arg0: int[][]): void;
                getPrinter(): string;
                setPrinter(arg0: string): void;
                getSides(): JobAttributes$SidesType;
                setSides(arg0: JobAttributes$SidesType): void;
                setSidesToDefault(): void;
                getToPage(): number;
                setToPage(arg0: int): void;

            }

            const PopupMenu: JavaClassStatics<PopupMenu, PopupMenu$$constructor>;
            interface PopupMenu$$constructor extends SuppressProperties {

                new (): PopupMenu;
                new (arg0: string): PopupMenu;

            }
            interface PopupMenu extends Menu {

                getParent(): MenuContainer;
                addNotify(): void;
                show(arg0: Component, arg1: int, arg2: int): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            const Component$BaselineResizeBehavior: JavaClassStatics<Component$BaselineResizeBehavior> & NoConstructor & {
                readonly CONSTANT_ASCENT: Component$BaselineResizeBehavior;
                readonly CONSTANT_DESCENT: Component$BaselineResizeBehavior;
                readonly CENTER_OFFSET: Component$BaselineResizeBehavior;
                readonly OTHER: Component$BaselineResizeBehavior;

                values(): JavaArray<Component$BaselineResizeBehavior>;
                valueOf(arg0: string): Component$BaselineResizeBehavior;

            }
            interface Component$BaselineResizeBehavior extends java.lang.Enum<Component$BaselineResizeBehavior> {}

            const FocusTraversalPolicy: JavaClassStatics<FocusTraversalPolicy> & NoConstructor;
            interface FocusTraversalPolicy extends JavaObject {

                getComponentAfter(arg0: Container, arg1: Component): Component;
                getComponentBefore(arg0: Container, arg1: Component): Component;
                getFirstComponent(arg0: Container): Component;
                getLastComponent(arg0: Container): Component;
                getDefaultComponent(arg0: Container): Component;
                getInitialComponent(arg0: Window): Component;

            }

            const LayoutManager: JavaInterfaceStatics<LayoutManager>;
            interface LayoutManager extends JavaObject {

                addLayoutComponent(arg0: string, arg1: Component): void;
                removeLayoutComponent(arg0: Component): void;
                preferredLayoutSize(arg0: Container): Dimension;
                minimumLayoutSize(arg0: Container): Dimension;
                layoutContainer(arg0: Container): void;

            }

            const EventQueue: JavaClassStatics<EventQueue, EventQueue$$constructor> & {

                getMostRecentEventTime(): number;
                getCurrentEvent(): AWTEvent;
                isDispatchThread(): boolean;
                invokeLater(arg0: java.lang.Runnable): void;
                invokeAndWait(arg0: java.lang.Runnable): void;

            }
            interface EventQueue$$constructor extends SuppressProperties {

                new (): EventQueue;

            }
            interface EventQueue extends JavaObject {

                postEvent(arg0: AWTEvent): void;
                getNextEvent(): AWTEvent;
                peekEvent(): AWTEvent;
                peekEvent(arg0: int): AWTEvent;
                push(arg0: EventQueue): void;
                createSecondaryLoop(): SecondaryLoop;

            }

            const Dialog$ModalityType: JavaClassStatics<Dialog$ModalityType> & NoConstructor & {
                readonly MODELESS: Dialog$ModalityType;
                readonly DOCUMENT_MODAL: Dialog$ModalityType;
                readonly APPLICATION_MODAL: Dialog$ModalityType;
                readonly TOOLKIT_MODAL: Dialog$ModalityType;

                values(): JavaArray<Dialog$ModalityType>;
                valueOf(arg0: string): Dialog$ModalityType;

            }
            interface Dialog$ModalityType extends java.lang.Enum<Dialog$ModalityType> {}

            const MenuComponent: JavaClassStatics<MenuComponent, MenuComponent$$constructor>;
            interface MenuComponent$$constructor extends SuppressProperties {

                new (): MenuComponent;

            }
            interface MenuComponent extends java.io.Serializable {

                getName(): string;
                setName(arg0: string): void;
                getParent(): MenuContainer;
                getFont(): Font;
                setFont(arg0: Font): void;
                removeNotify(): void;
                /** @deprecated */
                postEvent(arg0: Event): boolean;
                dispatchEvent(arg0: AWTEvent): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            const PrintJob: JavaClassStatics<PrintJob> & NoConstructor;
            interface PrintJob extends JavaObject {

                getGraphics(): Graphics;
                getPageDimension(): Dimension;
                getPageResolution(): number;
                lastPageFirst(): boolean;
                end(): void;
                /** @deprecated */
                finalize(): void;

            }

            const Insets: JavaClassStatics<Insets, Insets$$constructor>;
            interface Insets$$constructor extends SuppressProperties {

                new (arg0: int, arg1: int, arg2: int, arg3: int): Insets;

            }
            interface Insets extends java.lang.Cloneable, java.io.Serializable {
                top: number;
                left: number;
                bottom: number;
                right: number;

                set(arg0: int, arg1: int, arg2: int, arg3: int): void;
                clone(): any;

            }

            const ComponentOrientation: JavaClassStatics<ComponentOrientation> & NoConstructor & {
                readonly LEFT_TO_RIGHT: ComponentOrientation;
                readonly RIGHT_TO_LEFT: ComponentOrientation;
                readonly UNKNOWN: ComponentOrientation;

                getOrientation(arg0: java.util.Locale): ComponentOrientation;
                /** @deprecated */
                getOrientation(arg0: java.util.ResourceBundle): ComponentOrientation;

            }
            interface ComponentOrientation extends java.io.Serializable {

                isHorizontal(): boolean;
                isLeftToRight(): boolean;

            }

            const MenuBar: JavaClassStatics<MenuBar, MenuBar$$constructor>;
            interface MenuBar$$constructor extends SuppressProperties {

                new (): MenuBar;

            }
            interface MenuBar extends MenuComponent, MenuContainer, javax.accessibility.Accessible {

                addNotify(): void;
                removeNotify(): void;
                getHelpMenu(): Menu;
                setHelpMenu(arg0: Menu): void;
                add(arg0: Menu): Menu;
                remove(arg0: int): void;
                remove(arg0: MenuComponent): void;
                getMenuCount(): number;
                /** @deprecated */
                countMenus(): number;
                getMenu(arg0: int): Menu;
                shortcuts(): java.util.Enumeration<MenuShortcut>;
                getShortcutMenuItem(arg0: MenuShortcut): MenuItem;
                deleteShortcut(arg0: MenuShortcut): void;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            const JobAttributes$DestinationType: JavaClassStatics<JobAttributes$DestinationType> & NoConstructor & {
                readonly FILE: JobAttributes$DestinationType;
                readonly PRINTER: JobAttributes$DestinationType;
            }
            interface JobAttributes$DestinationType extends AttributeValue {}

            const PageAttributes$MediaType: JavaClassStatics<PageAttributes$MediaType> & NoConstructor & {
                readonly ISO_4A0: PageAttributes$MediaType;
                readonly ISO_2A0: PageAttributes$MediaType;
                readonly ISO_A0: PageAttributes$MediaType;
                readonly ISO_A1: PageAttributes$MediaType;
                readonly ISO_A2: PageAttributes$MediaType;
                readonly ISO_A3: PageAttributes$MediaType;
                readonly ISO_A4: PageAttributes$MediaType;
                readonly ISO_A5: PageAttributes$MediaType;
                readonly ISO_A6: PageAttributes$MediaType;
                readonly ISO_A7: PageAttributes$MediaType;
                readonly ISO_A8: PageAttributes$MediaType;
                readonly ISO_A9: PageAttributes$MediaType;
                readonly ISO_A10: PageAttributes$MediaType;
                readonly ISO_B0: PageAttributes$MediaType;
                readonly ISO_B1: PageAttributes$MediaType;
                readonly ISO_B2: PageAttributes$MediaType;
                readonly ISO_B3: PageAttributes$MediaType;
                readonly ISO_B4: PageAttributes$MediaType;
                readonly ISO_B5: PageAttributes$MediaType;
                readonly ISO_B6: PageAttributes$MediaType;
                readonly ISO_B7: PageAttributes$MediaType;
                readonly ISO_B8: PageAttributes$MediaType;
                readonly ISO_B9: PageAttributes$MediaType;
                readonly ISO_B10: PageAttributes$MediaType;
                readonly JIS_B0: PageAttributes$MediaType;
                readonly JIS_B1: PageAttributes$MediaType;
                readonly JIS_B2: PageAttributes$MediaType;
                readonly JIS_B3: PageAttributes$MediaType;
                readonly JIS_B4: PageAttributes$MediaType;
                readonly JIS_B5: PageAttributes$MediaType;
                readonly JIS_B6: PageAttributes$MediaType;
                readonly JIS_B7: PageAttributes$MediaType;
                readonly JIS_B8: PageAttributes$MediaType;
                readonly JIS_B9: PageAttributes$MediaType;
                readonly JIS_B10: PageAttributes$MediaType;
                readonly ISO_C0: PageAttributes$MediaType;
                readonly ISO_C1: PageAttributes$MediaType;
                readonly ISO_C2: PageAttributes$MediaType;
                readonly ISO_C3: PageAttributes$MediaType;
                readonly ISO_C4: PageAttributes$MediaType;
                readonly ISO_C5: PageAttributes$MediaType;
                readonly ISO_C6: PageAttributes$MediaType;
                readonly ISO_C7: PageAttributes$MediaType;
                readonly ISO_C8: PageAttributes$MediaType;
                readonly ISO_C9: PageAttributes$MediaType;
                readonly ISO_C10: PageAttributes$MediaType;
                readonly ISO_DESIGNATED_LONG: PageAttributes$MediaType;
                readonly EXECUTIVE: PageAttributes$MediaType;
                readonly FOLIO: PageAttributes$MediaType;
                readonly INVOICE: PageAttributes$MediaType;
                readonly LEDGER: PageAttributes$MediaType;
                readonly NA_LETTER: PageAttributes$MediaType;
                readonly NA_LEGAL: PageAttributes$MediaType;
                readonly QUARTO: PageAttributes$MediaType;
                readonly A: PageAttributes$MediaType;
                readonly B: PageAttributes$MediaType;
                readonly C: PageAttributes$MediaType;
                readonly D: PageAttributes$MediaType;
                readonly E: PageAttributes$MediaType;
                readonly NA_10X15_ENVELOPE: PageAttributes$MediaType;
                readonly NA_10X14_ENVELOPE: PageAttributes$MediaType;
                readonly NA_10X13_ENVELOPE: PageAttributes$MediaType;
                readonly NA_9X12_ENVELOPE: PageAttributes$MediaType;
                readonly NA_9X11_ENVELOPE: PageAttributes$MediaType;
                readonly NA_7X9_ENVELOPE: PageAttributes$MediaType;
                readonly NA_6X9_ENVELOPE: PageAttributes$MediaType;
                readonly NA_NUMBER_9_ENVELOPE: PageAttributes$MediaType;
                readonly NA_NUMBER_10_ENVELOPE: PageAttributes$MediaType;
                readonly NA_NUMBER_11_ENVELOPE: PageAttributes$MediaType;
                readonly NA_NUMBER_12_ENVELOPE: PageAttributes$MediaType;
                readonly NA_NUMBER_14_ENVELOPE: PageAttributes$MediaType;
                readonly INVITE_ENVELOPE: PageAttributes$MediaType;
                readonly ITALY_ENVELOPE: PageAttributes$MediaType;
                readonly MONARCH_ENVELOPE: PageAttributes$MediaType;
                readonly PERSONAL_ENVELOPE: PageAttributes$MediaType;
                readonly A0: PageAttributes$MediaType;
                readonly A1: PageAttributes$MediaType;
                readonly A2: PageAttributes$MediaType;
                readonly A3: PageAttributes$MediaType;
                readonly A4: PageAttributes$MediaType;
                readonly A5: PageAttributes$MediaType;
                readonly A6: PageAttributes$MediaType;
                readonly A7: PageAttributes$MediaType;
                readonly A8: PageAttributes$MediaType;
                readonly A9: PageAttributes$MediaType;
                readonly A10: PageAttributes$MediaType;
                readonly B0: PageAttributes$MediaType;
                readonly B1: PageAttributes$MediaType;
                readonly B2: PageAttributes$MediaType;
                readonly B3: PageAttributes$MediaType;
                readonly B4: PageAttributes$MediaType;
                readonly ISO_B4_ENVELOPE: PageAttributes$MediaType;
                readonly B5: PageAttributes$MediaType;
                readonly ISO_B5_ENVELOPE: PageAttributes$MediaType;
                readonly B6: PageAttributes$MediaType;
                readonly B7: PageAttributes$MediaType;
                readonly B8: PageAttributes$MediaType;
                readonly B9: PageAttributes$MediaType;
                readonly B10: PageAttributes$MediaType;
                readonly C0: PageAttributes$MediaType;
                readonly ISO_C0_ENVELOPE: PageAttributes$MediaType;
                readonly C1: PageAttributes$MediaType;
                readonly ISO_C1_ENVELOPE: PageAttributes$MediaType;
                readonly C2: PageAttributes$MediaType;
                readonly ISO_C2_ENVELOPE: PageAttributes$MediaType;
                readonly C3: PageAttributes$MediaType;
                readonly ISO_C3_ENVELOPE: PageAttributes$MediaType;
                readonly C4: PageAttributes$MediaType;
                readonly ISO_C4_ENVELOPE: PageAttributes$MediaType;
                readonly C5: PageAttributes$MediaType;
                readonly ISO_C5_ENVELOPE: PageAttributes$MediaType;
                readonly C6: PageAttributes$MediaType;
                readonly ISO_C6_ENVELOPE: PageAttributes$MediaType;
                readonly C7: PageAttributes$MediaType;
                readonly ISO_C7_ENVELOPE: PageAttributes$MediaType;
                readonly C8: PageAttributes$MediaType;
                readonly ISO_C8_ENVELOPE: PageAttributes$MediaType;
                readonly C9: PageAttributes$MediaType;
                readonly ISO_C9_ENVELOPE: PageAttributes$MediaType;
                readonly C10: PageAttributes$MediaType;
                readonly ISO_C10_ENVELOPE: PageAttributes$MediaType;
                readonly ISO_DESIGNATED_LONG_ENVELOPE: PageAttributes$MediaType;
                readonly STATEMENT: PageAttributes$MediaType;
                readonly TABLOID: PageAttributes$MediaType;
                readonly LETTER: PageAttributes$MediaType;
                readonly NOTE: PageAttributes$MediaType;
                readonly LEGAL: PageAttributes$MediaType;
                readonly ENV_10X15: PageAttributes$MediaType;
                readonly ENV_10X14: PageAttributes$MediaType;
                readonly ENV_10X13: PageAttributes$MediaType;
                readonly ENV_9X12: PageAttributes$MediaType;
                readonly ENV_9X11: PageAttributes$MediaType;
                readonly ENV_7X9: PageAttributes$MediaType;
                readonly ENV_6X9: PageAttributes$MediaType;
                readonly ENV_9: PageAttributes$MediaType;
                readonly ENV_10: PageAttributes$MediaType;
                readonly ENV_11: PageAttributes$MediaType;
                readonly ENV_12: PageAttributes$MediaType;
                readonly ENV_14: PageAttributes$MediaType;
                readonly ENV_INVITE: PageAttributes$MediaType;
                readonly ENV_ITALY: PageAttributes$MediaType;
                readonly ENV_MONARCH: PageAttributes$MediaType;
                readonly ENV_PERSONAL: PageAttributes$MediaType;
                readonly INVITE: PageAttributes$MediaType;
                readonly ITALY: PageAttributes$MediaType;
                readonly MONARCH: PageAttributes$MediaType;
                readonly PERSONAL: PageAttributes$MediaType;
            }
            interface PageAttributes$MediaType extends AttributeValue {}

            const MenuShortcut: JavaClassStatics<MenuShortcut, MenuShortcut$$constructor>;
            interface MenuShortcut$$constructor extends SuppressProperties {

                new (arg0: int): MenuShortcut;
                new (arg0: int, arg1: boolean): MenuShortcut;

            }
            interface MenuShortcut extends java.io.Serializable {

                getKey(): number;
                usesShiftModifier(): boolean;
                equals(arg0: MenuShortcut): boolean;

            }

            const MenuItem: JavaClassStatics<MenuItem, MenuItem$$constructor>;
            interface MenuItem$$constructor extends SuppressProperties {

                new (): MenuItem;
                new (arg0: string): MenuItem;
                new (arg0: string, arg1: MenuShortcut): MenuItem;

            }
            interface MenuItem extends MenuComponent, javax.accessibility.Accessible {

                addNotify(): void;
                getLabel(): string;
                setLabel(arg0: string): void;
                isEnabled(): boolean;
                setEnabled(arg0: boolean): void;
                /** @deprecated */
                enable(): void;
                /** @deprecated */
                enable(arg0: boolean): void;
                /** @deprecated */
                disable(): void;
                getShortcut(): MenuShortcut;
                setShortcut(arg0: MenuShortcut): void;
                deleteShortcut(): void;
                setActionCommand(arg0: string): void;
                getActionCommand(): string;
                addActionListener(arg0: java.awt.event.ActionListener): void;
                removeActionListener(arg0: java.awt.event.ActionListener): void;
                getActionListeners(): JavaArray<java.awt.event.ActionListener>;
                getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;
                paramString(): string;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            const JobAttributes$MultipleDocumentHandlingType: JavaClassStatics<JobAttributes$MultipleDocumentHandlingType> & NoConstructor & {
                readonly SEPARATE_DOCUMENTS_COLLATED_COPIES: JobAttributes$MultipleDocumentHandlingType;
                readonly SEPARATE_DOCUMENTS_UNCOLLATED_COPIES: JobAttributes$MultipleDocumentHandlingType;
            }
            interface JobAttributes$MultipleDocumentHandlingType extends AttributeValue {}

            const PageAttributes$ColorType: JavaClassStatics<PageAttributes$ColorType> & NoConstructor & {
                readonly COLOR: PageAttributes$ColorType;
                readonly MONOCHROME: PageAttributes$ColorType;
            }
            interface PageAttributes$ColorType extends AttributeValue {}

            const Menu: JavaClassStatics<Menu, Menu$$constructor>;
            interface Menu$$constructor extends SuppressProperties {

                new (): Menu;
                new (arg0: string): Menu;
                new (arg0: string, arg1: boolean): Menu;

            }
            interface Menu extends MenuItem, MenuContainer, javax.accessibility.Accessible {

                addNotify(): void;
                removeNotify(): void;
                isTearOff(): boolean;
                getItemCount(): number;
                /** @deprecated */
                countItems(): number;
                getItem(arg0: int): MenuItem;
                add(arg0: MenuItem): MenuItem;
                add(arg0: string): void;
                insert(arg0: MenuItem, arg1: int): void;
                insert(arg0: string, arg1: int): void;
                addSeparator(): void;
                insertSeparator(arg0: int): void;
                remove(arg0: int): void;
                remove(arg0: MenuComponent): void;
                removeAll(): void;
                paramString(): string;
                getAccessibleContext(): javax.accessibility.AccessibleContext;

            }

            const JobAttributes$SidesType: JavaClassStatics<JobAttributes$SidesType> & NoConstructor & {
                readonly ONE_SIDED: JobAttributes$SidesType;
                readonly TWO_SIDED_LONG_EDGE: JobAttributes$SidesType;
                readonly TWO_SIDED_SHORT_EDGE: JobAttributes$SidesType;
            }
            interface JobAttributes$SidesType extends AttributeValue {}

            const PageAttributes$PrintQualityType: JavaClassStatics<PageAttributes$PrintQualityType> & NoConstructor & {
                readonly HIGH: PageAttributes$PrintQualityType;
                readonly NORMAL: PageAttributes$PrintQualityType;
                readonly DRAFT: PageAttributes$PrintQualityType;
            }
            interface PageAttributes$PrintQualityType extends AttributeValue {}

            const JobAttributes$DialogType: JavaClassStatics<JobAttributes$DialogType> & NoConstructor & {
                readonly COMMON: JobAttributes$DialogType;
                readonly NATIVE: JobAttributes$DialogType;
                readonly NONE: JobAttributes$DialogType;
            }
            interface JobAttributes$DialogType extends AttributeValue {}

            const PageAttributes$OrientationRequestedType: JavaClassStatics<PageAttributes$OrientationRequestedType> & NoConstructor & {
                readonly PORTRAIT: PageAttributes$OrientationRequestedType;
                readonly LANDSCAPE: PageAttributes$OrientationRequestedType;
            }
            interface PageAttributes$OrientationRequestedType extends AttributeValue {}

            const PageAttributes$OriginType: JavaClassStatics<PageAttributes$OriginType> & NoConstructor & {
                readonly PHYSICAL: PageAttributes$OriginType;
                readonly PRINTABLE: PageAttributes$OriginType;
            }
            interface PageAttributes$OriginType extends AttributeValue {}

            const JobAttributes$DefaultSelectionType: JavaClassStatics<JobAttributes$DefaultSelectionType> & NoConstructor & {
                readonly ALL: JobAttributes$DefaultSelectionType;
                readonly RANGE: JobAttributes$DefaultSelectionType;
                readonly SELECTION: JobAttributes$DefaultSelectionType;
            }
            interface JobAttributes$DefaultSelectionType extends AttributeValue {}

            const SecondaryLoop: JavaInterfaceStatics<SecondaryLoop>;
            interface SecondaryLoop extends JavaObject {

                enter(): boolean;
                exit(): boolean;

            }

            export {
                Rectangle,
                Image,
                Shape,
                Dimension,
                GraphicsConfiguration,
                ImageCapabilities,
                Transparency,
                Point,
                Graphics2D,
                Graphics,
                Stroke,
                Composite,
                GraphicsDevice,
                RenderingHints,
                RenderingHints$Key,
                Color,
                Paint,
                Font,
                Polygon,
                BufferCapabilities,
                FontMetrics,
                PaintContext,
                DisplayMode,
                Window,
                GraphicsDevice$WindowTranslucency,
                CompositeContext,
                GraphicsConfigTemplate,
                BufferCapabilities$FlipContents,
                Dialog$ModalExclusionType,
                AWTKeyStroke,
                Toolkit,
                Component,
                MenuContainer,
                Event,
                AWTEvent,
                AttributeValue,
                Window$Type,
                Frame,
                Cursor,
                Container,
                PageAttributes,
                JobAttributes,
                PopupMenu,
                Component$BaselineResizeBehavior,
                FocusTraversalPolicy,
                LayoutManager,
                EventQueue,
                Dialog$ModalityType,
                MenuComponent,
                PrintJob,
                Insets,
                ComponentOrientation,
                MenuBar,
                JobAttributes$DestinationType,
                PageAttributes$MediaType,
                MenuShortcut,
                MenuItem,
                JobAttributes$MultipleDocumentHandlingType,
                PageAttributes$ColorType,
                Menu,
                JobAttributes$SidesType,
                PageAttributes$PrintQualityType,
                JobAttributes$DialogType,
                PageAttributes$OrientationRequestedType,
                PageAttributes$OriginType,
                JobAttributes$DefaultSelectionType,
                SecondaryLoop
            }

        }
        namespace awt {

            namespace image {

                const BufferedImage: JavaClassStatics<BufferedImage, BufferedImage$$constructor> & {
                    readonly TYPE_CUSTOM: number;
                    readonly TYPE_INT_RGB: number;
                    readonly TYPE_INT_ARGB: number;
                    readonly TYPE_INT_ARGB_PRE: number;
                    readonly TYPE_INT_BGR: number;
                    readonly TYPE_3BYTE_BGR: number;
                    readonly TYPE_4BYTE_ABGR: number;
                    readonly TYPE_4BYTE_ABGR_PRE: number;
                    readonly TYPE_USHORT_565_RGB: number;
                    readonly TYPE_USHORT_555_RGB: number;
                    readonly TYPE_BYTE_GRAY: number;
                    readonly TYPE_USHORT_GRAY: number;
                    readonly TYPE_BYTE_BINARY: number;
                    readonly TYPE_BYTE_INDEXED: number;
                }
                interface BufferedImage$$constructor extends SuppressProperties {

                    new (arg0: int, arg1: int, arg2: int): BufferedImage;
                    new (arg0: int, arg1: int, arg2: int, arg3: IndexColorModel): BufferedImage;
                    new (arg0: ColorModel, arg1: WritableRaster, arg2: boolean, arg3: java.util.Hashtable<any, any>): BufferedImage;

                }
                interface BufferedImage extends java.awt.Image, WritableRenderedImage, java.awt.Transparency {

                    getType(): number;
                    getColorModel(): ColorModel;
                    getRaster(): WritableRaster;
                    getAlphaRaster(): WritableRaster;
                    getRGB(arg0: int, arg1: int): number;
                    getRGB(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int, arg6: int): JavaArray<number>;
                    setRGB(arg0: int, arg1: int, arg2: int): void;
                    setRGB(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int, arg6: int): void;
                    getWidth(): number;
                    getHeight(): number;
                    getWidth(arg0: ImageObserver): number;
                    getHeight(arg0: ImageObserver): number;
                    getSource(): ImageProducer;
                    getProperty(arg0: string, arg1: ImageObserver): any;
                    getProperty(arg0: string): any;
                    getGraphics(): java.awt.Graphics;
                    createGraphics(): java.awt.Graphics2D;
                    getSubimage(arg0: int, arg1: int, arg2: int, arg3: int): BufferedImage;
                    isAlphaPremultiplied(): boolean;
                    coerceData(arg0: boolean): void;
                    getSources(): java.util.Vector<RenderedImage>;
                    getPropertyNames(): JavaArray<string>;
                    getMinX(): number;
                    getMinY(): number;
                    getSampleModel(): SampleModel;
                    getNumXTiles(): number;
                    getNumYTiles(): number;
                    getMinTileX(): number;
                    getMinTileY(): number;
                    getTileWidth(): number;
                    getTileHeight(): number;
                    getTileGridXOffset(): number;
                    getTileGridYOffset(): number;
                    getTile(arg0: int, arg1: int): Raster;
                    getData(): Raster;
                    getData(arg0: java.awt.Rectangle): Raster;
                    copyData(arg0: WritableRaster): WritableRaster;
                    setData(arg0: Raster): void;
                    addTileObserver(arg0: TileObserver): void;
                    removeTileObserver(arg0: TileObserver): void;
                    isTileWritable(arg0: int, arg1: int): boolean;
                    getWritableTileIndices(): JavaArray<java.awt.Point>;
                    hasTileWriters(): boolean;
                    getWritableTile(arg0: int, arg1: int): WritableRaster;
                    releaseWritableTile(arg0: int, arg1: int): void;
                    getTransparency(): number;

                }

                const ImageObserver: JavaInterfaceStatics<ImageObserver> & {
                    readonly WIDTH: number;
                    readonly HEIGHT: number;
                    readonly PROPERTIES: number;
                    readonly SOMEBITS: number;
                    readonly FRAMEBITS: number;
                    readonly ALLBITS: number;
                    readonly ERROR: number;
                    readonly ABORT: number;
                }
                interface ImageObserver extends JavaObject {

                    imageUpdate(arg0: java.awt.Image, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): boolean;

                }

                const ImageProducer: JavaInterfaceStatics<ImageProducer>;
                interface ImageProducer extends JavaObject {

                    addConsumer(arg0: ImageConsumer): void;
                    isConsumer(arg0: ImageConsumer): boolean;
                    removeConsumer(arg0: ImageConsumer): void;
                    startProduction(arg0: ImageConsumer): void;
                    requestTopDownLeftRightResend(arg0: ImageConsumer): void;

                }

                const RenderedImage: JavaInterfaceStatics<RenderedImage>;
                interface RenderedImage extends JavaObject {

                    getSources(): java.util.Vector<RenderedImage>;
                    getProperty(arg0: string): any;
                    getPropertyNames(): JavaArray<string>;
                    getColorModel(): ColorModel;
                    getSampleModel(): SampleModel;
                    getWidth(): number;
                    getHeight(): number;
                    getMinX(): number;
                    getMinY(): number;
                    getNumXTiles(): number;
                    getNumYTiles(): number;
                    getMinTileX(): number;
                    getMinTileY(): number;
                    getTileWidth(): number;
                    getTileHeight(): number;
                    getTileGridXOffset(): number;
                    getTileGridYOffset(): number;
                    getTile(arg0: int, arg1: int): Raster;
                    getData(): Raster;
                    getData(arg0: java.awt.Rectangle): Raster;
                    copyData(arg0: WritableRaster): WritableRaster;

                }

                const ColorModel: JavaClassStatics<ColorModel, ColorModel$$constructor> & {

                    getRGBdefault(): ColorModel;

                }
                interface ColorModel$$constructor extends SuppressProperties {

                    new (arg0: int): ColorModel;

                }
                interface ColorModel extends java.awt.Transparency {

                    hasAlpha(): boolean;
                    isAlphaPremultiplied(): boolean;
                    getTransferType(): number;
                    getPixelSize(): number;
                    getComponentSize(arg0: int): number;
                    getComponentSize(): JavaArray<number>;
                    getTransparency(): number;
                    getNumComponents(): number;
                    getNumColorComponents(): number;
                    getRed(arg0: int): number;
                    getGreen(arg0: int): number;
                    getBlue(arg0: int): number;
                    getAlpha(arg0: int): number;
                    getRGB(arg0: int): number;
                    getRed(arg0: any): number;
                    getGreen(arg0: any): number;
                    getBlue(arg0: any): number;
                    getAlpha(arg0: any): number;
                    getRGB(arg0: any): number;
                    getDataElements(arg0: int, arg1: any): any;
                    getComponents(arg0: int, arg1: int[], arg2: int): JavaArray<number>;
                    getComponents(arg0: any, arg1: int[], arg2: int): JavaArray<number>;
                    getUnnormalizedComponents(arg0: float[], arg1: int, arg2: int[], arg3: int): JavaArray<number>;
                    getNormalizedComponents(arg0: int[], arg1: int, arg2: float[], arg3: int): JavaArray<number>;
                    getDataElement(arg0: int[], arg1: int): number;
                    getDataElements(arg0: int[], arg1: int, arg2: any): any;
                    getDataElement(arg0: float[], arg1: int): number;
                    getDataElements(arg0: float[], arg1: int, arg2: any): any;
                    getNormalizedComponents(arg0: any, arg1: float[], arg2: int): JavaArray<number>;
                    getColorSpace(): java.awt.color.ColorSpace;
                    coerceData(arg0: WritableRaster, arg1: boolean): ColorModel;
                    isCompatibleRaster(arg0: Raster): boolean;
                    createCompatibleWritableRaster(arg0: int, arg1: int): WritableRaster;
                    createCompatibleSampleModel(arg0: int, arg1: int): SampleModel;
                    isCompatibleSampleModel(arg0: SampleModel): boolean;
                    /** @deprecated */
                    finalize(): void;
                    getAlphaRaster(arg0: WritableRaster): WritableRaster;

                }

                const Raster: JavaClassStatics<Raster> & NoConstructor & {

                    createInterleavedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: java.awt.Point): WritableRaster;
                    createInterleavedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: java.awt.Point): WritableRaster;
                    createBandedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: java.awt.Point): WritableRaster;
                    createBandedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int[], arg6: java.awt.Point): WritableRaster;
                    createPackedRaster(arg0: int, arg1: int, arg2: int, arg3: int[], arg4: java.awt.Point): WritableRaster;
                    createPackedRaster(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: java.awt.Point): WritableRaster;
                    createInterleavedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: java.awt.Point): WritableRaster;
                    createBandedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: int[], arg6: java.awt.Point): WritableRaster;
                    createPackedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: java.awt.Point): WritableRaster;
                    createPackedRaster(arg0: DataBuffer, arg1: int, arg2: int, arg3: int, arg4: java.awt.Point): WritableRaster;
                    createRaster(arg0: SampleModel, arg1: DataBuffer, arg2: java.awt.Point): Raster;
                    createWritableRaster(arg0: SampleModel, arg1: java.awt.Point): WritableRaster;
                    createWritableRaster(arg0: SampleModel, arg1: DataBuffer, arg2: java.awt.Point): WritableRaster;

                }
                interface Raster extends JavaObject {

                    getParent(): Raster;
                    getSampleModelTranslateX(): number;
                    getSampleModelTranslateY(): number;
                    createCompatibleWritableRaster(): WritableRaster;
                    createCompatibleWritableRaster(arg0: int, arg1: int): WritableRaster;
                    createCompatibleWritableRaster(arg0: java.awt.Rectangle): WritableRaster;
                    createCompatibleWritableRaster(arg0: int, arg1: int, arg2: int, arg3: int): WritableRaster;
                    createTranslatedChild(arg0: int, arg1: int): Raster;
                    createChild(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int[]): Raster;
                    getBounds(): java.awt.Rectangle;
                    getMinX(): number;
                    getMinY(): number;
                    getWidth(): number;
                    getHeight(): number;
                    getNumBands(): number;
                    getNumDataElements(): number;
                    getTransferType(): number;
                    getDataBuffer(): DataBuffer;
                    getSampleModel(): SampleModel;
                    getDataElements(arg0: int, arg1: int, arg2: any): any;
                    getDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any): any;
                    getPixel(arg0: int, arg1: int, arg2: int[]): JavaArray<number>;
                    getPixel(arg0: int, arg1: int, arg2: float[]): JavaArray<number>;
                    getPixel(arg0: int, arg1: int, arg2: double[]): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[]): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[]): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[]): JavaArray<number>;
                    getSample(arg0: int, arg1: int, arg2: int): number;
                    getSampleFloat(arg0: int, arg1: int, arg2: int): number;
                    getSampleDouble(arg0: int, arg1: int, arg2: int): number;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[]): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[]): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[]): JavaArray<number>;

                }

                const WritableRenderedImage: JavaInterfaceStatics<WritableRenderedImage>;
                interface WritableRenderedImage extends RenderedImage {

                    addTileObserver(arg0: TileObserver): void;
                    removeTileObserver(arg0: TileObserver): void;
                    getWritableTile(arg0: int, arg1: int): WritableRaster;
                    releaseWritableTile(arg0: int, arg1: int): void;
                    isTileWritable(arg0: int, arg1: int): boolean;
                    getWritableTileIndices(): JavaArray<java.awt.Point>;
                    hasTileWriters(): boolean;
                    setData(arg0: Raster): void;

                }

                const SampleModel: JavaClassStatics<SampleModel, SampleModel$$constructor>;
                interface SampleModel$$constructor extends SuppressProperties {

                    new (arg0: int, arg1: int, arg2: int, arg3: int): SampleModel;

                }
                interface SampleModel extends JavaObject {

                    getWidth(): number;
                    getHeight(): number;
                    getNumBands(): number;
                    getNumDataElements(): number;
                    getDataType(): number;
                    getTransferType(): number;
                    getPixel(arg0: int, arg1: int, arg2: int[], arg3: DataBuffer): JavaArray<number>;
                    getDataElements(arg0: int, arg1: int, arg2: any, arg3: DataBuffer): any;
                    getDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any, arg5: DataBuffer): any;
                    setDataElements(arg0: int, arg1: int, arg2: any, arg3: DataBuffer): void;
                    setDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any, arg5: DataBuffer): void;
                    getPixel(arg0: int, arg1: int, arg2: float[], arg3: DataBuffer): JavaArray<number>;
                    getPixel(arg0: int, arg1: int, arg2: double[], arg3: DataBuffer): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: DataBuffer): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[], arg5: DataBuffer): JavaArray<number>;
                    getPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[], arg5: DataBuffer): JavaArray<number>;
                    getSample(arg0: int, arg1: int, arg2: int, arg3: DataBuffer): number;
                    getSampleFloat(arg0: int, arg1: int, arg2: int, arg3: DataBuffer): number;
                    getSampleDouble(arg0: int, arg1: int, arg2: int, arg3: DataBuffer): number;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: DataBuffer): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[], arg6: DataBuffer): JavaArray<number>;
                    getSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[], arg6: DataBuffer): JavaArray<number>;
                    setPixel(arg0: int, arg1: int, arg2: int[], arg3: DataBuffer): void;
                    setPixel(arg0: int, arg1: int, arg2: float[], arg3: DataBuffer): void;
                    setPixel(arg0: int, arg1: int, arg2: double[], arg3: DataBuffer): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[], arg5: DataBuffer): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[], arg5: DataBuffer): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[], arg5: DataBuffer): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: int, arg4: DataBuffer): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: float, arg4: DataBuffer): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: double, arg4: DataBuffer): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[], arg6: DataBuffer): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[], arg6: DataBuffer): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[], arg6: DataBuffer): void;
                    createCompatibleSampleModel(arg0: int, arg1: int): SampleModel;
                    createSubsetSampleModel(arg0: int[]): SampleModel;
                    createDataBuffer(): DataBuffer;
                    getSampleSize(): JavaArray<number>;
                    getSampleSize(arg0: int): number;

                }

                const TileObserver: JavaInterfaceStatics<TileObserver>;
                interface TileObserver extends JavaObject {

                    tileUpdate(arg0: WritableRenderedImage, arg1: int, arg2: int, arg3: boolean): void;

                }

                const ImageConsumer: JavaInterfaceStatics<ImageConsumer> & {
                    readonly RANDOMPIXELORDER: number;
                    readonly TOPDOWNLEFTRIGHT: number;
                    readonly COMPLETESCANLINES: number;
                    readonly SINGLEPASS: number;
                    readonly SINGLEFRAME: number;
                    readonly IMAGEERROR: number;
                    readonly SINGLEFRAMEDONE: number;
                    readonly STATICIMAGEDONE: number;
                    readonly IMAGEABORTED: number;
                }
                interface ImageConsumer extends JavaObject {

                    setDimensions(arg0: int, arg1: int): void;
                    setProperties(arg0: java.util.Hashtable<any, any>): void;
                    setColorModel(arg0: ColorModel): void;
                    setHints(arg0: int): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: ColorModel, arg5: byte[], arg6: int, arg7: int): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: ColorModel, arg5: int[], arg6: int, arg7: int): void;
                    imageComplete(arg0: int): void;

                }

                const IndexColorModel: JavaClassStatics<IndexColorModel, IndexColorModel$$constructor>;
                interface IndexColorModel$$constructor extends SuppressProperties {

                    new (arg0: int, arg1: int, arg2: byte[], arg3: byte[], arg4: byte[]): IndexColorModel;
                    new (arg0: int, arg1: int, arg2: byte[], arg3: byte[], arg4: byte[], arg5: int): IndexColorModel;
                    new (arg0: int, arg1: int, arg2: byte[], arg3: byte[], arg4: byte[], arg5: byte[]): IndexColorModel;
                    new (arg0: int, arg1: int, arg2: byte[], arg3: int, arg4: boolean): IndexColorModel;
                    new (arg0: int, arg1: int, arg2: byte[], arg3: int, arg4: boolean, arg5: int): IndexColorModel;
                    new (arg0: int, arg1: int, arg2: int[], arg3: int, arg4: boolean, arg5: int, arg6: int): IndexColorModel;
                    new (arg0: int, arg1: int, arg2: int[], arg3: int, arg4: int, arg5: java.math.BigInteger): IndexColorModel;

                }
                interface IndexColorModel extends ColorModel {

                    getTransparency(): number;
                    getComponentSize(): JavaArray<number>;
                    getComponentSize(arg0: int): number;
                    getMapSize(): number;
                    getTransparentPixel(): number;
                    getReds(arg0: byte[]): void;
                    getGreens(arg0: byte[]): void;
                    getBlues(arg0: byte[]): void;
                    getAlphas(arg0: byte[]): void;
                    getRGBs(arg0: int[]): void;
                    getRed(arg0: int): number;
                    getRed(arg0: any): number;
                    getGreen(arg0: int): number;
                    getGreen(arg0: any): number;
                    getBlue(arg0: int): number;
                    getBlue(arg0: any): number;
                    getAlpha(arg0: int): number;
                    getAlpha(arg0: any): number;
                    getRGB(arg0: int): number;
                    getRGB(arg0: any): number;
                    getDataElements(arg0: int, arg1: any): any;
                    getDataElements(arg0: float[], arg1: int, arg2: any): any;
                    getComponents(arg0: int, arg1: int[], arg2: int): JavaArray<number>;
                    getComponents(arg0: any, arg1: int[], arg2: int): JavaArray<number>;
                    getDataElement(arg0: int[], arg1: int): number;
                    getDataElement(arg0: float[], arg1: int): number;
                    getDataElements(arg0: int[], arg1: int, arg2: any): any;
                    createCompatibleWritableRaster(arg0: int, arg1: int): WritableRaster;
                    isCompatibleRaster(arg0: Raster): boolean;
                    createCompatibleSampleModel(arg0: int, arg1: int): SampleModel;
                    isCompatibleSampleModel(arg0: SampleModel): boolean;
                    convertToIntDiscrete(arg0: Raster, arg1: boolean): BufferedImage;
                    isValid(arg0: int): boolean;
                    isValid(): boolean;
                    getValidPixels(): java.math.BigInteger;
                    /** @deprecated */
                    finalize(): void;

                }

                const WritableRaster: JavaClassStatics<WritableRaster> & NoConstructor;
                interface WritableRaster extends Raster {

                    getWritableParent(): WritableRaster;
                    createWritableTranslatedChild(arg0: int, arg1: int): WritableRaster;
                    createWritableChild(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int[]): WritableRaster;
                    setDataElements(arg0: int, arg1: int, arg2: any): void;
                    setDataElements(arg0: int, arg1: int, arg2: Raster): void;
                    setDataElements(arg0: int, arg1: int, arg2: int, arg3: int, arg4: any): void;
                    setRect(arg0: Raster): void;
                    setRect(arg0: int, arg1: int, arg2: Raster): void;
                    setPixel(arg0: int, arg1: int, arg2: int[]): void;
                    setPixel(arg0: int, arg1: int, arg2: float[]): void;
                    setPixel(arg0: int, arg1: int, arg2: double[]): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int[]): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: float[]): void;
                    setPixels(arg0: int, arg1: int, arg2: int, arg3: int, arg4: double[]): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: int): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: float): void;
                    setSample(arg0: int, arg1: int, arg2: int, arg3: double): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int[]): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: float[]): void;
                    setSamples(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: double[]): void;

                }

                const DataBuffer: JavaClassStatics<DataBuffer> & NoConstructor & {
                    readonly TYPE_BYTE: number;
                    readonly TYPE_USHORT: number;
                    readonly TYPE_SHORT: number;
                    readonly TYPE_INT: number;
                    readonly TYPE_FLOAT: number;
                    readonly TYPE_DOUBLE: number;
                    readonly TYPE_UNDEFINED: number;

                    getDataTypeSize(arg0: int): number;

                }
                interface DataBuffer extends JavaObject {

                    getDataType(): number;
                    getSize(): number;
                    getOffset(): number;
                    getOffsets(): JavaArray<number>;
                    getNumBanks(): number;
                    getElem(arg0: int): number;
                    getElem(arg0: int, arg1: int): number;
                    setElem(arg0: int, arg1: int): void;
                    setElem(arg0: int, arg1: int, arg2: int): void;
                    getElemFloat(arg0: int): number;
                    getElemFloat(arg0: int, arg1: int): number;
                    setElemFloat(arg0: int, arg1: float): void;
                    setElemFloat(arg0: int, arg1: int, arg2: float): void;
                    getElemDouble(arg0: int): number;
                    getElemDouble(arg0: int, arg1: int): number;
                    setElemDouble(arg0: int, arg1: double): void;
                    setElemDouble(arg0: int, arg1: int, arg2: double): void;

                }

                const BufferedImageOp: JavaInterfaceStatics<BufferedImageOp>;
                interface BufferedImageOp extends JavaObject {

                    filter(arg0: BufferedImage, arg1: BufferedImage): BufferedImage;
                    getBounds2D(arg0: BufferedImage): java.awt.geom.Rectangle2D;
                    createCompatibleDestImage(arg0: BufferedImage, arg1: ColorModel): BufferedImage;
                    getPoint2D(arg0: java.awt.geom.Point2D, arg1: java.awt.geom.Point2D): java.awt.geom.Point2D;
                    getRenderingHints(): java.awt.RenderingHints;

                }

                const VolatileImage: JavaClassStatics<VolatileImage> & NoConstructor & {
                    readonly IMAGE_OK: number;
                    readonly IMAGE_RESTORED: number;
                    readonly IMAGE_INCOMPATIBLE: number;
                }
                interface VolatileImage extends java.awt.Image, java.awt.Transparency {

                    getSnapshot(): BufferedImage;
                    getWidth(): number;
                    getWidth(arg0: ImageObserver): number;
                    getHeight(): number;
                    getHeight(arg0: ImageObserver): number;
                    getSource(): ImageProducer;
                    getGraphics(): java.awt.Graphics;
                    createGraphics(): java.awt.Graphics2D;
                    validate(arg0: java.awt.GraphicsConfiguration): number;
                    contentsLost(): boolean;
                    getCapabilities(): java.awt.ImageCapabilities;
                    getCapabilities(arg0: java.awt.GraphicsConfiguration): java.awt.ImageCapabilities;
                    getTransparency(): number;

                }

                const BufferStrategy: JavaClassStatics<BufferStrategy> & NoConstructor;
                interface BufferStrategy extends JavaObject {

                    getCapabilities(): java.awt.BufferCapabilities;
                    getDrawGraphics(): java.awt.Graphics;
                    contentsLost(): boolean;
                    contentsRestored(): boolean;
                    show(): void;
                    dispose(): void;

                }

                export {
                    BufferedImage,
                    ImageObserver,
                    ImageProducer,
                    RenderedImage,
                    ColorModel,
                    Raster,
                    WritableRenderedImage,
                    SampleModel,
                    TileObserver,
                    ImageConsumer,
                    IndexColorModel,
                    WritableRaster,
                    DataBuffer,
                    BufferedImageOp,
                    VolatileImage,
                    BufferStrategy
                }

            }
            namespace image {

                namespace renderable {

                    const RenderableImage: JavaInterfaceStatics<RenderableImage> & {
                        readonly HINTS_OBSERVED: string;
                    }
                    interface RenderableImage extends JavaObject {

                        getSources(): java.util.Vector<RenderableImage>;
                        getProperty(arg0: string): any;
                        getPropertyNames(): JavaArray<string>;
                        isDynamic(): boolean;
                        getWidth(): number;
                        getHeight(): number;
                        getMinX(): number;
                        getMinY(): number;
                        createScaledRendering(arg0: int, arg1: int, arg2: java.awt.RenderingHints): java.awt.image.RenderedImage;
                        createDefaultRendering(): java.awt.image.RenderedImage;
                        createRendering(arg0: RenderContext): java.awt.image.RenderedImage;

                    }

                    const RenderContext: JavaClassStatics<RenderContext, RenderContext$$constructor>;
                    interface RenderContext$$constructor extends SuppressProperties {

                        new (arg0: java.awt.geom.AffineTransform, arg1: java.awt.Shape, arg2: java.awt.RenderingHints): RenderContext;
                        new (arg0: java.awt.geom.AffineTransform): RenderContext;
                        new (arg0: java.awt.geom.AffineTransform, arg1: java.awt.RenderingHints): RenderContext;
                        new (arg0: java.awt.geom.AffineTransform, arg1: java.awt.Shape): RenderContext;

                    }
                    interface RenderContext extends java.lang.Cloneable {

                        getRenderingHints(): java.awt.RenderingHints;
                        setRenderingHints(arg0: java.awt.RenderingHints): void;
                        setTransform(arg0: java.awt.geom.AffineTransform): void;
                        preConcatenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        /** @deprecated */
                        preConcetenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        concatenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        /** @deprecated */
                        concetenateTransform(arg0: java.awt.geom.AffineTransform): void;
                        getTransform(): java.awt.geom.AffineTransform;
                        setAreaOfInterest(arg0: java.awt.Shape): void;
                        getAreaOfInterest(): java.awt.Shape;
                        clone(): any;

                    }

                    export { RenderableImage, RenderContext }

                }

            }

            namespace geom {

                const Point2D: JavaClassStatics<Point2D> & NoConstructor & {

                    distanceSq(arg0: double, arg1: double, arg2: double, arg3: double): number;
                    distance(arg0: double, arg1: double, arg2: double, arg3: double): number;

                }
                interface Point2D extends java.lang.Cloneable {

                    getX(): number;
                    getY(): number;
                    setLocation(arg0: double, arg1: double): void;
                    setLocation(arg0: Point2D): void;
                    distanceSq(arg0: double, arg1: double): number;
                    distanceSq(arg0: Point2D): number;
                    distance(arg0: double, arg1: double): number;
                    distance(arg0: Point2D): number;
                    clone(): any;

                }

                const Rectangle2D: JavaClassStatics<Rectangle2D> & NoConstructor & {
                    readonly OUT_LEFT: number;
                    readonly OUT_TOP: number;
                    readonly OUT_RIGHT: number;
                    readonly OUT_BOTTOM: number;

                    intersect(arg0: Rectangle2D, arg1: Rectangle2D, arg2: Rectangle2D): void;
                    union(arg0: Rectangle2D, arg1: Rectangle2D, arg2: Rectangle2D): void;

                }
                interface Rectangle2D extends RectangularShape {

                    setRect(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setRect(arg0: Rectangle2D): void;
                    intersectsLine(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersectsLine(arg0: Line2D): boolean;
                    outcode(arg0: double, arg1: double): number;
                    outcode(arg0: Point2D): number;
                    setFrame(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrame(arg0: Point2D, arg1: Dimension2D): void;
                    setFrame(arg0: Rectangle2D): void;
                    getBounds2D(): Rectangle2D;
                    contains(arg0: double, arg1: double): boolean;
                    contains(arg0: Point2D): boolean;
                    contains(arg0: Rectangle2D): boolean;
                    intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersects(arg0: Rectangle2D): boolean;
                    contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    createIntersection(arg0: Rectangle2D): Rectangle2D;
                    createUnion(arg0: Rectangle2D): Rectangle2D;
                    add(arg0: double, arg1: double): void;
                    add(arg0: Point2D): void;
                    add(arg0: Rectangle2D): void;
                    getPathIterator(arg0: AffineTransform): PathIterator;
                    getPathIterator(arg0: AffineTransform, arg1: double): PathIterator;

                }

                const RectangularShape: JavaClassStatics<RectangularShape> & NoConstructor;
                interface RectangularShape extends java.awt.Shape, java.lang.Cloneable {

                    getX(): number;
                    getY(): number;
                    getWidth(): number;
                    getHeight(): number;
                    getMinX(): number;
                    getMinY(): number;
                    getMaxX(): number;
                    getMaxY(): number;
                    getCenterX(): number;
                    getCenterY(): number;
                    getFrame(): Rectangle2D;
                    isEmpty(): boolean;
                    setFrame(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrame(arg0: Point2D, arg1: Dimension2D): void;
                    setFrame(arg0: Rectangle2D): void;
                    setFrameFromDiagonal(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrameFromDiagonal(arg0: Point2D, arg1: Point2D): void;
                    setFrameFromCenter(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setFrameFromCenter(arg0: Point2D, arg1: Point2D): void;
                    contains(arg0: Point2D): boolean;
                    contains(arg0: double, arg1: double): boolean;
                    contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersects(arg0: Rectangle2D): boolean;
                    intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    contains(arg0: Rectangle2D): boolean;
                    getBounds(): java.awt.Rectangle;
                    getPathIterator(arg0: AffineTransform, arg1: double): PathIterator;
                    getPathIterator(arg0: AffineTransform): PathIterator;
                    clone(): any;

                }

                const Dimension2D: JavaClassStatics<Dimension2D> & NoConstructor;
                interface Dimension2D extends java.lang.Cloneable {

                    getWidth(): number;
                    getHeight(): number;
                    setSize(arg0: double, arg1: double): void;
                    setSize(arg0: Dimension2D): void;
                    clone(): any;

                }

                const Line2D: JavaClassStatics<Line2D> & NoConstructor & {

                    relativeCCW(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    linesIntersect(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): boolean;
                    ptSegDistSq(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    ptSegDist(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    ptLineDistSq(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;
                    ptLineDist(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): number;

                }
                interface Line2D extends java.awt.Shape, java.lang.Cloneable {

                    getX1(): number;
                    getY1(): number;
                    getP1(): Point2D;
                    getX2(): number;
                    getY2(): number;
                    getP2(): Point2D;
                    setLine(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setLine(arg0: Point2D, arg1: Point2D): void;
                    setLine(arg0: Line2D): void;
                    relativeCCW(arg0: double, arg1: double): number;
                    relativeCCW(arg0: Point2D): number;
                    intersectsLine(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersectsLine(arg0: Line2D): boolean;
                    ptSegDistSq(arg0: double, arg1: double): number;
                    ptSegDistSq(arg0: Point2D): number;
                    ptSegDist(arg0: double, arg1: double): number;
                    ptSegDist(arg0: Point2D): number;
                    ptLineDistSq(arg0: double, arg1: double): number;
                    ptLineDistSq(arg0: Point2D): number;
                    ptLineDist(arg0: double, arg1: double): number;
                    ptLineDist(arg0: Point2D): number;
                    contains(arg0: double, arg1: double): boolean;
                    contains(arg0: Point2D): boolean;
                    intersects(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    intersects(arg0: Rectangle2D): boolean;
                    contains(arg0: double, arg1: double, arg2: double, arg3: double): boolean;
                    contains(arg0: Rectangle2D): boolean;
                    getBounds(): java.awt.Rectangle;
                    getPathIterator(arg0: AffineTransform): PathIterator;
                    getPathIterator(arg0: AffineTransform, arg1: double): PathIterator;
                    clone(): any;

                }

                const PathIterator: JavaInterfaceStatics<PathIterator> & {
                    readonly WIND_EVEN_ODD: number;
                    readonly WIND_NON_ZERO: number;
                    readonly SEG_MOVETO: number;
                    readonly SEG_LINETO: number;
                    readonly SEG_QUADTO: number;
                    readonly SEG_CUBICTO: number;
                    readonly SEG_CLOSE: number;
                }
                interface PathIterator extends JavaObject {

                    getWindingRule(): number;
                    isDone(): boolean;
                    next(): void;
                    currentSegment(arg0: float[]): number;
                    currentSegment(arg0: double[]): number;

                }

                const AffineTransform: JavaClassStatics<AffineTransform, AffineTransform$$constructor> & {
                    readonly TYPE_IDENTITY: number;
                    readonly TYPE_TRANSLATION: number;
                    readonly TYPE_UNIFORM_SCALE: number;
                    readonly TYPE_GENERAL_SCALE: number;
                    readonly TYPE_MASK_SCALE: number;
                    readonly TYPE_FLIP: number;
                    readonly TYPE_QUADRANT_ROTATION: number;
                    readonly TYPE_GENERAL_ROTATION: number;
                    readonly TYPE_MASK_ROTATION: number;
                    readonly TYPE_GENERAL_TRANSFORM: number;

                    getTranslateInstance(arg0: double, arg1: double): AffineTransform;
                    getRotateInstance(arg0: double): AffineTransform;
                    getRotateInstance(arg0: double, arg1: double, arg2: double): AffineTransform;
                    getRotateInstance(arg0: double, arg1: double): AffineTransform;
                    getRotateInstance(arg0: double, arg1: double, arg2: double, arg3: double): AffineTransform;
                    getQuadrantRotateInstance(arg0: int): AffineTransform;
                    getQuadrantRotateInstance(arg0: int, arg1: double, arg2: double): AffineTransform;
                    getScaleInstance(arg0: double, arg1: double): AffineTransform;
                    getShearInstance(arg0: double, arg1: double): AffineTransform;

                }
                interface AffineTransform$$constructor extends SuppressProperties {

                    new (): AffineTransform;
                    new (arg0: AffineTransform): AffineTransform;
                    new (arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float): AffineTransform;
                    new (arg0: float[]): AffineTransform;
                    new (arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): AffineTransform;
                    new (arg0: double[]): AffineTransform;

                }
                interface AffineTransform extends java.lang.Cloneable, java.io.Serializable {

                    getType(): number;
                    getDeterminant(): number;
                    getMatrix(arg0: double[]): void;
                    getScaleX(): number;
                    getScaleY(): number;
                    getShearX(): number;
                    getShearY(): number;
                    getTranslateX(): number;
                    getTranslateY(): number;
                    translate(arg0: double, arg1: double): void;
                    rotate(arg0: double): void;
                    rotate(arg0: double, arg1: double, arg2: double): void;
                    rotate(arg0: double, arg1: double): void;
                    rotate(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    quadrantRotate(arg0: int): void;
                    quadrantRotate(arg0: int, arg1: double, arg2: double): void;
                    scale(arg0: double, arg1: double): void;
                    shear(arg0: double, arg1: double): void;
                    setToIdentity(): void;
                    setToTranslation(arg0: double, arg1: double): void;
                    setToRotation(arg0: double): void;
                    setToRotation(arg0: double, arg1: double, arg2: double): void;
                    setToRotation(arg0: double, arg1: double): void;
                    setToRotation(arg0: double, arg1: double, arg2: double, arg3: double): void;
                    setToQuadrantRotation(arg0: int): void;
                    setToQuadrantRotation(arg0: int, arg1: double, arg2: double): void;
                    setToScale(arg0: double, arg1: double): void;
                    setToShear(arg0: double, arg1: double): void;
                    setTransform(arg0: AffineTransform): void;
                    setTransform(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): void;
                    concatenate(arg0: AffineTransform): void;
                    preConcatenate(arg0: AffineTransform): void;
                    createInverse(): AffineTransform;
                    invert(): void;
                    transform(arg0: Point2D, arg1: Point2D): Point2D;
                    transform(arg0: Point2D[], arg1: int, arg2: Point2D[], arg3: int, arg4: int): void;
                    transform(arg0: float[], arg1: int, arg2: float[], arg3: int, arg4: int): void;
                    transform(arg0: double[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    transform(arg0: float[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    transform(arg0: double[], arg1: int, arg2: float[], arg3: int, arg4: int): void;
                    inverseTransform(arg0: Point2D, arg1: Point2D): Point2D;
                    inverseTransform(arg0: double[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    deltaTransform(arg0: Point2D, arg1: Point2D): Point2D;
                    deltaTransform(arg0: double[], arg1: int, arg2: double[], arg3: int, arg4: int): void;
                    createTransformedShape(arg0: java.awt.Shape): java.awt.Shape;
                    isIdentity(): boolean;
                    clone(): any;

                }

                export {
                    Point2D,
                    Rectangle2D,
                    RectangularShape,
                    Dimension2D,
                    Line2D,
                    PathIterator,
                    AffineTransform
                }

            }

            namespace color {

                const ColorSpace: JavaClassStatics<ColorSpace> & NoConstructor & {
                    readonly TYPE_XYZ: number;
                    readonly TYPE_Lab: number;
                    readonly TYPE_Luv: number;
                    readonly TYPE_YCbCr: number;
                    readonly TYPE_Yxy: number;
                    readonly TYPE_RGB: number;
                    readonly TYPE_GRAY: number;
                    readonly TYPE_HSV: number;
                    readonly TYPE_HLS: number;
                    readonly TYPE_CMYK: number;
                    readonly TYPE_CMY: number;
                    readonly TYPE_2CLR: number;
                    readonly TYPE_3CLR: number;
                    readonly TYPE_4CLR: number;
                    readonly TYPE_5CLR: number;
                    readonly TYPE_6CLR: number;
                    readonly TYPE_7CLR: number;
                    readonly TYPE_8CLR: number;
                    readonly TYPE_9CLR: number;
                    readonly TYPE_ACLR: number;
                    readonly TYPE_BCLR: number;
                    readonly TYPE_CCLR: number;
                    readonly TYPE_DCLR: number;
                    readonly TYPE_ECLR: number;
                    readonly TYPE_FCLR: number;
                    readonly CS_sRGB: number;
                    readonly CS_LINEAR_RGB: number;
                    readonly CS_CIEXYZ: number;
                    readonly CS_PYCC: number;
                    readonly CS_GRAY: number;

                    getInstance(arg0: int): ColorSpace;

                }
                interface ColorSpace extends java.io.Serializable {

                    isCS_sRGB(): boolean;
                    toRGB(arg0: float[]): JavaArray<number>;
                    fromRGB(arg0: float[]): JavaArray<number>;
                    toCIEXYZ(arg0: float[]): JavaArray<number>;
                    fromCIEXYZ(arg0: float[]): JavaArray<number>;
                    getType(): number;
                    getNumComponents(): number;
                    getName(arg0: int): string;
                    getMinValue(arg0: int): number;
                    getMaxValue(arg0: int): number;

                }

                export { ColorSpace }

            }

            namespace font {

                const GlyphVector: JavaClassStatics<GlyphVector> & NoConstructor & {
                    readonly FLAG_HAS_TRANSFORMS: number;
                    readonly FLAG_HAS_POSITION_ADJUSTMENTS: number;
                    readonly FLAG_RUN_RTL: number;
                    readonly FLAG_COMPLEX_GLYPHS: number;
                    readonly FLAG_MASK: number;
                }
                interface GlyphVector extends java.lang.Cloneable {

                    getFont(): java.awt.Font;
                    getFontRenderContext(): FontRenderContext;
                    performDefaultLayout(): void;
                    getNumGlyphs(): number;
                    getGlyphCode(arg0: int): number;
                    getGlyphCodes(arg0: int, arg1: int, arg2: int[]): JavaArray<number>;
                    getGlyphCharIndex(arg0: int): number;
                    getGlyphCharIndices(arg0: int, arg1: int, arg2: int[]): JavaArray<number>;
                    getLogicalBounds(): java.awt.geom.Rectangle2D;
                    getVisualBounds(): java.awt.geom.Rectangle2D;
                    getPixelBounds(arg0: FontRenderContext, arg1: float, arg2: float): java.awt.Rectangle;
                    getOutline(): java.awt.Shape;
                    getOutline(arg0: float, arg1: float): java.awt.Shape;
                    getGlyphOutline(arg0: int): java.awt.Shape;
                    getGlyphOutline(arg0: int, arg1: float, arg2: float): java.awt.Shape;
                    getGlyphPosition(arg0: int): java.awt.geom.Point2D;
                    setGlyphPosition(arg0: int, arg1: java.awt.geom.Point2D): void;
                    getGlyphTransform(arg0: int): java.awt.geom.AffineTransform;
                    setGlyphTransform(arg0: int, arg1: java.awt.geom.AffineTransform): void;
                    getLayoutFlags(): number;
                    getGlyphPositions(arg0: int, arg1: int, arg2: float[]): JavaArray<number>;
                    getGlyphLogicalBounds(arg0: int): java.awt.Shape;
                    getGlyphVisualBounds(arg0: int): java.awt.Shape;
                    getGlyphPixelBounds(arg0: int, arg1: FontRenderContext, arg2: float, arg3: float): java.awt.Rectangle;
                    getGlyphMetrics(arg0: int): GlyphMetrics;
                    getGlyphJustificationInfo(arg0: int): GlyphJustificationInfo;
                    equals(arg0: GlyphVector): boolean;

                }

                const FontRenderContext: JavaClassStatics<FontRenderContext, FontRenderContext$$constructor>;
                interface FontRenderContext$$constructor extends SuppressProperties {

                    new (arg0: java.awt.geom.AffineTransform, arg1: boolean, arg2: boolean): FontRenderContext;
                    new (arg0: java.awt.geom.AffineTransform, arg1: any, arg2: any): FontRenderContext;

                }
                interface FontRenderContext extends JavaObject {

                    isTransformed(): boolean;
                    getTransformType(): number;
                    getTransform(): java.awt.geom.AffineTransform;
                    isAntiAliased(): boolean;
                    usesFractionalMetrics(): boolean;
                    getAntiAliasingHint(): any;
                    getFractionalMetricsHint(): any;
                    equals(arg0: FontRenderContext): boolean;

                }

                const GlyphJustificationInfo: JavaClassStatics<GlyphJustificationInfo, GlyphJustificationInfo$$constructor> & {
                    readonly PRIORITY_KASHIDA: number;
                    readonly PRIORITY_WHITESPACE: number;
                    readonly PRIORITY_INTERCHAR: number;
                    readonly PRIORITY_NONE: number;
                }
                interface GlyphJustificationInfo$$constructor extends SuppressProperties {

                    new (arg0: float, arg1: boolean, arg2: int, arg3: float, arg4: float, arg5: boolean, arg6: int, arg7: float, arg8: float): GlyphJustificationInfo;

                }
                interface GlyphJustificationInfo extends JavaObject {
                    readonly weight: number;
                    readonly growPriority: number;
                    readonly growAbsorb: boolean;
                    readonly growLeftLimit: number;
                    readonly growRightLimit: number;
                    readonly shrinkPriority: number;
                    readonly shrinkAbsorb: boolean;
                    readonly shrinkLeftLimit: number;
                    readonly shrinkRightLimit: number;
                }

                const GlyphMetrics: JavaClassStatics<GlyphMetrics, GlyphMetrics$$constructor> & {
                    readonly STANDARD: number;
                    readonly LIGATURE: number;
                    readonly COMBINING: number;
                    readonly COMPONENT: number;
                    readonly WHITESPACE: number;
                }
                interface GlyphMetrics$$constructor extends SuppressProperties {

                    new (arg0: float, arg1: java.awt.geom.Rectangle2D, arg2: byte): GlyphMetrics;
                    new (arg0: boolean, arg1: float, arg2: float, arg3: java.awt.geom.Rectangle2D, arg4: byte): GlyphMetrics;

                }
                interface GlyphMetrics extends JavaObject {

                    getAdvance(): number;
                    getAdvanceX(): number;
                    getAdvanceY(): number;
                    getBounds2D(): java.awt.geom.Rectangle2D;
                    getLSB(): number;
                    getRSB(): number;
                    getType(): number;
                    isStandard(): boolean;
                    isLigature(): boolean;
                    isCombining(): boolean;
                    isComponent(): boolean;
                    isWhitespace(): boolean;

                }

                const TextAttribute: JavaClassStatics<TextAttribute> & NoConstructor & {
                    readonly FAMILY: TextAttribute;
                    readonly WEIGHT: TextAttribute;
                    readonly WEIGHT_EXTRA_LIGHT: number;
                    readonly WEIGHT_LIGHT: number;
                    readonly WEIGHT_DEMILIGHT: number;
                    readonly WEIGHT_REGULAR: number;
                    readonly WEIGHT_SEMIBOLD: number;
                    readonly WEIGHT_MEDIUM: number;
                    readonly WEIGHT_DEMIBOLD: number;
                    readonly WEIGHT_BOLD: number;
                    readonly WEIGHT_HEAVY: number;
                    readonly WEIGHT_EXTRABOLD: number;
                    readonly WEIGHT_ULTRABOLD: number;
                    readonly WIDTH: TextAttribute;
                    readonly WIDTH_CONDENSED: number;
                    readonly WIDTH_SEMI_CONDENSED: number;
                    readonly WIDTH_REGULAR: number;
                    readonly WIDTH_SEMI_EXTENDED: number;
                    readonly WIDTH_EXTENDED: number;
                    readonly POSTURE: TextAttribute;
                    readonly POSTURE_REGULAR: number;
                    readonly POSTURE_OBLIQUE: number;
                    readonly SIZE: TextAttribute;
                    readonly TRANSFORM: TextAttribute;
                    readonly SUPERSCRIPT: TextAttribute;
                    readonly SUPERSCRIPT_SUPER: number;
                    readonly SUPERSCRIPT_SUB: number;
                    readonly FONT: TextAttribute;
                    readonly CHAR_REPLACEMENT: TextAttribute;
                    readonly FOREGROUND: TextAttribute;
                    readonly BACKGROUND: TextAttribute;
                    readonly UNDERLINE: TextAttribute;
                    readonly UNDERLINE_ON: number;
                    readonly STRIKETHROUGH: TextAttribute;
                    readonly STRIKETHROUGH_ON: boolean;
                    readonly RUN_DIRECTION: TextAttribute;
                    readonly RUN_DIRECTION_LTR: boolean;
                    readonly RUN_DIRECTION_RTL: boolean;
                    readonly BIDI_EMBEDDING: TextAttribute;
                    readonly JUSTIFICATION: TextAttribute;
                    readonly JUSTIFICATION_FULL: number;
                    readonly JUSTIFICATION_NONE: number;
                    readonly INPUT_METHOD_HIGHLIGHT: TextAttribute;
                    readonly INPUT_METHOD_UNDERLINE: TextAttribute;
                    readonly UNDERLINE_LOW_ONE_PIXEL: number;
                    readonly UNDERLINE_LOW_TWO_PIXEL: number;
                    readonly UNDERLINE_LOW_DOTTED: number;
                    readonly UNDERLINE_LOW_GRAY: number;
                    readonly UNDERLINE_LOW_DASHED: number;
                    readonly SWAP_COLORS: TextAttribute;
                    readonly SWAP_COLORS_ON: boolean;
                    readonly NUMERIC_SHAPING: TextAttribute;
                    readonly KERNING: TextAttribute;
                    readonly KERNING_ON: number;
                    readonly LIGATURES: TextAttribute;
                    readonly LIGATURES_ON: number;
                    readonly TRACKING: TextAttribute;
                    readonly TRACKING_TIGHT: number;
                    readonly TRACKING_LOOSE: number;
                }
                interface TextAttribute extends java.text.AttributedCharacterIterator$Attribute {}

                const LineMetrics: JavaClassStatics<LineMetrics> & NoConstructor;
                interface LineMetrics extends JavaObject {

                    getNumChars(): number;
                    getAscent(): number;
                    getDescent(): number;
                    getLeading(): number;
                    getHeight(): number;
                    getBaselineIndex(): number;
                    getBaselineOffsets(): JavaArray<number>;
                    getStrikethroughOffset(): number;
                    getStrikethroughThickness(): number;
                    getUnderlineOffset(): number;
                    getUnderlineThickness(): number;

                }

                const TextHitInfo: JavaClassStatics<TextHitInfo> & NoConstructor & {

                    leading(arg0: int): TextHitInfo;
                    trailing(arg0: int): TextHitInfo;
                    beforeOffset(arg0: int): TextHitInfo;
                    afterOffset(arg0: int): TextHitInfo;

                }
                interface TextHitInfo extends JavaObject {

                    getCharIndex(): number;
                    isLeadingEdge(): boolean;
                    getInsertionIndex(): number;
                    equals(arg0: TextHitInfo): boolean;
                    equals(arg0: any): boolean;
                    getOtherHit(): TextHitInfo;
                    getOffsetHit(arg0: int): TextHitInfo;

                }

                export {
                    GlyphVector,
                    FontRenderContext,
                    GlyphJustificationInfo,
                    GlyphMetrics,
                    TextAttribute,
                    LineMetrics,
                    TextHitInfo
                }

            }

            namespace im {

                const InputContext: JavaClassStatics<InputContext> & NoConstructor & {

                    getInstance(): InputContext;

                }
                interface InputContext extends JavaObject {

                    selectInputMethod(arg0: java.util.Locale): boolean;
                    getLocale(): java.util.Locale;
                    setCharacterSubsets(arg0: java.lang.Character$Subset[]): void;
                    setCompositionEnabled(arg0: boolean): void;
                    isCompositionEnabled(): boolean;
                    reconvert(): void;
                    dispatchEvent(arg0: java.awt.AWTEvent): void;
                    removeNotify(arg0: java.awt.Component): void;
                    endComposition(): void;
                    dispose(): void;
                    getInputMethodControlObject(): any;

                }

                const InputMethodHighlight: JavaClassStatics<InputMethodHighlight, InputMethodHighlight$$constructor> & {
                    readonly RAW_TEXT: number;
                    readonly CONVERTED_TEXT: number;
                    readonly UNSELECTED_RAW_TEXT_HIGHLIGHT: InputMethodHighlight;
                    readonly SELECTED_RAW_TEXT_HIGHLIGHT: InputMethodHighlight;
                    readonly UNSELECTED_CONVERTED_TEXT_HIGHLIGHT: InputMethodHighlight;
                    readonly SELECTED_CONVERTED_TEXT_HIGHLIGHT: InputMethodHighlight;
                }
                interface InputMethodHighlight$$constructor extends SuppressProperties {

                    new (arg0: boolean, arg1: int): InputMethodHighlight;
                    new (arg0: boolean, arg1: int, arg2: int): InputMethodHighlight;
                    new (arg0: boolean, arg1: int, arg2: int, arg3: JavaMap<java.awt.font.TextAttribute, any>): InputMethodHighlight;

                }
                interface InputMethodHighlight extends JavaObject {

                    isSelected(): boolean;
                    getState(): number;
                    getVariation(): number;
                    getStyle(): JavaMap<java.awt.font.TextAttribute, any>;

                }

                const InputMethodRequests: JavaInterfaceStatics<InputMethodRequests>;
                interface InputMethodRequests extends JavaObject {

                    getTextLocation(arg0: java.awt.font.TextHitInfo): java.awt.Rectangle;
                    getLocationOffset(arg0: int, arg1: int): java.awt.font.TextHitInfo;
                    getInsertPositionOffset(): number;
                    getCommittedText(arg0: int, arg1: int, arg2: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator;
                    getCommittedTextLength(): number;
                    cancelLatestCommittedText(arg0: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator;
                    getSelectedText(arg0: java.text.AttributedCharacterIterator$Attribute[]): java.text.AttributedCharacterIterator;

                }

                export { InputContext, InputMethodHighlight, InputMethodRequests }

            }

            namespace event {

                const WindowFocusListener: JavaInterfaceStatics<WindowFocusListener>;
                interface WindowFocusListener extends java.util.EventListener {

                    windowGainedFocus(arg0: WindowEvent): void;
                    windowLostFocus(arg0: WindowEvent): void;

                }

                const WindowListener: JavaInterfaceStatics<WindowListener>;
                interface WindowListener extends java.util.EventListener {

                    windowOpened(arg0: WindowEvent): void;
                    windowClosing(arg0: WindowEvent): void;
                    windowClosed(arg0: WindowEvent): void;
                    windowIconified(arg0: WindowEvent): void;
                    windowDeiconified(arg0: WindowEvent): void;
                    windowActivated(arg0: WindowEvent): void;
                    windowDeactivated(arg0: WindowEvent): void;

                }

                const WindowStateListener: JavaInterfaceStatics<WindowStateListener>;
                interface WindowStateListener extends java.util.EventListener {

                    windowStateChanged(arg0: WindowEvent): void;

                }

                const WindowEvent: JavaClassStatics<WindowEvent, WindowEvent$$constructor> & {
                    readonly WINDOW_FIRST: number;
                    readonly WINDOW_OPENED: number;
                    readonly WINDOW_CLOSING: number;
                    readonly WINDOW_CLOSED: number;
                    readonly WINDOW_ICONIFIED: number;
                    readonly WINDOW_DEICONIFIED: number;
                    readonly WINDOW_ACTIVATED: number;
                    readonly WINDOW_DEACTIVATED: number;
                    readonly WINDOW_GAINED_FOCUS: number;
                    readonly WINDOW_LOST_FOCUS: number;
                    readonly WINDOW_STATE_CHANGED: number;
                    readonly WINDOW_LAST: number;
                }
                interface WindowEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Window, arg1: int, arg2: java.awt.Window, arg3: int, arg4: int): WindowEvent;
                    new (arg0: java.awt.Window, arg1: int, arg2: java.awt.Window): WindowEvent;
                    new (arg0: java.awt.Window, arg1: int, arg2: int, arg3: int): WindowEvent;
                    new (arg0: java.awt.Window, arg1: int): WindowEvent;

                }
                interface WindowEvent extends ComponentEvent {

                    getWindow(): java.awt.Window;
                    getOppositeWindow(): java.awt.Window;
                    getOldState(): number;
                    getNewState(): number;
                    paramString(): string;

                }

                const ComponentEvent: JavaClassStatics<ComponentEvent, ComponentEvent$$constructor> & {
                    readonly COMPONENT_FIRST: number;
                    readonly COMPONENT_LAST: number;
                    readonly COMPONENT_MOVED: number;
                    readonly COMPONENT_RESIZED: number;
                    readonly COMPONENT_SHOWN: number;
                    readonly COMPONENT_HIDDEN: number;
                }
                interface ComponentEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int): ComponentEvent;

                }
                interface ComponentEvent extends java.awt.AWTEvent {

                    getComponent(): java.awt.Component;
                    paramString(): string;

                }

                const FocusEvent$Cause: JavaClassStatics<FocusEvent$Cause> & NoConstructor & {
                    readonly UNKNOWN: FocusEvent$Cause;
                    readonly MOUSE_EVENT: FocusEvent$Cause;
                    readonly TRAVERSAL: FocusEvent$Cause;
                    readonly TRAVERSAL_UP: FocusEvent$Cause;
                    readonly TRAVERSAL_DOWN: FocusEvent$Cause;
                    readonly TRAVERSAL_FORWARD: FocusEvent$Cause;
                    readonly TRAVERSAL_BACKWARD: FocusEvent$Cause;
                    readonly ROLLBACK: FocusEvent$Cause;
                    readonly UNEXPECTED: FocusEvent$Cause;
                    readonly ACTIVATION: FocusEvent$Cause;
                    readonly CLEAR_GLOBAL_FOCUS_OWNER: FocusEvent$Cause;

                    values(): JavaArray<FocusEvent$Cause>;
                    valueOf(arg0: string): FocusEvent$Cause;

                }
                interface FocusEvent$Cause extends java.lang.Enum<FocusEvent$Cause> {}

                const ComponentListener: JavaInterfaceStatics<ComponentListener>;
                interface ComponentListener extends java.util.EventListener {

                    componentResized(arg0: ComponentEvent): void;
                    componentMoved(arg0: ComponentEvent): void;
                    componentShown(arg0: ComponentEvent): void;
                    componentHidden(arg0: ComponentEvent): void;

                }

                const ContainerListener: JavaInterfaceStatics<ContainerListener>;
                interface ContainerListener extends java.util.EventListener {

                    componentAdded(arg0: ContainerEvent): void;
                    componentRemoved(arg0: ContainerEvent): void;

                }

                const KeyEvent: JavaClassStatics<KeyEvent, KeyEvent$$constructor> & {
                    readonly KEY_FIRST: number;
                    readonly KEY_LAST: number;
                    readonly KEY_TYPED: number;
                    readonly KEY_PRESSED: number;
                    readonly KEY_RELEASED: number;
                    readonly VK_ENTER: number;
                    readonly VK_BACK_SPACE: number;
                    readonly VK_TAB: number;
                    readonly VK_CANCEL: number;
                    readonly VK_CLEAR: number;
                    readonly VK_SHIFT: number;
                    readonly VK_CONTROL: number;
                    readonly VK_ALT: number;
                    readonly VK_PAUSE: number;
                    readonly VK_CAPS_LOCK: number;
                    readonly VK_ESCAPE: number;
                    readonly VK_SPACE: number;
                    readonly VK_PAGE_UP: number;
                    readonly VK_PAGE_DOWN: number;
                    readonly VK_END: number;
                    readonly VK_HOME: number;
                    readonly VK_LEFT: number;
                    readonly VK_UP: number;
                    readonly VK_RIGHT: number;
                    readonly VK_DOWN: number;
                    readonly VK_COMMA: number;
                    readonly VK_MINUS: number;
                    readonly VK_PERIOD: number;
                    readonly VK_SLASH: number;
                    readonly VK_0: number;
                    readonly VK_1: number;
                    readonly VK_2: number;
                    readonly VK_3: number;
                    readonly VK_4: number;
                    readonly VK_5: number;
                    readonly VK_6: number;
                    readonly VK_7: number;
                    readonly VK_8: number;
                    readonly VK_9: number;
                    readonly VK_SEMICOLON: number;
                    readonly VK_EQUALS: number;
                    readonly VK_A: number;
                    readonly VK_B: number;
                    readonly VK_C: number;
                    readonly VK_D: number;
                    readonly VK_E: number;
                    readonly VK_F: number;
                    readonly VK_G: number;
                    readonly VK_H: number;
                    readonly VK_I: number;
                    readonly VK_J: number;
                    readonly VK_K: number;
                    readonly VK_L: number;
                    readonly VK_M: number;
                    readonly VK_N: number;
                    readonly VK_O: number;
                    readonly VK_P: number;
                    readonly VK_Q: number;
                    readonly VK_R: number;
                    readonly VK_S: number;
                    readonly VK_T: number;
                    readonly VK_U: number;
                    readonly VK_V: number;
                    readonly VK_W: number;
                    readonly VK_X: number;
                    readonly VK_Y: number;
                    readonly VK_Z: number;
                    readonly VK_OPEN_BRACKET: number;
                    readonly VK_BACK_SLASH: number;
                    readonly VK_CLOSE_BRACKET: number;
                    readonly VK_NUMPAD0: number;
                    readonly VK_NUMPAD1: number;
                    readonly VK_NUMPAD2: number;
                    readonly VK_NUMPAD3: number;
                    readonly VK_NUMPAD4: number;
                    readonly VK_NUMPAD5: number;
                    readonly VK_NUMPAD6: number;
                    readonly VK_NUMPAD7: number;
                    readonly VK_NUMPAD8: number;
                    readonly VK_NUMPAD9: number;
                    readonly VK_MULTIPLY: number;
                    readonly VK_ADD: number;
                    readonly VK_SEPARATER: number;
                    readonly VK_SEPARATOR: number;
                    readonly VK_SUBTRACT: number;
                    readonly VK_DECIMAL: number;
                    readonly VK_DIVIDE: number;
                    readonly VK_DELETE: number;
                    readonly VK_NUM_LOCK: number;
                    readonly VK_SCROLL_LOCK: number;
                    readonly VK_F1: number;
                    readonly VK_F2: number;
                    readonly VK_F3: number;
                    readonly VK_F4: number;
                    readonly VK_F5: number;
                    readonly VK_F6: number;
                    readonly VK_F7: number;
                    readonly VK_F8: number;
                    readonly VK_F9: number;
                    readonly VK_F10: number;
                    readonly VK_F11: number;
                    readonly VK_F12: number;
                    readonly VK_F13: number;
                    readonly VK_F14: number;
                    readonly VK_F15: number;
                    readonly VK_F16: number;
                    readonly VK_F17: number;
                    readonly VK_F18: number;
                    readonly VK_F19: number;
                    readonly VK_F20: number;
                    readonly VK_F21: number;
                    readonly VK_F22: number;
                    readonly VK_F23: number;
                    readonly VK_F24: number;
                    readonly VK_PRINTSCREEN: number;
                    readonly VK_INSERT: number;
                    readonly VK_HELP: number;
                    readonly VK_META: number;
                    readonly VK_BACK_QUOTE: number;
                    readonly VK_QUOTE: number;
                    readonly VK_KP_UP: number;
                    readonly VK_KP_DOWN: number;
                    readonly VK_KP_LEFT: number;
                    readonly VK_KP_RIGHT: number;
                    readonly VK_DEAD_GRAVE: number;
                    readonly VK_DEAD_ACUTE: number;
                    readonly VK_DEAD_CIRCUMFLEX: number;
                    readonly VK_DEAD_TILDE: number;
                    readonly VK_DEAD_MACRON: number;
                    readonly VK_DEAD_BREVE: number;
                    readonly VK_DEAD_ABOVEDOT: number;
                    readonly VK_DEAD_DIAERESIS: number;
                    readonly VK_DEAD_ABOVERING: number;
                    readonly VK_DEAD_DOUBLEACUTE: number;
                    readonly VK_DEAD_CARON: number;
                    readonly VK_DEAD_CEDILLA: number;
                    readonly VK_DEAD_OGONEK: number;
                    readonly VK_DEAD_IOTA: number;
                    readonly VK_DEAD_VOICED_SOUND: number;
                    readonly VK_DEAD_SEMIVOICED_SOUND: number;
                    readonly VK_AMPERSAND: number;
                    readonly VK_ASTERISK: number;
                    readonly VK_QUOTEDBL: number;
                    readonly VK_LESS: number;
                    readonly VK_GREATER: number;
                    readonly VK_BRACELEFT: number;
                    readonly VK_BRACERIGHT: number;
                    readonly VK_AT: number;
                    readonly VK_COLON: number;
                    readonly VK_CIRCUMFLEX: number;
                    readonly VK_DOLLAR: number;
                    readonly VK_EURO_SIGN: number;
                    readonly VK_EXCLAMATION_MARK: number;
                    readonly VK_INVERTED_EXCLAMATION_MARK: number;
                    readonly VK_LEFT_PARENTHESIS: number;
                    readonly VK_NUMBER_SIGN: number;
                    readonly VK_PLUS: number;
                    readonly VK_RIGHT_PARENTHESIS: number;
                    readonly VK_UNDERSCORE: number;
                    readonly VK_WINDOWS: number;
                    readonly VK_CONTEXT_MENU: number;
                    readonly VK_FINAL: number;
                    readonly VK_CONVERT: number;
                    readonly VK_NONCONVERT: number;
                    readonly VK_ACCEPT: number;
                    readonly VK_MODECHANGE: number;
                    readonly VK_KANA: number;
                    readonly VK_KANJI: number;
                    readonly VK_ALPHANUMERIC: number;
                    readonly VK_KATAKANA: number;
                    readonly VK_HIRAGANA: number;
                    readonly VK_FULL_WIDTH: number;
                    readonly VK_HALF_WIDTH: number;
                    readonly VK_ROMAN_CHARACTERS: number;
                    readonly VK_ALL_CANDIDATES: number;
                    readonly VK_PREVIOUS_CANDIDATE: number;
                    readonly VK_CODE_INPUT: number;
                    readonly VK_JAPANESE_KATAKANA: number;
                    readonly VK_JAPANESE_HIRAGANA: number;
                    readonly VK_JAPANESE_ROMAN: number;
                    readonly VK_KANA_LOCK: number;
                    readonly VK_INPUT_METHOD_ON_OFF: number;
                    readonly VK_CUT: number;
                    readonly VK_COPY: number;
                    readonly VK_PASTE: number;
                    readonly VK_UNDO: number;
                    readonly VK_AGAIN: number;
                    readonly VK_FIND: number;
                    readonly VK_PROPS: number;
                    readonly VK_STOP: number;
                    readonly VK_COMPOSE: number;
                    readonly VK_ALT_GRAPH: number;
                    readonly VK_BEGIN: number;
                    readonly VK_UNDEFINED: number;
                    readonly CHAR_UNDEFINED: number;
                    readonly KEY_LOCATION_UNKNOWN: number;
                    readonly KEY_LOCATION_STANDARD: number;
                    readonly KEY_LOCATION_LEFT: number;
                    readonly KEY_LOCATION_RIGHT: number;
                    readonly KEY_LOCATION_NUMPAD: number;

                    getKeyText(arg0: int): string;
                    /** @deprecated */
                    getKeyModifiersText(arg0: int): string;
                    getExtendedKeyCodeForChar(arg0: int): number;

                }
                interface KeyEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: char, arg6: int): KeyEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: char): KeyEvent;
                    /** @deprecated */
                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int): KeyEvent;

                }
                interface KeyEvent extends InputEvent {

                    getKeyCode(): number;
                    setKeyCode(arg0: int): void;
                    getKeyChar(): number;
                    setKeyChar(arg0: char): void;
                    /** @deprecated */
                    setModifiers(arg0: int): void;
                    getKeyLocation(): number;
                    isActionKey(): boolean;
                    paramString(): string;
                    getExtendedKeyCode(): number;

                }

                const HierarchyBoundsListener: JavaInterfaceStatics<HierarchyBoundsListener>;
                interface HierarchyBoundsListener extends java.util.EventListener {

                    ancestorMoved(arg0: HierarchyEvent): void;
                    ancestorResized(arg0: HierarchyEvent): void;

                }

                const AWTEventListener: JavaInterfaceStatics<AWTEventListener>;
                interface AWTEventListener extends java.util.EventListener {

                    eventDispatched(arg0: java.awt.AWTEvent): void;

                }

                const MouseListener: JavaInterfaceStatics<MouseListener>;
                interface MouseListener extends java.util.EventListener {

                    mouseClicked(arg0: MouseEvent): void;
                    mousePressed(arg0: MouseEvent): void;
                    mouseReleased(arg0: MouseEvent): void;
                    mouseEntered(arg0: MouseEvent): void;
                    mouseExited(arg0: MouseEvent): void;

                }

                const MouseWheelListener: JavaInterfaceStatics<MouseWheelListener>;
                interface MouseWheelListener extends java.util.EventListener {

                    mouseWheelMoved(arg0: MouseWheelEvent): void;

                }

                const HierarchyListener: JavaInterfaceStatics<HierarchyListener>;
                interface HierarchyListener extends java.util.EventListener {

                    hierarchyChanged(arg0: HierarchyEvent): void;

                }

                const MouseMotionListener: JavaInterfaceStatics<MouseMotionListener>;
                interface MouseMotionListener extends java.util.EventListener {

                    mouseDragged(arg0: MouseEvent): void;
                    mouseMoved(arg0: MouseEvent): void;

                }

                const InputMethodListener: JavaInterfaceStatics<InputMethodListener>;
                interface InputMethodListener extends java.util.EventListener {

                    inputMethodTextChanged(arg0: InputMethodEvent): void;
                    caretPositionChanged(arg0: InputMethodEvent): void;

                }

                const FocusListener: JavaInterfaceStatics<FocusListener>;
                interface FocusListener extends java.util.EventListener {

                    focusGained(arg0: FocusEvent): void;
                    focusLost(arg0: FocusEvent): void;

                }

                const KeyListener: JavaInterfaceStatics<KeyListener>;
                interface KeyListener extends java.util.EventListener {

                    keyTyped(arg0: KeyEvent): void;
                    keyPressed(arg0: KeyEvent): void;
                    keyReleased(arg0: KeyEvent): void;

                }

                const MouseWheelEvent: JavaClassStatics<MouseWheelEvent, MouseWheelEvent$$constructor> & {
                    readonly WHEEL_UNIT_SCROLL: number;
                    readonly WHEEL_BLOCK_SCROLL: number;
                }
                interface MouseWheelEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: boolean, arg8: int, arg9: int, arg10: int): MouseWheelEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: boolean, arg10: int, arg11: int, arg12: int): MouseWheelEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: boolean, arg10: int, arg11: int, arg12: int, arg13: double): MouseWheelEvent;

                }
                interface MouseWheelEvent extends MouseEvent {

                    getScrollType(): number;
                    getScrollAmount(): number;
                    getWheelRotation(): number;
                    getPreciseWheelRotation(): number;
                    getUnitsToScroll(): number;
                    paramString(): string;

                }

                const InputMethodEvent: JavaClassStatics<InputMethodEvent, InputMethodEvent$$constructor> & {
                    readonly INPUT_METHOD_FIRST: number;
                    readonly INPUT_METHOD_TEXT_CHANGED: number;
                    readonly CARET_POSITION_CHANGED: number;
                    readonly INPUT_METHOD_LAST: number;
                }
                interface InputMethodEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: java.text.AttributedCharacterIterator, arg4: int, arg5: java.awt.font.TextHitInfo, arg6: java.awt.font.TextHitInfo): InputMethodEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: java.text.AttributedCharacterIterator, arg3: int, arg4: java.awt.font.TextHitInfo, arg5: java.awt.font.TextHitInfo): InputMethodEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: java.awt.font.TextHitInfo, arg3: java.awt.font.TextHitInfo): InputMethodEvent;

                }
                interface InputMethodEvent extends java.awt.AWTEvent {

                    getText(): java.text.AttributedCharacterIterator;
                    getCommittedCharacterCount(): number;
                    getCaret(): java.awt.font.TextHitInfo;
                    getVisiblePosition(): java.awt.font.TextHitInfo;
                    consume(): void;
                    isConsumed(): boolean;
                    getWhen(): number;
                    paramString(): string;

                }

                const InputEvent: JavaClassStatics<InputEvent> & NoConstructor & {
                    /** @deprecated */
                    readonly SHIFT_MASK: number;
                    /** @deprecated */
                    readonly CTRL_MASK: number;
                    /** @deprecated */
                    readonly META_MASK: number;
                    /** @deprecated */
                    readonly ALT_MASK: number;
                    /** @deprecated */
                    readonly ALT_GRAPH_MASK: number;
                    /** @deprecated */
                    readonly BUTTON1_MASK: number;
                    /** @deprecated */
                    readonly BUTTON2_MASK: number;
                    /** @deprecated */
                    readonly BUTTON3_MASK: number;
                    readonly SHIFT_DOWN_MASK: number;
                    readonly CTRL_DOWN_MASK: number;
                    readonly META_DOWN_MASK: number;
                    readonly ALT_DOWN_MASK: number;
                    readonly BUTTON1_DOWN_MASK: number;
                    readonly BUTTON2_DOWN_MASK: number;
                    readonly BUTTON3_DOWN_MASK: number;
                    readonly ALT_GRAPH_DOWN_MASK: number;

                    getMaskForButton(arg0: int): number;
                    getModifiersExText(arg0: int): string;

                }
                interface InputEvent extends ComponentEvent {

                    isShiftDown(): boolean;
                    isControlDown(): boolean;
                    isMetaDown(): boolean;
                    isAltDown(): boolean;
                    isAltGraphDown(): boolean;
                    getWhen(): number;
                    /** @deprecated */
                    getModifiers(): number;
                    getModifiersEx(): number;
                    consume(): void;
                    isConsumed(): boolean;

                }

                const ContainerEvent: JavaClassStatics<ContainerEvent, ContainerEvent$$constructor> & {
                    readonly CONTAINER_FIRST: number;
                    readonly CONTAINER_LAST: number;
                    readonly COMPONENT_ADDED: number;
                    readonly COMPONENT_REMOVED: number;
                }
                interface ContainerEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: java.awt.Component): ContainerEvent;

                }
                interface ContainerEvent extends ComponentEvent {

                    getContainer(): java.awt.Container;
                    getChild(): java.awt.Component;
                    paramString(): string;

                }

                const HierarchyEvent: JavaClassStatics<HierarchyEvent, HierarchyEvent$$constructor> & {
                    readonly HIERARCHY_FIRST: number;
                    readonly HIERARCHY_CHANGED: number;
                    readonly ANCESTOR_MOVED: number;
                    readonly ANCESTOR_RESIZED: number;
                    readonly HIERARCHY_LAST: number;
                    readonly PARENT_CHANGED: number;
                    readonly DISPLAYABILITY_CHANGED: number;
                    readonly SHOWING_CHANGED: number;
                }
                interface HierarchyEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: java.awt.Component, arg3: java.awt.Container): HierarchyEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: java.awt.Component, arg3: java.awt.Container, arg4: long): HierarchyEvent;

                }
                interface HierarchyEvent extends java.awt.AWTEvent {

                    getComponent(): java.awt.Component;
                    getChanged(): java.awt.Component;
                    getChangedParent(): java.awt.Container;
                    getChangeFlags(): number;
                    paramString(): string;

                }

                const FocusEvent: JavaClassStatics<FocusEvent, FocusEvent$$constructor> & {
                    readonly FOCUS_FIRST: number;
                    readonly FOCUS_LAST: number;
                    readonly FOCUS_GAINED: number;
                    readonly FOCUS_LOST: number;
                }
                interface FocusEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: boolean, arg3: java.awt.Component): FocusEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: boolean, arg3: java.awt.Component, arg4: FocusEvent$Cause): FocusEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: boolean): FocusEvent;
                    new (arg0: java.awt.Component, arg1: int): FocusEvent;

                }
                interface FocusEvent extends ComponentEvent {

                    isTemporary(): boolean;
                    getOppositeComponent(): java.awt.Component;
                    paramString(): string;
                    getCause(): FocusEvent$Cause;

                }

                const MouseEvent: JavaClassStatics<MouseEvent, MouseEvent$$constructor> & {
                    readonly MOUSE_FIRST: number;
                    readonly MOUSE_LAST: number;
                    readonly MOUSE_CLICKED: number;
                    readonly MOUSE_PRESSED: number;
                    readonly MOUSE_RELEASED: number;
                    readonly MOUSE_MOVED: number;
                    readonly MOUSE_ENTERED: number;
                    readonly MOUSE_EXITED: number;
                    readonly MOUSE_DRAGGED: number;
                    readonly MOUSE_WHEEL: number;
                    readonly NOBUTTON: number;
                    readonly BUTTON1: number;
                    readonly BUTTON2: number;
                    readonly BUTTON3: number;

                    getMouseModifiersText(arg0: int): string;

                }
                interface MouseEvent$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: boolean, arg8: int): MouseEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: boolean): MouseEvent;
                    new (arg0: java.awt.Component, arg1: int, arg2: long, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int, arg9: boolean, arg10: int): MouseEvent;

                }
                interface MouseEvent extends InputEvent {

                    getLocationOnScreen(): java.awt.Point;
                    getXOnScreen(): number;
                    getYOnScreen(): number;
                    getModifiersEx(): number;
                    getX(): number;
                    getY(): number;
                    getPoint(): java.awt.Point;
                    translatePoint(arg0: int, arg1: int): void;
                    getClickCount(): number;
                    getButton(): number;
                    isPopupTrigger(): boolean;
                    paramString(): string;

                }

                const ActionListener: JavaInterfaceStatics<ActionListener>;
                interface ActionListener extends java.util.EventListener {

                    actionPerformed(arg0: ActionEvent): void;

                }

                const ActionEvent: JavaClassStatics<ActionEvent, ActionEvent$$constructor> & {
                    readonly SHIFT_MASK: number;
                    readonly CTRL_MASK: number;
                    readonly META_MASK: number;
                    readonly ALT_MASK: number;
                    readonly ACTION_FIRST: number;
                    readonly ACTION_LAST: number;
                    readonly ACTION_PERFORMED: number;
                }
                interface ActionEvent$$constructor extends SuppressProperties {

                    new (arg0: any, arg1: int, arg2: string): ActionEvent;
                    new (arg0: any, arg1: int, arg2: string, arg3: int): ActionEvent;
                    new (arg0: any, arg1: int, arg2: string, arg3: long, arg4: int): ActionEvent;

                }
                interface ActionEvent extends java.awt.AWTEvent {

                    getActionCommand(): string;
                    getWhen(): number;
                    getModifiers(): number;
                    paramString(): string;

                }

                export {
                    WindowFocusListener,
                    WindowListener,
                    WindowStateListener,
                    WindowEvent,
                    ComponentEvent,
                    FocusEvent$Cause,
                    ComponentListener,
                    ContainerListener,
                    KeyEvent,
                    HierarchyBoundsListener,
                    AWTEventListener,
                    MouseListener,
                    MouseWheelListener,
                    HierarchyListener,
                    MouseMotionListener,
                    InputMethodListener,
                    FocusListener,
                    KeyListener,
                    MouseWheelEvent,
                    InputMethodEvent,
                    InputEvent,
                    ContainerEvent,
                    HierarchyEvent,
                    FocusEvent,
                    MouseEvent,
                    ActionListener,
                    ActionEvent
                }

            }

            namespace datatransfer {

                const Clipboard: JavaClassStatics<Clipboard, Clipboard$$constructor>;
                interface Clipboard$$constructor extends SuppressProperties {

                    new (arg0: string): Clipboard;

                }
                interface Clipboard extends JavaObject {

                    getName(): string;
                    setContents(arg0: Transferable, arg1: ClipboardOwner): void;
                    getContents(arg0: any): Transferable;
                    getAvailableDataFlavors(): JavaArray<DataFlavor>;
                    isDataFlavorAvailable(arg0: DataFlavor): boolean;
                    getData(arg0: DataFlavor): any;
                    addFlavorListener(arg0: FlavorListener): void;
                    removeFlavorListener(arg0: FlavorListener): void;
                    getFlavorListeners(): JavaArray<FlavorListener>;

                }

                const DataFlavor: JavaClassStatics<DataFlavor, DataFlavor$$constructor> & {
                    readonly stringFlavor: DataFlavor;
                    readonly imageFlavor: DataFlavor;
                    /** @deprecated */
                    readonly plainTextFlavor: DataFlavor;
                    readonly javaSerializedObjectMimeType: string;
                    readonly javaFileListFlavor: DataFlavor;
                    readonly javaJVMLocalObjectMimeType: string;
                    readonly javaRemoteObjectMimeType: string;
                    readonly selectionHtmlFlavor: DataFlavor;
                    readonly fragmentHtmlFlavor: DataFlavor;
                    readonly allHtmlFlavor: DataFlavor;

                    getTextPlainUnicodeFlavor(): DataFlavor;
                    selectBestTextFlavor(arg0: DataFlavor[]): DataFlavor;

                }
                interface DataFlavor$$constructor extends SuppressProperties {

                    new (): DataFlavor;
                    new (arg0: JavaClassArg<any>, arg1: string): DataFlavor;
                    new (arg0: string, arg1: string): DataFlavor;
                    new (arg0: string, arg1: string, arg2: java.lang.ClassLoader): DataFlavor;
                    new (arg0: string): DataFlavor;

                }
                interface DataFlavor extends java.io.Externalizable, java.lang.Cloneable {

                    getReaderForText(arg0: Transferable): java.io.Reader;
                    getMimeType(): string;
                    getRepresentationClass(): JavaClass<any>;
                    getHumanPresentableName(): string;
                    getPrimaryType(): string;
                    getSubType(): string;
                    getParameter(arg0: string): string;
                    setHumanPresentableName(arg0: string): void;
                    equals(arg0: DataFlavor): boolean;
                    /** @deprecated */
                    equals(arg0: string): boolean;
                    equals(arg0: any): boolean;
                    match(arg0: DataFlavor): boolean;
                    isMimeTypeEqual(arg0: string): boolean;
                    isMimeTypeEqual(arg0: DataFlavor): boolean;
                    isMimeTypeSerializedObject(): boolean;
                    getDefaultRepresentationClass(): JavaClass<any>;
                    getDefaultRepresentationClassAsString(): string;
                    isRepresentationClassInputStream(): boolean;
                    isRepresentationClassReader(): boolean;
                    isRepresentationClassCharBuffer(): boolean;
                    isRepresentationClassByteBuffer(): boolean;
                    isRepresentationClassSerializable(): boolean;
                    isRepresentationClassRemote(): boolean;
                    isFlavorSerializedObjectType(): boolean;
                    isFlavorRemoteObjectType(): boolean;
                    isFlavorJavaFileListType(): boolean;
                    isFlavorTextType(): boolean;
                    writeExternal(arg0: java.io.ObjectOutput): void;
                    readExternal(arg0: java.io.ObjectInput): void;
                    clone(): any;

                }

                const Transferable: JavaInterfaceStatics<Transferable>;
                interface Transferable extends JavaObject {

                    getTransferDataFlavors(): JavaArray<DataFlavor>;
                    isDataFlavorSupported(arg0: DataFlavor): boolean;
                    getTransferData(arg0: DataFlavor): any;

                }

                const ClipboardOwner: JavaInterfaceStatics<ClipboardOwner>;
                interface ClipboardOwner extends JavaObject {

                    lostOwnership(arg0: Clipboard, arg1: Transferable): void;

                }

                const FlavorListener: JavaInterfaceStatics<FlavorListener>;
                interface FlavorListener extends java.util.EventListener {

                    flavorsChanged(arg0: FlavorEvent): void;

                }

                const FlavorEvent: JavaClassStatics<FlavorEvent, FlavorEvent$$constructor>;
                interface FlavorEvent$$constructor extends SuppressProperties {

                    new (arg0: Clipboard): FlavorEvent;

                }
                interface FlavorEvent extends java.util.EventObject {}

                const FlavorMap: JavaInterfaceStatics<FlavorMap>;
                interface FlavorMap extends JavaObject {

                    getNativesForFlavors(arg0: DataFlavor[]): JavaMap<DataFlavor, string>;
                    getFlavorsForNatives(arg0: string[]): JavaMap<string, DataFlavor>;

                }

                export {
                    Clipboard,
                    DataFlavor,
                    Transferable,
                    ClipboardOwner,
                    FlavorListener,
                    FlavorEvent,
                    FlavorMap
                }

            }

            namespace dnd {

                const DragGestureListener: JavaInterfaceStatics<DragGestureListener>;
                interface DragGestureListener extends java.util.EventListener {

                    dragGestureRecognized(arg0: DragGestureEvent): void;

                }

                const DragGestureRecognizer: JavaClassStatics<DragGestureRecognizer> & NoConstructor;
                interface DragGestureRecognizer extends java.io.Serializable {

                    getDragSource(): DragSource;
                    getComponent(): java.awt.Component;
                    setComponent(arg0: java.awt.Component): void;
                    getSourceActions(): number;
                    setSourceActions(arg0: int): void;
                    getTriggerEvent(): java.awt.event.InputEvent;
                    resetRecognizer(): void;
                    addDragGestureListener(arg0: DragGestureListener): void;
                    removeDragGestureListener(arg0: DragGestureListener): void;

                }

                const DragSource: JavaClassStatics<DragSource, DragSource$$constructor> & {
                    readonly DefaultCopyDrop: java.awt.Cursor;
                    readonly DefaultMoveDrop: java.awt.Cursor;
                    readonly DefaultLinkDrop: java.awt.Cursor;
                    readonly DefaultCopyNoDrop: java.awt.Cursor;
                    readonly DefaultMoveNoDrop: java.awt.Cursor;
                    readonly DefaultLinkNoDrop: java.awt.Cursor;

                    getDefaultDragSource(): DragSource;
                    isDragImageSupported(): boolean;
                    getDragThreshold(): number;

                }
                interface DragSource$$constructor extends SuppressProperties {

                    new (): DragSource;

                }
                interface DragSource extends java.io.Serializable {

                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.Image, arg3: java.awt.Point, arg4: java.awt.datatransfer.Transferable, arg5: DragSourceListener, arg6: java.awt.datatransfer.FlavorMap): void;
                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.datatransfer.Transferable, arg3: DragSourceListener, arg4: java.awt.datatransfer.FlavorMap): void;
                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.Image, arg3: java.awt.Point, arg4: java.awt.datatransfer.Transferable, arg5: DragSourceListener): void;
                    startDrag(arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.datatransfer.Transferable, arg3: DragSourceListener): void;
                    getFlavorMap(): java.awt.datatransfer.FlavorMap;
                    createDragGestureRecognizer<T extends DragGestureRecognizer>(arg0: JavaClassArg<T>, arg1: java.awt.Component, arg2: int, arg3: DragGestureListener): T;
                    createDefaultDragGestureRecognizer(arg0: java.awt.Component, arg1: int, arg2: DragGestureListener): DragGestureRecognizer;
                    addDragSourceListener(arg0: DragSourceListener): void;
                    removeDragSourceListener(arg0: DragSourceListener): void;
                    getDragSourceListeners(): JavaArray<DragSourceListener>;
                    addDragSourceMotionListener(arg0: DragSourceMotionListener): void;
                    removeDragSourceMotionListener(arg0: DragSourceMotionListener): void;
                    getDragSourceMotionListeners(): JavaArray<DragSourceMotionListener>;
                    getListeners<T extends java.util.EventListener>(arg0: JavaClassArg<T>): JavaArray<T>;

                }

                const DropTarget: JavaClassStatics<DropTarget, DropTarget$$constructor>;
                interface DropTarget$$constructor extends SuppressProperties {

                    new (arg0: java.awt.Component, arg1: int, arg2: DropTargetListener, arg3: boolean, arg4: java.awt.datatransfer.FlavorMap): DropTarget;
                    new (arg0: java.awt.Component, arg1: int, arg2: DropTargetListener, arg3: boolean): DropTarget;
                    new (): DropTarget;
                    new (arg0: java.awt.Component, arg1: DropTargetListener): DropTarget;
                    new (arg0: java.awt.Component, arg1: int, arg2: DropTargetListener): DropTarget;

                }
                interface DropTarget extends DropTargetListener, java.io.Serializable {

                    setComponent(arg0: java.awt.Component): void;
                    getComponent(): java.awt.Component;
                    setDefaultActions(arg0: int): void;
                    getDefaultActions(): number;
                    setActive(arg0: boolean): void;
                    isActive(): boolean;
                    addDropTargetListener(arg0: DropTargetListener): void;
                    removeDropTargetListener(arg0: DropTargetListener): void;
                    dragEnter(arg0: DropTargetDragEvent): void;
                    dragOver(arg0: DropTargetDragEvent): void;
                    dropActionChanged(arg0: DropTargetDragEvent): void;
                    dragExit(arg0: DropTargetEvent): void;
                    drop(arg0: DropTargetDropEvent): void;
                    getFlavorMap(): java.awt.datatransfer.FlavorMap;
                    setFlavorMap(arg0: java.awt.datatransfer.FlavorMap): void;
                    addNotify(): void;
                    removeNotify(): void;
                    getDropTargetContext(): DropTargetContext;

                }

                const DragSourceMotionListener: JavaInterfaceStatics<DragSourceMotionListener>;
                interface DragSourceMotionListener extends java.util.EventListener {

                    dragMouseMoved(arg0: DragSourceDragEvent): void;

                }

                const DropTargetContext: JavaClassStatics<DropTargetContext> & NoConstructor;
                interface DropTargetContext extends java.io.Serializable {

                    getDropTarget(): DropTarget;
                    getComponent(): java.awt.Component;
                    dropComplete(arg0: boolean): void;

                }

                const DropTargetEvent: JavaClassStatics<DropTargetEvent, DropTargetEvent$$constructor>;
                interface DropTargetEvent$$constructor extends SuppressProperties {

                    new (arg0: DropTargetContext): DropTargetEvent;

                }
                interface DropTargetEvent extends java.util.EventObject {

                    getDropTargetContext(): DropTargetContext;

                }

                const DragSourceListener: JavaInterfaceStatics<DragSourceListener>;
                interface DragSourceListener extends java.util.EventListener {

                    dragEnter(arg0: DragSourceDragEvent): void;
                    dragOver(arg0: DragSourceDragEvent): void;
                    dropActionChanged(arg0: DragSourceDragEvent): void;
                    dragExit(arg0: DragSourceEvent): void;
                    dragDropEnd(arg0: DragSourceDropEvent): void;

                }

                const DropTargetListener: JavaInterfaceStatics<DropTargetListener>;
                interface DropTargetListener extends java.util.EventListener {

                    dragEnter(arg0: DropTargetDragEvent): void;
                    dragOver(arg0: DropTargetDragEvent): void;
                    dropActionChanged(arg0: DropTargetDragEvent): void;
                    dragExit(arg0: DropTargetEvent): void;
                    drop(arg0: DropTargetDropEvent): void;

                }

                const DragGestureEvent: JavaClassStatics<DragGestureEvent, DragGestureEvent$$constructor>;
                interface DragGestureEvent$$constructor extends SuppressProperties {

                    new (arg0: DragGestureRecognizer, arg1: int, arg2: java.awt.Point, arg3: JavaList<any>): DragGestureEvent;

                }
                interface DragGestureEvent extends java.util.EventObject {

                    getSourceAsDragGestureRecognizer(): DragGestureRecognizer;
                    getComponent(): java.awt.Component;
                    getDragSource(): DragSource;
                    getDragOrigin(): java.awt.Point;
                    iterator(): java.util.Iterator<java.awt.event.InputEvent>;
                    toArray(): JavaArray<any>;
                    toArray(arg0: any[]): JavaArray<any>;
                    getDragAction(): number;
                    getTriggerEvent(): java.awt.event.InputEvent;
                    startDrag(arg0: java.awt.Cursor, arg1: java.awt.datatransfer.Transferable): void;
                    startDrag(arg0: java.awt.Cursor, arg1: java.awt.datatransfer.Transferable, arg2: DragSourceListener): void;
                    startDrag(arg0: java.awt.Cursor, arg1: java.awt.Image, arg2: java.awt.Point, arg3: java.awt.datatransfer.Transferable, arg4: DragSourceListener): void;

                }

                const DropTargetDragEvent: JavaClassStatics<DropTargetDragEvent, DropTargetDragEvent$$constructor>;
                interface DropTargetDragEvent$$constructor extends SuppressProperties {

                    new (arg0: DropTargetContext, arg1: java.awt.Point, arg2: int, arg3: int): DropTargetDragEvent;

                }
                interface DropTargetDragEvent extends DropTargetEvent {

                    getLocation(): java.awt.Point;
                    getCurrentDataFlavors(): JavaArray<java.awt.datatransfer.DataFlavor>;
                    getCurrentDataFlavorsAsList(): JavaList<java.awt.datatransfer.DataFlavor>;
                    isDataFlavorSupported(arg0: java.awt.datatransfer.DataFlavor): boolean;
                    getSourceActions(): number;
                    getDropAction(): number;
                    getTransferable(): java.awt.datatransfer.Transferable;
                    acceptDrag(arg0: int): void;
                    rejectDrag(): void;

                }

                const DropTargetDropEvent: JavaClassStatics<DropTargetDropEvent, DropTargetDropEvent$$constructor>;
                interface DropTargetDropEvent$$constructor extends SuppressProperties {

                    new (arg0: DropTargetContext, arg1: java.awt.Point, arg2: int, arg3: int): DropTargetDropEvent;
                    new (arg0: DropTargetContext, arg1: java.awt.Point, arg2: int, arg3: int, arg4: boolean): DropTargetDropEvent;

                }
                interface DropTargetDropEvent extends DropTargetEvent {

                    getLocation(): java.awt.Point;
                    getCurrentDataFlavors(): JavaArray<java.awt.datatransfer.DataFlavor>;
                    getCurrentDataFlavorsAsList(): JavaList<java.awt.datatransfer.DataFlavor>;
                    isDataFlavorSupported(arg0: java.awt.datatransfer.DataFlavor): boolean;
                    getSourceActions(): number;
                    getDropAction(): number;
                    getTransferable(): java.awt.datatransfer.Transferable;
                    acceptDrop(arg0: int): void;
                    rejectDrop(): void;
                    dropComplete(arg0: boolean): void;
                    isLocalTransfer(): boolean;

                }

                const DragSourceEvent: JavaClassStatics<DragSourceEvent, DragSourceEvent$$constructor>;
                interface DragSourceEvent$$constructor extends SuppressProperties {

                    new (arg0: DragSourceContext): DragSourceEvent;
                    new (arg0: DragSourceContext, arg1: int, arg2: int): DragSourceEvent;

                }
                interface DragSourceEvent extends java.util.EventObject {

                    getDragSourceContext(): DragSourceContext;
                    getLocation(): java.awt.Point;
                    getX(): number;
                    getY(): number;

                }

                const DragSourceDropEvent: JavaClassStatics<DragSourceDropEvent, DragSourceDropEvent$$constructor>;
                interface DragSourceDropEvent$$constructor extends SuppressProperties {

                    new (arg0: DragSourceContext, arg1: int, arg2: boolean): DragSourceDropEvent;
                    new (arg0: DragSourceContext, arg1: int, arg2: boolean, arg3: int, arg4: int): DragSourceDropEvent;
                    new (arg0: DragSourceContext): DragSourceDropEvent;

                }
                interface DragSourceDropEvent extends DragSourceEvent {

                    getDropSuccess(): boolean;
                    getDropAction(): number;

                }

                const DragSourceDragEvent: JavaClassStatics<DragSourceDragEvent, DragSourceDragEvent$$constructor>;
                interface DragSourceDragEvent$$constructor extends SuppressProperties {

                    new (arg0: DragSourceContext, arg1: int, arg2: int, arg3: int): DragSourceDragEvent;
                    new (arg0: DragSourceContext, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): DragSourceDragEvent;

                }
                interface DragSourceDragEvent extends DragSourceEvent {

                    getTargetActions(): number;
                    getGestureModifiers(): number;
                    getGestureModifiersEx(): number;
                    getUserAction(): number;
                    getDropAction(): number;

                }

                const DragSourceContext: JavaClassStatics<DragSourceContext, DragSourceContext$$constructor>;
                interface DragSourceContext$$constructor extends SuppressProperties {

                    new (arg0: DragGestureEvent, arg1: java.awt.Cursor, arg2: java.awt.Image, arg3: java.awt.Point, arg4: java.awt.datatransfer.Transferable, arg5: DragSourceListener): DragSourceContext;

                }
                interface DragSourceContext extends DragSourceListener, DragSourceMotionListener, java.io.Serializable {

                    getDragSource(): DragSource;
                    getComponent(): java.awt.Component;
                    getTrigger(): DragGestureEvent;
                    getSourceActions(): number;
                    setCursor(arg0: java.awt.Cursor): void;
                    getCursor(): java.awt.Cursor;
                    addDragSourceListener(arg0: DragSourceListener): void;
                    removeDragSourceListener(arg0: DragSourceListener): void;
                    transferablesFlavorsChanged(): void;
                    dragEnter(arg0: DragSourceDragEvent): void;
                    dragOver(arg0: DragSourceDragEvent): void;
                    dragExit(arg0: DragSourceEvent): void;
                    dropActionChanged(arg0: DragSourceDragEvent): void;
                    dragDropEnd(arg0: DragSourceDropEvent): void;
                    dragMouseMoved(arg0: DragSourceDragEvent): void;
                    getTransferable(): java.awt.datatransfer.Transferable;

                }

                export {
                    DragGestureListener,
                    DragGestureRecognizer,
                    DragSource,
                    DropTarget,
                    DragSourceMotionListener,
                    DropTargetContext,
                    DropTargetEvent,
                    DragSourceListener,
                    DropTargetListener,
                    DragGestureEvent,
                    DropTargetDragEvent,
                    DropTargetDropEvent,
                    DragSourceEvent,
                    DragSourceDropEvent,
                    DragSourceDragEvent,
                    DragSourceContext
                }

            }

        }

        namespace time {

            const Instant: JavaClassStatics<Instant> & NoConstructor & {
                readonly EPOCH: Instant;
                readonly MIN: Instant;
                readonly MAX: Instant;

                now(): Instant;
                now(arg0: Clock): Instant;
                ofEpochSecond(arg0: long): Instant;
                ofEpochSecond(arg0: long, arg1: long): Instant;
                ofEpochMilli(arg0: long): Instant;
                from(arg0: java.time.temporal.TemporalAccessor): Instant;
                parse(arg0: java.lang.CharSequence): Instant;

            }
            interface Instant extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<Instant>, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getEpochSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): Instant;
                with(arg0: java.time.temporal.TemporalField, arg1: long): Instant;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): Instant;
                plus(arg0: java.time.temporal.TemporalAmount): Instant;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): Instant;
                plusSeconds(arg0: long): Instant;
                plusMillis(arg0: long): Instant;
                plusNanos(arg0: long): Instant;
                minus(arg0: java.time.temporal.TemporalAmount): Instant;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): Instant;
                minusSeconds(arg0: long): Instant;
                minusMillis(arg0: long): Instant;
                minusNanos(arg0: long): Instant;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                atOffset(arg0: ZoneOffset): OffsetDateTime;
                atZone(arg0: ZoneId): ZonedDateTime;
                toEpochMilli(): number;
                compareTo(arg0: Instant): number;
                isAfter(arg0: Instant): boolean;
                isBefore(arg0: Instant): boolean;

            }

            const Clock: JavaClassStatics<Clock> & NoConstructor & {

                systemUTC(): Clock;
                systemDefaultZone(): Clock;
                system(arg0: ZoneId): Clock;
                tickMillis(arg0: ZoneId): Clock;
                tickSeconds(arg0: ZoneId): Clock;
                tickMinutes(arg0: ZoneId): Clock;
                tick(arg0: Clock, arg1: Duration): Clock;
                fixed(arg0: Instant, arg1: ZoneId): Clock;
                offset(arg0: Clock, arg1: Duration): Clock;

            }
            interface Clock extends InstantSource {

                getZone(): ZoneId;
                withZone(arg0: ZoneId): Clock;
                millis(): number;
                instant(): Instant;

            }

            const Duration: JavaClassStatics<Duration> & NoConstructor & {
                readonly ZERO: Duration;

                ofDays(arg0: long): Duration;
                ofHours(arg0: long): Duration;
                ofMinutes(arg0: long): Duration;
                ofSeconds(arg0: long): Duration;
                ofSeconds(arg0: long, arg1: long): Duration;
                ofMillis(arg0: long): Duration;
                ofNanos(arg0: long): Duration;
                of(arg0: long, arg1: java.time.temporal.TemporalUnit): Duration;
                from(arg0: java.time.temporal.TemporalAmount): Duration;
                parse(arg0: java.lang.CharSequence): Duration;
                between(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.Temporal): Duration;

            }
            interface Duration extends java.time.temporal.TemporalAmount, java.lang.Comparable<Duration>, java.io.Serializable {

                get(arg0: java.time.temporal.TemporalUnit): number;
                getUnits(): JavaList<java.time.temporal.TemporalUnit>;
                isZero(): boolean;
                isNegative(): boolean;
                getSeconds(): number;
                getNano(): number;
                withSeconds(arg0: long): Duration;
                withNanos(arg0: int): Duration;
                plus(arg0: Duration): Duration;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): Duration;
                plusDays(arg0: long): Duration;
                plusHours(arg0: long): Duration;
                plusMinutes(arg0: long): Duration;
                plusSeconds(arg0: long): Duration;
                plusMillis(arg0: long): Duration;
                plusNanos(arg0: long): Duration;
                minus(arg0: Duration): Duration;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): Duration;
                minusDays(arg0: long): Duration;
                minusHours(arg0: long): Duration;
                minusMinutes(arg0: long): Duration;
                minusSeconds(arg0: long): Duration;
                minusMillis(arg0: long): Duration;
                minusNanos(arg0: long): Duration;
                multipliedBy(arg0: long): Duration;
                dividedBy(arg0: long): Duration;
                dividedBy(arg0: Duration): number;
                negated(): Duration;
                abs(): Duration;
                addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                toDays(): number;
                toHours(): number;
                toMinutes(): number;
                toSeconds(): number;
                toMillis(): number;
                toNanos(): number;
                toDaysPart(): number;
                toHoursPart(): number;
                toMinutesPart(): number;
                toSecondsPart(): number;
                toMillisPart(): number;
                toNanosPart(): number;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): Duration;
                compareTo(arg0: Duration): number;

            }

            const ZonedDateTime: JavaClassStatics<ZonedDateTime> & NoConstructor & {

                now(): ZonedDateTime;
                now(arg0: ZoneId): ZonedDateTime;
                now(arg0: Clock): ZonedDateTime;
                of(arg0: LocalDate, arg1: LocalTime, arg2: ZoneId): ZonedDateTime;
                of(arg0: LocalDateTime, arg1: ZoneId): ZonedDateTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: ZoneId): ZonedDateTime;
                ofLocal(arg0: LocalDateTime, arg1: ZoneId, arg2: ZoneOffset): ZonedDateTime;
                ofInstant(arg0: Instant, arg1: ZoneId): ZonedDateTime;
                ofInstant(arg0: LocalDateTime, arg1: ZoneOffset, arg2: ZoneId): ZonedDateTime;
                ofStrict(arg0: LocalDateTime, arg1: ZoneOffset, arg2: ZoneId): ZonedDateTime;
                from(arg0: java.time.temporal.TemporalAccessor): ZonedDateTime;
                parse(arg0: java.lang.CharSequence): ZonedDateTime;
                parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): ZonedDateTime;

            }
            interface ZonedDateTime extends java.time.temporal.Temporal, java.time.chrono.ChronoZonedDateTime<LocalDate>, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getOffset(): ZoneOffset;
                withEarlierOffsetAtOverlap(): ZonedDateTime;
                withLaterOffsetAtOverlap(): ZonedDateTime;
                getZone(): ZoneId;
                withZoneSameLocal(arg0: ZoneId): ZonedDateTime;
                withZoneSameInstant(arg0: ZoneId): ZonedDateTime;
                withFixedOffsetZone(): ZonedDateTime;
                toLocalDateTime(): LocalDateTime;
                toLocalDate(): LocalDate;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): ZonedDateTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): ZonedDateTime;
                withYear(arg0: int): ZonedDateTime;
                withMonth(arg0: int): ZonedDateTime;
                withDayOfMonth(arg0: int): ZonedDateTime;
                withDayOfYear(arg0: int): ZonedDateTime;
                withHour(arg0: int): ZonedDateTime;
                withMinute(arg0: int): ZonedDateTime;
                withSecond(arg0: int): ZonedDateTime;
                withNano(arg0: int): ZonedDateTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): ZonedDateTime;
                plus(arg0: java.time.temporal.TemporalAmount): ZonedDateTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ZonedDateTime;
                plusYears(arg0: long): ZonedDateTime;
                plusMonths(arg0: long): ZonedDateTime;
                plusWeeks(arg0: long): ZonedDateTime;
                plusDays(arg0: long): ZonedDateTime;
                plusHours(arg0: long): ZonedDateTime;
                plusMinutes(arg0: long): ZonedDateTime;
                plusSeconds(arg0: long): ZonedDateTime;
                plusNanos(arg0: long): ZonedDateTime;
                minus(arg0: java.time.temporal.TemporalAmount): ZonedDateTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ZonedDateTime;
                minusYears(arg0: long): ZonedDateTime;
                minusMonths(arg0: long): ZonedDateTime;
                minusWeeks(arg0: long): ZonedDateTime;
                minusDays(arg0: long): ZonedDateTime;
                minusHours(arg0: long): ZonedDateTime;
                minusMinutes(arg0: long): ZonedDateTime;
                minusSeconds(arg0: long): ZonedDateTime;
                minusNanos(arg0: long): ZonedDateTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                toOffsetDateTime(): OffsetDateTime;

            }

            const ZoneOffset: JavaClassStatics<ZoneOffset> & NoConstructor & {
                readonly UTC: ZoneOffset;
                readonly MIN: ZoneOffset;
                readonly MAX: ZoneOffset;

                of(arg0: string): ZoneOffset;
                ofHours(arg0: int): ZoneOffset;
                ofHoursMinutes(arg0: int, arg1: int): ZoneOffset;
                ofHoursMinutesSeconds(arg0: int, arg1: int, arg2: int): ZoneOffset;
                from(arg0: java.time.temporal.TemporalAccessor): ZoneOffset;
                ofTotalSeconds(arg0: int): ZoneOffset;

            }
            interface ZoneOffset extends ZoneId, java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster, java.lang.Comparable<ZoneOffset>, java.io.Serializable {

                getTotalSeconds(): number;
                getId(): string;
                getRules(): java.time.zone.ZoneRules;
                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                compareTo(arg0: ZoneOffset): number;

            }

            const OffsetDateTime: JavaClassStatics<OffsetDateTime> & NoConstructor & {
                readonly MIN: OffsetDateTime;
                readonly MAX: OffsetDateTime;

                timeLineOrder(): java.util.Comparator<OffsetDateTime>;
                now(): OffsetDateTime;
                now(arg0: ZoneId): OffsetDateTime;
                now(arg0: Clock): OffsetDateTime;
                of(arg0: LocalDate, arg1: LocalTime, arg2: ZoneOffset): OffsetDateTime;
                of(arg0: LocalDateTime, arg1: ZoneOffset): OffsetDateTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: ZoneOffset): OffsetDateTime;
                ofInstant(arg0: Instant, arg1: ZoneId): OffsetDateTime;
                from(arg0: java.time.temporal.TemporalAccessor): OffsetDateTime;
                parse(arg0: java.lang.CharSequence): OffsetDateTime;
                parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): OffsetDateTime;

            }
            interface OffsetDateTime extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<OffsetDateTime>, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getOffset(): ZoneOffset;
                withOffsetSameLocal(arg0: ZoneOffset): OffsetDateTime;
                withOffsetSameInstant(arg0: ZoneOffset): OffsetDateTime;
                toLocalDateTime(): LocalDateTime;
                toLocalDate(): LocalDate;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): OffsetDateTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): OffsetDateTime;
                withYear(arg0: int): OffsetDateTime;
                withMonth(arg0: int): OffsetDateTime;
                withDayOfMonth(arg0: int): OffsetDateTime;
                withDayOfYear(arg0: int): OffsetDateTime;
                withHour(arg0: int): OffsetDateTime;
                withMinute(arg0: int): OffsetDateTime;
                withSecond(arg0: int): OffsetDateTime;
                withNano(arg0: int): OffsetDateTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): OffsetDateTime;
                plus(arg0: java.time.temporal.TemporalAmount): OffsetDateTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetDateTime;
                plusYears(arg0: long): OffsetDateTime;
                plusMonths(arg0: long): OffsetDateTime;
                plusWeeks(arg0: long): OffsetDateTime;
                plusDays(arg0: long): OffsetDateTime;
                plusHours(arg0: long): OffsetDateTime;
                plusMinutes(arg0: long): OffsetDateTime;
                plusSeconds(arg0: long): OffsetDateTime;
                plusNanos(arg0: long): OffsetDateTime;
                minus(arg0: java.time.temporal.TemporalAmount): OffsetDateTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetDateTime;
                minusYears(arg0: long): OffsetDateTime;
                minusMonths(arg0: long): OffsetDateTime;
                minusWeeks(arg0: long): OffsetDateTime;
                minusDays(arg0: long): OffsetDateTime;
                minusHours(arg0: long): OffsetDateTime;
                minusMinutes(arg0: long): OffsetDateTime;
                minusSeconds(arg0: long): OffsetDateTime;
                minusNanos(arg0: long): OffsetDateTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atZoneSameInstant(arg0: ZoneId): ZonedDateTime;
                atZoneSimilarLocal(arg0: ZoneId): ZonedDateTime;
                toOffsetTime(): OffsetTime;
                toZonedDateTime(): ZonedDateTime;
                toInstant(): Instant;
                toEpochSecond(): number;
                compareTo(arg0: OffsetDateTime): number;
                isAfter(arg0: OffsetDateTime): boolean;
                isBefore(arg0: OffsetDateTime): boolean;
                isEqual(arg0: OffsetDateTime): boolean;

            }

            const ZoneId: JavaClassStatics<ZoneId> & NoConstructor & {
                readonly SHORT_IDS: JavaMap<string, string>;

                systemDefault(): ZoneId;
                getAvailableZoneIds(): JavaSet<string>;
                of(arg0: string, arg1: JavaMap<string, string>): ZoneId;
                of(arg0: string): ZoneId;
                ofOffset(arg0: string, arg1: ZoneOffset): ZoneId;
                from(arg0: java.time.temporal.TemporalAccessor): ZoneId;

            }
            interface ZoneId extends java.io.Serializable {

                getId(): string;
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                getRules(): java.time.zone.ZoneRules;
                normalized(): ZoneId;

            }

            const LocalDate: JavaClassStatics<LocalDate> & NoConstructor & {
                readonly MIN: LocalDate;
                readonly MAX: LocalDate;
                readonly EPOCH: LocalDate;

                now(): LocalDate;
                now(arg0: ZoneId): LocalDate;
                now(arg0: Clock): LocalDate;
                of(arg0: int, arg1: Month, arg2: int): LocalDate;
                of(arg0: int, arg1: int, arg2: int): LocalDate;
                ofYearDay(arg0: int, arg1: int): LocalDate;
                ofInstant(arg0: Instant, arg1: ZoneId): LocalDate;
                ofEpochDay(arg0: long): LocalDate;
                from(arg0: java.time.temporal.TemporalAccessor): LocalDate;
                parse(arg0: java.lang.CharSequence): LocalDate;
                parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): LocalDate;

            }
            interface LocalDate extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.time.chrono.ChronoLocalDate, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getChronology(): java.time.chrono.IsoChronology;
                getEra(): java.time.chrono.IsoEra;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                isLeapYear(): boolean;
                lengthOfMonth(): number;
                lengthOfYear(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): LocalDate;
                with(arg0: java.time.temporal.TemporalField, arg1: long): LocalDate;
                withYear(arg0: int): LocalDate;
                withMonth(arg0: int): LocalDate;
                withDayOfMonth(arg0: int): LocalDate;
                withDayOfYear(arg0: int): LocalDate;
                plus(arg0: java.time.temporal.TemporalAmount): LocalDate;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDate;
                plusYears(arg0: long): LocalDate;
                plusMonths(arg0: long): LocalDate;
                plusWeeks(arg0: long): LocalDate;
                plusDays(arg0: long): LocalDate;
                minus(arg0: java.time.temporal.TemporalAmount): LocalDate;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDate;
                minusYears(arg0: long): LocalDate;
                minusMonths(arg0: long): LocalDate;
                minusWeeks(arg0: long): LocalDate;
                minusDays(arg0: long): LocalDate;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                until(arg0: java.time.chrono.ChronoLocalDate): Period;
                datesUntil(arg0: LocalDate): java.util.stream.Stream<LocalDate>;
                datesUntil(arg0: LocalDate, arg1: Period): java.util.stream.Stream<LocalDate>;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atTime(arg0: LocalTime): LocalDateTime;
                atTime(arg0: int, arg1: int): LocalDateTime;
                atTime(arg0: int, arg1: int, arg2: int): LocalDateTime;
                atTime(arg0: int, arg1: int, arg2: int, arg3: int): LocalDateTime;
                atTime(arg0: OffsetTime): OffsetDateTime;
                atStartOfDay(): LocalDateTime;
                atStartOfDay(arg0: ZoneId): ZonedDateTime;
                toEpochDay(): number;
                toEpochSecond(arg0: LocalTime, arg1: ZoneOffset): number;
                compareTo(arg0: java.time.chrono.ChronoLocalDate): number;
                isAfter(arg0: java.time.chrono.ChronoLocalDate): boolean;
                isBefore(arg0: java.time.chrono.ChronoLocalDate): boolean;
                isEqual(arg0: java.time.chrono.ChronoLocalDate): boolean;

            }

            const LocalTime: JavaClassStatics<LocalTime> & NoConstructor & {
                readonly MIN: LocalTime;
                readonly MAX: LocalTime;
                readonly MIDNIGHT: LocalTime;
                readonly NOON: LocalTime;

                now(): LocalTime;
                now(arg0: ZoneId): LocalTime;
                now(arg0: Clock): LocalTime;
                of(arg0: int, arg1: int): LocalTime;
                of(arg0: int, arg1: int, arg2: int): LocalTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int): LocalTime;
                ofInstant(arg0: Instant, arg1: ZoneId): LocalTime;
                ofSecondOfDay(arg0: long): LocalTime;
                ofNanoOfDay(arg0: long): LocalTime;
                from(arg0: java.time.temporal.TemporalAccessor): LocalTime;
                parse(arg0: java.lang.CharSequence): LocalTime;
                parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): LocalTime;

            }
            interface LocalTime extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<LocalTime>, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): LocalTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): LocalTime;
                withHour(arg0: int): LocalTime;
                withMinute(arg0: int): LocalTime;
                withSecond(arg0: int): LocalTime;
                withNano(arg0: int): LocalTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): LocalTime;
                plus(arg0: java.time.temporal.TemporalAmount): LocalTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalTime;
                plusHours(arg0: long): LocalTime;
                plusMinutes(arg0: long): LocalTime;
                plusSeconds(arg0: long): LocalTime;
                plusNanos(arg0: long): LocalTime;
                minus(arg0: java.time.temporal.TemporalAmount): LocalTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalTime;
                minusHours(arg0: long): LocalTime;
                minusMinutes(arg0: long): LocalTime;
                minusSeconds(arg0: long): LocalTime;
                minusNanos(arg0: long): LocalTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atDate(arg0: LocalDate): LocalDateTime;
                atOffset(arg0: ZoneOffset): OffsetTime;
                toSecondOfDay(): number;
                toNanoOfDay(): number;
                toEpochSecond(arg0: LocalDate, arg1: ZoneOffset): number;
                compareTo(arg0: LocalTime): number;
                isAfter(arg0: LocalTime): boolean;
                isBefore(arg0: LocalTime): boolean;

            }

            const DayOfWeek: JavaClassStatics<DayOfWeek> & NoConstructor & {
                readonly MONDAY: DayOfWeek;
                readonly TUESDAY: DayOfWeek;
                readonly WEDNESDAY: DayOfWeek;
                readonly THURSDAY: DayOfWeek;
                readonly FRIDAY: DayOfWeek;
                readonly SATURDAY: DayOfWeek;
                readonly SUNDAY: DayOfWeek;

                values(): JavaArray<DayOfWeek>;
                valueOf(arg0: string): DayOfWeek;
                of(arg0: int): DayOfWeek;
                from(arg0: java.time.temporal.TemporalAccessor): DayOfWeek;

            }
            interface DayOfWeek extends java.lang.Enum<DayOfWeek>, java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster {

                getValue(): number;
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                plus(arg0: long): DayOfWeek;
                minus(arg0: long): DayOfWeek;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

            }

            const Period: JavaClassStatics<Period> & NoConstructor & {
                readonly ZERO: Period;

                ofYears(arg0: int): Period;
                ofMonths(arg0: int): Period;
                ofWeeks(arg0: int): Period;
                ofDays(arg0: int): Period;
                of(arg0: int, arg1: int, arg2: int): Period;
                from(arg0: java.time.temporal.TemporalAmount): Period;
                parse(arg0: java.lang.CharSequence): Period;
                between(arg0: LocalDate, arg1: LocalDate): Period;

            }
            interface Period extends java.time.chrono.ChronoPeriod, java.io.Serializable {

                get(arg0: java.time.temporal.TemporalUnit): number;
                getUnits(): JavaList<java.time.temporal.TemporalUnit>;
                getChronology(): java.time.chrono.IsoChronology;
                isZero(): boolean;
                isNegative(): boolean;
                getYears(): number;
                getMonths(): number;
                getDays(): number;
                withYears(arg0: int): Period;
                withMonths(arg0: int): Period;
                withDays(arg0: int): Period;
                plus(arg0: java.time.temporal.TemporalAmount): Period;
                plusYears(arg0: long): Period;
                plusMonths(arg0: long): Period;
                plusDays(arg0: long): Period;
                minus(arg0: java.time.temporal.TemporalAmount): Period;
                minusYears(arg0: long): Period;
                minusMonths(arg0: long): Period;
                minusDays(arg0: long): Period;
                multipliedBy(arg0: int): Period;
                negated(): Period;
                normalized(): Period;
                toTotalMonths(): number;
                addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

            }

            const Month: JavaClassStatics<Month> & NoConstructor & {
                readonly JANUARY: Month;
                readonly FEBRUARY: Month;
                readonly MARCH: Month;
                readonly APRIL: Month;
                readonly MAY: Month;
                readonly JUNE: Month;
                readonly JULY: Month;
                readonly AUGUST: Month;
                readonly SEPTEMBER: Month;
                readonly OCTOBER: Month;
                readonly NOVEMBER: Month;
                readonly DECEMBER: Month;

                values(): JavaArray<Month>;
                valueOf(arg0: string): Month;
                of(arg0: int): Month;
                from(arg0: java.time.temporal.TemporalAccessor): Month;

            }
            interface Month extends java.lang.Enum<Month>, java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster {

                getValue(): number;
                getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                plus(arg0: long): Month;
                minus(arg0: long): Month;
                length(arg0: boolean): number;
                minLength(): number;
                maxLength(): number;
                firstDayOfYear(arg0: boolean): number;
                firstMonthOfQuarter(): Month;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

            }

            const OffsetTime: JavaClassStatics<OffsetTime> & NoConstructor & {
                readonly MIN: OffsetTime;
                readonly MAX: OffsetTime;

                now(): OffsetTime;
                now(arg0: ZoneId): OffsetTime;
                now(arg0: Clock): OffsetTime;
                of(arg0: LocalTime, arg1: ZoneOffset): OffsetTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: ZoneOffset): OffsetTime;
                ofInstant(arg0: Instant, arg1: ZoneId): OffsetTime;
                from(arg0: java.time.temporal.TemporalAccessor): OffsetTime;
                parse(arg0: java.lang.CharSequence): OffsetTime;
                parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): OffsetTime;

            }
            interface OffsetTime extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<OffsetTime>, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                getOffset(): ZoneOffset;
                withOffsetSameLocal(arg0: ZoneOffset): OffsetTime;
                withOffsetSameInstant(arg0: ZoneOffset): OffsetTime;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): OffsetTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): OffsetTime;
                withHour(arg0: int): OffsetTime;
                withMinute(arg0: int): OffsetTime;
                withSecond(arg0: int): OffsetTime;
                withNano(arg0: int): OffsetTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): OffsetTime;
                plus(arg0: java.time.temporal.TemporalAmount): OffsetTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetTime;
                plusHours(arg0: long): OffsetTime;
                plusMinutes(arg0: long): OffsetTime;
                plusSeconds(arg0: long): OffsetTime;
                plusNanos(arg0: long): OffsetTime;
                minus(arg0: java.time.temporal.TemporalAmount): OffsetTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): OffsetTime;
                minusHours(arg0: long): OffsetTime;
                minusMinutes(arg0: long): OffsetTime;
                minusSeconds(arg0: long): OffsetTime;
                minusNanos(arg0: long): OffsetTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atDate(arg0: LocalDate): OffsetDateTime;
                toEpochSecond(arg0: LocalDate): number;
                compareTo(arg0: OffsetTime): number;
                isAfter(arg0: OffsetTime): boolean;
                isBefore(arg0: OffsetTime): boolean;
                isEqual(arg0: OffsetTime): boolean;

            }

            const InstantSource: JavaInterfaceStatics<InstantSource> & {

                system(): InstantSource;
                tick(arg0: InstantSource, arg1: Duration): InstantSource;
                fixed(arg0: Instant): InstantSource;
                offset(arg0: InstantSource, arg1: Duration): InstantSource;

            }
            interface InstantSource extends JavaObject {

                instant(): Instant;
                millis(): number;
                withZone(arg0: ZoneId): Clock;

            }

            const LocalDateTime: JavaClassStatics<LocalDateTime> & NoConstructor & {
                readonly MIN: LocalDateTime;
                readonly MAX: LocalDateTime;

                now(): LocalDateTime;
                now(arg0: ZoneId): LocalDateTime;
                now(arg0: Clock): LocalDateTime;
                of(arg0: int, arg1: Month, arg2: int, arg3: int, arg4: int): LocalDateTime;
                of(arg0: int, arg1: Month, arg2: int, arg3: int, arg4: int, arg5: int): LocalDateTime;
                of(arg0: int, arg1: Month, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): LocalDateTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): LocalDateTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int): LocalDateTime;
                of(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int): LocalDateTime;
                of(arg0: LocalDate, arg1: LocalTime): LocalDateTime;
                ofInstant(arg0: Instant, arg1: ZoneId): LocalDateTime;
                ofEpochSecond(arg0: long, arg1: int, arg2: ZoneOffset): LocalDateTime;
                from(arg0: java.time.temporal.TemporalAccessor): LocalDateTime;
                parse(arg0: java.lang.CharSequence): LocalDateTime;
                parse(arg0: java.lang.CharSequence, arg1: java.time.format.DateTimeFormatter): LocalDateTime;

            }
            interface LocalDateTime extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.time.chrono.ChronoLocalDateTime<LocalDate>, java.io.Serializable {

                isSupported(arg0: java.time.temporal.TemporalField): boolean;
                isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                get(arg0: java.time.temporal.TemporalField): number;
                getLong(arg0: java.time.temporal.TemporalField): number;
                toLocalDate(): LocalDate;
                getYear(): number;
                getMonthValue(): number;
                getMonth(): Month;
                getDayOfMonth(): number;
                getDayOfYear(): number;
                getDayOfWeek(): DayOfWeek;
                toLocalTime(): LocalTime;
                getHour(): number;
                getMinute(): number;
                getSecond(): number;
                getNano(): number;
                with(arg0: java.time.temporal.TemporalAdjuster): LocalDateTime;
                with(arg0: java.time.temporal.TemporalField, arg1: long): LocalDateTime;
                withYear(arg0: int): LocalDateTime;
                withMonth(arg0: int): LocalDateTime;
                withDayOfMonth(arg0: int): LocalDateTime;
                withDayOfYear(arg0: int): LocalDateTime;
                withHour(arg0: int): LocalDateTime;
                withMinute(arg0: int): LocalDateTime;
                withSecond(arg0: int): LocalDateTime;
                withNano(arg0: int): LocalDateTime;
                truncatedTo(arg0: java.time.temporal.TemporalUnit): LocalDateTime;
                plus(arg0: java.time.temporal.TemporalAmount): LocalDateTime;
                plus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDateTime;
                plusYears(arg0: long): LocalDateTime;
                plusMonths(arg0: long): LocalDateTime;
                plusWeeks(arg0: long): LocalDateTime;
                plusDays(arg0: long): LocalDateTime;
                plusHours(arg0: long): LocalDateTime;
                plusMinutes(arg0: long): LocalDateTime;
                plusSeconds(arg0: long): LocalDateTime;
                plusNanos(arg0: long): LocalDateTime;
                minus(arg0: java.time.temporal.TemporalAmount): LocalDateTime;
                minus(arg0: long, arg1: java.time.temporal.TemporalUnit): LocalDateTime;
                minusYears(arg0: long): LocalDateTime;
                minusMonths(arg0: long): LocalDateTime;
                minusWeeks(arg0: long): LocalDateTime;
                minusDays(arg0: long): LocalDateTime;
                minusHours(arg0: long): LocalDateTime;
                minusMinutes(arg0: long): LocalDateTime;
                minusSeconds(arg0: long): LocalDateTime;
                minusNanos(arg0: long): LocalDateTime;
                query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                format(arg0: java.time.format.DateTimeFormatter): string;
                atOffset(arg0: ZoneOffset): OffsetDateTime;
                atZone(arg0: ZoneId): ZonedDateTime;
                compareTo(arg0: java.time.chrono.ChronoLocalDateTime<any>): number;
                isAfter(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean;
                isBefore(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean;
                isEqual(arg0: java.time.chrono.ChronoLocalDateTime<any>): boolean;

            }

            export {
                Instant,
                Clock,
                Duration,
                ZonedDateTime,
                ZoneOffset,
                OffsetDateTime,
                ZoneId,
                LocalDate,
                LocalTime,
                DayOfWeek,
                Period,
                Month,
                OffsetTime,
                InstantSource,
                LocalDateTime
            }

        }
        namespace time {

            namespace temporal {

                const TemporalUnit: JavaInterfaceStatics<TemporalUnit>;
                interface TemporalUnit extends JavaObject {

                    getDuration(): java.time.Duration;
                    isDurationEstimated(): boolean;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    isSupportedBy(arg0: Temporal): boolean;
                    addTo<R extends Temporal>(arg0: R, arg1: long): R;
                    between(arg0: Temporal, arg1: Temporal): number;

                }

                const TemporalAdjuster: JavaInterfaceStatics<TemporalAdjuster>;
                interface TemporalAdjuster extends JavaObject {

                    adjustInto(arg0: Temporal): Temporal;

                }

                const ValueRange: JavaClassStatics<ValueRange> & NoConstructor & {

                    of(arg0: long, arg1: long): ValueRange;
                    of(arg0: long, arg1: long, arg2: long): ValueRange;
                    of(arg0: long, arg1: long, arg2: long, arg3: long): ValueRange;

                }
                interface ValueRange extends java.io.Serializable {

                    isFixed(): boolean;
                    getMinimum(): number;
                    getLargestMinimum(): number;
                    getSmallestMaximum(): number;
                    getMaximum(): number;
                    isIntValue(): boolean;
                    isValidValue(arg0: long): boolean;
                    isValidIntValue(arg0: long): boolean;
                    checkValidValue(arg0: long, arg1: TemporalField): number;
                    checkValidIntValue(arg0: long, arg1: TemporalField): number;

                }

                const Temporal: JavaInterfaceStatics<Temporal>;
                interface Temporal extends TemporalAccessor {

                    isSupported(arg0: TemporalUnit): boolean;
                    isSupported(arg0: TemporalField): boolean;
                    with(arg0: TemporalAdjuster): Temporal;
                    with(arg0: TemporalField, arg1: long): Temporal;
                    plus(arg0: TemporalAmount): Temporal;
                    plus(arg0: long, arg1: TemporalUnit): Temporal;
                    minus(arg0: TemporalAmount): Temporal;
                    minus(arg0: long, arg1: TemporalUnit): Temporal;
                    until(arg0: Temporal, arg1: TemporalUnit): number;

                }

                const TemporalAccessor: JavaInterfaceStatics<TemporalAccessor>;
                interface TemporalAccessor extends JavaObject {

                    isSupported(arg0: TemporalField): boolean;
                    range(arg0: TemporalField): ValueRange;
                    get(arg0: TemporalField): number;
                    getLong(arg0: TemporalField): number;
                    query<R>(arg0: TemporalQuery<R>): R;

                }

                const TemporalField: JavaInterfaceStatics<TemporalField>;
                interface TemporalField extends JavaObject {

                    getDisplayName(arg0: java.util.Locale): string;
                    getBaseUnit(): TemporalUnit;
                    getRangeUnit(): TemporalUnit;
                    range(): ValueRange;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    isSupportedBy(arg0: TemporalAccessor): boolean;
                    rangeRefinedBy(arg0: TemporalAccessor): ValueRange;
                    getFrom(arg0: TemporalAccessor): number;
                    adjustInto<R extends Temporal>(arg0: R, arg1: long): R;
                    resolve(arg0: JavaMap<TemporalField, long>, arg1: TemporalAccessor, arg2: java.time.format.ResolverStyle): TemporalAccessor;

                }

                const TemporalAmount: JavaInterfaceStatics<TemporalAmount>;
                interface TemporalAmount extends JavaObject {

                    get(arg0: TemporalUnit): number;
                    getUnits(): JavaList<TemporalUnit>;
                    addTo(arg0: Temporal): Temporal;
                    subtractFrom(arg0: Temporal): Temporal;

                }

                const TemporalQuery: JavaInterfaceStatics<TemporalQuery<any>>;
                interface TemporalQuery<R> extends JavaObject {

                    queryFrom(arg0: TemporalAccessor): R;

                }

                const ChronoField: JavaClassStatics<ChronoField> & NoConstructor & {
                    readonly NANO_OF_SECOND: ChronoField;
                    readonly NANO_OF_DAY: ChronoField;
                    readonly MICRO_OF_SECOND: ChronoField;
                    readonly MICRO_OF_DAY: ChronoField;
                    readonly MILLI_OF_SECOND: ChronoField;
                    readonly MILLI_OF_DAY: ChronoField;
                    readonly SECOND_OF_MINUTE: ChronoField;
                    readonly SECOND_OF_DAY: ChronoField;
                    readonly MINUTE_OF_HOUR: ChronoField;
                    readonly MINUTE_OF_DAY: ChronoField;
                    readonly HOUR_OF_AMPM: ChronoField;
                    readonly CLOCK_HOUR_OF_AMPM: ChronoField;
                    readonly HOUR_OF_DAY: ChronoField;
                    readonly CLOCK_HOUR_OF_DAY: ChronoField;
                    readonly AMPM_OF_DAY: ChronoField;
                    readonly DAY_OF_WEEK: ChronoField;
                    readonly ALIGNED_DAY_OF_WEEK_IN_MONTH: ChronoField;
                    readonly ALIGNED_DAY_OF_WEEK_IN_YEAR: ChronoField;
                    readonly DAY_OF_MONTH: ChronoField;
                    readonly DAY_OF_YEAR: ChronoField;
                    readonly EPOCH_DAY: ChronoField;
                    readonly ALIGNED_WEEK_OF_MONTH: ChronoField;
                    readonly ALIGNED_WEEK_OF_YEAR: ChronoField;
                    readonly MONTH_OF_YEAR: ChronoField;
                    readonly PROLEPTIC_MONTH: ChronoField;
                    readonly YEAR_OF_ERA: ChronoField;
                    readonly YEAR: ChronoField;
                    readonly ERA: ChronoField;
                    readonly INSTANT_SECONDS: ChronoField;
                    readonly OFFSET_SECONDS: ChronoField;

                    values(): JavaArray<ChronoField>;
                    valueOf(arg0: string): ChronoField;

                }
                interface ChronoField extends java.lang.Enum<ChronoField>, TemporalField {

                    getDisplayName(arg0: java.util.Locale): string;
                    getBaseUnit(): TemporalUnit;
                    getRangeUnit(): TemporalUnit;
                    range(): ValueRange;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    checkValidValue(arg0: long): number;
                    checkValidIntValue(arg0: long): number;
                    isSupportedBy(arg0: TemporalAccessor): boolean;
                    rangeRefinedBy(arg0: TemporalAccessor): ValueRange;
                    getFrom(arg0: TemporalAccessor): number;
                    adjustInto<R extends Temporal>(arg0: R, arg1: long): R;

                }

                const ChronoUnit: JavaClassStatics<ChronoUnit> & NoConstructor & {
                    readonly NANOS: ChronoUnit;
                    readonly MICROS: ChronoUnit;
                    readonly MILLIS: ChronoUnit;
                    readonly SECONDS: ChronoUnit;
                    readonly MINUTES: ChronoUnit;
                    readonly HOURS: ChronoUnit;
                    readonly HALF_DAYS: ChronoUnit;
                    readonly DAYS: ChronoUnit;
                    readonly WEEKS: ChronoUnit;
                    readonly MONTHS: ChronoUnit;
                    readonly YEARS: ChronoUnit;
                    readonly DECADES: ChronoUnit;
                    readonly CENTURIES: ChronoUnit;
                    readonly MILLENNIA: ChronoUnit;
                    readonly ERAS: ChronoUnit;
                    readonly FOREVER: ChronoUnit;

                    values(): JavaArray<ChronoUnit>;
                    valueOf(arg0: string): ChronoUnit;

                }
                interface ChronoUnit extends java.lang.Enum<ChronoUnit>, TemporalUnit {

                    getDuration(): java.time.Duration;
                    isDurationEstimated(): boolean;
                    isDateBased(): boolean;
                    isTimeBased(): boolean;
                    isSupportedBy(arg0: Temporal): boolean;
                    addTo<R extends Temporal>(arg0: R, arg1: long): R;
                    between(arg0: Temporal, arg1: Temporal): number;

                }

                export {
                    TemporalUnit,
                    TemporalAdjuster,
                    ValueRange,
                    Temporal,
                    TemporalAccessor,
                    TemporalField,
                    TemporalAmount,
                    TemporalQuery,
                    ChronoField,
                    ChronoUnit
                }

            }

            namespace format {

                const DateTimeFormatter: JavaClassStatics<DateTimeFormatter> & NoConstructor & {
                    readonly ISO_LOCAL_DATE: DateTimeFormatter;
                    readonly ISO_OFFSET_DATE: DateTimeFormatter;
                    readonly ISO_DATE: DateTimeFormatter;
                    readonly ISO_LOCAL_TIME: DateTimeFormatter;
                    readonly ISO_OFFSET_TIME: DateTimeFormatter;
                    readonly ISO_TIME: DateTimeFormatter;
                    readonly ISO_LOCAL_DATE_TIME: DateTimeFormatter;
                    readonly ISO_OFFSET_DATE_TIME: DateTimeFormatter;
                    readonly ISO_ZONED_DATE_TIME: DateTimeFormatter;
                    readonly ISO_DATE_TIME: DateTimeFormatter;
                    readonly ISO_ORDINAL_DATE: DateTimeFormatter;
                    readonly ISO_WEEK_DATE: DateTimeFormatter;
                    readonly ISO_INSTANT: DateTimeFormatter;
                    readonly BASIC_ISO_DATE: DateTimeFormatter;
                    readonly RFC_1123_DATE_TIME: DateTimeFormatter;

                    ofPattern(arg0: string): DateTimeFormatter;
                    ofPattern(arg0: string, arg1: java.util.Locale): DateTimeFormatter;
                    ofLocalizedDate(arg0: FormatStyle): DateTimeFormatter;
                    ofLocalizedTime(arg0: FormatStyle): DateTimeFormatter;
                    ofLocalizedDateTime(arg0: FormatStyle): DateTimeFormatter;
                    ofLocalizedDateTime(arg0: FormatStyle, arg1: FormatStyle): DateTimeFormatter;
                    parsedExcessDays(): java.time.temporal.TemporalQuery<java.time.Period>;
                    parsedLeapSecond(): java.time.temporal.TemporalQuery<boolean>;

                }
                interface DateTimeFormatter extends JavaObject {

                    getLocale(): java.util.Locale;
                    withLocale(arg0: java.util.Locale): DateTimeFormatter;
                    localizedBy(arg0: java.util.Locale): DateTimeFormatter;
                    getDecimalStyle(): DecimalStyle;
                    withDecimalStyle(arg0: DecimalStyle): DateTimeFormatter;
                    getChronology(): java.time.chrono.Chronology;
                    withChronology(arg0: java.time.chrono.Chronology): DateTimeFormatter;
                    getZone(): java.time.ZoneId;
                    withZone(arg0: java.time.ZoneId): DateTimeFormatter;
                    getResolverStyle(): ResolverStyle;
                    withResolverStyle(arg0: ResolverStyle): DateTimeFormatter;
                    getResolverFields(): JavaSet<java.time.temporal.TemporalField>;
                    withResolverFields(...arg0: java.time.temporal.TemporalField[]): DateTimeFormatter;
                    withResolverFields(arg0: JavaSet<java.time.temporal.TemporalField>): DateTimeFormatter;
                    format(arg0: java.time.temporal.TemporalAccessor): string;
                    formatTo(arg0: java.time.temporal.TemporalAccessor, arg1: java.lang.Appendable): void;
                    parse(arg0: java.lang.CharSequence): java.time.temporal.TemporalAccessor;
                    parse(arg0: java.lang.CharSequence, arg1: java.text.ParsePosition): java.time.temporal.TemporalAccessor;
                    parse<T>(arg0: java.lang.CharSequence, arg1: java.time.temporal.TemporalQuery<T>): T;
                    parseBest(arg0: java.lang.CharSequence, ...arg1: java.time.temporal.TemporalQuery<any>[]): java.time.temporal.TemporalAccessor;
                    parseUnresolved(arg0: java.lang.CharSequence, arg1: java.text.ParsePosition): java.time.temporal.TemporalAccessor;
                    toFormat(): java.text.Format;
                    toFormat(arg0: java.time.temporal.TemporalQuery<any>): java.text.Format;

                }

                const TextStyle: JavaClassStatics<TextStyle> & NoConstructor & {
                    readonly FULL: TextStyle;
                    readonly FULL_STANDALONE: TextStyle;
                    readonly SHORT: TextStyle;
                    readonly SHORT_STANDALONE: TextStyle;
                    readonly NARROW: TextStyle;
                    readonly NARROW_STANDALONE: TextStyle;

                    values(): JavaArray<TextStyle>;
                    valueOf(arg0: string): TextStyle;

                }
                interface TextStyle extends java.lang.Enum<TextStyle> {

                    isStandalone(): boolean;
                    asStandalone(): TextStyle;
                    asNormal(): TextStyle;

                }

                const ResolverStyle: JavaClassStatics<ResolverStyle> & NoConstructor & {
                    readonly STRICT: ResolverStyle;
                    readonly SMART: ResolverStyle;
                    readonly LENIENT: ResolverStyle;

                    values(): JavaArray<ResolverStyle>;
                    valueOf(arg0: string): ResolverStyle;

                }
                interface ResolverStyle extends java.lang.Enum<ResolverStyle> {}

                const DecimalStyle: JavaClassStatics<DecimalStyle> & NoConstructor & {
                    readonly STANDARD: DecimalStyle;

                    getAvailableLocales(): JavaSet<java.util.Locale>;
                    ofDefaultLocale(): DecimalStyle;
                    of(arg0: java.util.Locale): DecimalStyle;

                }
                interface DecimalStyle extends JavaObject {

                    getZeroDigit(): number;
                    withZeroDigit(arg0: char): DecimalStyle;
                    getPositiveSign(): number;
                    withPositiveSign(arg0: char): DecimalStyle;
                    getNegativeSign(): number;
                    withNegativeSign(arg0: char): DecimalStyle;
                    getDecimalSeparator(): number;
                    withDecimalSeparator(arg0: char): DecimalStyle;

                }

                const FormatStyle: JavaClassStatics<FormatStyle> & NoConstructor & {
                    readonly FULL: FormatStyle;
                    readonly LONG: FormatStyle;
                    readonly MEDIUM: FormatStyle;
                    readonly SHORT: FormatStyle;

                    values(): JavaArray<FormatStyle>;
                    valueOf(arg0: string): FormatStyle;

                }
                interface FormatStyle extends java.lang.Enum<FormatStyle> {}

                export {
                    DateTimeFormatter,
                    TextStyle,
                    ResolverStyle,
                    DecimalStyle,
                    FormatStyle
                }

            }

            namespace chrono {

                const ChronoZonedDateTime: JavaInterfaceStatics<ChronoZonedDateTime<any>> & {

                    timeLineOrder(): java.util.Comparator<ChronoZonedDateTime<any>>;
                    from(arg0: java.time.temporal.TemporalAccessor): ChronoZonedDateTime<any>;

                }
                interface ChronoZonedDateTime<D extends ChronoLocalDate> extends java.time.temporal.Temporal, java.lang.Comparable<ChronoZonedDateTime<any>> {

                    range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                    get(arg0: java.time.temporal.TemporalField): number;
                    getLong(arg0: java.time.temporal.TemporalField): number;
                    toLocalDate(): D;
                    toLocalTime(): java.time.LocalTime;
                    toLocalDateTime(): ChronoLocalDateTime<D>;
                    getChronology(): Chronology;
                    getOffset(): java.time.ZoneOffset;
                    getZone(): java.time.ZoneId;
                    withEarlierOffsetAtOverlap(): ChronoZonedDateTime<D>;
                    withLaterOffsetAtOverlap(): ChronoZonedDateTime<D>;
                    withZoneSameLocal(arg0: java.time.ZoneId): ChronoZonedDateTime<D>;
                    withZoneSameInstant(arg0: java.time.ZoneId): ChronoZonedDateTime<D>;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                    with(arg0: java.time.temporal.TemporalAdjuster): ChronoZonedDateTime<D>;
                    with(arg0: java.time.temporal.TemporalField, arg1: long): ChronoZonedDateTime<D>;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoZonedDateTime<D>;
                    plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoZonedDateTime<D>;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoZonedDateTime<D>;
                    minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoZonedDateTime<D>;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    format(arg0: java.time.format.DateTimeFormatter): string;
                    toInstant(): java.time.Instant;
                    toEpochSecond(): number;
                    compareTo(arg0: ChronoZonedDateTime<any>): number;
                    isBefore(arg0: ChronoZonedDateTime<any>): boolean;
                    isAfter(arg0: ChronoZonedDateTime<any>): boolean;
                    isEqual(arg0: ChronoZonedDateTime<any>): boolean;

                }

                const Chronology: JavaInterfaceStatics<Chronology> & {

                    from(arg0: java.time.temporal.TemporalAccessor): Chronology;
                    ofLocale(arg0: java.util.Locale): Chronology;
                    of(arg0: string): Chronology;
                    getAvailableChronologies(): JavaSet<Chronology>;

                }
                interface Chronology extends java.lang.Comparable<Chronology> {

                    getId(): string;
                    getCalendarType(): string;
                    date(arg0: Era, arg1: int, arg2: int, arg3: int): ChronoLocalDate;
                    date(arg0: int, arg1: int, arg2: int): ChronoLocalDate;
                    dateYearDay(arg0: Era, arg1: int, arg2: int): ChronoLocalDate;
                    dateYearDay(arg0: int, arg1: int): ChronoLocalDate;
                    dateEpochDay(arg0: long): ChronoLocalDate;
                    dateNow(): ChronoLocalDate;
                    dateNow(arg0: java.time.ZoneId): ChronoLocalDate;
                    dateNow(arg0: java.time.Clock): ChronoLocalDate;
                    date(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDate;
                    localDateTime(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDateTime<any>;
                    zonedDateTime(arg0: java.time.temporal.TemporalAccessor): ChronoZonedDateTime<any>;
                    zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): ChronoZonedDateTime<any>;
                    isLeapYear(arg0: long): boolean;
                    prolepticYear(arg0: Era, arg1: int): number;
                    eraOf(arg0: int): Era;
                    eras(): JavaList<Era>;
                    range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange;
                    getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;
                    resolveDate(arg0: JavaMap<java.time.temporal.TemporalField, long>, arg1: java.time.format.ResolverStyle): ChronoLocalDate;
                    period(arg0: int, arg1: int, arg2: int): ChronoPeriod;
                    epochSecond(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: java.time.ZoneOffset): number;
                    epochSecond(arg0: Era, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: java.time.ZoneOffset): number;
                    compareTo(arg0: Chronology): number;

                }

                const ChronoLocalDate: JavaInterfaceStatics<ChronoLocalDate> & {

                    timeLineOrder(): java.util.Comparator<ChronoLocalDate>;
                    from(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDate;

                }
                interface ChronoLocalDate extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<ChronoLocalDate> {

                    getChronology(): Chronology;
                    getEra(): Era;
                    isLeapYear(): boolean;
                    lengthOfMonth(): number;
                    lengthOfYear(): number;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                    with(arg0: java.time.temporal.TemporalAdjuster): ChronoLocalDate;
                    with(arg0: java.time.temporal.TemporalField, arg1: long): ChronoLocalDate;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDate;
                    plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDate;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDate;
                    minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDate;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    until(arg0: java.time.temporal.Temporal, arg1: java.time.temporal.TemporalUnit): number;
                    until(arg0: ChronoLocalDate): ChronoPeriod;
                    format(arg0: java.time.format.DateTimeFormatter): string;
                    atTime(arg0: java.time.LocalTime): ChronoLocalDateTime<any>;
                    toEpochDay(): number;
                    compareTo(arg0: ChronoLocalDate): number;
                    isAfter(arg0: ChronoLocalDate): boolean;
                    isBefore(arg0: ChronoLocalDate): boolean;
                    isEqual(arg0: ChronoLocalDate): boolean;

                }

                const ChronoLocalDateTime: JavaInterfaceStatics<ChronoLocalDateTime<any>> & {

                    timeLineOrder(): java.util.Comparator<ChronoLocalDateTime<any>>;
                    from(arg0: java.time.temporal.TemporalAccessor): ChronoLocalDateTime<any>;

                }
                interface ChronoLocalDateTime<D extends ChronoLocalDate> extends java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable<ChronoLocalDateTime<any>> {

                    getChronology(): Chronology;
                    toLocalDate(): D;
                    toLocalTime(): java.time.LocalTime;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    isSupported(arg0: java.time.temporal.TemporalUnit): boolean;
                    with(arg0: java.time.temporal.TemporalAdjuster): ChronoLocalDateTime<D>;
                    with(arg0: java.time.temporal.TemporalField, arg1: long): ChronoLocalDateTime<D>;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDateTime<D>;
                    plus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDateTime<D>;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoLocalDateTime<D>;
                    minus(arg0: long, arg1: java.time.temporal.TemporalUnit): ChronoLocalDateTime<D>;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    format(arg0: java.time.format.DateTimeFormatter): string;
                    atZone(arg0: java.time.ZoneId): ChronoZonedDateTime<D>;
                    toInstant(arg0: java.time.ZoneOffset): java.time.Instant;
                    toEpochSecond(arg0: java.time.ZoneOffset): number;
                    compareTo(arg0: ChronoLocalDateTime<any>): number;
                    isAfter(arg0: ChronoLocalDateTime<any>): boolean;
                    isBefore(arg0: ChronoLocalDateTime<any>): boolean;
                    isEqual(arg0: ChronoLocalDateTime<any>): boolean;

                }

                const ChronoPeriod: JavaInterfaceStatics<ChronoPeriod> & {

                    between(arg0: ChronoLocalDate, arg1: ChronoLocalDate): ChronoPeriod;

                }
                interface ChronoPeriod extends java.time.temporal.TemporalAmount {

                    get(arg0: java.time.temporal.TemporalUnit): number;
                    getUnits(): JavaList<java.time.temporal.TemporalUnit>;
                    getChronology(): Chronology;
                    isZero(): boolean;
                    isNegative(): boolean;
                    plus(arg0: java.time.temporal.TemporalAmount): ChronoPeriod;
                    minus(arg0: java.time.temporal.TemporalAmount): ChronoPeriod;
                    multipliedBy(arg0: int): ChronoPeriod;
                    negated(): ChronoPeriod;
                    normalized(): ChronoPeriod;
                    addTo(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    subtractFrom(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;

                }

                const Era: JavaInterfaceStatics<Era>;
                interface Era extends java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster {

                    getValue(): number;
                    isSupported(arg0: java.time.temporal.TemporalField): boolean;
                    range(arg0: java.time.temporal.TemporalField): java.time.temporal.ValueRange;
                    get(arg0: java.time.temporal.TemporalField): number;
                    getLong(arg0: java.time.temporal.TemporalField): number;
                    query<R>(arg0: java.time.temporal.TemporalQuery<R>): R;
                    adjustInto(arg0: java.time.temporal.Temporal): java.time.temporal.Temporal;
                    getDisplayName(arg0: java.time.format.TextStyle, arg1: java.util.Locale): string;

                }

                const IsoEra: JavaClassStatics<IsoEra> & NoConstructor & {
                    readonly BCE: IsoEra;
                    readonly CE: IsoEra;

                    values(): JavaArray<IsoEra>;
                    valueOf(arg0: string): IsoEra;
                    of(arg0: int): IsoEra;

                }
                interface IsoEra extends java.lang.Enum<IsoEra>, Era {

                    getValue(): number;

                }

                const IsoChronology: JavaClassStatics<IsoChronology> & NoConstructor & {
                    readonly INSTANCE: IsoChronology;
                }
                interface IsoChronology extends AbstractChronology, java.io.Serializable {

                    getId(): string;
                    getCalendarType(): string;
                    date(arg0: Era, arg1: int, arg2: int, arg3: int): java.time.LocalDate;
                    date(arg0: int, arg1: int, arg2: int): java.time.LocalDate;
                    dateYearDay(arg0: Era, arg1: int, arg2: int): java.time.LocalDate;
                    dateYearDay(arg0: int, arg1: int): java.time.LocalDate;
                    dateEpochDay(arg0: long): java.time.LocalDate;
                    date(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDate;
                    epochSecond(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: java.time.ZoneOffset): number;
                    epochSecond(arg0: Era, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: java.time.ZoneOffset): number;
                    localDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.LocalDateTime;
                    zonedDateTime(arg0: java.time.temporal.TemporalAccessor): java.time.ZonedDateTime;
                    zonedDateTime(arg0: java.time.Instant, arg1: java.time.ZoneId): java.time.ZonedDateTime;
                    dateNow(): java.time.LocalDate;
                    dateNow(arg0: java.time.ZoneId): java.time.LocalDate;
                    dateNow(arg0: java.time.Clock): java.time.LocalDate;
                    isLeapYear(arg0: long): boolean;
                    prolepticYear(arg0: Era, arg1: int): number;
                    eraOf(arg0: int): IsoEra;
                    eras(): JavaList<Era>;
                    resolveDate(arg0: JavaMap<java.time.temporal.TemporalField, long>, arg1: java.time.format.ResolverStyle): java.time.LocalDate;
                    range(arg0: java.time.temporal.ChronoField): java.time.temporal.ValueRange;
                    period(arg0: int, arg1: int, arg2: int): java.time.Period;

                }

                const AbstractChronology: JavaClassStatics<AbstractChronology> & NoConstructor;
                interface AbstractChronology extends Chronology {

                    resolveDate(arg0: JavaMap<java.time.temporal.TemporalField, long>, arg1: java.time.format.ResolverStyle): ChronoLocalDate;
                    compareTo(arg0: Chronology): number;

                }

                export {
                    ChronoZonedDateTime,
                    Chronology,
                    ChronoLocalDate,
                    ChronoLocalDateTime,
                    ChronoPeriod,
                    Era,
                    IsoEra,
                    IsoChronology,
                    AbstractChronology
                }

            }

            namespace zone {

                const ZoneRules: JavaClassStatics<ZoneRules> & NoConstructor & {

                    of(arg0: java.time.ZoneOffset, arg1: java.time.ZoneOffset, arg2: JavaList<ZoneOffsetTransition>, arg3: JavaList<ZoneOffsetTransition>, arg4: JavaList<ZoneOffsetTransitionRule>): ZoneRules;
                    of(arg0: java.time.ZoneOffset): ZoneRules;

                }
                interface ZoneRules extends java.io.Serializable {

                    isFixedOffset(): boolean;
                    getOffset(arg0: java.time.Instant): java.time.ZoneOffset;
                    getOffset(arg0: java.time.LocalDateTime): java.time.ZoneOffset;
                    getValidOffsets(arg0: java.time.LocalDateTime): JavaList<java.time.ZoneOffset>;
                    getTransition(arg0: java.time.LocalDateTime): ZoneOffsetTransition;
                    getStandardOffset(arg0: java.time.Instant): java.time.ZoneOffset;
                    getDaylightSavings(arg0: java.time.Instant): java.time.Duration;
                    isDaylightSavings(arg0: java.time.Instant): boolean;
                    isValidOffset(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset): boolean;
                    nextTransition(arg0: java.time.Instant): ZoneOffsetTransition;
                    previousTransition(arg0: java.time.Instant): ZoneOffsetTransition;
                    getTransitions(): JavaList<ZoneOffsetTransition>;
                    getTransitionRules(): JavaList<ZoneOffsetTransitionRule>;

                }

                const ZoneOffsetTransitionRule: JavaClassStatics<ZoneOffsetTransitionRule> & NoConstructor & {

                    of(arg0: java.time.Month, arg1: int, arg2: java.time.DayOfWeek, arg3: java.time.LocalTime, arg4: boolean, arg5: ZoneOffsetTransitionRule$TimeDefinition, arg6: java.time.ZoneOffset, arg7: java.time.ZoneOffset, arg8: java.time.ZoneOffset): ZoneOffsetTransitionRule;

                }
                interface ZoneOffsetTransitionRule extends java.io.Serializable {

                    getMonth(): java.time.Month;
                    getDayOfMonthIndicator(): number;
                    getDayOfWeek(): java.time.DayOfWeek;
                    getLocalTime(): java.time.LocalTime;
                    isMidnightEndOfDay(): boolean;
                    getTimeDefinition(): ZoneOffsetTransitionRule$TimeDefinition;
                    getStandardOffset(): java.time.ZoneOffset;
                    getOffsetBefore(): java.time.ZoneOffset;
                    getOffsetAfter(): java.time.ZoneOffset;
                    createTransition(arg0: int): ZoneOffsetTransition;

                }

                const ZoneOffsetTransition: JavaClassStatics<ZoneOffsetTransition> & NoConstructor & {

                    of(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneOffset): ZoneOffsetTransition;

                }
                interface ZoneOffsetTransition extends java.lang.Comparable<ZoneOffsetTransition>, java.io.Serializable {

                    getInstant(): java.time.Instant;
                    toEpochSecond(): number;
                    getDateTimeBefore(): java.time.LocalDateTime;
                    getDateTimeAfter(): java.time.LocalDateTime;
                    getOffsetBefore(): java.time.ZoneOffset;
                    getOffsetAfter(): java.time.ZoneOffset;
                    getDuration(): java.time.Duration;
                    isGap(): boolean;
                    isOverlap(): boolean;
                    isValidOffset(arg0: java.time.ZoneOffset): boolean;
                    compareTo(arg0: ZoneOffsetTransition): number;

                }

                const ZoneOffsetTransitionRule$TimeDefinition: JavaClassStatics<ZoneOffsetTransitionRule$TimeDefinition> & NoConstructor & {
                    readonly UTC: ZoneOffsetTransitionRule$TimeDefinition;
                    readonly WALL: ZoneOffsetTransitionRule$TimeDefinition;
                    readonly STANDARD: ZoneOffsetTransitionRule$TimeDefinition;

                    values(): JavaArray<ZoneOffsetTransitionRule$TimeDefinition>;
                    valueOf(arg0: string): ZoneOffsetTransitionRule$TimeDefinition;

                }
                interface ZoneOffsetTransitionRule$TimeDefinition extends java.lang.Enum<ZoneOffsetTransitionRule$TimeDefinition> {

                    createDateTime(arg0: java.time.LocalDateTime, arg1: java.time.ZoneOffset, arg2: java.time.ZoneOffset): java.time.LocalDateTime;

                }

                export {
                    ZoneRules,
                    ZoneOffsetTransitionRule,
                    ZoneOffsetTransition,
                    ZoneOffsetTransitionRule$TimeDefinition
                }

            }

        }

        namespace security {

            const PublicKey: JavaInterfaceStatics<PublicKey> & {
                /** @deprecated */
                readonly serialVersionUID: number;
            }
            interface PublicKey extends Key {}

            const Key: JavaInterfaceStatics<Key> & {
                /** @deprecated */
                readonly serialVersionUID: number;
            }
            interface Key extends java.io.Serializable {

                getAlgorithm(): string;
                getFormat(): string;
                getEncoded(): JavaArray<number>;

            }

            const Principal: JavaInterfaceStatics<Principal>;
            interface Principal extends JavaObject {

                getName(): string;
                implies(arg0: javax.security.auth.Subject): boolean;

            }

            const PrivilegedAction: JavaInterfaceStatics<PrivilegedAction<any>>;
            interface PrivilegedAction<T> extends JavaObject {

                run(): T;

            }

            const PrivilegedExceptionAction: JavaInterfaceStatics<PrivilegedExceptionAction<any>>;
            interface PrivilegedExceptionAction<T> extends JavaObject {

                run(): T;

            }

            /** @deprecated */
            const AccessControlContext: JavaClassStatics<AccessControlContext, AccessControlContext$$constructor>;
            interface AccessControlContext$$constructor extends SuppressProperties {

                new (arg0: ProtectionDomain[]): AccessControlContext;
                new (arg0: AccessControlContext, arg1: DomainCombiner): AccessControlContext;

            }
            interface AccessControlContext extends JavaObject {

                getDomainCombiner(): DomainCombiner;
                checkPermission(arg0: Permission): void;

            }

            const ProtectionDomain: JavaClassStatics<ProtectionDomain, ProtectionDomain$$constructor>;
            interface ProtectionDomain$$constructor extends SuppressProperties {

                new (arg0: CodeSource, arg1: PermissionCollection): ProtectionDomain;
                new (arg0: CodeSource, arg1: PermissionCollection, arg2: java.lang.ClassLoader, arg3: Principal[]): ProtectionDomain;

            }
            interface ProtectionDomain extends JavaObject {

                getCodeSource(): CodeSource;
                getClassLoader(): java.lang.ClassLoader;
                getPrincipals(): JavaArray<Principal>;
                getPermissions(): PermissionCollection;
                staticPermissionsOnly(): boolean;
                implies(arg0: Permission): boolean;

            }

            const Permission: JavaClassStatics<Permission, Permission$$constructor>;
            interface Permission$$constructor extends SuppressProperties {

                new (arg0: string): Permission;

            }
            interface Permission extends Guard, java.io.Serializable {

                checkGuard(arg0: any): void;
                implies(arg0: Permission): boolean;
                getName(): string;
                getActions(): string;
                newPermissionCollection(): PermissionCollection;

            }

            /** @deprecated */
            const DomainCombiner: JavaInterfaceStatics<DomainCombiner>;
            interface DomainCombiner extends JavaObject {

                combine(arg0: ProtectionDomain[], arg1: ProtectionDomain[]): JavaArray<ProtectionDomain>;

            }

            const Guard: JavaInterfaceStatics<Guard>;
            interface Guard extends JavaObject {

                checkGuard(arg0: any): void;

            }

            const CodeSource: JavaClassStatics<CodeSource, CodeSource$$constructor>;
            interface CodeSource$$constructor extends SuppressProperties {

                new (arg0: java.net.URL, arg1: java.security.cert.Certificate[]): CodeSource;
                new (arg0: java.net.URL, arg1: CodeSigner[]): CodeSource;

            }
            interface CodeSource extends java.io.Serializable {

                getLocation(): java.net.URL;
                getCertificates(): JavaArray<java.security.cert.Certificate>;
                getCodeSigners(): JavaArray<CodeSigner>;
                implies(arg0: CodeSource): boolean;

            }

            const PermissionCollection: JavaClassStatics<PermissionCollection, PermissionCollection$$constructor>;
            interface PermissionCollection$$constructor extends SuppressProperties {

                new (): PermissionCollection;

            }
            interface PermissionCollection extends java.io.Serializable {

                add(arg0: Permission): void;
                implies(arg0: Permission): boolean;
                elements(): java.util.Enumeration<Permission>;
                elementsAsStream(): java.util.stream.Stream<Permission>;
                setReadOnly(): void;
                isReadOnly(): boolean;

            }

            const CodeSigner: JavaClassStatics<CodeSigner, CodeSigner$$constructor>;
            interface CodeSigner$$constructor extends SuppressProperties {

                new (arg0: java.security.cert.CertPath, arg1: Timestamp): CodeSigner;

            }
            interface CodeSigner extends java.io.Serializable {

                getSignerCertPath(): java.security.cert.CertPath;
                getTimestamp(): Timestamp;

            }

            const Provider: JavaClassStatics<Provider> & NoConstructor;
            interface Provider extends java.util.Properties {

                configure(arg0: string): Provider;
                isConfigured(): boolean;
                getName(): string;
                /** @deprecated */
                getVersion(): number;
                getVersionStr(): string;
                getInfo(): string;
                clear(): void;
                load(arg0: java.io.InputStream): void;
                load(arg0: java.io.Reader): void;
                putAll(arg0: JavaMap<any, any>): void;
                entrySet(): JavaSet<java.util.Map$Entry<any, any>>;
                keySet(): JavaSet<any>;
                values(): JavaCollection<any>;
                put(arg0: any, arg1: any): any;
                putIfAbsent(arg0: any, arg1: any): any;
                remove(arg0: any): any;
                remove(arg0: any, arg1: any): boolean;
                replace(arg0: any, arg1: any, arg2: any): boolean;
                replace(arg0: any, arg1: any): any;
                replaceAll(arg0: java.util.function.BiFunction<any, any, any>): void;
                compute(arg0: any, arg1: java.util.function.BiFunction<any, any, any>): any;
                computeIfAbsent(arg0: any, arg1: java.util.function.Function<any, any>): any;
                computeIfPresent(arg0: any, arg1: java.util.function.BiFunction<any, any, any>): any;
                merge(arg0: any, arg1: any, arg2: java.util.function.BiFunction<any, any, any>): any;
                get(arg0: any): any;
                getOrDefault(arg0: any, arg1: any): any;
                forEach(arg0: java.util.function.BiConsumer<any, any>): void;
                keys(): java.util.Enumeration<any>;
                elements(): java.util.Enumeration<any>;
                getProperty(arg0: string): string;
                getProperty(arg0: string, arg1: string): string;
                getService(arg0: string, arg1: string): Provider$Service;
                getServices(): JavaSet<Provider$Service>;

            }

            const Provider$Service: JavaClassStatics<Provider$Service, Provider$Service$$constructor>;
            interface Provider$Service$$constructor extends SuppressProperties {

                new (arg0: Provider, arg1: string, arg2: string, arg3: string, arg4: JavaList<string>, arg5: JavaMap<string, string>): Provider$Service;

            }
            interface Provider$Service extends JavaObject {

                getType(): string;
                getAlgorithm(): string;
                getProvider(): Provider;
                getClassName(): string;
                getAttribute(arg0: string): string;
                newInstance(arg0: any): any;
                supportsParameter(arg0: any): boolean;

            }

            const Timestamp: JavaClassStatics<Timestamp, Timestamp$$constructor>;
            interface Timestamp$$constructor extends SuppressProperties {

                new (arg0: java.util.Date, arg1: java.security.cert.CertPath): Timestamp;

            }
            interface Timestamp extends java.io.Serializable {

                getTimestamp(): java.util.Date;
                getSignerCertPath(): java.security.cert.CertPath;

            }

            export {
                PublicKey,
                Key,
                Principal,
                PrivilegedAction,
                PrivilegedExceptionAction,
                AccessControlContext,
                ProtectionDomain,
                Permission,
                DomainCombiner,
                Guard,
                CodeSource,
                PermissionCollection,
                CodeSigner,
                Provider,
                Provider$Service,
                Timestamp
            }

        }
        namespace security {

            namespace cert {

                const Certificate: JavaClassStatics<Certificate> & NoConstructor;
                interface Certificate extends java.io.Serializable {

                    getType(): string;
                    getEncoded(): JavaArray<number>;
                    verify(arg0: java.security.PublicKey): void;
                    verify(arg0: java.security.PublicKey, arg1: string): void;
                    verify(arg0: java.security.PublicKey, arg1: java.security.Provider): void;
                    getPublicKey(): java.security.PublicKey;

                }

                const CertPath: JavaClassStatics<CertPath> & NoConstructor;
                interface CertPath extends java.io.Serializable {

                    getType(): string;
                    getEncodings(): java.util.Iterator<string>;
                    getEncoded(): JavaArray<number>;
                    getEncoded(arg0: string): JavaArray<number>;
                    getCertificates(): JavaList<any>;

                }

                export { Certificate, CertPath }

            }

        }

        namespace text {

            const AttributedCharacterIterator: JavaInterfaceStatics<AttributedCharacterIterator>;
            interface AttributedCharacterIterator extends CharacterIterator {

                getRunStart(): number;
                getRunStart(arg0: AttributedCharacterIterator$Attribute): number;
                getRunStart(arg0: JavaSet<any>): number;
                getRunLimit(): number;
                getRunLimit(arg0: AttributedCharacterIterator$Attribute): number;
                getRunLimit(arg0: JavaSet<any>): number;
                getAttributes(): JavaMap<AttributedCharacterIterator$Attribute, any>;
                getAttribute(arg0: AttributedCharacterIterator$Attribute): any;
                getAllAttributeKeys(): JavaSet<AttributedCharacterIterator$Attribute>;

            }

            const ParsePosition: JavaClassStatics<ParsePosition, ParsePosition$$constructor>;
            interface ParsePosition$$constructor extends SuppressProperties {

                new (arg0: int): ParsePosition;

            }
            interface ParsePosition extends JavaObject {

                getIndex(): number;
                setIndex(arg0: int): void;
                setErrorIndex(arg0: int): void;
                getErrorIndex(): number;

            }

            const CharacterIterator: JavaInterfaceStatics<CharacterIterator> & {
                readonly DONE: number;
            }
            interface CharacterIterator extends java.lang.Cloneable {

                first(): number;
                last(): number;
                current(): number;
                next(): number;
                previous(): number;
                setIndex(arg0: int): number;
                getBeginIndex(): number;
                getEndIndex(): number;
                getIndex(): number;
                clone(): any;

            }

            const Format: JavaClassStatics<Format> & NoConstructor;
            interface Format extends java.io.Serializable, java.lang.Cloneable {

                format(arg0: any): string;
                format(arg0: any, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                formatToCharacterIterator(arg0: any): AttributedCharacterIterator;
                parseObject(arg0: string, arg1: ParsePosition): any;
                parseObject(arg0: string): any;
                clone(): any;

            }

            const AttributedCharacterIterator$Attribute: JavaClassStatics<AttributedCharacterIterator$Attribute> & NoConstructor & {
                readonly LANGUAGE: AttributedCharacterIterator$Attribute;
                readonly READING: AttributedCharacterIterator$Attribute;
                readonly INPUT_METHOD_SEGMENT: AttributedCharacterIterator$Attribute;
            }
            interface AttributedCharacterIterator$Attribute extends java.io.Serializable {}

            const FieldPosition: JavaClassStatics<FieldPosition, FieldPosition$$constructor>;
            interface FieldPosition$$constructor extends SuppressProperties {

                new (arg0: int): FieldPosition;
                new (arg0: Format$Field): FieldPosition;
                new (arg0: Format$Field, arg1: int): FieldPosition;

            }
            interface FieldPosition extends JavaObject {

                getFieldAttribute(): Format$Field;
                getField(): number;
                getBeginIndex(): number;
                getEndIndex(): number;
                setBeginIndex(arg0: int): void;
                setEndIndex(arg0: int): void;

            }

            const Format$Field: JavaClassStatics<Format$Field> & NoConstructor;
            interface Format$Field extends AttributedCharacterIterator$Attribute {}

            const NumberFormat: JavaClassStatics<NumberFormat> & NoConstructor & {
                readonly INTEGER_FIELD: number;
                readonly FRACTION_FIELD: number;

                getInstance(): NumberFormat;
                getInstance(arg0: java.util.Locale): NumberFormat;
                getNumberInstance(): NumberFormat;
                getNumberInstance(arg0: java.util.Locale): NumberFormat;
                getIntegerInstance(): NumberFormat;
                getIntegerInstance(arg0: java.util.Locale): NumberFormat;
                getCurrencyInstance(): NumberFormat;
                getCurrencyInstance(arg0: java.util.Locale): NumberFormat;
                getPercentInstance(): NumberFormat;
                getPercentInstance(arg0: java.util.Locale): NumberFormat;
                getCompactNumberInstance(): NumberFormat;
                getCompactNumberInstance(arg0: java.util.Locale, arg1: NumberFormat$Style): NumberFormat;
                getAvailableLocales(): JavaArray<java.util.Locale>;

            }
            interface NumberFormat extends Format {

                format(arg0: any, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                format(arg0: any): string;
                parseObject(arg0: string, arg1: ParsePosition): any;
                parseObject(arg0: string): any;
                format(arg0: double): string;
                format(arg0: long): string;
                format(arg0: double, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                format(arg0: long, arg1: java.lang.StringBuffer, arg2: FieldPosition): java.lang.StringBuffer;
                parse(arg0: string, arg1: ParsePosition): java.lang.Number;
                parse(arg0: string): java.lang.Number;
                isParseIntegerOnly(): boolean;
                setParseIntegerOnly(arg0: boolean): void;
                clone(): any;
                isGroupingUsed(): boolean;
                setGroupingUsed(arg0: boolean): void;
                getMaximumIntegerDigits(): number;
                setMaximumIntegerDigits(arg0: int): void;
                getMinimumIntegerDigits(): number;
                setMinimumIntegerDigits(arg0: int): void;
                getMaximumFractionDigits(): number;
                setMaximumFractionDigits(arg0: int): void;
                getMinimumFractionDigits(): number;
                setMinimumFractionDigits(arg0: int): void;
                getCurrency(): java.util.Currency;
                setCurrency(arg0: java.util.Currency): void;
                getRoundingMode(): java.math.RoundingMode;
                setRoundingMode(arg0: java.math.RoundingMode): void;

            }

            const NumberFormat$Style: JavaClassStatics<NumberFormat$Style> & NoConstructor & {
                readonly SHORT: NumberFormat$Style;
                readonly LONG: NumberFormat$Style;

                values(): JavaArray<NumberFormat$Style>;
                valueOf(arg0: string): NumberFormat$Style;

            }
            interface NumberFormat$Style extends java.lang.Enum<NumberFormat$Style> {}

            export {
                AttributedCharacterIterator,
                ParsePosition,
                CharacterIterator,
                Format,
                AttributedCharacterIterator$Attribute,
                FieldPosition,
                Format$Field,
                NumberFormat,
                NumberFormat$Style
            }

        }

        namespace math {

            const BigInteger: JavaClassStatics<BigInteger, BigInteger$$constructor> & {
                readonly ZERO: BigInteger;
                readonly ONE: BigInteger;
                readonly TWO: BigInteger;
                readonly TEN: BigInteger;

                probablePrime(arg0: int, arg1: java.util.Random): BigInteger;
                valueOf(arg0: long): BigInteger;

            }
            interface BigInteger$$constructor extends SuppressProperties {

                new (arg0: byte[], arg1: int, arg2: int): BigInteger;
                new (arg0: byte[]): BigInteger;
                new (arg0: int, arg1: byte[], arg2: int, arg3: int): BigInteger;
                new (arg0: int, arg1: byte[]): BigInteger;
                new (arg0: string, arg1: int): BigInteger;
                new (arg0: string): BigInteger;
                new (arg0: int, arg1: java.util.Random): BigInteger;
                new (arg0: int, arg1: int, arg2: java.util.Random): BigInteger;

            }
            interface BigInteger extends java.lang.Number, java.lang.Comparable<BigInteger> {

                nextProbablePrime(): BigInteger;
                add(arg0: BigInteger): BigInteger;
                subtract(arg0: BigInteger): BigInteger;
                multiply(arg0: BigInteger): BigInteger;
                divide(arg0: BigInteger): BigInteger;
                divideAndRemainder(arg0: BigInteger): JavaArray<BigInteger>;
                remainder(arg0: BigInteger): BigInteger;
                pow(arg0: int): BigInteger;
                sqrt(): BigInteger;
                sqrtAndRemainder(): JavaArray<BigInteger>;
                gcd(arg0: BigInteger): BigInteger;
                abs(): BigInteger;
                negate(): BigInteger;
                signum(): number;
                mod(arg0: BigInteger): BigInteger;
                modPow(arg0: BigInteger, arg1: BigInteger): BigInteger;
                modInverse(arg0: BigInteger): BigInteger;
                shiftLeft(arg0: int): BigInteger;
                shiftRight(arg0: int): BigInteger;
                and(arg0: BigInteger): BigInteger;
                or(arg0: BigInteger): BigInteger;
                xor(arg0: BigInteger): BigInteger;
                not(): BigInteger;
                andNot(arg0: BigInteger): BigInteger;
                testBit(arg0: int): boolean;
                setBit(arg0: int): BigInteger;
                clearBit(arg0: int): BigInteger;
                flipBit(arg0: int): BigInteger;
                getLowestSetBit(): number;
                bitLength(): number;
                bitCount(): number;
                isProbablePrime(arg0: int): boolean;
                compareTo(arg0: BigInteger): number;
                min(arg0: BigInteger): BigInteger;
                max(arg0: BigInteger): BigInteger;
                toString(arg0: int): string;
                toString(): string;
                toByteArray(): JavaArray<number>;
                intValue(): number;
                longValue(): number;
                floatValue(): number;
                doubleValue(): number;
                longValueExact(): number;
                intValueExact(): number;
                shortValueExact(): number;
                byteValueExact(): number;

            }

            const BigDecimal: JavaClassStatics<BigDecimal, BigDecimal$$constructor> & {
                readonly ZERO: BigDecimal;
                readonly ONE: BigDecimal;
                readonly TEN: BigDecimal;
                /** @deprecated */
                readonly ROUND_UP: number;
                /** @deprecated */
                readonly ROUND_DOWN: number;
                /** @deprecated */
                readonly ROUND_CEILING: number;
                /** @deprecated */
                readonly ROUND_FLOOR: number;
                /** @deprecated */
                readonly ROUND_HALF_UP: number;
                /** @deprecated */
                readonly ROUND_HALF_DOWN: number;
                /** @deprecated */
                readonly ROUND_HALF_EVEN: number;
                /** @deprecated */
                readonly ROUND_UNNECESSARY: number;

                valueOf(arg0: long, arg1: int): BigDecimal;
                valueOf(arg0: long): BigDecimal;
                valueOf(arg0: double): BigDecimal;

            }
            interface BigDecimal$$constructor extends SuppressProperties {

                new (arg0: char[], arg1: int, arg2: int): BigDecimal;
                new (arg0: char[], arg1: int, arg2: int, arg3: MathContext): BigDecimal;
                new (arg0: char[]): BigDecimal;
                new (arg0: char[], arg1: MathContext): BigDecimal;
                new (arg0: string): BigDecimal;
                new (arg0: string, arg1: MathContext): BigDecimal;
                new (arg0: double): BigDecimal;
                new (arg0: double, arg1: MathContext): BigDecimal;
                new (arg0: BigInteger): BigDecimal;
                new (arg0: BigInteger, arg1: MathContext): BigDecimal;
                new (arg0: BigInteger, arg1: int): BigDecimal;
                new (arg0: BigInteger, arg1: int, arg2: MathContext): BigDecimal;
                new (arg0: int): BigDecimal;
                new (arg0: int, arg1: MathContext): BigDecimal;
                new (arg0: long): BigDecimal;
                new (arg0: long, arg1: MathContext): BigDecimal;

            }
            interface BigDecimal extends java.lang.Number, java.lang.Comparable<BigDecimal> {

                add(arg0: BigDecimal): BigDecimal;
                add(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                subtract(arg0: BigDecimal): BigDecimal;
                subtract(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                multiply(arg0: BigDecimal): BigDecimal;
                multiply(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                /** @deprecated */
                divide(arg0: BigDecimal, arg1: int, arg2: int): BigDecimal;
                divide(arg0: BigDecimal, arg1: int, arg2: RoundingMode): BigDecimal;
                /** @deprecated */
                divide(arg0: BigDecimal, arg1: int): BigDecimal;
                divide(arg0: BigDecimal, arg1: RoundingMode): BigDecimal;
                divide(arg0: BigDecimal): BigDecimal;
                divide(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                divideToIntegralValue(arg0: BigDecimal): BigDecimal;
                divideToIntegralValue(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                remainder(arg0: BigDecimal): BigDecimal;
                remainder(arg0: BigDecimal, arg1: MathContext): BigDecimal;
                divideAndRemainder(arg0: BigDecimal): JavaArray<BigDecimal>;
                divideAndRemainder(arg0: BigDecimal, arg1: MathContext): JavaArray<BigDecimal>;
                sqrt(arg0: MathContext): BigDecimal;
                pow(arg0: int): BigDecimal;
                pow(arg0: int, arg1: MathContext): BigDecimal;
                abs(): BigDecimal;
                abs(arg0: MathContext): BigDecimal;
                negate(): BigDecimal;
                negate(arg0: MathContext): BigDecimal;
                plus(): BigDecimal;
                plus(arg0: MathContext): BigDecimal;
                signum(): number;
                scale(): number;
                precision(): number;
                unscaledValue(): BigInteger;
                round(arg0: MathContext): BigDecimal;
                setScale(arg0: int, arg1: RoundingMode): BigDecimal;
                /** @deprecated */
                setScale(arg0: int, arg1: int): BigDecimal;
                setScale(arg0: int): BigDecimal;
                movePointLeft(arg0: int): BigDecimal;
                movePointRight(arg0: int): BigDecimal;
                scaleByPowerOfTen(arg0: int): BigDecimal;
                stripTrailingZeros(): BigDecimal;
                compareTo(arg0: BigDecimal): number;
                min(arg0: BigDecimal): BigDecimal;
                max(arg0: BigDecimal): BigDecimal;
                toEngineeringString(): string;
                toPlainString(): string;
                toBigInteger(): BigInteger;
                toBigIntegerExact(): BigInteger;
                longValue(): number;
                longValueExact(): number;
                intValue(): number;
                intValueExact(): number;
                shortValueExact(): number;
                byteValueExact(): number;
                floatValue(): number;
                doubleValue(): number;
                ulp(): BigDecimal;

            }

            const RoundingMode: JavaClassStatics<RoundingMode> & NoConstructor & {
                readonly UP: RoundingMode;
                readonly DOWN: RoundingMode;
                readonly CEILING: RoundingMode;
                readonly FLOOR: RoundingMode;
                readonly HALF_UP: RoundingMode;
                readonly HALF_DOWN: RoundingMode;
                readonly HALF_EVEN: RoundingMode;
                readonly UNNECESSARY: RoundingMode;

                values(): JavaArray<RoundingMode>;
                valueOf(arg0: string): RoundingMode;
                valueOf(arg0: int): RoundingMode;

            }
            interface RoundingMode extends java.lang.Enum<RoundingMode> {}

            const MathContext: JavaClassStatics<MathContext, MathContext$$constructor> & {
                readonly UNLIMITED: MathContext;
                readonly DECIMAL32: MathContext;
                readonly DECIMAL64: MathContext;
                readonly DECIMAL128: MathContext;
            }
            interface MathContext$$constructor extends SuppressProperties {

                new (arg0: int): MathContext;
                new (arg0: int, arg1: RoundingMode): MathContext;
                new (arg0: string): MathContext;

            }
            interface MathContext extends java.io.Serializable {

                getPrecision(): number;
                getRoundingMode(): RoundingMode;

            }

            export { BigInteger, BigDecimal, RoundingMode, MathContext }

        }

        namespace beans {

            const PropertyChangeListener: JavaInterfaceStatics<PropertyChangeListener>;
            interface PropertyChangeListener extends java.util.EventListener {

                propertyChange(arg0: PropertyChangeEvent): void;

            }

            const PropertyChangeEvent: JavaClassStatics<PropertyChangeEvent, PropertyChangeEvent$$constructor>;
            interface PropertyChangeEvent$$constructor extends SuppressProperties {

                new (arg0: any, arg1: string, arg2: any, arg3: any): PropertyChangeEvent;

            }
            interface PropertyChangeEvent extends java.util.EventObject {

                getPropertyName(): string;
                getNewValue(): any;
                getOldValue(): any;
                setPropagationId(arg0: any): void;
                getPropagationId(): any;

            }

            export { PropertyChangeListener, PropertyChangeEvent }

        }

        namespace net {

            const Socket: JavaClassStatics<Socket, Socket$$constructor> & {

                /** @deprecated */
                setSocketImplFactory(arg0: SocketImplFactory): void;

            }
            interface Socket$$constructor extends SuppressProperties {

                new (): Socket;
                new (arg0: Proxy): Socket;
                new (arg0: string, arg1: int): Socket;
                new (arg0: InetAddress, arg1: int): Socket;
                new (arg0: string, arg1: int, arg2: InetAddress, arg3: int): Socket;
                new (arg0: InetAddress, arg1: int, arg2: InetAddress, arg3: int): Socket;
                /** @deprecated */
                new (arg0: string, arg1: int, arg2: boolean): Socket;
                /** @deprecated */
                new (arg0: InetAddress, arg1: int, arg2: boolean): Socket;

            }
            interface Socket extends java.io.Closeable {

                connect(arg0: SocketAddress): void;
                connect(arg0: SocketAddress, arg1: int): void;
                bind(arg0: SocketAddress): void;
                getInetAddress(): InetAddress;
                getLocalAddress(): InetAddress;
                getPort(): number;
                getLocalPort(): number;
                getRemoteSocketAddress(): SocketAddress;
                getLocalSocketAddress(): SocketAddress;
                getChannel(): java.nio.channels.SocketChannel;
                getInputStream(): java.io.InputStream;
                getOutputStream(): java.io.OutputStream;
                setTcpNoDelay(arg0: boolean): void;
                getTcpNoDelay(): boolean;
                setSoLinger(arg0: boolean, arg1: int): void;
                getSoLinger(): number;
                sendUrgentData(arg0: int): void;
                setOOBInline(arg0: boolean): void;
                getOOBInline(): boolean;
                setSoTimeout(arg0: int): void;
                getSoTimeout(): number;
                setSendBufferSize(arg0: int): void;
                getSendBufferSize(): number;
                setReceiveBufferSize(arg0: int): void;
                getReceiveBufferSize(): number;
                setKeepAlive(arg0: boolean): void;
                getKeepAlive(): boolean;
                setTrafficClass(arg0: int): void;
                getTrafficClass(): number;
                setReuseAddress(arg0: boolean): void;
                getReuseAddress(): boolean;
                close(): void;
                shutdownInput(): void;
                shutdownOutput(): void;
                isConnected(): boolean;
                isBound(): boolean;
                isClosed(): boolean;
                isInputShutdown(): boolean;
                isOutputShutdown(): boolean;
                setPerformancePreferences(arg0: int, arg1: int, arg2: int): void;
                setOption<T>(arg0: SocketOption<T>, arg1: T): Socket;
                getOption<T>(arg0: SocketOption<T>): T;
                supportedOptions(): JavaSet<SocketOption<any>>;

            }

            const Proxy: JavaClassStatics<Proxy, Proxy$$constructor> & {
                readonly NO_PROXY: Proxy;
            }
            interface Proxy$$constructor extends SuppressProperties {

                new (arg0: Proxy$Type, arg1: SocketAddress): Proxy;

            }
            interface Proxy extends JavaObject {

                type(): Proxy$Type;
                address(): SocketAddress;

            }

            const SocketImplFactory: JavaInterfaceStatics<SocketImplFactory>;
            interface SocketImplFactory extends JavaObject {

                createSocketImpl(): SocketImpl;

            }

            const SocketOption: JavaInterfaceStatics<SocketOption<any>>;
            interface SocketOption<T> extends JavaObject {

                name(): string;
                type(): JavaClass<T>;

            }

            const SocketAddress: JavaClassStatics<SocketAddress, SocketAddress$$constructor>;
            interface SocketAddress$$constructor extends SuppressProperties {

                new (): SocketAddress;

            }
            interface SocketAddress extends java.io.Serializable {}

            const InetAddress: JavaClassStatics<InetAddress> & NoConstructor & {

                getByAddress(arg0: string, arg1: byte[]): InetAddress;
                getByName(arg0: string): InetAddress;
                getAllByName(arg0: string): JavaArray<InetAddress>;
                getLoopbackAddress(): InetAddress;
                getByAddress(arg0: byte[]): InetAddress;
                getLocalHost(): InetAddress;

            }
            interface InetAddress extends java.io.Serializable {

                isMulticastAddress(): boolean;
                isAnyLocalAddress(): boolean;
                isLoopbackAddress(): boolean;
                isLinkLocalAddress(): boolean;
                isSiteLocalAddress(): boolean;
                isMCGlobal(): boolean;
                isMCNodeLocal(): boolean;
                isMCLinkLocal(): boolean;
                isMCSiteLocal(): boolean;
                isMCOrgLocal(): boolean;
                isReachable(arg0: int): boolean;
                isReachable(arg0: NetworkInterface, arg1: int, arg2: int): boolean;
                getHostName(): string;
                getCanonicalHostName(): string;
                getAddress(): JavaArray<number>;
                getHostAddress(): string;

            }

            const NetworkInterface: JavaClassStatics<NetworkInterface> & NoConstructor & {

                getByName(arg0: string): NetworkInterface;
                getByIndex(arg0: int): NetworkInterface;
                getByInetAddress(arg0: InetAddress): NetworkInterface;
                getNetworkInterfaces(): java.util.Enumeration<NetworkInterface>;
                networkInterfaces(): java.util.stream.Stream<NetworkInterface>;

            }
            interface NetworkInterface extends JavaObject {

                getName(): string;
                getInetAddresses(): java.util.Enumeration<InetAddress>;
                inetAddresses(): java.util.stream.Stream<InetAddress>;
                getInterfaceAddresses(): JavaList<InterfaceAddress>;
                getSubInterfaces(): java.util.Enumeration<NetworkInterface>;
                subInterfaces(): java.util.stream.Stream<NetworkInterface>;
                getParent(): NetworkInterface;
                getIndex(): number;
                getDisplayName(): string;
                isUp(): boolean;
                isLoopback(): boolean;
                isPointToPoint(): boolean;
                supportsMulticast(): boolean;
                getHardwareAddress(): JavaArray<number>;
                getMTU(): number;
                isVirtual(): boolean;

            }

            const SocketImpl: JavaClassStatics<SocketImpl, SocketImpl$$constructor>;
            interface SocketImpl$$constructor extends SuppressProperties {

                new (): SocketImpl;

            }
            interface SocketImpl extends SocketOptions {}

            const Proxy$Type: JavaClassStatics<Proxy$Type> & NoConstructor & {
                readonly DIRECT: Proxy$Type;
                readonly HTTP: Proxy$Type;
                readonly SOCKS: Proxy$Type;

                values(): JavaArray<Proxy$Type>;
                valueOf(arg0: string): Proxy$Type;

            }
            interface Proxy$Type extends java.lang.Enum<Proxy$Type> {}

            const SocketOptions: JavaInterfaceStatics<SocketOptions> & {
                readonly TCP_NODELAY: number;
                readonly SO_BINDADDR: number;
                readonly SO_REUSEADDR: number;
                readonly SO_REUSEPORT: number;
                readonly SO_BROADCAST: number;
                readonly IP_MULTICAST_IF: number;
                readonly IP_MULTICAST_IF2: number;
                readonly IP_MULTICAST_LOOP: number;
                readonly IP_TOS: number;
                readonly SO_LINGER: number;
                readonly SO_TIMEOUT: number;
                readonly SO_SNDBUF: number;
                readonly SO_RCVBUF: number;
                readonly SO_KEEPALIVE: number;
                readonly SO_OOBINLINE: number;
            }
            interface SocketOptions extends JavaObject {

                setOption(arg0: int, arg1: any): void;
                getOption(arg0: int): any;

            }

            const InterfaceAddress: JavaClassStatics<InterfaceAddress> & NoConstructor;
            interface InterfaceAddress extends JavaObject {

                getAddress(): InetAddress;
                getBroadcast(): InetAddress;
                getNetworkPrefixLength(): number;

            }

            const ServerSocket: JavaClassStatics<ServerSocket, ServerSocket$$constructor> & {

                /** @deprecated */
                setSocketFactory(arg0: SocketImplFactory): void;

            }
            interface ServerSocket$$constructor extends SuppressProperties {

                new (): ServerSocket;
                new (arg0: int): ServerSocket;
                new (arg0: int, arg1: int): ServerSocket;
                new (arg0: int, arg1: int, arg2: InetAddress): ServerSocket;

            }
            interface ServerSocket extends java.io.Closeable {

                bind(arg0: SocketAddress): void;
                bind(arg0: SocketAddress, arg1: int): void;
                getInetAddress(): InetAddress;
                getLocalPort(): number;
                getLocalSocketAddress(): SocketAddress;
                accept(): Socket;
                close(): void;
                getChannel(): java.nio.channels.ServerSocketChannel;
                isBound(): boolean;
                isClosed(): boolean;
                setSoTimeout(arg0: int): void;
                getSoTimeout(): number;
                setReuseAddress(arg0: boolean): void;
                getReuseAddress(): boolean;
                setReceiveBufferSize(arg0: int): void;
                getReceiveBufferSize(): number;
                setPerformancePreferences(arg0: int, arg1: int, arg2: int): void;
                setOption<T>(arg0: SocketOption<T>, arg1: T): ServerSocket;
                getOption<T>(arg0: SocketOption<T>): T;
                supportedOptions(): JavaSet<SocketOption<any>>;

            }

            const DatagramSocket: JavaClassStatics<DatagramSocket, DatagramSocket$$constructor> & {

                /** @deprecated */
                setDatagramSocketImplFactory(arg0: DatagramSocketImplFactory): void;

            }
            interface DatagramSocket$$constructor extends SuppressProperties {

                new (): DatagramSocket;
                new (arg0: SocketAddress): DatagramSocket;
                new (arg0: int): DatagramSocket;
                new (arg0: int, arg1: InetAddress): DatagramSocket;

            }
            interface DatagramSocket extends java.io.Closeable {

                bind(arg0: SocketAddress): void;
                connect(arg0: InetAddress, arg1: int): void;
                connect(arg0: SocketAddress): void;
                disconnect(): void;
                isBound(): boolean;
                isConnected(): boolean;
                getInetAddress(): InetAddress;
                getPort(): number;
                getRemoteSocketAddress(): SocketAddress;
                getLocalSocketAddress(): SocketAddress;
                send(arg0: DatagramPacket): void;
                receive(arg0: DatagramPacket): void;
                getLocalAddress(): InetAddress;
                getLocalPort(): number;
                setSoTimeout(arg0: int): void;
                getSoTimeout(): number;
                setSendBufferSize(arg0: int): void;
                getSendBufferSize(): number;
                setReceiveBufferSize(arg0: int): void;
                getReceiveBufferSize(): number;
                setReuseAddress(arg0: boolean): void;
                getReuseAddress(): boolean;
                setBroadcast(arg0: boolean): void;
                getBroadcast(): boolean;
                setTrafficClass(arg0: int): void;
                getTrafficClass(): number;
                close(): void;
                isClosed(): boolean;
                getChannel(): java.nio.channels.DatagramChannel;
                setOption<T>(arg0: SocketOption<T>, arg1: T): DatagramSocket;
                getOption<T>(arg0: SocketOption<T>): T;
                supportedOptions(): JavaSet<SocketOption<any>>;
                joinGroup(arg0: SocketAddress, arg1: NetworkInterface): void;
                leaveGroup(arg0: SocketAddress, arg1: NetworkInterface): void;

            }

            const ProtocolFamily: JavaInterfaceStatics<ProtocolFamily>;
            interface ProtocolFamily extends JavaObject {

                name(): string;

            }

            const DatagramSocketImplFactory: JavaInterfaceStatics<DatagramSocketImplFactory>;
            interface DatagramSocketImplFactory extends JavaObject {

                createDatagramSocketImpl(): DatagramSocketImpl;

            }

            const DatagramPacket: JavaClassStatics<DatagramPacket, DatagramPacket$$constructor>;
            interface DatagramPacket$$constructor extends SuppressProperties {

                new (arg0: byte[], arg1: int, arg2: int): DatagramPacket;
                new (arg0: byte[], arg1: int): DatagramPacket;
                new (arg0: byte[], arg1: int, arg2: int, arg3: InetAddress, arg4: int): DatagramPacket;
                new (arg0: byte[], arg1: int, arg2: int, arg3: SocketAddress): DatagramPacket;
                new (arg0: byte[], arg1: int, arg2: InetAddress, arg3: int): DatagramPacket;
                new (arg0: byte[], arg1: int, arg2: SocketAddress): DatagramPacket;

            }
            interface DatagramPacket extends JavaObject {

                getAddress(): InetAddress;
                getPort(): number;
                getData(): JavaArray<number>;
                getOffset(): number;
                getLength(): number;
                setData(arg0: byte[], arg1: int, arg2: int): void;
                setAddress(arg0: InetAddress): void;
                setPort(arg0: int): void;
                setSocketAddress(arg0: SocketAddress): void;
                getSocketAddress(): SocketAddress;
                setData(arg0: byte[]): void;
                setLength(arg0: int): void;

            }

            const DatagramSocketImpl: JavaClassStatics<DatagramSocketImpl, DatagramSocketImpl$$constructor>;
            interface DatagramSocketImpl$$constructor extends SuppressProperties {

                new (): DatagramSocketImpl;

            }
            interface DatagramSocketImpl extends SocketOptions {}

            export {
                Socket,
                Proxy,
                SocketImplFactory,
                SocketOption,
                SocketAddress,
                InetAddress,
                NetworkInterface,
                SocketImpl,
                Proxy$Type,
                SocketOptions,
                InterfaceAddress,
                ServerSocket,
                DatagramSocket,
                ProtocolFamily,
                DatagramSocketImplFactory,
                DatagramPacket,
                DatagramSocketImpl
            }

        }

    }

    namespace javax {

        namespace sound.sampled {

            const Clip: JavaInterfaceStatics<Clip> & {
                readonly LOOP_CONTINUOUSLY: number;
            }
            interface Clip extends DataLine {

                open(arg0: AudioFormat, arg1: byte[], arg2: int, arg3: int): void;
                open(arg0: AudioInputStream): void;
                open(): void;
                getFrameLength(): number;
                getMicrosecondLength(): number;
                setFramePosition(arg0: int): void;
                setMicrosecondPosition(arg0: long): void;
                setLoopPoints(arg0: int, arg1: int): void;
                loop(arg0: int): void;

            }

            const DataLine: JavaInterfaceStatics<DataLine>;
            interface DataLine extends Line {

                drain(): void;
                flush(): void;
                start(): void;
                stop(): void;
                isRunning(): boolean;
                isActive(): boolean;
                getFormat(): AudioFormat;
                getBufferSize(): number;
                available(): number;
                getFramePosition(): number;
                getLongFramePosition(): number;
                getMicrosecondPosition(): number;
                getLevel(): number;

            }

            const AudioFormat: JavaClassStatics<AudioFormat, AudioFormat$$constructor>;
            interface AudioFormat$$constructor extends SuppressProperties {

                new (arg0: AudioFormat$Encoding, arg1: float, arg2: int, arg3: int, arg4: int, arg5: float, arg6: boolean): AudioFormat;
                new (arg0: AudioFormat$Encoding, arg1: float, arg2: int, arg3: int, arg4: int, arg5: float, arg6: boolean, arg7: JavaMap<string, any>): AudioFormat;
                new (arg0: float, arg1: int, arg2: int, arg3: boolean, arg4: boolean): AudioFormat;

            }
            interface AudioFormat extends JavaObject {

                getEncoding(): AudioFormat$Encoding;
                getSampleRate(): number;
                getSampleSizeInBits(): number;
                getChannels(): number;
                getFrameSize(): number;
                getFrameRate(): number;
                isBigEndian(): boolean;
                properties(): JavaMap<string, any>;
                getProperty(arg0: string): any;
                matches(arg0: AudioFormat): boolean;

            }

            const AudioInputStream: JavaClassStatics<AudioInputStream, AudioInputStream$$constructor>;
            interface AudioInputStream$$constructor extends SuppressProperties {

                new (arg0: java.io.InputStream, arg1: AudioFormat, arg2: long): AudioInputStream;
                new (arg0: TargetDataLine): AudioInputStream;

            }
            interface AudioInputStream extends java.io.InputStream {

                getFormat(): AudioFormat;
                getFrameLength(): number;
                read(): number;
                read(arg0: byte[]): number;
                read(arg0: byte[], arg1: int, arg2: int): number;
                skip(arg0: long): number;
                available(): number;
                close(): void;
                mark(arg0: int): void;
                reset(): void;
                markSupported(): boolean;

            }

            const Line: JavaInterfaceStatics<Line>;
            interface Line extends java.lang.AutoCloseable {

                getLineInfo(): Line$Info;
                open(): void;
                close(): void;
                isOpen(): boolean;
                getControls(): JavaArray<Control>;
                isControlSupported(arg0: Control$Type): boolean;
                getControl(arg0: Control$Type): Control;
                addLineListener(arg0: LineListener): void;
                removeLineListener(arg0: LineListener): void;

            }

            const AudioFormat$Encoding: JavaClassStatics<AudioFormat$Encoding, AudioFormat$Encoding$$constructor> & {
                readonly PCM_SIGNED: AudioFormat$Encoding;
                readonly PCM_UNSIGNED: AudioFormat$Encoding;
                readonly PCM_FLOAT: AudioFormat$Encoding;
                readonly ULAW: AudioFormat$Encoding;
                readonly ALAW: AudioFormat$Encoding;
            }
            interface AudioFormat$Encoding$$constructor extends SuppressProperties {

                new (arg0: string): AudioFormat$Encoding;

            }
            interface AudioFormat$Encoding extends JavaObject {}

            const Line$Info: JavaClassStatics<Line$Info, Line$Info$$constructor>;
            interface Line$Info$$constructor extends SuppressProperties {

                new (arg0: JavaClassArg<any>): Line$Info;

            }
            interface Line$Info extends JavaObject {

                getLineClass(): JavaClass<any>;
                matches(arg0: Line$Info): boolean;

            }

            const TargetDataLine: JavaInterfaceStatics<TargetDataLine>;
            interface TargetDataLine extends DataLine {

                open(arg0: AudioFormat, arg1: int): void;
                open(arg0: AudioFormat): void;
                open(): void;
                read(arg0: byte[], arg1: int, arg2: int): number;

            }

            const Control$Type: JavaClassStatics<Control$Type> & NoConstructor;
            interface Control$Type extends JavaObject {}

            const Control: JavaClassStatics<Control> & NoConstructor;
            interface Control extends JavaObject {

                getType(): Control$Type;

            }

            const LineListener: JavaInterfaceStatics<LineListener>;
            interface LineListener extends java.util.EventListener {

                update(arg0: LineEvent): void;

            }

            const LineEvent: JavaClassStatics<LineEvent, LineEvent$$constructor>;
            interface LineEvent$$constructor extends SuppressProperties {

                new (arg0: Line, arg1: LineEvent$Type, arg2: long): LineEvent;

            }
            interface LineEvent extends java.util.EventObject {

                getLine(): Line;
                getType(): LineEvent$Type;
                getFramePosition(): number;

            }

            const LineEvent$Type: JavaClassStatics<LineEvent$Type> & NoConstructor & {
                readonly OPEN: LineEvent$Type;
                readonly CLOSE: LineEvent$Type;
                readonly START: LineEvent$Type;
                readonly STOP: LineEvent$Type;
            }
            interface LineEvent$Type extends JavaObject {}

            export {
                Clip,
                DataLine,
                AudioFormat,
                AudioInputStream,
                Line,
                AudioFormat$Encoding,
                Line$Info,
                TargetDataLine,
                Control$Type,
                Control,
                LineListener,
                LineEvent,
                LineEvent$Type
            }

        }

        namespace accessibility {

            const Accessible: JavaInterfaceStatics<Accessible>;
            interface Accessible extends JavaObject {

                getAccessibleContext(): AccessibleContext;

            }

            const AccessibleContext: JavaClassStatics<AccessibleContext> & NoConstructor & {
                readonly ACCESSIBLE_NAME_PROPERTY: string;
                readonly ACCESSIBLE_DESCRIPTION_PROPERTY: string;
                readonly ACCESSIBLE_STATE_PROPERTY: string;
                readonly ACCESSIBLE_VALUE_PROPERTY: string;
                readonly ACCESSIBLE_SELECTION_PROPERTY: string;
                readonly ACCESSIBLE_CARET_PROPERTY: string;
                readonly ACCESSIBLE_VISIBLE_DATA_PROPERTY: string;
                readonly ACCESSIBLE_CHILD_PROPERTY: string;
                readonly ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY: string;
                readonly ACCESSIBLE_TABLE_CAPTION_CHANGED: string;
                readonly ACCESSIBLE_TABLE_SUMMARY_CHANGED: string;
                readonly ACCESSIBLE_TABLE_MODEL_CHANGED: string;
                readonly ACCESSIBLE_TABLE_ROW_HEADER_CHANGED: string;
                readonly ACCESSIBLE_TABLE_ROW_DESCRIPTION_CHANGED: string;
                readonly ACCESSIBLE_TABLE_COLUMN_HEADER_CHANGED: string;
                readonly ACCESSIBLE_TABLE_COLUMN_DESCRIPTION_CHANGED: string;
                readonly ACCESSIBLE_ACTION_PROPERTY: string;
                readonly ACCESSIBLE_HYPERTEXT_OFFSET: string;
                readonly ACCESSIBLE_TEXT_PROPERTY: string;
                readonly ACCESSIBLE_INVALIDATE_CHILDREN: string;
                readonly ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED: string;
                readonly ACCESSIBLE_COMPONENT_BOUNDS_CHANGED: string;
            }
            interface AccessibleContext extends JavaObject {

                getAccessibleName(): string;
                setAccessibleName(arg0: string): void;
                getAccessibleDescription(): string;
                setAccessibleDescription(arg0: string): void;
                getAccessibleRole(): AccessibleRole;
                getAccessibleStateSet(): AccessibleStateSet;
                getAccessibleParent(): Accessible;
                setAccessibleParent(arg0: Accessible): void;
                getAccessibleIndexInParent(): number;
                getAccessibleChildrenCount(): number;
                getAccessibleChild(arg0: int): Accessible;
                getLocale(): java.util.Locale;
                addPropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                removePropertyChangeListener(arg0: java.beans.PropertyChangeListener): void;
                getAccessibleAction(): AccessibleAction;
                getAccessibleComponent(): AccessibleComponent;
                getAccessibleSelection(): AccessibleSelection;
                getAccessibleText(): AccessibleText;
                getAccessibleEditableText(): AccessibleEditableText;
                getAccessibleValue(): AccessibleValue;
                getAccessibleIcon(): JavaArray<AccessibleIcon>;
                getAccessibleRelationSet(): AccessibleRelationSet;
                getAccessibleTable(): AccessibleTable;
                firePropertyChange(arg0: string, arg1: any, arg2: any): void;

            }

            const AccessibleStateSet: JavaClassStatics<AccessibleStateSet, AccessibleStateSet$$constructor>;
            interface AccessibleStateSet$$constructor extends SuppressProperties {

                new (): AccessibleStateSet;
                new (arg0: AccessibleState[]): AccessibleStateSet;

            }
            interface AccessibleStateSet extends JavaObject {

                add(arg0: AccessibleState): boolean;
                addAll(arg0: AccessibleState[]): void;
                remove(arg0: AccessibleState): boolean;
                clear(): void;
                contains(arg0: AccessibleState): boolean;
                toArray(): JavaArray<AccessibleState>;

            }

            const AccessibleTable: JavaInterfaceStatics<AccessibleTable>;
            interface AccessibleTable extends JavaObject {

                getAccessibleCaption(): Accessible;
                setAccessibleCaption(arg0: Accessible): void;
                getAccessibleSummary(): Accessible;
                setAccessibleSummary(arg0: Accessible): void;
                getAccessibleRowCount(): number;
                getAccessibleColumnCount(): number;
                getAccessibleAt(arg0: int, arg1: int): Accessible;
                getAccessibleRowExtentAt(arg0: int, arg1: int): number;
                getAccessibleColumnExtentAt(arg0: int, arg1: int): number;
                getAccessibleRowHeader(): AccessibleTable;
                setAccessibleRowHeader(arg0: AccessibleTable): void;
                getAccessibleColumnHeader(): AccessibleTable;
                setAccessibleColumnHeader(arg0: AccessibleTable): void;
                getAccessibleRowDescription(arg0: int): Accessible;
                setAccessibleRowDescription(arg0: int, arg1: Accessible): void;
                getAccessibleColumnDescription(arg0: int): Accessible;
                setAccessibleColumnDescription(arg0: int, arg1: Accessible): void;
                isAccessibleSelected(arg0: int, arg1: int): boolean;
                isAccessibleRowSelected(arg0: int): boolean;
                isAccessibleColumnSelected(arg0: int): boolean;
                getSelectedAccessibleRows(): JavaArray<number>;
                getSelectedAccessibleColumns(): JavaArray<number>;

            }

            const AccessibleComponent: JavaInterfaceStatics<AccessibleComponent>;
            interface AccessibleComponent extends JavaObject {

                getBackground(): java.awt.Color;
                setBackground(arg0: java.awt.Color): void;
                getForeground(): java.awt.Color;
                setForeground(arg0: java.awt.Color): void;
                getCursor(): java.awt.Cursor;
                setCursor(arg0: java.awt.Cursor): void;
                getFont(): java.awt.Font;
                setFont(arg0: java.awt.Font): void;
                getFontMetrics(arg0: java.awt.Font): java.awt.FontMetrics;
                isEnabled(): boolean;
                setEnabled(arg0: boolean): void;
                isVisible(): boolean;
                setVisible(arg0: boolean): void;
                isShowing(): boolean;
                contains(arg0: java.awt.Point): boolean;
                getLocationOnScreen(): java.awt.Point;
                getLocation(): java.awt.Point;
                setLocation(arg0: java.awt.Point): void;
                getBounds(): java.awt.Rectangle;
                setBounds(arg0: java.awt.Rectangle): void;
                getSize(): java.awt.Dimension;
                setSize(arg0: java.awt.Dimension): void;
                getAccessibleAt(arg0: java.awt.Point): Accessible;
                isFocusTraversable(): boolean;
                requestFocus(): void;
                addFocusListener(arg0: java.awt.event.FocusListener): void;
                removeFocusListener(arg0: java.awt.event.FocusListener): void;

            }

            const AccessibleAction: JavaInterfaceStatics<AccessibleAction> & {
                readonly TOGGLE_EXPAND: string;
                readonly INCREMENT: string;
                readonly DECREMENT: string;
                readonly CLICK: string;
                readonly TOGGLE_POPUP: string;
            }
            interface AccessibleAction extends JavaObject {

                getAccessibleActionCount(): number;
                getAccessibleActionDescription(arg0: int): string;
                doAccessibleAction(arg0: int): boolean;

            }

            const AccessibleRole: JavaClassStatics<AccessibleRole> & NoConstructor & {
                readonly ALERT: AccessibleRole;
                readonly COLUMN_HEADER: AccessibleRole;
                readonly CANVAS: AccessibleRole;
                readonly COMBO_BOX: AccessibleRole;
                readonly DESKTOP_ICON: AccessibleRole;
                readonly HTML_CONTAINER: AccessibleRole;
                readonly INTERNAL_FRAME: AccessibleRole;
                readonly DESKTOP_PANE: AccessibleRole;
                readonly OPTION_PANE: AccessibleRole;
                readonly WINDOW: AccessibleRole;
                readonly FRAME: AccessibleRole;
                readonly DIALOG: AccessibleRole;
                readonly COLOR_CHOOSER: AccessibleRole;
                readonly DIRECTORY_PANE: AccessibleRole;
                readonly FILE_CHOOSER: AccessibleRole;
                readonly FILLER: AccessibleRole;
                readonly HYPERLINK: AccessibleRole;
                readonly ICON: AccessibleRole;
                readonly LABEL: AccessibleRole;
                readonly ROOT_PANE: AccessibleRole;
                readonly GLASS_PANE: AccessibleRole;
                readonly LAYERED_PANE: AccessibleRole;
                readonly LIST: AccessibleRole;
                readonly LIST_ITEM: AccessibleRole;
                readonly MENU_BAR: AccessibleRole;
                readonly POPUP_MENU: AccessibleRole;
                readonly MENU: AccessibleRole;
                readonly MENU_ITEM: AccessibleRole;
                readonly SEPARATOR: AccessibleRole;
                readonly PAGE_TAB_LIST: AccessibleRole;
                readonly PAGE_TAB: AccessibleRole;
                readonly PANEL: AccessibleRole;
                readonly PROGRESS_BAR: AccessibleRole;
                readonly PASSWORD_TEXT: AccessibleRole;
                readonly PUSH_BUTTON: AccessibleRole;
                readonly TOGGLE_BUTTON: AccessibleRole;
                readonly CHECK_BOX: AccessibleRole;
                readonly RADIO_BUTTON: AccessibleRole;
                readonly ROW_HEADER: AccessibleRole;
                readonly SCROLL_PANE: AccessibleRole;
                readonly SCROLL_BAR: AccessibleRole;
                readonly VIEWPORT: AccessibleRole;
                readonly SLIDER: AccessibleRole;
                readonly SPLIT_PANE: AccessibleRole;
                readonly TABLE: AccessibleRole;
                readonly TEXT: AccessibleRole;
                readonly TREE: AccessibleRole;
                readonly TOOL_BAR: AccessibleRole;
                readonly TOOL_TIP: AccessibleRole;
                readonly AWT_COMPONENT: AccessibleRole;
                readonly SWING_COMPONENT: AccessibleRole;
                readonly UNKNOWN: AccessibleRole;
                readonly STATUS_BAR: AccessibleRole;
                readonly DATE_EDITOR: AccessibleRole;
                readonly SPIN_BOX: AccessibleRole;
                readonly FONT_CHOOSER: AccessibleRole;
                readonly GROUP_BOX: AccessibleRole;
                readonly HEADER: AccessibleRole;
                readonly FOOTER: AccessibleRole;
                readonly PARAGRAPH: AccessibleRole;
                readonly RULER: AccessibleRole;
                readonly EDITBAR: AccessibleRole;
                readonly PROGRESS_MONITOR: AccessibleRole;
            }
            interface AccessibleRole extends AccessibleBundle {}

            const AccessibleText: JavaInterfaceStatics<AccessibleText> & {
                readonly CHARACTER: number;
                readonly WORD: number;
                readonly SENTENCE: number;
            }
            interface AccessibleText extends JavaObject {

                getIndexAtPoint(arg0: java.awt.Point): number;
                getCharacterBounds(arg0: int): java.awt.Rectangle;
                getCharCount(): number;
                getCaretPosition(): number;
                getAtIndex(arg0: int, arg1: int): string;
                getAfterIndex(arg0: int, arg1: int): string;
                getBeforeIndex(arg0: int, arg1: int): string;
                getCharacterAttribute(arg0: int): javax.swing.text.AttributeSet;
                getSelectionStart(): number;
                getSelectionEnd(): number;
                getSelectedText(): string;

            }

            const AccessibleRelationSet: JavaClassStatics<AccessibleRelationSet, AccessibleRelationSet$$constructor>;
            interface AccessibleRelationSet$$constructor extends SuppressProperties {

                new (): AccessibleRelationSet;
                new (arg0: AccessibleRelation[]): AccessibleRelationSet;

            }
            interface AccessibleRelationSet extends JavaObject {

                add(arg0: AccessibleRelation): boolean;
                addAll(arg0: AccessibleRelation[]): void;
                remove(arg0: AccessibleRelation): boolean;
                clear(): void;
                size(): number;
                contains(arg0: string): boolean;
                get(arg0: string): AccessibleRelation;
                toArray(): JavaArray<AccessibleRelation>;

            }

            const AccessibleEditableText: JavaInterfaceStatics<AccessibleEditableText>;
            interface AccessibleEditableText extends AccessibleText {

                setTextContents(arg0: string): void;
                insertTextAtIndex(arg0: int, arg1: string): void;
                getTextRange(arg0: int, arg1: int): string;
                delete(arg0: int, arg1: int): void;
                cut(arg0: int, arg1: int): void;
                paste(arg0: int): void;
                replaceText(arg0: int, arg1: int, arg2: string): void;
                selectText(arg0: int, arg1: int): void;
                setAttributes(arg0: int, arg1: int, arg2: javax.swing.text.AttributeSet): void;

            }

            const AccessibleSelection: JavaInterfaceStatics<AccessibleSelection>;
            interface AccessibleSelection extends JavaObject {

                getAccessibleSelectionCount(): number;
                getAccessibleSelection(arg0: int): Accessible;
                isAccessibleChildSelected(arg0: int): boolean;
                addAccessibleSelection(arg0: int): void;
                removeAccessibleSelection(arg0: int): void;
                clearAccessibleSelection(): void;
                selectAllAccessibleSelection(): void;

            }

            const AccessibleIcon: JavaInterfaceStatics<AccessibleIcon>;
            interface AccessibleIcon extends JavaObject {

                getAccessibleIconDescription(): string;
                setAccessibleIconDescription(arg0: string): void;
                getAccessibleIconWidth(): number;
                getAccessibleIconHeight(): number;

            }

            const AccessibleValue: JavaInterfaceStatics<AccessibleValue>;
            interface AccessibleValue extends JavaObject {

                getCurrentAccessibleValue(): java.lang.Number;
                setCurrentAccessibleValue(arg0: java.lang.Number): boolean;
                getMinimumAccessibleValue(): java.lang.Number;
                getMaximumAccessibleValue(): java.lang.Number;

            }

            const AccessibleRelation: JavaClassStatics<AccessibleRelation, AccessibleRelation$$constructor> & {
                readonly LABEL_FOR: string;
                readonly LABELED_BY: string;
                readonly MEMBER_OF: string;
                readonly CONTROLLER_FOR: string;
                readonly CONTROLLED_BY: string;
                readonly FLOWS_TO: string;
                readonly FLOWS_FROM: string;
                readonly SUBWINDOW_OF: string;
                readonly PARENT_WINDOW_OF: string;
                readonly EMBEDS: string;
                readonly EMBEDDED_BY: string;
                readonly CHILD_NODE_OF: string;
                readonly LABEL_FOR_PROPERTY: string;
                readonly LABELED_BY_PROPERTY: string;
                readonly MEMBER_OF_PROPERTY: string;
                readonly CONTROLLER_FOR_PROPERTY: string;
                readonly CONTROLLED_BY_PROPERTY: string;
                readonly FLOWS_TO_PROPERTY: string;
                readonly FLOWS_FROM_PROPERTY: string;
                readonly SUBWINDOW_OF_PROPERTY: string;
                readonly PARENT_WINDOW_OF_PROPERTY: string;
                readonly EMBEDS_PROPERTY: string;
                readonly EMBEDDED_BY_PROPERTY: string;
                readonly CHILD_NODE_OF_PROPERTY: string;
            }
            interface AccessibleRelation$$constructor extends SuppressProperties {

                new (arg0: string): AccessibleRelation;
                new (arg0: string, arg1: any): AccessibleRelation;
                new (arg0: string, arg1: any[]): AccessibleRelation;

            }
            interface AccessibleRelation extends AccessibleBundle {

                getKey(): string;
                getTarget(): JavaArray<any>;
                setTarget(arg0: any): void;
                setTarget(arg0: any[]): void;

            }

            const AccessibleBundle: JavaClassStatics<AccessibleBundle, AccessibleBundle$$constructor>;
            interface AccessibleBundle$$constructor extends SuppressProperties {

                new (): AccessibleBundle;

            }
            interface AccessibleBundle extends JavaObject {

                toDisplayString(arg0: java.util.Locale): string;
                toDisplayString(): string;

            }

            const AccessibleState: JavaClassStatics<AccessibleState> & NoConstructor & {
                readonly ACTIVE: AccessibleState;
                readonly PRESSED: AccessibleState;
                readonly ARMED: AccessibleState;
                readonly BUSY: AccessibleState;
                readonly CHECKED: AccessibleState;
                readonly EDITABLE: AccessibleState;
                readonly EXPANDABLE: AccessibleState;
                readonly COLLAPSED: AccessibleState;
                readonly EXPANDED: AccessibleState;
                readonly ENABLED: AccessibleState;
                readonly FOCUSABLE: AccessibleState;
                readonly FOCUSED: AccessibleState;
                readonly ICONIFIED: AccessibleState;
                readonly MODAL: AccessibleState;
                readonly OPAQUE: AccessibleState;
                readonly RESIZABLE: AccessibleState;
                readonly MULTISELECTABLE: AccessibleState;
                readonly SELECTABLE: AccessibleState;
                readonly SELECTED: AccessibleState;
                readonly SHOWING: AccessibleState;
                readonly VISIBLE: AccessibleState;
                readonly VERTICAL: AccessibleState;
                readonly HORIZONTAL: AccessibleState;
                readonly SINGLE_LINE: AccessibleState;
                readonly MULTI_LINE: AccessibleState;
                readonly TRANSIENT: AccessibleState;
                readonly MANAGES_DESCENDANTS: AccessibleState;
                readonly INDETERMINATE: AccessibleState;
                readonly TRUNCATED: AccessibleState;
            }
            interface AccessibleState extends AccessibleBundle {}

            export {
                Accessible,
                AccessibleContext,
                AccessibleStateSet,
                AccessibleTable,
                AccessibleComponent,
                AccessibleAction,
                AccessibleRole,
                AccessibleText,
                AccessibleRelationSet,
                AccessibleEditableText,
                AccessibleSelection,
                AccessibleIcon,
                AccessibleValue,
                AccessibleRelation,
                AccessibleBundle,
                AccessibleState
            }

        }

        namespace security.auth {

            const Subject: JavaClassStatics<Subject, Subject$$constructor> & {

                /** @deprecated */
                getSubject(arg0: java.security.AccessControlContext): Subject;
                doAs<T>(arg0: Subject, arg1: java.security.PrivilegedAction<T>): T;
                doAs<T>(arg0: Subject, arg1: java.security.PrivilegedExceptionAction<T>): T;
                /** @deprecated */
                doAsPrivileged<T>(arg0: Subject, arg1: java.security.PrivilegedAction<T>, arg2: java.security.AccessControlContext): T;
                /** @deprecated */
                doAsPrivileged<T>(arg0: Subject, arg1: java.security.PrivilegedExceptionAction<T>, arg2: java.security.AccessControlContext): T;

            }
            interface Subject$$constructor extends SuppressProperties {

                new (): Subject;
                new (arg0: boolean, arg1: JavaSet<any>, arg2: JavaSet<any>, arg3: JavaSet<any>): Subject;

            }
            interface Subject extends java.io.Serializable {

                setReadOnly(): void;
                isReadOnly(): boolean;
                getPrincipals(): JavaSet<java.security.Principal>;
                getPrincipals<T extends java.security.Principal>(arg0: JavaClassArg<T>): JavaSet<T>;
                getPublicCredentials(): JavaSet<any>;
                getPrivateCredentials(): JavaSet<any>;
                getPublicCredentials<T>(arg0: JavaClassArg<T>): JavaSet<T>;
                getPrivateCredentials<T>(arg0: JavaClassArg<T>): JavaSet<T>;

            }

            export { Subject }

        }

        namespace annotation.processing {

            const Processor: JavaInterfaceStatics<Processor>;
            interface Processor extends JavaObject {

                getSupportedOptions(): JavaSet<string>;
                getSupportedAnnotationTypes(): JavaSet<string>;
                getSupportedSourceVersion(): javax.lang.model.SourceVersion;
                init(arg0: ProcessingEnvironment): void;
                process(arg0: JavaSet<any>, arg1: RoundEnvironment): boolean;
                getCompletions(arg0: javax.lang.model.element.Element, arg1: javax.lang.model.element.AnnotationMirror, arg2: javax.lang.model.element.ExecutableElement, arg3: string): java.lang.Iterable<any>;

            }

            const ProcessingEnvironment: JavaInterfaceStatics<ProcessingEnvironment>;
            interface ProcessingEnvironment extends JavaObject {

                getOptions(): JavaMap<string, string>;
                getMessager(): Messager;
                getFiler(): Filer;
                getElementUtils(): javax.lang.model.util.Elements;
                getTypeUtils(): javax.lang.model.util.Types;
                getSourceVersion(): javax.lang.model.SourceVersion;
                getLocale(): java.util.Locale;
                isPreviewEnabled(): boolean;

            }

            const RoundEnvironment: JavaInterfaceStatics<RoundEnvironment>;
            interface RoundEnvironment extends JavaObject {

                processingOver(): boolean;
                errorRaised(): boolean;
                getRootElements(): JavaSet<any>;
                getElementsAnnotatedWith(arg0: javax.lang.model.element.TypeElement): JavaSet<any>;
                getElementsAnnotatedWithAny(...arg0: javax.lang.model.element.TypeElement[]): JavaSet<any>;
                getElementsAnnotatedWith(arg0: JavaClassArg<any>): JavaSet<any>;
                getElementsAnnotatedWithAny(arg0: JavaSet<JavaClassArg<any>>): JavaSet<any>;

            }

            const Filer: JavaInterfaceStatics<Filer>;
            interface Filer extends JavaObject {

                createSourceFile(arg0: java.lang.CharSequence, ...arg1: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
                createClassFile(arg0: java.lang.CharSequence, ...arg1: javax.lang.model.element.Element[]): javax.tools.JavaFileObject;
                createResource(arg0: javax.tools.JavaFileManager$Location, arg1: java.lang.CharSequence, arg2: java.lang.CharSequence, ...arg3: javax.lang.model.element.Element[]): javax.tools.FileObject;
                getResource(arg0: javax.tools.JavaFileManager$Location, arg1: java.lang.CharSequence, arg2: java.lang.CharSequence): javax.tools.FileObject;

            }

            const Messager: JavaInterfaceStatics<Messager>;
            interface Messager extends JavaObject {

                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence): void;
                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence, arg2: javax.lang.model.element.Element): void;
                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence, arg2: javax.lang.model.element.Element, arg3: javax.lang.model.element.AnnotationMirror): void;
                printMessage(arg0: javax.tools.Diagnostic$Kind, arg1: java.lang.CharSequence, arg2: javax.lang.model.element.Element, arg3: javax.lang.model.element.AnnotationMirror, arg4: javax.lang.model.element.AnnotationValue): void;

            }

            export {
                Processor,
                ProcessingEnvironment,
                RoundEnvironment,
                Filer,
                Messager
            }

        }

        namespace swing.text {

            const AttributeSet: JavaInterfaceStatics<AttributeSet> & {
                readonly NameAttribute: any;
                readonly ResolveAttribute: any;
            }
            interface AttributeSet extends JavaObject {

                getAttributeCount(): number;
                isDefined(arg0: any): boolean;
                isEqual(arg0: AttributeSet): boolean;
                copyAttributes(): AttributeSet;
                getAttribute(arg0: any): any;
                getAttributeNames(): java.util.Enumeration<any>;
                containsAttribute(arg0: any, arg1: any): boolean;
                containsAttributes(arg0: AttributeSet): boolean;
                getResolveParent(): AttributeSet;

            }

            export { AttributeSet }

        }

        namespace lang.model {

            const SourceVersion: JavaClassStatics<SourceVersion> & NoConstructor & {
                readonly RELEASE_0: SourceVersion;
                readonly RELEASE_1: SourceVersion;
                readonly RELEASE_2: SourceVersion;
                readonly RELEASE_3: SourceVersion;
                readonly RELEASE_4: SourceVersion;
                readonly RELEASE_5: SourceVersion;
                readonly RELEASE_6: SourceVersion;
                readonly RELEASE_7: SourceVersion;
                readonly RELEASE_8: SourceVersion;
                readonly RELEASE_9: SourceVersion;
                readonly RELEASE_10: SourceVersion;
                readonly RELEASE_11: SourceVersion;
                readonly RELEASE_12: SourceVersion;
                readonly RELEASE_13: SourceVersion;
                readonly RELEASE_14: SourceVersion;
                readonly RELEASE_15: SourceVersion;
                readonly RELEASE_16: SourceVersion;
                readonly RELEASE_17: SourceVersion;

                values(): JavaArray<SourceVersion>;
                valueOf(arg0: string): SourceVersion;
                latest(): SourceVersion;
                latestSupported(): SourceVersion;
                isIdentifier(arg0: java.lang.CharSequence): boolean;
                isName(arg0: java.lang.CharSequence): boolean;
                isName(arg0: java.lang.CharSequence, arg1: SourceVersion): boolean;
                isKeyword(arg0: java.lang.CharSequence): boolean;
                isKeyword(arg0: java.lang.CharSequence, arg1: SourceVersion): boolean;

            }
            interface SourceVersion extends java.lang.Enum<SourceVersion> {}

            const AnnotatedConstruct: JavaInterfaceStatics<AnnotatedConstruct>;
            interface AnnotatedConstruct extends JavaObject {

                getAnnotationMirrors(): JavaList<any>;
                getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;

            }

            export { SourceVersion, AnnotatedConstruct }

        }
        namespace lang.model {

            namespace element {

                const ModuleElement: JavaInterfaceStatics<ModuleElement>;
                interface ModuleElement extends Element, QualifiedNameable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getQualifiedName(): Name;
                    getSimpleName(): Name;
                    getEnclosedElements(): JavaList<any>;
                    isOpen(): boolean;
                    isUnnamed(): boolean;
                    getEnclosingElement(): Element;
                    getDirectives(): JavaList<any>;

                }

                const AnnotationValue: JavaInterfaceStatics<AnnotationValue>;
                interface AnnotationValue extends JavaObject {

                    getValue(): any;
                    accept<R, P>(arg0: AnnotationValueVisitor<R, P>, arg1: P): R;

                }

                const ExecutableElement: JavaInterfaceStatics<ExecutableElement>;
                interface ExecutableElement extends Element, Parameterizable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getTypeParameters(): JavaList<any>;
                    getReturnType(): javax.lang.model.type.TypeMirror;
                    getParameters(): JavaList<any>;
                    getReceiverType(): javax.lang.model.type.TypeMirror;
                    isVarArgs(): boolean;
                    isDefault(): boolean;
                    getThrownTypes(): JavaList<any>;
                    getDefaultValue(): AnnotationValue;
                    getSimpleName(): Name;

                }

                const TypeElement: JavaInterfaceStatics<TypeElement>;
                interface TypeElement extends Element, Parameterizable, QualifiedNameable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getEnclosedElements(): JavaList<any>;
                    getNestingKind(): NestingKind;
                    getQualifiedName(): Name;
                    getSimpleName(): Name;
                    getSuperclass(): javax.lang.model.type.TypeMirror;
                    getInterfaces(): JavaList<any>;
                    getTypeParameters(): JavaList<any>;
                    getRecordComponents(): JavaList<any>;
                    getPermittedSubclasses(): JavaList<any>;
                    getEnclosingElement(): Element;

                }

                const AnnotationMirror: JavaInterfaceStatics<AnnotationMirror>;
                interface AnnotationMirror extends JavaObject {

                    getAnnotationType(): javax.lang.model.type.DeclaredType;
                    getElementValues(): JavaMap<any, any>;

                }

                const PackageElement: JavaInterfaceStatics<PackageElement>;
                interface PackageElement extends Element, QualifiedNameable {

                    asType(): javax.lang.model.type.TypeMirror;
                    getQualifiedName(): Name;
                    getSimpleName(): Name;
                    getEnclosedElements(): JavaList<any>;
                    isUnnamed(): boolean;
                    getEnclosingElement(): Element;

                }

                const Name: JavaInterfaceStatics<Name>;
                interface Name extends java.lang.CharSequence {

                    contentEquals(arg0: java.lang.CharSequence): boolean;

                }

                const ModuleElement$Directive: JavaInterfaceStatics<ModuleElement$Directive>;
                interface ModuleElement$Directive extends JavaObject {

                    getKind(): ModuleElement$DirectiveKind;
                    accept<R, P>(arg0: ModuleElement$DirectiveVisitor<R, P>, arg1: P): R;

                }

                const Element: JavaInterfaceStatics<Element>;
                interface Element extends javax.lang.model.AnnotatedConstruct {

                    asType(): javax.lang.model.type.TypeMirror;
                    getKind(): ElementKind;
                    getModifiers(): JavaSet<Modifier>;
                    getSimpleName(): Name;
                    getEnclosingElement(): Element;
                    getEnclosedElements(): JavaList<any>;
                    getAnnotationMirrors(): JavaList<any>;
                    getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                    getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                    accept<R, P>(arg0: ElementVisitor<R, P>, arg1: P): R;

                }

                const RecordComponentElement: JavaInterfaceStatics<RecordComponentElement>;
                interface RecordComponentElement extends Element {

                    getEnclosingElement(): Element;
                    getSimpleName(): Name;
                    getAccessor(): ExecutableElement;

                }

                const QualifiedNameable: JavaInterfaceStatics<QualifiedNameable>;
                interface QualifiedNameable extends Element {

                    getQualifiedName(): Name;

                }

                const ElementKind: JavaClassStatics<ElementKind> & NoConstructor & {
                    readonly PACKAGE: ElementKind;
                    readonly ENUM: ElementKind;
                    readonly CLASS: ElementKind;
                    readonly ANNOTATION_TYPE: ElementKind;
                    readonly INTERFACE: ElementKind;
                    readonly ENUM_CONSTANT: ElementKind;
                    readonly FIELD: ElementKind;
                    readonly PARAMETER: ElementKind;
                    readonly LOCAL_VARIABLE: ElementKind;
                    readonly EXCEPTION_PARAMETER: ElementKind;
                    readonly METHOD: ElementKind;
                    readonly CONSTRUCTOR: ElementKind;
                    readonly STATIC_INIT: ElementKind;
                    readonly INSTANCE_INIT: ElementKind;
                    readonly TYPE_PARAMETER: ElementKind;
                    readonly OTHER: ElementKind;
                    readonly RESOURCE_VARIABLE: ElementKind;
                    readonly MODULE: ElementKind;
                    readonly RECORD: ElementKind;
                    readonly RECORD_COMPONENT: ElementKind;
                    readonly BINDING_VARIABLE: ElementKind;

                    values(): JavaArray<ElementKind>;
                    valueOf(arg0: string): ElementKind;

                }
                interface ElementKind extends java.lang.Enum<ElementKind> {

                    isClass(): boolean;
                    isInterface(): boolean;
                    isField(): boolean;

                }

                const NestingKind: JavaClassStatics<NestingKind> & NoConstructor & {
                    readonly TOP_LEVEL: NestingKind;
                    readonly MEMBER: NestingKind;
                    readonly LOCAL: NestingKind;
                    readonly ANONYMOUS: NestingKind;

                    values(): JavaArray<NestingKind>;
                    valueOf(arg0: string): NestingKind;

                }
                interface NestingKind extends java.lang.Enum<NestingKind> {

                    isNested(): boolean;

                }

                const Modifier: JavaClassStatics<Modifier> & NoConstructor & {
                    readonly PUBLIC: Modifier;
                    readonly PROTECTED: Modifier;
                    readonly PRIVATE: Modifier;
                    readonly ABSTRACT: Modifier;
                    readonly DEFAULT: Modifier;
                    readonly STATIC: Modifier;
                    readonly SEALED: Modifier;
                    readonly NON_SEALED: Modifier;
                    readonly FINAL: Modifier;
                    readonly TRANSIENT: Modifier;
                    readonly VOLATILE: Modifier;
                    readonly SYNCHRONIZED: Modifier;
                    readonly NATIVE: Modifier;
                    readonly STRICTFP: Modifier;

                    values(): JavaArray<Modifier>;
                    valueOf(arg0: string): Modifier;

                }
                interface Modifier extends java.lang.Enum<Modifier> {}

                const AnnotationValueVisitor: JavaInterfaceStatics<AnnotationValueVisitor<any, any>>;
                interface AnnotationValueVisitor<R, P> extends JavaObject {

                    visit(arg0: AnnotationValue, arg1: P): R;
                    visit(arg0: AnnotationValue): R;
                    visitBoolean(arg0: boolean, arg1: P): R;
                    visitByte(arg0: byte, arg1: P): R;
                    visitChar(arg0: char, arg1: P): R;
                    visitDouble(arg0: double, arg1: P): R;
                    visitFloat(arg0: float, arg1: P): R;
                    visitInt(arg0: int, arg1: P): R;
                    visitLong(arg0: long, arg1: P): R;
                    visitShort(arg0: short, arg1: P): R;
                    visitString(arg0: string, arg1: P): R;
                    visitType(arg0: javax.lang.model.type.TypeMirror, arg1: P): R;
                    visitEnumConstant(arg0: VariableElement, arg1: P): R;
                    visitAnnotation(arg0: AnnotationMirror, arg1: P): R;
                    visitArray(arg0: JavaList<any>, arg1: P): R;
                    visitUnknown(arg0: AnnotationValue, arg1: P): R;

                }

                const Parameterizable: JavaInterfaceStatics<Parameterizable>;
                interface Parameterizable extends Element {

                    getTypeParameters(): JavaList<any>;

                }

                const ModuleElement$DirectiveVisitor: JavaInterfaceStatics<ModuleElement$DirectiveVisitor<any, any>>;
                interface ModuleElement$DirectiveVisitor<R, P> extends JavaObject {

                    visit(arg0: ModuleElement$Directive): R;
                    visit(arg0: ModuleElement$Directive, arg1: P): R;
                    visitRequires(arg0: ModuleElement$RequiresDirective, arg1: P): R;
                    visitExports(arg0: ModuleElement$ExportsDirective, arg1: P): R;
                    visitOpens(arg0: ModuleElement$OpensDirective, arg1: P): R;
                    visitUses(arg0: ModuleElement$UsesDirective, arg1: P): R;
                    visitProvides(arg0: ModuleElement$ProvidesDirective, arg1: P): R;
                    visitUnknown(arg0: ModuleElement$Directive, arg1: P): R;

                }

                const ElementVisitor: JavaInterfaceStatics<ElementVisitor<any, any>>;
                interface ElementVisitor<R, P> extends JavaObject {

                    visit(arg0: Element, arg1: P): R;
                    visit(arg0: Element): R;
                    visitPackage(arg0: PackageElement, arg1: P): R;
                    visitType(arg0: TypeElement, arg1: P): R;
                    visitVariable(arg0: VariableElement, arg1: P): R;
                    visitExecutable(arg0: ExecutableElement, arg1: P): R;
                    visitTypeParameter(arg0: TypeParameterElement, arg1: P): R;
                    visitUnknown(arg0: Element, arg1: P): R;
                    visitModule(arg0: ModuleElement, arg1: P): R;
                    visitRecordComponent(arg0: RecordComponentElement, arg1: P): R;

                }

                const ModuleElement$DirectiveKind: JavaClassStatics<ModuleElement$DirectiveKind> & NoConstructor & {
                    readonly REQUIRES: ModuleElement$DirectiveKind;
                    readonly EXPORTS: ModuleElement$DirectiveKind;
                    readonly OPENS: ModuleElement$DirectiveKind;
                    readonly USES: ModuleElement$DirectiveKind;
                    readonly PROVIDES: ModuleElement$DirectiveKind;

                    values(): JavaArray<ModuleElement$DirectiveKind>;
                    valueOf(arg0: string): ModuleElement$DirectiveKind;

                }
                interface ModuleElement$DirectiveKind extends java.lang.Enum<ModuleElement$DirectiveKind> {}

                const ModuleElement$OpensDirective: JavaInterfaceStatics<ModuleElement$OpensDirective>;
                interface ModuleElement$OpensDirective extends ModuleElement$Directive {

                    getPackage(): PackageElement;
                    getTargetModules(): JavaList<any>;

                }

                const ModuleElement$ProvidesDirective: JavaInterfaceStatics<ModuleElement$ProvidesDirective>;
                interface ModuleElement$ProvidesDirective extends ModuleElement$Directive {

                    getService(): TypeElement;
                    getImplementations(): JavaList<any>;

                }

                const ModuleElement$RequiresDirective: JavaInterfaceStatics<ModuleElement$RequiresDirective>;
                interface ModuleElement$RequiresDirective extends ModuleElement$Directive {

                    isStatic(): boolean;
                    isTransitive(): boolean;
                    getDependency(): ModuleElement;

                }

                const ModuleElement$ExportsDirective: JavaInterfaceStatics<ModuleElement$ExportsDirective>;
                interface ModuleElement$ExportsDirective extends ModuleElement$Directive {

                    getPackage(): PackageElement;
                    getTargetModules(): JavaList<any>;

                }

                const ModuleElement$UsesDirective: JavaInterfaceStatics<ModuleElement$UsesDirective>;
                interface ModuleElement$UsesDirective extends ModuleElement$Directive {

                    getService(): TypeElement;

                }

                const VariableElement: JavaInterfaceStatics<VariableElement>;
                interface VariableElement extends Element {

                    asType(): javax.lang.model.type.TypeMirror;
                    getConstantValue(): any;
                    getSimpleName(): Name;
                    getEnclosingElement(): Element;

                }

                const TypeParameterElement: JavaInterfaceStatics<TypeParameterElement>;
                interface TypeParameterElement extends Element {

                    asType(): javax.lang.model.type.TypeMirror;
                    getGenericElement(): Element;
                    getBounds(): JavaList<any>;
                    getEnclosingElement(): Element;

                }

                export {
                    ModuleElement,
                    AnnotationValue,
                    ExecutableElement,
                    TypeElement,
                    AnnotationMirror,
                    PackageElement,
                    Name,
                    ModuleElement$Directive,
                    Element,
                    RecordComponentElement,
                    QualifiedNameable,
                    ElementKind,
                    NestingKind,
                    Modifier,
                    AnnotationValueVisitor,
                    Parameterizable,
                    ModuleElement$DirectiveVisitor,
                    ElementVisitor,
                    ModuleElement$DirectiveKind,
                    ModuleElement$OpensDirective,
                    ModuleElement$ProvidesDirective,
                    ModuleElement$RequiresDirective,
                    ModuleElement$ExportsDirective,
                    ModuleElement$UsesDirective,
                    VariableElement,
                    TypeParameterElement
                }

            }

            namespace util {

                const Elements: JavaInterfaceStatics<Elements>;
                interface Elements extends JavaObject {

                    getPackageElement(arg0: java.lang.CharSequence): javax.lang.model.element.PackageElement;
                    getPackageElement(arg0: javax.lang.model.element.ModuleElement, arg1: java.lang.CharSequence): javax.lang.model.element.PackageElement;
                    getAllPackageElements(arg0: java.lang.CharSequence): JavaSet<any>;
                    getTypeElement(arg0: java.lang.CharSequence): javax.lang.model.element.TypeElement;
                    getTypeElement(arg0: javax.lang.model.element.ModuleElement, arg1: java.lang.CharSequence): javax.lang.model.element.TypeElement;
                    getAllTypeElements(arg0: java.lang.CharSequence): JavaSet<any>;
                    getModuleElement(arg0: java.lang.CharSequence): javax.lang.model.element.ModuleElement;
                    getAllModuleElements(): JavaSet<any>;
                    getElementValuesWithDefaults(arg0: javax.lang.model.element.AnnotationMirror): JavaMap<any, any>;
                    getDocComment(arg0: javax.lang.model.element.Element): string;
                    isDeprecated(arg0: javax.lang.model.element.Element): boolean;
                    getOrigin(arg0: javax.lang.model.element.Element): Elements$Origin;
                    getOrigin(arg0: javax.lang.model.AnnotatedConstruct, arg1: javax.lang.model.element.AnnotationMirror): Elements$Origin;
                    getOrigin(arg0: javax.lang.model.element.ModuleElement, arg1: javax.lang.model.element.ModuleElement$Directive): Elements$Origin;
                    isBridge(arg0: javax.lang.model.element.ExecutableElement): boolean;
                    getBinaryName(arg0: javax.lang.model.element.TypeElement): javax.lang.model.element.Name;
                    getPackageOf(arg0: javax.lang.model.element.Element): javax.lang.model.element.PackageElement;
                    getModuleOf(arg0: javax.lang.model.element.Element): javax.lang.model.element.ModuleElement;
                    getAllMembers(arg0: javax.lang.model.element.TypeElement): JavaList<any>;
                    getAllAnnotationMirrors(arg0: javax.lang.model.element.Element): JavaList<any>;
                    hides(arg0: javax.lang.model.element.Element, arg1: javax.lang.model.element.Element): boolean;
                    overrides(arg0: javax.lang.model.element.ExecutableElement, arg1: javax.lang.model.element.ExecutableElement, arg2: javax.lang.model.element.TypeElement): boolean;
                    getConstantExpression(arg0: any): string;
                    printElements(arg0: java.io.Writer, ...arg1: javax.lang.model.element.Element[]): void;
                    getName(arg0: java.lang.CharSequence): javax.lang.model.element.Name;
                    isFunctionalInterface(arg0: javax.lang.model.element.TypeElement): boolean;
                    isAutomaticModule(arg0: javax.lang.model.element.ModuleElement): boolean;
                    recordComponentFor(arg0: javax.lang.model.element.ExecutableElement): javax.lang.model.element.RecordComponentElement;

                }

                const Types: JavaInterfaceStatics<Types>;
                interface Types extends JavaObject {

                    asElement(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.element.Element;
                    isSameType(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    isSubtype(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    isAssignable(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    contains(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): boolean;
                    isSubsignature(arg0: javax.lang.model.type.ExecutableType, arg1: javax.lang.model.type.ExecutableType): boolean;
                    directSupertypes(arg0: javax.lang.model.type.TypeMirror): JavaList<any>;
                    erasure(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.TypeMirror;
                    boxedClass(arg0: javax.lang.model.type.PrimitiveType): javax.lang.model.element.TypeElement;
                    unboxedType(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.PrimitiveType;
                    capture(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.TypeMirror;
                    getPrimitiveType(arg0: javax.lang.model.type.TypeKind): javax.lang.model.type.PrimitiveType;
                    getNullType(): javax.lang.model.type.NullType;
                    getNoType(arg0: javax.lang.model.type.TypeKind): javax.lang.model.type.NoType;
                    getArrayType(arg0: javax.lang.model.type.TypeMirror): javax.lang.model.type.ArrayType;
                    getWildcardType(arg0: javax.lang.model.type.TypeMirror, arg1: javax.lang.model.type.TypeMirror): javax.lang.model.type.WildcardType;
                    getDeclaredType(arg0: javax.lang.model.element.TypeElement, ...arg1: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
                    getDeclaredType(arg0: javax.lang.model.type.DeclaredType, arg1: javax.lang.model.element.TypeElement, ...arg2: javax.lang.model.type.TypeMirror[]): javax.lang.model.type.DeclaredType;
                    asMemberOf(arg0: javax.lang.model.type.DeclaredType, arg1: javax.lang.model.element.Element): javax.lang.model.type.TypeMirror;

                }

                const Elements$Origin: JavaClassStatics<Elements$Origin> & NoConstructor & {
                    readonly EXPLICIT: Elements$Origin;
                    readonly MANDATED: Elements$Origin;
                    readonly SYNTHETIC: Elements$Origin;

                    values(): JavaArray<Elements$Origin>;
                    valueOf(arg0: string): Elements$Origin;

                }
                interface Elements$Origin extends java.lang.Enum<Elements$Origin> {

                    isDeclared(): boolean;

                }

                export { Elements, Types, Elements$Origin }

            }

            namespace type {

                const TypeKind: JavaClassStatics<TypeKind> & NoConstructor & {
                    readonly BOOLEAN: TypeKind;
                    readonly BYTE: TypeKind;
                    readonly SHORT: TypeKind;
                    readonly INT: TypeKind;
                    readonly LONG: TypeKind;
                    readonly CHAR: TypeKind;
                    readonly FLOAT: TypeKind;
                    readonly DOUBLE: TypeKind;
                    readonly VOID: TypeKind;
                    readonly NONE: TypeKind;
                    readonly NULL: TypeKind;
                    readonly ARRAY: TypeKind;
                    readonly DECLARED: TypeKind;
                    readonly ERROR: TypeKind;
                    readonly TYPEVAR: TypeKind;
                    readonly WILDCARD: TypeKind;
                    readonly PACKAGE: TypeKind;
                    readonly EXECUTABLE: TypeKind;
                    readonly OTHER: TypeKind;
                    readonly UNION: TypeKind;
                    readonly INTERSECTION: TypeKind;
                    readonly MODULE: TypeKind;

                    values(): JavaArray<TypeKind>;
                    valueOf(arg0: string): TypeKind;

                }
                interface TypeKind extends java.lang.Enum<TypeKind> {

                    isPrimitive(): boolean;

                }

                const ExecutableType: JavaInterfaceStatics<ExecutableType>;
                interface ExecutableType extends TypeMirror {

                    getTypeVariables(): JavaList<any>;
                    getReturnType(): TypeMirror;
                    getParameterTypes(): JavaList<any>;
                    getReceiverType(): TypeMirror;
                    getThrownTypes(): JavaList<any>;

                }

                const ArrayType: JavaInterfaceStatics<ArrayType>;
                interface ArrayType extends ReferenceType {

                    getComponentType(): TypeMirror;

                }

                const NoType: JavaInterfaceStatics<NoType>;
                interface NoType extends TypeMirror {}

                const DeclaredType: JavaInterfaceStatics<DeclaredType>;
                interface DeclaredType extends ReferenceType {

                    asElement(): javax.lang.model.element.Element;
                    getEnclosingType(): TypeMirror;
                    getTypeArguments(): JavaList<any>;

                }

                const TypeMirror: JavaInterfaceStatics<TypeMirror>;
                interface TypeMirror extends javax.lang.model.AnnotatedConstruct {

                    getKind(): TypeKind;
                    getAnnotationMirrors(): JavaList<any>;
                    getAnnotation<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): A;
                    getAnnotationsByType<A extends java.lang.annotation.Annotation>(arg0: JavaClassArg<A>): JavaArray<A>;
                    accept<R, P>(arg0: TypeVisitor<R, P>, arg1: P): R;

                }

                const NullType: JavaInterfaceStatics<NullType>;
                interface NullType extends ReferenceType {}

                const WildcardType: JavaInterfaceStatics<WildcardType>;
                interface WildcardType extends TypeMirror {

                    getExtendsBound(): TypeMirror;
                    getSuperBound(): TypeMirror;

                }

                const PrimitiveType: JavaInterfaceStatics<PrimitiveType>;
                interface PrimitiveType extends TypeMirror {}

                const TypeVisitor: JavaInterfaceStatics<TypeVisitor<any, any>>;
                interface TypeVisitor<R, P> extends JavaObject {

                    visit(arg0: TypeMirror, arg1: P): R;
                    visit(arg0: TypeMirror): R;
                    visitPrimitive(arg0: PrimitiveType, arg1: P): R;
                    visitNull(arg0: NullType, arg1: P): R;
                    visitArray(arg0: ArrayType, arg1: P): R;
                    visitDeclared(arg0: DeclaredType, arg1: P): R;
                    visitError(arg0: ErrorType, arg1: P): R;
                    visitTypeVariable(arg0: TypeVariable, arg1: P): R;
                    visitWildcard(arg0: WildcardType, arg1: P): R;
                    visitExecutable(arg0: ExecutableType, arg1: P): R;
                    visitNoType(arg0: NoType, arg1: P): R;
                    visitUnknown(arg0: TypeMirror, arg1: P): R;
                    visitUnion(arg0: UnionType, arg1: P): R;
                    visitIntersection(arg0: IntersectionType, arg1: P): R;

                }

                const ReferenceType: JavaInterfaceStatics<ReferenceType>;
                interface ReferenceType extends TypeMirror {}

                const IntersectionType: JavaInterfaceStatics<IntersectionType>;
                interface IntersectionType extends TypeMirror {

                    getBounds(): JavaList<any>;

                }

                const UnionType: JavaInterfaceStatics<UnionType>;
                interface UnionType extends TypeMirror {

                    getAlternatives(): JavaList<any>;

                }

                const TypeVariable: JavaInterfaceStatics<TypeVariable>;
                interface TypeVariable extends ReferenceType {

                    asElement(): javax.lang.model.element.Element;
                    getUpperBound(): TypeMirror;
                    getLowerBound(): TypeMirror;

                }

                const ErrorType: JavaInterfaceStatics<ErrorType>;
                interface ErrorType extends DeclaredType {}

                export {
                    TypeKind,
                    ExecutableType,
                    ArrayType,
                    NoType,
                    DeclaredType,
                    TypeMirror,
                    NullType,
                    WildcardType,
                    PrimitiveType,
                    TypeVisitor,
                    ReferenceType,
                    IntersectionType,
                    UnionType,
                    TypeVariable,
                    ErrorType
                }

            }

        }

        namespace tools {

            const Diagnostic$Kind: JavaClassStatics<Diagnostic$Kind> & NoConstructor & {
                readonly ERROR: Diagnostic$Kind;
                readonly WARNING: Diagnostic$Kind;
                readonly MANDATORY_WARNING: Diagnostic$Kind;
                readonly NOTE: Diagnostic$Kind;
                readonly OTHER: Diagnostic$Kind;

                values(): JavaArray<Diagnostic$Kind>;
                valueOf(arg0: string): Diagnostic$Kind;

            }
            interface Diagnostic$Kind extends java.lang.Enum<Diagnostic$Kind> {}

            const FileObject: JavaInterfaceStatics<FileObject>;
            interface FileObject extends JavaObject {

                toUri(): java.net.URI;
                getName(): string;
                openInputStream(): java.io.InputStream;
                openOutputStream(): java.io.OutputStream;
                openReader(arg0: boolean): java.io.Reader;
                getCharContent(arg0: boolean): java.lang.CharSequence;
                openWriter(): java.io.Writer;
                getLastModified(): number;
                delete(): boolean;

            }

            const JavaFileManager$Location: JavaInterfaceStatics<JavaFileManager$Location>;
            interface JavaFileManager$Location extends JavaObject {

                getName(): string;
                isOutputLocation(): boolean;
                isModuleOrientedLocation(): boolean;

            }

            const JavaFileObject: JavaInterfaceStatics<JavaFileObject>;
            interface JavaFileObject extends FileObject {

                getKind(): JavaFileObject$Kind;
                isNameCompatible(arg0: string, arg1: JavaFileObject$Kind): boolean;
                getNestingKind(): javax.lang.model.element.NestingKind;
                getAccessLevel(): javax.lang.model.element.Modifier;

            }

            const JavaFileObject$Kind: JavaClassStatics<JavaFileObject$Kind> & NoConstructor & {
                readonly SOURCE: JavaFileObject$Kind;
                readonly CLASS: JavaFileObject$Kind;
                readonly HTML: JavaFileObject$Kind;
                readonly OTHER: JavaFileObject$Kind;

                values(): JavaArray<JavaFileObject$Kind>;
                valueOf(arg0: string): JavaFileObject$Kind;

            }
            interface JavaFileObject$Kind extends java.lang.Enum<JavaFileObject$Kind> {
                readonly extension: string;
            }

            export {
                Diagnostic$Kind,
                FileObject,
                JavaFileManager$Location,
                JavaFileObject,
                JavaFileObject$Kind
            }

        }

    }

    namespace javassist {

        const CtBehavior: JavaClassStatics<CtBehavior> & NoConstructor;
        interface CtBehavior extends CtMember {

            getLongName(): string;
            getMethodInfo(): javassist.bytecode.MethodInfo;
            getMethodInfo2(): javassist.bytecode.MethodInfo;
            getModifiers(): number;
            setModifiers(arg0: int): void;
            hasAnnotation(arg0: string): boolean;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getParameterAnnotations(): JavaArray<JavaArray<any>>;
            getAvailableParameterAnnotations(): JavaArray<JavaArray<any>>;
            getParameterTypes(): JavaArray<CtClass>;
            getSignature(): string;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            getExceptionTypes(): JavaArray<CtClass>;
            setExceptionTypes(arg0: CtClass[]): void;
            isEmpty(): boolean;
            setBody(arg0: string): void;
            setBody(arg0: string, arg1: string, arg2: string): void;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;
            useCflow(arg0: string): void;
            addLocalVariable(arg0: string, arg1: CtClass): void;
            insertParameter(arg0: CtClass): void;
            addParameter(arg0: CtClass): void;
            instrument(arg0: CodeConverter): void;
            instrument(arg0: javassist.expr.ExprEditor): void;
            insertBefore(arg0: string): void;
            insertAfter(arg0: string): void;
            insertAfter(arg0: string, arg1: boolean): void;
            insertAfter(arg0: string, arg1: boolean, arg2: boolean): void;
            addCatch(arg0: string, arg1: CtClass): void;
            addCatch(arg0: string, arg1: CtClass, arg2: string): void;
            insertAt(arg0: int, arg1: string): number;
            insertAt(arg0: int, arg1: boolean, arg2: string): number;

        }

        const CtField$Initializer: JavaClassStatics<CtField$Initializer, CtField$Initializer$$constructor> & {

            constant(arg0: int): CtField$Initializer;
            constant(arg0: boolean): CtField$Initializer;
            constant(arg0: long): CtField$Initializer;
            constant(arg0: float): CtField$Initializer;
            constant(arg0: double): CtField$Initializer;
            constant(arg0: string): CtField$Initializer;
            byParameter(arg0: int): CtField$Initializer;
            byNew(arg0: CtClass): CtField$Initializer;
            byNew(arg0: CtClass, arg1: string[]): CtField$Initializer;
            byNewWithParams(arg0: CtClass): CtField$Initializer;
            byNewWithParams(arg0: CtClass, arg1: string[]): CtField$Initializer;
            byCall(arg0: CtClass, arg1: string): CtField$Initializer;
            byCall(arg0: CtClass, arg1: string, arg2: string[]): CtField$Initializer;
            byCallWithParams(arg0: CtClass, arg1: string): CtField$Initializer;
            byCallWithParams(arg0: CtClass, arg1: string, arg2: string[]): CtField$Initializer;
            byNewArray(arg0: CtClass, arg1: int): CtField$Initializer;
            byNewArray(arg0: CtClass, arg1: int[]): CtField$Initializer;
            byExpr(arg0: string): CtField$Initializer;

        }
        interface CtField$Initializer$$constructor extends SuppressProperties {

            new (): CtField$Initializer;

        }
        interface CtField$Initializer extends JavaObject {}

        const CtClass: JavaClassStatics<CtClass> & NoConstructor & {
            debugDump: string;
            readonly version: string;
            booleanType: CtClass;
            charType: CtClass;
            byteType: CtClass;
            shortType: CtClass;
            intType: CtClass;
            longType: CtClass;
            floatType: CtClass;
            doubleType: CtClass;
            voidType: CtClass;

            main(arg0: string[]): void;

        }
        interface CtClass extends JavaObject {

            getClassPool(): ClassPool;
            getClassFile(): javassist.bytecode.ClassFile;
            getClassFile2(): javassist.bytecode.ClassFile;
            getAccessorMaker(): javassist.compiler.AccessorMaker;
            getURL(): java.net.URL;
            isModified(): boolean;
            isFrozen(): boolean;
            freeze(): void;
            defrost(): void;
            isPrimitive(): boolean;
            isArray(): boolean;
            isKotlin(): boolean;
            getComponentType(): CtClass;
            subtypeOf(arg0: CtClass): boolean;
            getName(): string;
            getSimpleName(): string;
            getPackageName(): string;
            setName(arg0: string): void;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            replaceClassName(arg0: string, arg1: string): void;
            replaceClassName(arg0: ClassMap): void;
            getRefClasses(): JavaCollection<string>;
            isInterface(): boolean;
            isAnnotation(): boolean;
            isEnum(): boolean;
            getModifiers(): number;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            hasAnnotation(arg0: string): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getDeclaredClasses(): JavaArray<CtClass>;
            getNestedClasses(): JavaArray<CtClass>;
            setModifiers(arg0: int): void;
            subclassOf(arg0: CtClass): boolean;
            getSuperclass(): CtClass;
            setSuperclass(arg0: CtClass): void;
            getInterfaces(): JavaArray<CtClass>;
            setInterfaces(arg0: CtClass[]): void;
            addInterface(arg0: CtClass): void;
            getDeclaringClass(): CtClass;
            /** @deprecated */
            getEnclosingMethod(): CtMethod;
            getEnclosingBehavior(): CtBehavior;
            makeNestedClass(arg0: string, arg1: boolean): CtClass;
            getFields(): JavaArray<CtField>;
            getField(arg0: string): CtField;
            getField(arg0: string, arg1: string): CtField;
            getDeclaredFields(): JavaArray<CtField>;
            getDeclaredField(arg0: string): CtField;
            getDeclaredField(arg0: string, arg1: string): CtField;
            getDeclaredBehaviors(): JavaArray<CtBehavior>;
            getConstructors(): JavaArray<CtConstructor>;
            getConstructor(arg0: string): CtConstructor;
            getDeclaredConstructors(): JavaArray<CtConstructor>;
            getDeclaredConstructor(arg0: CtClass[]): CtConstructor;
            getClassInitializer(): CtConstructor;
            getMethods(): JavaArray<CtMethod>;
            getMethod(arg0: string, arg1: string): CtMethod;
            getDeclaredMethods(): JavaArray<CtMethod>;
            getDeclaredMethod(arg0: string, arg1: CtClass[]): CtMethod;
            getDeclaredMethods(arg0: string): JavaArray<CtMethod>;
            getDeclaredMethod(arg0: string): CtMethod;
            makeClassInitializer(): CtConstructor;
            addConstructor(arg0: CtConstructor): void;
            removeConstructor(arg0: CtConstructor): void;
            addMethod(arg0: CtMethod): void;
            removeMethod(arg0: CtMethod): void;
            addField(arg0: CtField): void;
            addField(arg0: CtField, arg1: string): void;
            addField(arg0: CtField, arg1: CtField$Initializer): void;
            removeField(arg0: CtField): void;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;
            instrument(arg0: CodeConverter): void;
            instrument(arg0: javassist.expr.ExprEditor): void;
            toClass(): JavaClass<any>;
            toClass(arg0: JavaClassArg<any>): JavaClass<any>;
            toClass(arg0: java.lang.invoke.MethodHandles$Lookup): JavaClass<any>;
            toClass(arg0: java.lang.ClassLoader, arg1: java.security.ProtectionDomain): JavaClass<any>;
            /** @deprecated */
            toClass(arg0: java.lang.ClassLoader): JavaClass<any>;
            detach(): void;
            stopPruning(arg0: boolean): boolean;
            prune(): void;
            rebuildClassFile(): void;
            toBytecode(): JavaArray<number>;
            writeFile(): void;
            writeFile(arg0: string): void;
            debugWriteFile(): void;
            debugWriteFile(arg0: string): void;
            toBytecode(arg0: java.io.DataOutputStream): void;
            makeUniqueName(arg0: string): string;

        }

        const CtField: JavaClassStatics<CtField, CtField$$constructor> & {

            make(arg0: string, arg1: CtClass): CtField;

        }
        interface CtField$$constructor extends SuppressProperties {

            new (arg0: CtClass, arg1: string, arg2: CtClass): CtField;
            new (arg0: CtField, arg1: CtClass): CtField;

        }
        interface CtField extends CtMember {

            getFieldInfo(): javassist.bytecode.FieldInfo;
            getFieldInfo2(): javassist.bytecode.FieldInfo;
            getDeclaringClass(): CtClass;
            getName(): string;
            setName(arg0: string): void;
            getModifiers(): number;
            setModifiers(arg0: int): void;
            hasAnnotation(arg0: string): boolean;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getSignature(): string;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            getType(): CtClass;
            setType(arg0: CtClass): void;
            getConstantValue(): any;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;

        }

        const CodeConverter: JavaClassStatics<CodeConverter, CodeConverter$$constructor>;
        interface CodeConverter$$constructor extends SuppressProperties {

            new (): CodeConverter;

        }
        interface CodeConverter extends JavaObject {

            replaceNew(arg0: CtClass, arg1: CtClass, arg2: string): void;
            replaceNew(arg0: CtClass, arg1: CtClass): void;
            redirectFieldAccess(arg0: CtField, arg1: CtClass, arg2: string): void;
            replaceFieldRead(arg0: CtField, arg1: CtClass, arg2: string): void;
            replaceFieldWrite(arg0: CtField, arg1: CtClass, arg2: string): void;
            replaceArrayAccess(arg0: CtClass, arg1: CodeConverter$ArrayAccessReplacementMethodNames): void;
            redirectMethodCall(arg0: CtMethod, arg1: CtMethod): void;
            redirectMethodCall(arg0: string, arg1: CtMethod): void;
            redirectMethodCallToStatic(arg0: CtMethod, arg1: CtMethod): void;
            insertBeforeMethod(arg0: CtMethod, arg1: CtMethod): void;
            insertAfterMethod(arg0: CtMethod, arg1: CtMethod): void;

        }

        const ClassPool: JavaClassStatics<ClassPool, ClassPool$$constructor> & {
            doPruning: boolean;
            releaseUnmodifiedClassFile: boolean;
            cacheOpenedJarFile: boolean;

            getDefault(): ClassPool;

        }
        interface ClassPool$$constructor extends SuppressProperties {

            new (): ClassPool;
            new (arg0: boolean): ClassPool;
            new (arg0: ClassPool): ClassPool;

        }
        interface ClassPool extends JavaObject {
            childFirstLookup: boolean;

            importPackage(arg0: string): void;
            clearImportedPackages(): void;
            getImportedPackages(): java.util.Iterator<string>;
            /** @deprecated */
            recordInvalidClassName(arg0: string): void;
            lookupCflow(arg0: string): JavaArray<any>;
            getAndRename(arg0: string, arg1: string): CtClass;
            get(arg0: string): CtClass;
            getOrNull(arg0: string): CtClass;
            getCtClass(arg0: string): CtClass;
            find(arg0: string): java.net.URL;
            get(arg0: string[]): JavaArray<CtClass>;
            getMethod(arg0: string, arg1: string): CtMethod;
            makeClass(arg0: java.io.InputStream): CtClass;
            makeClass(arg0: java.io.InputStream, arg1: boolean): CtClass;
            makeClass(arg0: javassist.bytecode.ClassFile): CtClass;
            makeClass(arg0: javassist.bytecode.ClassFile, arg1: boolean): CtClass;
            makeClassIfNew(arg0: java.io.InputStream): CtClass;
            makeClass(arg0: string): CtClass;
            makeClass(arg0: string, arg1: CtClass): CtClass;
            makeInterface(arg0: string): CtClass;
            makeInterface(arg0: string, arg1: CtClass): CtClass;
            makeAnnotation(arg0: string): CtClass;
            appendSystemPath(): ClassPath;
            insertClassPath(arg0: ClassPath): ClassPath;
            appendClassPath(arg0: ClassPath): ClassPath;
            insertClassPath(arg0: string): ClassPath;
            appendClassPath(arg0: string): ClassPath;
            removeClassPath(arg0: ClassPath): void;
            appendPathList(arg0: string): void;
            toClass(arg0: CtClass): JavaClass;
            getClassLoader(): java.lang.ClassLoader;
            /** @deprecated */
            toClass(arg0: CtClass, arg1: java.lang.ClassLoader): JavaClass;
            /** @deprecated */
            toClass(arg0: CtClass, arg1: java.lang.ClassLoader, arg2: java.security.ProtectionDomain): JavaClass;
            toClass(arg0: CtClass, arg1: JavaClassArg<any>): JavaClass<any>;
            toClass(arg0: CtClass, arg1: java.lang.invoke.MethodHandles$Lookup): JavaClass<any>;
            toClass(arg0: CtClass, arg1: JavaClassArg<any>, arg2: java.lang.ClassLoader, arg3: java.security.ProtectionDomain): JavaClass;
            /** @deprecated */
            makePackage(arg0: java.lang.ClassLoader, arg1: string): void;

        }

        const CtMember: JavaClassStatics<CtMember> & NoConstructor;
        interface CtMember extends JavaObject {

            getDeclaringClass(): CtClass;
            visibleFrom(arg0: CtClass): boolean;
            getModifiers(): number;
            setModifiers(arg0: int): void;
            hasAnnotation(arg0: JavaClassArg<any>): boolean;
            hasAnnotation(arg0: string): boolean;
            getAnnotation(arg0: JavaClassArg<any>): any;
            getAnnotations(): JavaArray<any>;
            getAvailableAnnotations(): JavaArray<any>;
            getName(): string;
            getSignature(): string;
            getGenericSignature(): string;
            setGenericSignature(arg0: string): void;
            getAttribute(arg0: string): JavaArray<number>;
            setAttribute(arg0: string, arg1: byte[]): void;

        }

        const CtMethod: JavaClassStatics<CtMethod, CtMethod$$constructor> & {

            make(arg0: string, arg1: CtClass): CtMethod;
            make(arg0: javassist.bytecode.MethodInfo, arg1: CtClass): CtMethod;

        }
        interface CtMethod$$constructor extends SuppressProperties {

            new (arg0: CtClass, arg1: string, arg2: CtClass[], arg3: CtClass): CtMethod;
            new (arg0: CtMethod, arg1: CtClass, arg2: ClassMap): CtMethod;

        }
        interface CtMethod extends CtBehavior {

            getLongName(): string;
            getName(): string;
            setName(arg0: string): void;
            getReturnType(): CtClass;
            isEmpty(): boolean;
            setBody(arg0: CtMethod, arg1: ClassMap): void;
            setBody(arg0: string): void;
            setBody(arg0: string, arg1: string, arg2: string): void;
            setWrappedBody(arg0: CtMethod, arg1: CtMethod$ConstParameter): void;

        }

        const CtConstructor: JavaClassStatics<CtConstructor, CtConstructor$$constructor>;
        interface CtConstructor$$constructor extends SuppressProperties {

            new (arg0: CtClass[], arg1: CtClass): CtConstructor;
            new (arg0: CtConstructor, arg1: CtClass, arg2: ClassMap): CtConstructor;

        }
        interface CtConstructor extends CtBehavior {

            isConstructor(): boolean;
            isClassInitializer(): boolean;
            getLongName(): string;
            getName(): string;
            isEmpty(): boolean;
            callsSuper(): boolean;
            setBody(arg0: string): void;
            setBody(arg0: CtConstructor, arg1: ClassMap): void;
            setBody(arg0: string, arg1: string, arg2: string): void;
            insertBeforeBody(arg0: string): void;
            toMethod(arg0: string, arg1: CtClass): CtMethod;
            toMethod(arg0: string, arg1: CtClass, arg2: ClassMap): CtMethod;

        }

        const ClassMap: JavaClassStatics<ClassMap, ClassMap$$constructor> & {

            toJvmName(arg0: string): string;
            toJavaName(arg0: string): string;

        }
        interface ClassMap$$constructor extends SuppressProperties {

            new (): ClassMap;

        }
        interface ClassMap extends java.util.HashMap<string, string> {

            put(arg0: CtClass, arg1: CtClass): void;
            put(arg0: string, arg1: string): string;
            putIfNone(arg0: string, arg1: string): void;
            get(arg0: any): string;
            fix(arg0: CtClass): void;
            fix(arg0: string): void;

        }

        const CtMethod$ConstParameter: JavaClassStatics<CtMethod$ConstParameter> & NoConstructor & {

            integer(arg0: int): CtMethod$ConstParameter;
            integer(arg0: long): CtMethod$ConstParameter;
            string(arg0: string): CtMethod$ConstParameter;

        }
        interface CtMethod$ConstParameter extends JavaObject {}

        const ClassPath: JavaInterfaceStatics<ClassPath>;
        interface ClassPath extends JavaObject {

            openClassfile(arg0: string): java.io.InputStream;
            find(arg0: string): java.net.URL;

        }

        const CodeConverter$ArrayAccessReplacementMethodNames: JavaInterfaceStatics<CodeConverter$ArrayAccessReplacementMethodNames>;
        interface CodeConverter$ArrayAccessReplacementMethodNames extends JavaObject {

            byteOrBooleanRead(): string;
            byteOrBooleanWrite(): string;
            charRead(): string;
            charWrite(): string;
            doubleRead(): string;
            doubleWrite(): string;
            floatRead(): string;
            floatWrite(): string;
            intRead(): string;
            intWrite(): string;
            longRead(): string;
            longWrite(): string;
            objectRead(): string;
            objectWrite(): string;
            shortRead(): string;
            shortWrite(): string;

        }

        export {
            CtBehavior,
            CtField$Initializer,
            CtClass,
            CtField,
            CodeConverter,
            ClassPool,
            CtMember,
            CtMethod,
            CtConstructor,
            ClassMap,
            CtMethod$ConstParameter,
            ClassPath,
            CodeConverter$ArrayAccessReplacementMethodNames
        }

    }
    namespace javassist {

        namespace util.proxy {

            const ProxyFactory: JavaClassStatics<ProxyFactory, ProxyFactory$$constructor> & {
                onlyPublicMethods: boolean;
                useCache: boolean;
                useWriteReplace: boolean;
                classLoaderProvider: ProxyFactory$ClassLoaderProvider;
                nameGenerator: ProxyFactory$UniqueName;

                isProxyClass(arg0: JavaClassArg<any>): boolean;
                getHandler(arg0: Proxy): MethodHandler;

            }
            interface ProxyFactory$$constructor extends SuppressProperties {

                new (): ProxyFactory;

            }
            interface ProxyFactory extends JavaObject {
                writeDirectory: string;

                isUseCache(): boolean;
                setUseCache(arg0: boolean): void;
                isUseWriteReplace(): boolean;
                setUseWriteReplace(arg0: boolean): void;
                setSuperclass(arg0: JavaClassArg<any>): void;
                getSuperclass(): JavaClass<any>;
                setInterfaces(arg0: JavaClassArg<any>[]): void;
                getInterfaces(): JavaArray<JavaClass<any>>;
                setFilter(arg0: MethodFilter): void;
                setGenericSignature(arg0: string): void;
                createClass(): JavaClass<any>;
                createClass(arg0: MethodFilter): JavaClass<any>;
                createClass(arg0: java.lang.invoke.MethodHandles$Lookup): JavaClass<any>;
                createClass(arg0: java.lang.invoke.MethodHandles$Lookup, arg1: MethodFilter): JavaClass<any>;
                getKey(arg0: JavaClassArg<any>, arg1: JavaClassArg<any>[], arg2: byte[], arg3: boolean): string;
                create(arg0: JavaClassArg<any>[], arg1: any[], arg2: MethodHandler): any;
                create(arg0: JavaClassArg<any>[], arg1: any[]): any;
                /** @deprecated */
                setHandler(arg0: MethodHandler): void;

            }

            const ProxyFactory$ClassLoaderProvider: JavaInterfaceStatics<ProxyFactory$ClassLoaderProvider>;
            interface ProxyFactory$ClassLoaderProvider extends JavaObject {

                get(arg0: ProxyFactory): java.lang.ClassLoader;

            }

            const MethodHandler: JavaInterfaceStatics<MethodHandler>;
            interface MethodHandler extends JavaObject {

                invoke(arg0: any, arg1: java.lang.reflect.Method, arg2: java.lang.reflect.Method, arg3: any[]): any;

            }

            const ProxyFactory$UniqueName: JavaInterfaceStatics<ProxyFactory$UniqueName>;
            interface ProxyFactory$UniqueName extends JavaObject {

                get(arg0: string): string;

            }

            const Proxy: JavaInterfaceStatics<Proxy>;
            interface Proxy extends JavaObject {

                setHandler(arg0: MethodHandler): void;

            }

            const MethodFilter: JavaInterfaceStatics<MethodFilter>;
            interface MethodFilter extends JavaObject {

                isHandled(arg0: java.lang.reflect.Method): boolean;

            }

            export {
                ProxyFactory,
                ProxyFactory$ClassLoaderProvider,
                MethodHandler,
                ProxyFactory$UniqueName,
                Proxy,
                MethodFilter
            }

        }

        namespace bytecode {

            const ConstPool: JavaClassStatics<ConstPool, ConstPool$$constructor> & {
                readonly CONST_Class: number;
                readonly CONST_Fieldref: number;
                readonly CONST_Methodref: number;
                readonly CONST_InterfaceMethodref: number;
                readonly CONST_String: number;
                readonly CONST_Integer: number;
                readonly CONST_Float: number;
                readonly CONST_Long: number;
                readonly CONST_Double: number;
                readonly CONST_NameAndType: number;
                readonly CONST_Utf8: number;
                readonly CONST_MethodHandle: number;
                readonly CONST_MethodType: number;
                readonly CONST_Dynamic: number;
                readonly CONST_DynamicCallSite: number;
                readonly CONST_InvokeDynamic: number;
                readonly CONST_Module: number;
                readonly CONST_Package: number;
                readonly THIS: javassist.CtClass;
                readonly REF_getField: number;
                readonly REF_getStatic: number;
                readonly REF_putField: number;
                readonly REF_putStatic: number;
                readonly REF_invokeVirtual: number;
                readonly REF_invokeStatic: number;
                readonly REF_invokeSpecial: number;
                readonly REF_newInvokeSpecial: number;
                readonly REF_invokeInterface: number;
            }
            interface ConstPool$$constructor extends SuppressProperties {

                new (arg0: string): ConstPool;
                new (arg0: java.io.DataInputStream): ConstPool;

            }
            interface ConstPool extends JavaObject {

                getSize(): number;
                getClassName(): string;
                getThisClassInfo(): number;
                getTag(arg0: int): number;
                getClassInfo(arg0: int): string;
                getClassInfoByDescriptor(arg0: int): string;
                getNameAndTypeName(arg0: int): number;
                getNameAndTypeDescriptor(arg0: int): number;
                getMemberClass(arg0: int): number;
                getMemberNameAndType(arg0: int): number;
                getFieldrefClass(arg0: int): number;
                getFieldrefClassName(arg0: int): string;
                getFieldrefNameAndType(arg0: int): number;
                getFieldrefName(arg0: int): string;
                getFieldrefType(arg0: int): string;
                getMethodrefClass(arg0: int): number;
                getMethodrefClassName(arg0: int): string;
                getMethodrefNameAndType(arg0: int): number;
                getMethodrefName(arg0: int): string;
                getMethodrefType(arg0: int): string;
                getInterfaceMethodrefClass(arg0: int): number;
                getInterfaceMethodrefClassName(arg0: int): string;
                getInterfaceMethodrefNameAndType(arg0: int): number;
                getInterfaceMethodrefName(arg0: int): string;
                getInterfaceMethodrefType(arg0: int): string;
                getLdcValue(arg0: int): any;
                getIntegerInfo(arg0: int): number;
                getFloatInfo(arg0: int): number;
                getLongInfo(arg0: int): number;
                getDoubleInfo(arg0: int): number;
                getStringInfo(arg0: int): string;
                getUtf8Info(arg0: int): string;
                getMethodHandleKind(arg0: int): number;
                getMethodHandleIndex(arg0: int): number;
                getMethodTypeInfo(arg0: int): number;
                getInvokeDynamicBootstrap(arg0: int): number;
                getInvokeDynamicNameAndType(arg0: int): number;
                getInvokeDynamicType(arg0: int): string;
                getDynamicBootstrap(arg0: int): number;
                getDynamicNameAndType(arg0: int): number;
                getDynamicType(arg0: int): string;
                getModuleInfo(arg0: int): string;
                getPackageInfo(arg0: int): string;
                isConstructor(arg0: string, arg1: int): number;
                isMember(arg0: string, arg1: string, arg2: int): number;
                eqMember(arg0: string, arg1: string, arg2: int): string;
                copy(arg0: int, arg1: ConstPool, arg2: JavaMap<string, string>): number;
                addClassInfo(arg0: javassist.CtClass): number;
                addClassInfo(arg0: string): number;
                addNameAndTypeInfo(arg0: string, arg1: string): number;
                addNameAndTypeInfo(arg0: int, arg1: int): number;
                addFieldrefInfo(arg0: int, arg1: string, arg2: string): number;
                addFieldrefInfo(arg0: int, arg1: int): number;
                addMethodrefInfo(arg0: int, arg1: string, arg2: string): number;
                addMethodrefInfo(arg0: int, arg1: int): number;
                addInterfaceMethodrefInfo(arg0: int, arg1: string, arg2: string): number;
                addInterfaceMethodrefInfo(arg0: int, arg1: int): number;
                addStringInfo(arg0: string): number;
                addIntegerInfo(arg0: int): number;
                addFloatInfo(arg0: float): number;
                addLongInfo(arg0: long): number;
                addDoubleInfo(arg0: double): number;
                addUtf8Info(arg0: string): number;
                addMethodHandleInfo(arg0: int, arg1: int): number;
                addMethodTypeInfo(arg0: int): number;
                addInvokeDynamicInfo(arg0: int, arg1: int): number;
                addDynamicInfo(arg0: int, arg1: int): number;
                addModuleInfo(arg0: int): number;
                addPackageInfo(arg0: int): number;
                getClassNames(): JavaSet<string>;
                renameClass(arg0: string, arg1: string): void;
                renameClass(arg0: JavaMap<string, string>): void;
                write(arg0: java.io.DataOutputStream): void;
                print(): void;
                print(arg0: java.io.PrintWriter): void;

            }

            const MethodInfo: JavaClassStatics<MethodInfo, MethodInfo$$constructor> & {
                doPreverify: boolean;
                readonly nameInit: string;
                readonly nameClinit: string;
            }
            interface MethodInfo$$constructor extends SuppressProperties {

                new (arg0: ConstPool, arg1: string, arg2: string): MethodInfo;
                new (arg0: ConstPool, arg1: string, arg2: MethodInfo, arg3: JavaMap<string, string>): MethodInfo;

            }
            interface MethodInfo extends JavaObject {

                getName(): string;
                setName(arg0: string): void;
                isMethod(): boolean;
                getConstPool(): ConstPool;
                isConstructor(): boolean;
                isStaticInitializer(): boolean;
                getAccessFlags(): number;
                setAccessFlags(arg0: int): void;
                getDescriptor(): string;
                setDescriptor(arg0: string): void;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                removeAttribute(arg0: string): AttributeInfo;
                addAttribute(arg0: AttributeInfo): void;
                getExceptionsAttribute(): ExceptionsAttribute;
                getCodeAttribute(): CodeAttribute;
                removeExceptionsAttribute(): void;
                setExceptionsAttribute(arg0: ExceptionsAttribute): void;
                removeCodeAttribute(): void;
                setCodeAttribute(arg0: CodeAttribute): void;
                rebuildStackMapIf6(arg0: javassist.ClassPool, arg1: ClassFile): void;
                rebuildStackMap(arg0: javassist.ClassPool): void;
                rebuildStackMapForME(arg0: javassist.ClassPool): void;
                getLineNumber(arg0: int): number;
                setSuperclass(arg0: string): void;

            }

            const ClassFile: JavaClassStatics<ClassFile, ClassFile$$constructor> & {
                readonly JAVA_1: number;
                readonly JAVA_2: number;
                readonly JAVA_3: number;
                readonly JAVA_4: number;
                readonly JAVA_5: number;
                readonly JAVA_6: number;
                readonly JAVA_7: number;
                readonly JAVA_8: number;
                readonly JAVA_9: number;
                readonly JAVA_10: number;
                readonly JAVA_11: number;
                readonly MAJOR_VERSION: number;
            }
            interface ClassFile$$constructor extends SuppressProperties {

                new (arg0: java.io.DataInputStream): ClassFile;
                new (arg0: boolean, arg1: string, arg2: string): ClassFile;

            }
            interface ClassFile extends JavaObject {

                compact(): void;
                prune(): void;
                getConstPool(): ConstPool;
                isInterface(): boolean;
                isFinal(): boolean;
                isAbstract(): boolean;
                getAccessFlags(): number;
                setAccessFlags(arg0: int): void;
                getInnerAccessFlags(): number;
                getName(): string;
                setName(arg0: string): void;
                getSuperclass(): string;
                getSuperclassId(): number;
                setSuperclass(arg0: string): void;
                renameClass(arg0: string, arg1: string): void;
                renameClass(arg0: JavaMap<string, string>): void;
                getRefClasses(arg0: JavaMap<string, string>): void;
                getInterfaces(): JavaArray<string>;
                setInterfaces(arg0: string[]): void;
                addInterface(arg0: string): void;
                getFields(): JavaList<FieldInfo>;
                addField(arg0: FieldInfo): void;
                addField2(arg0: FieldInfo): void;
                getMethods(): JavaList<MethodInfo>;
                getMethod(arg0: string): MethodInfo;
                getStaticInitializer(): MethodInfo;
                addMethod(arg0: MethodInfo): void;
                addMethod2(arg0: MethodInfo): void;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                removeAttribute(arg0: string): AttributeInfo;
                addAttribute(arg0: AttributeInfo): void;
                getSourceFile(): string;
                write(arg0: java.io.DataOutputStream): void;
                getMajorVersion(): number;
                setMajorVersion(arg0: int): void;
                getMinorVersion(): number;
                setMinorVersion(arg0: int): void;
                setVersionToJava5(): void;

            }

            const AttributeInfo: JavaClassStatics<AttributeInfo, AttributeInfo$$constructor>;
            interface AttributeInfo$$constructor extends SuppressProperties {

                new (arg0: ConstPool, arg1: string, arg2: byte[]): AttributeInfo;

            }
            interface AttributeInfo extends JavaObject {

                getName(): string;
                getConstPool(): ConstPool;
                length(): number;
                get(): JavaArray<number>;
                set(arg0: byte[]): void;
                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;

            }

            const CodeAttribute: JavaClassStatics<CodeAttribute, CodeAttribute$$constructor> & {
                readonly tag: string;
            }
            interface CodeAttribute$$constructor extends SuppressProperties {

                new (arg0: ConstPool, arg1: int, arg2: int, arg3: byte[], arg4: ExceptionTable): CodeAttribute;

            }
            interface CodeAttribute extends AttributeInfo, Opcode {

                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                length(): number;
                get(): JavaArray<number>;
                set(arg0: byte[]): void;
                getDeclaringClass(): string;
                getMaxStack(): number;
                setMaxStack(arg0: int): void;
                computeMaxStack(): number;
                getMaxLocals(): number;
                setMaxLocals(arg0: int): void;
                getCodeLength(): number;
                getCode(): JavaArray<number>;
                iterator(): CodeIterator;
                getExceptionTable(): ExceptionTable;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                setAttribute(arg0: StackMapTable): void;
                setAttribute(arg0: StackMap): void;
                insertLocalVar(arg0: int, arg1: int): void;

            }

            const ExceptionsAttribute: JavaClassStatics<ExceptionsAttribute, ExceptionsAttribute$$constructor> & {
                readonly tag: string;
            }
            interface ExceptionsAttribute$$constructor extends SuppressProperties {

                new (arg0: ConstPool): ExceptionsAttribute;

            }
            interface ExceptionsAttribute extends AttributeInfo {

                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                getExceptionIndexes(): JavaArray<number>;
                getExceptions(): JavaArray<string>;
                setExceptionIndexes(arg0: int[]): void;
                setExceptions(arg0: string[]): void;
                tableLength(): number;
                getException(arg0: int): number;

            }

            const FieldInfo: JavaClassStatics<FieldInfo, FieldInfo$$constructor>;
            interface FieldInfo$$constructor extends SuppressProperties {

                new (arg0: ConstPool, arg1: string, arg2: string): FieldInfo;

            }
            interface FieldInfo extends JavaObject {

                getConstPool(): ConstPool;
                getName(): string;
                setName(arg0: string): void;
                getAccessFlags(): number;
                setAccessFlags(arg0: int): void;
                getDescriptor(): string;
                setDescriptor(arg0: string): void;
                getConstantValue(): number;
                getAttributes(): JavaList<AttributeInfo>;
                getAttribute(arg0: string): AttributeInfo;
                removeAttribute(arg0: string): AttributeInfo;
                addAttribute(arg0: AttributeInfo): void;

            }

            const Opcode: JavaInterfaceStatics<Opcode> & {
                readonly AALOAD: number;
                readonly AASTORE: number;
                readonly ACONST_NULL: number;
                readonly ALOAD: number;
                readonly ALOAD_0: number;
                readonly ALOAD_1: number;
                readonly ALOAD_2: number;
                readonly ALOAD_3: number;
                readonly ANEWARRAY: number;
                readonly ARETURN: number;
                readonly ARRAYLENGTH: number;
                readonly ASTORE: number;
                readonly ASTORE_0: number;
                readonly ASTORE_1: number;
                readonly ASTORE_2: number;
                readonly ASTORE_3: number;
                readonly ATHROW: number;
                readonly BALOAD: number;
                readonly BASTORE: number;
                readonly BIPUSH: number;
                readonly CALOAD: number;
                readonly CASTORE: number;
                readonly CHECKCAST: number;
                readonly D2F: number;
                readonly D2I: number;
                readonly D2L: number;
                readonly DADD: number;
                readonly DALOAD: number;
                readonly DASTORE: number;
                readonly DCMPG: number;
                readonly DCMPL: number;
                readonly DCONST_0: number;
                readonly DCONST_1: number;
                readonly DDIV: number;
                readonly DLOAD: number;
                readonly DLOAD_0: number;
                readonly DLOAD_1: number;
                readonly DLOAD_2: number;
                readonly DLOAD_3: number;
                readonly DMUL: number;
                readonly DNEG: number;
                readonly DREM: number;
                readonly DRETURN: number;
                readonly DSTORE: number;
                readonly DSTORE_0: number;
                readonly DSTORE_1: number;
                readonly DSTORE_2: number;
                readonly DSTORE_3: number;
                readonly DSUB: number;
                readonly DUP: number;
                readonly DUP2: number;
                readonly DUP2_X1: number;
                readonly DUP2_X2: number;
                readonly DUP_X1: number;
                readonly DUP_X2: number;
                readonly F2D: number;
                readonly F2I: number;
                readonly F2L: number;
                readonly FADD: number;
                readonly FALOAD: number;
                readonly FASTORE: number;
                readonly FCMPG: number;
                readonly FCMPL: number;
                readonly FCONST_0: number;
                readonly FCONST_1: number;
                readonly FCONST_2: number;
                readonly FDIV: number;
                readonly FLOAD: number;
                readonly FLOAD_0: number;
                readonly FLOAD_1: number;
                readonly FLOAD_2: number;
                readonly FLOAD_3: number;
                readonly FMUL: number;
                readonly FNEG: number;
                readonly FREM: number;
                readonly FRETURN: number;
                readonly FSTORE: number;
                readonly FSTORE_0: number;
                readonly FSTORE_1: number;
                readonly FSTORE_2: number;
                readonly FSTORE_3: number;
                readonly FSUB: number;
                readonly GETFIELD: number;
                readonly GETSTATIC: number;
                readonly GOTO: number;
                readonly GOTO_W: number;
                readonly I2B: number;
                readonly I2C: number;
                readonly I2D: number;
                readonly I2F: number;
                readonly I2L: number;
                readonly I2S: number;
                readonly IADD: number;
                readonly IALOAD: number;
                readonly IAND: number;
                readonly IASTORE: number;
                readonly ICONST_0: number;
                readonly ICONST_1: number;
                readonly ICONST_2: number;
                readonly ICONST_3: number;
                readonly ICONST_4: number;
                readonly ICONST_5: number;
                readonly ICONST_M1: number;
                readonly IDIV: number;
                readonly IFEQ: number;
                readonly IFGE: number;
                readonly IFGT: number;
                readonly IFLE: number;
                readonly IFLT: number;
                readonly IFNE: number;
                readonly IFNONNULL: number;
                readonly IFNULL: number;
                readonly IF_ACMPEQ: number;
                readonly IF_ACMPNE: number;
                readonly IF_ICMPEQ: number;
                readonly IF_ICMPGE: number;
                readonly IF_ICMPGT: number;
                readonly IF_ICMPLE: number;
                readonly IF_ICMPLT: number;
                readonly IF_ICMPNE: number;
                readonly IINC: number;
                readonly ILOAD: number;
                readonly ILOAD_0: number;
                readonly ILOAD_1: number;
                readonly ILOAD_2: number;
                readonly ILOAD_3: number;
                readonly IMUL: number;
                readonly INEG: number;
                readonly INSTANCEOF: number;
                readonly INVOKEDYNAMIC: number;
                readonly INVOKEINTERFACE: number;
                readonly INVOKESPECIAL: number;
                readonly INVOKESTATIC: number;
                readonly INVOKEVIRTUAL: number;
                readonly IOR: number;
                readonly IREM: number;
                readonly IRETURN: number;
                readonly ISHL: number;
                readonly ISHR: number;
                readonly ISTORE: number;
                readonly ISTORE_0: number;
                readonly ISTORE_1: number;
                readonly ISTORE_2: number;
                readonly ISTORE_3: number;
                readonly ISUB: number;
                readonly IUSHR: number;
                readonly IXOR: number;
                readonly JSR: number;
                readonly JSR_W: number;
                readonly L2D: number;
                readonly L2F: number;
                readonly L2I: number;
                readonly LADD: number;
                readonly LALOAD: number;
                readonly LAND: number;
                readonly LASTORE: number;
                readonly LCMP: number;
                readonly LCONST_0: number;
                readonly LCONST_1: number;
                readonly LDC: number;
                readonly LDC2_W: number;
                readonly LDC_W: number;
                readonly LDIV: number;
                readonly LLOAD: number;
                readonly LLOAD_0: number;
                readonly LLOAD_1: number;
                readonly LLOAD_2: number;
                readonly LLOAD_3: number;
                readonly LMUL: number;
                readonly LNEG: number;
                readonly LOOKUPSWITCH: number;
                readonly LOR: number;
                readonly LREM: number;
                readonly LRETURN: number;
                readonly LSHL: number;
                readonly LSHR: number;
                readonly LSTORE: number;
                readonly LSTORE_0: number;
                readonly LSTORE_1: number;
                readonly LSTORE_2: number;
                readonly LSTORE_3: number;
                readonly LSUB: number;
                readonly LUSHR: number;
                readonly LXOR: number;
                readonly MONITORENTER: number;
                readonly MONITOREXIT: number;
                readonly MULTIANEWARRAY: number;
                readonly NEW: number;
                readonly NEWARRAY: number;
                readonly NOP: number;
                readonly POP: number;
                readonly POP2: number;
                readonly PUTFIELD: number;
                readonly PUTSTATIC: number;
                readonly RET: number;
                readonly RETURN: number;
                readonly SALOAD: number;
                readonly SASTORE: number;
                readonly SIPUSH: number;
                readonly SWAP: number;
                readonly TABLESWITCH: number;
                readonly WIDE: number;
                readonly T_BOOLEAN: number;
                readonly T_CHAR: number;
                readonly T_FLOAT: number;
                readonly T_DOUBLE: number;
                readonly T_BYTE: number;
                readonly T_SHORT: number;
                readonly T_INT: number;
                readonly T_LONG: number;
                readonly STACK_GROW: JavaArray<number>;
            }
            interface Opcode extends JavaObject {}

            const StackMap: JavaClassStatics<StackMap> & NoConstructor & {
                readonly tag: string;
                readonly TOP: number;
                readonly INTEGER: number;
                readonly FLOAT: number;
                readonly DOUBLE: number;
                readonly LONG: number;
                readonly NULL: number;
                readonly THIS: number;
                readonly OBJECT: number;
                readonly UNINIT: number;
            }
            interface StackMap extends AttributeInfo {

                numOfEntries(): number;
                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                insertLocal(arg0: int, arg1: int, arg2: int): void;
                removeNew(arg0: int): void;
                print(arg0: java.io.PrintWriter): void;

            }

            const StackMapTable: JavaClassStatics<StackMapTable> & NoConstructor & {
                readonly tag: string;
                readonly TOP: number;
                readonly INTEGER: number;
                readonly FLOAT: number;
                readonly DOUBLE: number;
                readonly LONG: number;
                readonly NULL: number;
                readonly THIS: number;
                readonly OBJECT: number;
                readonly UNINIT: number;

                typeTagOf(arg0: char): number;

            }
            interface StackMapTable extends AttributeInfo {

                copy(arg0: ConstPool, arg1: JavaMap<string, string>): AttributeInfo;
                insertLocal(arg0: int, arg1: int, arg2: int): void;
                println(arg0: java.io.PrintWriter): void;
                println(arg0: java.io.PrintStream): void;
                removeNew(arg0: int): void;

            }

            const CodeIterator: JavaClassStatics<CodeIterator> & NoConstructor;
            interface CodeIterator extends Opcode {

                begin(): void;
                move(arg0: int): void;
                setMark(arg0: int): void;
                setMark2(arg0: int): void;
                getMark(): number;
                getMark2(): number;
                get(): CodeAttribute;
                getCodeLength(): number;
                byteAt(arg0: int): number;
                signedByteAt(arg0: int): number;
                writeByte(arg0: int, arg1: int): void;
                u16bitAt(arg0: int): number;
                s16bitAt(arg0: int): number;
                write16bit(arg0: int, arg1: int): void;
                s32bitAt(arg0: int): number;
                write32bit(arg0: int, arg1: int): void;
                write(arg0: byte[], arg1: int): void;
                hasNext(): boolean;
                next(): number;
                lookAhead(): number;
                skipConstructor(): number;
                skipSuperConstructor(): number;
                skipThisConstructor(): number;
                insert(arg0: byte[]): number;
                insert(arg0: int, arg1: byte[]): void;
                insertAt(arg0: int, arg1: byte[]): number;
                insertEx(arg0: byte[]): number;
                insertEx(arg0: int, arg1: byte[]): void;
                insertExAt(arg0: int, arg1: byte[]): number;
                insertGap(arg0: int): number;
                insertGap(arg0: int, arg1: int): number;
                insertExGap(arg0: int): number;
                insertExGap(arg0: int, arg1: int): number;
                insertGapAt(arg0: int, arg1: int, arg2: boolean): CodeIterator$Gap;
                insert(arg0: ExceptionTable, arg1: int): void;
                append(arg0: byte[]): number;
                appendGap(arg0: int): void;
                append(arg0: ExceptionTable, arg1: int): void;

            }

            const ExceptionTable: JavaClassStatics<ExceptionTable, ExceptionTable$$constructor>;
            interface ExceptionTable$$constructor extends SuppressProperties {

                new (arg0: ConstPool): ExceptionTable;

            }
            interface ExceptionTable extends java.lang.Cloneable {

                clone(): any;
                size(): number;
                startPc(arg0: int): number;
                setStartPc(arg0: int, arg1: int): void;
                endPc(arg0: int): number;
                setEndPc(arg0: int, arg1: int): void;
                handlerPc(arg0: int): number;
                setHandlerPc(arg0: int, arg1: int): void;
                catchType(arg0: int): number;
                setCatchType(arg0: int, arg1: int): void;
                add(arg0: int, arg1: ExceptionTable, arg2: int): void;
                add(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int): void;
                add(arg0: int, arg1: int, arg2: int, arg3: int): void;
                remove(arg0: int): void;
                copy(arg0: ConstPool, arg1: JavaMap<string, string>): ExceptionTable;

            }

            const CodeIterator$Gap: JavaClassStatics<CodeIterator$Gap, CodeIterator$Gap$$constructor>;
            interface CodeIterator$Gap$$constructor extends SuppressProperties {

                new (): CodeIterator$Gap;

            }
            interface CodeIterator$Gap extends JavaObject {
                position: number;
                length: number;
            }

            export {
                ConstPool,
                MethodInfo,
                ClassFile,
                AttributeInfo,
                CodeAttribute,
                ExceptionsAttribute,
                FieldInfo,
                Opcode,
                StackMap,
                StackMapTable,
                CodeIterator,
                ExceptionTable,
                CodeIterator$Gap
            }

        }

        namespace expr {

            const ExprEditor: JavaClassStatics<ExprEditor, ExprEditor$$constructor>;
            interface ExprEditor$$constructor extends SuppressProperties {

                new (): ExprEditor;

            }
            interface ExprEditor extends JavaObject {

                doit(arg0: javassist.CtClass, arg1: javassist.bytecode.MethodInfo): boolean;
                edit(arg0: NewExpr): void;
                edit(arg0: NewArray): void;
                edit(arg0: MethodCall): void;
                edit(arg0: ConstructorCall): void;
                edit(arg0: FieldAccess): void;
                edit(arg0: Instanceof): void;
                edit(arg0: Cast): void;
                edit(arg0: Handler): void;

            }

            const FieldAccess: JavaClassStatics<FieldAccess> & NoConstructor;
            interface FieldAccess extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                isStatic(): boolean;
                isReader(): boolean;
                isWriter(): boolean;
                getClassName(): string;
                getFieldName(): string;
                getField(): javassist.CtField;
                mayThrow(): JavaArray<javassist.CtClass>;
                getSignature(): string;
                replace(arg0: string): void;

            }

            const Handler: JavaClassStatics<Handler> & NoConstructor;
            interface Handler extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                mayThrow(): JavaArray<javassist.CtClass>;
                getType(): javassist.CtClass;
                isFinally(): boolean;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;
                insertBefore(arg0: string): void;

            }

            const Instanceof: JavaClassStatics<Instanceof> & NoConstructor;
            interface Instanceof extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getType(): javassist.CtClass;
                mayThrow(): JavaArray<javassist.CtClass>;
                replace(arg0: string): void;

            }

            const MethodCall: JavaClassStatics<MethodCall> & NoConstructor;
            interface MethodCall extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getClassName(): string;
                getMethodName(): string;
                getMethod(): javassist.CtMethod;
                getSignature(): string;
                mayThrow(): JavaArray<javassist.CtClass>;
                isSuper(): boolean;
                replace(arg0: string): void;

            }

            const NewExpr: JavaClassStatics<NewExpr> & NoConstructor;
            interface NewExpr extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getClassName(): string;
                getSignature(): string;
                getConstructor(): javassist.CtConstructor;
                mayThrow(): JavaArray<javassist.CtClass>;
                replace(arg0: string): void;

            }

            const ConstructorCall: JavaClassStatics<ConstructorCall> & NoConstructor;
            interface ConstructorCall extends MethodCall {

                getMethodName(): string;
                getMethod(): javassist.CtMethod;
                getConstructor(): javassist.CtConstructor;
                isSuper(): boolean;

            }

            const NewArray: JavaClassStatics<NewArray> & NoConstructor;
            interface NewArray extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                mayThrow(): JavaArray<javassist.CtClass>;
                getComponentType(): javassist.CtClass;
                getDimension(): number;
                getCreatedDimensions(): number;
                replace(arg0: string): void;

            }

            const Cast: JavaClassStatics<Cast> & NoConstructor;
            interface Cast extends Expr {

                where(): javassist.CtBehavior;
                getLineNumber(): number;
                getFileName(): string;
                getType(): javassist.CtClass;
                mayThrow(): JavaArray<javassist.CtClass>;
                replace(arg0: string): void;

            }

            const Expr: JavaClassStatics<Expr> & NoConstructor;
            interface Expr extends javassist.bytecode.Opcode {

                getEnclosingClass(): javassist.CtClass;
                where(): javassist.CtBehavior;
                mayThrow(): JavaArray<javassist.CtClass>;
                indexOfBytecode(): number;
                getLineNumber(): number;
                getFileName(): string;
                replace(arg0: string): void;
                replace(arg0: string, arg1: ExprEditor): void;

            }

            export {
                ExprEditor,
                FieldAccess,
                Handler,
                Instanceof,
                MethodCall,
                NewExpr,
                ConstructorCall,
                NewArray,
                Cast,
                Expr
            }

        }

        namespace compiler {

            const AccessorMaker: JavaClassStatics<AccessorMaker, AccessorMaker$$constructor>;
            interface AccessorMaker$$constructor extends SuppressProperties {

                new (arg0: javassist.CtClass): AccessorMaker;

            }
            interface AccessorMaker extends JavaObject {

                getConstructor(arg0: javassist.CtClass, arg1: string, arg2: javassist.bytecode.MethodInfo): string;
                getMethodAccessor(arg0: string, arg1: string, arg2: string, arg3: javassist.bytecode.MethodInfo): string;
                getFieldGetter(arg0: javassist.bytecode.FieldInfo, arg1: boolean): javassist.bytecode.MethodInfo;
                getFieldSetter(arg0: javassist.bytecode.FieldInfo, arg1: boolean): javassist.bytecode.MethodInfo;

            }

            export { AccessorMaker }

        }

    }

    namespace it.unimi.dsi.fastutil {

        const BidirectionalIterator: JavaInterfaceStatics<BidirectionalIterator<any>>;
        interface BidirectionalIterator<K> extends java.util.Iterator<K> {

            previous(): K;
            hasPrevious(): boolean;

        }

        export { BidirectionalIterator }

    }
    namespace it.unimi.dsi.fastutil {

        namespace ints {

            const IntList: JavaInterfaceStatics<IntList> & {

                of(): IntList;
                of(arg0: int): IntList;
                of(arg0: int, arg1: int): IntList;
                of(arg0: int, arg1: int, arg2: int): IntList;
                of(...arg0: int[]): IntList;

            }
            interface IntList extends JavaList<number>, java.lang.Comparable<JavaList<any>>, IntCollection {

                iterator(): IntListIterator;
                spliterator(): IntSpliterator;
                listIterator(): IntListIterator;
                listIterator(arg0: int): IntListIterator;
                subList(arg0: int, arg1: int): IntList;
                size(arg0: int): void;
                size(): number;
                getElements(arg0: int, arg1: int[], arg2: int, arg3: int): void;
                removeElements(arg0: int, arg1: int): void;
                addElements(arg0: int, arg1: int[]): void;
                addElements(arg0: int, arg1: int[], arg2: int, arg3: int): void;
                setElements(arg0: int[]): void;
                setElements(arg0: int, arg1: int[]): void;
                setElements(arg0: int, arg1: int[], arg2: int, arg3: int): void;
                add(arg0: int): boolean;
                add(arg0: int, arg1: int): void;
                /** @deprecated */
                add(arg0: int, arg1: int): void;
                addAll(arg0: int, arg1: IntCollection): boolean;
                addAll(arg0: JavaCollection<any>): boolean;
                addAll(arg0: int, arg1: JavaCollection<any>): boolean;
                addAll(arg0: IntCollection): boolean;
                set(arg0: int, arg1: int): number;
                replaceAll(arg0: java.util.function.IntUnaryOperator): void;
                replaceAll(arg0: IntUnaryOperator): void;
                /** @deprecated */
                replaceAll(arg0: java.util.function.UnaryOperator<int>): void;
                getInt(arg0: int): number;
                indexOf(arg0: int): number;
                lastIndexOf(arg0: int): number;
                /** @deprecated */
                contains(arg0: any): boolean;
                contains(arg0: int): boolean;
                /** @deprecated */
                get(arg0: int): number;
                /** @deprecated */
                indexOf(arg0: any): number;
                /** @deprecated */
                lastIndexOf(arg0: any): number;
                /** @deprecated */
                add(arg0: int): boolean;
                removeInt(arg0: int): number;
                /** @deprecated */
                remove(arg0: any): boolean;
                /** @deprecated */
                remove(arg0: int): number;
                /** @deprecated */
                set(arg0: int, arg1: int): number;
                addAll(arg0: int, arg1: IntList): boolean;
                addAll(arg0: IntList): boolean;
                /** @deprecated */
                sort(arg0: java.util.Comparator<any>): void;
                sort(arg0: IntComparator): void;
                /** @deprecated */
                unstableSort(arg0: java.util.Comparator<any>): void;
                unstableSort(arg0: IntComparator): void;

            }

            const IntUnaryOperator: JavaInterfaceStatics<IntUnaryOperator> & {

                identity(): IntUnaryOperator;
                negation(): IntUnaryOperator;

            }
            interface IntUnaryOperator extends java.util.function.UnaryOperator<number>, java.util.function.IntUnaryOperator {

                apply(arg0: int): number;
                /** @deprecated */
                applyAsInt(arg0: int): number;
                /** @deprecated */
                apply(arg0: int): number;

            }

            const IntIterable: JavaInterfaceStatics<IntIterable>;
            interface IntIterable extends java.lang.Iterable<number> {

                iterator(): IntIterator;
                intIterator(): IntIterator;
                spliterator(): IntSpliterator;
                intSpliterator(): IntSpliterator;
                forEach(arg0: java.util.function.IntConsumer): void;
                forEach(arg0: IntConsumer): void;
                /** @deprecated */
                forEach(arg0: java.util.function.Consumer<any>): void;

            }

            const IntListIterator: JavaInterfaceStatics<IntListIterator>;
            interface IntListIterator extends IntBidirectionalIterator, java.util.ListIterator<number> {

                set(arg0: int): void;
                add(arg0: int): void;
                remove(): void;
                /** @deprecated */
                set(arg0: int): void;
                /** @deprecated */
                add(arg0: int): void;
                /** @deprecated */
                next(): number;
                /** @deprecated */
                previous(): number;

            }

            const IntSpliterator: JavaInterfaceStatics<IntSpliterator>;
            interface IntSpliterator extends java.util.Spliterator$OfInt {

                /** @deprecated */
                tryAdvance(arg0: java.util.function.Consumer<any>): boolean;
                tryAdvance(arg0: IntConsumer): boolean;
                tryAdvance(arg0: java.util.function.IntConsumer): boolean;
                /** @deprecated */
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;
                forEachRemaining(arg0: IntConsumer): void;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                skip(arg0: long): number;
                trySplit(): IntSpliterator;
                getComparator(): IntComparator;

            }

            const IntCollection: JavaInterfaceStatics<IntCollection>;
            interface IntCollection extends JavaCollection<number>, IntIterable {

                iterator(): IntIterator;
                intIterator(): IntIterator;
                spliterator(): IntSpliterator;
                intSpliterator(): IntSpliterator;
                add(arg0: int): boolean;
                contains(arg0: int): boolean;
                rem(arg0: int): boolean;
                /** @deprecated */
                add(arg0: int): boolean;
                /** @deprecated */
                contains(arg0: any): boolean;
                /** @deprecated */
                remove(arg0: any): boolean;
                toIntArray(): JavaArray<number>;
                /** @deprecated */
                toIntArray(arg0: int[]): JavaArray<number>;
                toArray(arg0: int[]): JavaArray<number>;
                toArray(): JavaArray<any>;
                toArray<T>(arg0: T[]): JavaArray<T>;
                toArray<T>(arg0: java.util.function.IntFunction<T[]>): JavaArray<T>;
                addAll(arg0: IntCollection): boolean;
                addAll(arg0: JavaCollection<any>): boolean;
                containsAll(arg0: IntCollection): boolean;
                containsAll(arg0: JavaCollection<any>): boolean;
                removeAll(arg0: IntCollection): boolean;
                removeAll(arg0: JavaCollection<any>): boolean;
                /** @deprecated */
                removeIf(arg0: java.util.function.Predicate<any>): boolean;
                removeIf(arg0: java.util.function.IntPredicate): boolean;
                removeIf(arg0: IntPredicate): boolean;
                retainAll(arg0: IntCollection): boolean;
                retainAll(arg0: JavaCollection<any>): boolean;
                /** @deprecated */
                stream(): java.util.stream.Stream<number>;
                intStream(): java.util.stream.IntStream;
                /** @deprecated */
                parallelStream(): java.util.stream.Stream<number>;
                intParallelStream(): java.util.stream.IntStream;

            }

            const IntComparator: JavaInterfaceStatics<IntComparator>;
            interface IntComparator extends java.util.Comparator<number> {

                compare(arg0: int, arg1: int): number;
                reversed(): IntComparator;
                /** @deprecated */
                compare(arg0: int, arg1: int): number;
                thenComparing(arg0: IntComparator): IntComparator;
                thenComparing(arg0: java.util.Comparator<any>): java.util.Comparator<number>;

            }

            const IntBidirectionalIterator: JavaInterfaceStatics<IntBidirectionalIterator>;
            interface IntBidirectionalIterator extends IntIterator, it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator<number> {

                previousInt(): number;
                /** @deprecated */
                previous(): number;
                back(arg0: int): number;
                skip(arg0: int): number;

            }

            const IntPredicate: JavaInterfaceStatics<IntPredicate>;
            interface IntPredicate extends java.util.function.Predicate<number>, java.util.function.IntPredicate {

                /** @deprecated */
                test(arg0: int): boolean;
                test(arg0: int): boolean;
                and(arg0: java.util.function.IntPredicate): IntPredicate;
                and(arg0: IntPredicate): IntPredicate;
                /** @deprecated */
                and(arg0: java.util.function.Predicate<any>): java.util.function.Predicate<number>;
                negate(): IntPredicate;
                or(arg0: java.util.function.IntPredicate): IntPredicate;
                or(arg0: IntPredicate): IntPredicate;
                /** @deprecated */
                or(arg0: java.util.function.Predicate<any>): java.util.function.Predicate<number>;

            }

            const IntIterator: JavaInterfaceStatics<IntIterator>;
            interface IntIterator extends java.util.PrimitiveIterator$OfInt {

                nextInt(): number;
                /** @deprecated */
                next(): number;
                forEachRemaining(arg0: IntConsumer): void;
                /** @deprecated */
                forEachRemaining(arg0: java.util.function.Consumer<any>): void;
                forEachRemaining(arg0: java.util.function.IntConsumer): void;
                skip(arg0: int): number;

            }

            const IntConsumer: JavaInterfaceStatics<IntConsumer>;
            interface IntConsumer extends java.util.function.Consumer<number>, java.util.function.IntConsumer {

                /** @deprecated */
                accept(arg0: int): void;
                accept(arg0: int): void;
                andThen(arg0: java.util.function.IntConsumer): IntConsumer;
                andThen(arg0: IntConsumer): IntConsumer;
                /** @deprecated */
                andThen(arg0: java.util.function.Consumer<any>): java.util.function.Consumer<number>;

            }

            export {
                IntList,
                IntUnaryOperator,
                IntIterable,
                IntListIterator,
                IntSpliterator,
                IntCollection,
                IntComparator,
                IntBidirectionalIterator,
                IntPredicate,
                IntIterator,
                IntConsumer
            }

        }

        namespace objects {

            const ObjectIterator: JavaInterfaceStatics<ObjectIterator<any>>;
            interface ObjectIterator<K> extends java.util.Iterator<K> {

                skip(arg0: int): number;

            }

            const ObjectBidirectionalIterator: JavaInterfaceStatics<ObjectBidirectionalIterator<any>>;
            interface ObjectBidirectionalIterator<K> extends ObjectIterator<K>, it.unimi.dsi.fastutil.BidirectionalIterator<K> {

                back(arg0: int): number;
                skip(arg0: int): number;

            }

            export { ObjectIterator, ObjectBidirectionalIterator }

        }

    }

}

type AbstractRenderCodeCompiler = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AbstractRenderCodeCompiler;
type AbstractWidgetBuilder<B extends Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.AbstractWidgetBuilder<B, T, U> = any, T = /* minecraft class */ any, U extends Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<U, T> = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.AbstractWidgetBuilder<B, T, U>;
type AdvancementHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementHelper;
type AdvancementManagerHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementManagerHelper;
type AdvancementProgressHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.AdvancementProgressHelper;
type Alignable<B extends Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B> = any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Alignable<B>;
type AutoCompleteSuggestion = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.highlighting.AutoCompleteSuggestion;
type BaseEvent = Events.BaseEvent;
type BaseEventRegistry = Packages.xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry;
type BaseHelper<T = any> = Packages.xyz.wagyourtail.jsmacros.core.helpers.BaseHelper<T>;
type BaseLanguage<U = any, T extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<U> = any> = Packages.xyz.wagyourtail.jsmacros.core.language.BaseLanguage<U, T>;
type BaseLibrary = Packages.xyz.wagyourtail.jsmacros.core.library.BaseLibrary;
type BaseProfile = Packages.xyz.wagyourtail.jsmacros.core.config.BaseProfile;
type BaseScreen = Packages.xyz.wagyourtail.wagyourgui.BaseScreen;
type BaseScriptContext$SleepRunnable = Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext$SleepRunnable;
type BaseScriptContext<T = any> = Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<T>;
type BaseWrappedException$SourceLocation = Packages.xyz.wagyourtail.jsmacros.core.language.BaseWrappedException$SourceLocation;
type BaseWrappedException<T = any> = Packages.xyz.wagyourtail.jsmacros.core.language.BaseWrappedException<T>;
type BlockDataHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockDataHelper;
type BlockHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockHelper;
type BlockPosHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockPosHelper;
type BlockStateHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.BlockStateHelper;
type BossBarHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.BossBarHelper;
type Box = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box;
type Box$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Box$Builder;
type ButtonWidgetHelper$ButtonBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$ButtonBuilder;
type ButtonWidgetHelper$TexturedButtonBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper$TexturedButtonBuilder;
type ButtonWidgetHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ButtonWidgetHelper<T>;
type ChatHistoryManager = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.ChatHistoryManager;
type ChatHudLineHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ChatHudLineHelper;
type CheckBox = Packages.xyz.wagyourtail.wagyourgui.elements.CheckBox;
type CheckBoxWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper;
type CheckBoxWidgetHelper$CheckBoxBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CheckBoxWidgetHelper$CheckBoxBuilder;
type ChunkHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ChunkHelper;
type ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$AnnotationBuilder$AnnotationArrayBuilder<U>;
type ClassBuilder$AnnotationBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$AnnotationBuilder<T>;
type ClassBuilder$BodyBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$BodyBuilder;
type ClassBuilder$ConstructorBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$ConstructorBuilder;
type ClassBuilder$FieldBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$FieldBuilder;
type ClassBuilder$FieldBuilder$FieldInitializerBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$FieldBuilder$FieldInitializerBuilder;
type ClassBuilder$MethodBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder$MethodBuilder;
type ClassBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ClassBuilder<T>;
type ClickableWidgetHelper<B extends Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<B, T> = any, T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ClickableWidgetHelper<B, T>;
type ClientPlayerEntityHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ClientPlayerEntityHelper<T>;
type CommandBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandBuilder;
type CommandContextHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandContextHelper;
type CommandManager = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.CommandManager;
type CommandNodeHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.CommandNodeHelper;
type ConfigManager = Packages.xyz.wagyourtail.jsmacros.core.config.ConfigManager;
type Core<T extends Packages.xyz.wagyourtail.jsmacros.core.config.BaseProfile = any, U extends Packages.xyz.wagyourtail.jsmacros.core.event.BaseEventRegistry = any> = Packages.xyz.wagyourtail.jsmacros.core.Core<T, U>;
type CreativeItemStackHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.CreativeItemStackHelper;
type CustomImage = Packages.xyz.wagyourtail.jsmacros.client.api.classes.CustomImage;
type CyclingButtonWidgetHelper$CyclicButtonBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper$CyclicButtonBuilder<T>;
type CyclingButtonWidgetHelper<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.CyclingButtonWidgetHelper<T>;
type DirectionHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.DirectionHelper;
type Draw2D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw2D;
type Draw2DElement = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement;
type Draw2DElement$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Draw2DElement$Builder;
type Draw3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.Draw3D;
type EditorScreen = Packages.xyz.wagyourtail.jsmacros.client.gui.screens.EditorScreen;
type EnchantmentHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.EnchantmentHelper;
type EntityHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.EntityHelper<T>;
type EventContainer<T extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any> = any> = Packages.xyz.wagyourtail.jsmacros.core.language.EventContainer<T>;
type EventCustom = Packages.xyz.wagyourtail.jsmacros.core.event.impl.EventCustom;
type EventService = Packages.xyz.wagyourtail.jsmacros.core.service.EventService;
type Extension = Packages.xyz.wagyourtail.jsmacros.core.extensions.Extension;
type Extension$ExtMatch = Packages.xyz.wagyourtail.jsmacros.core.extensions.Extension$ExtMatch;
type ExtensionLoader = Packages.xyz.wagyourtail.jsmacros.core.extensions.ExtensionLoader;
type FJsMacros$EventAndContext = Packages.xyz.wagyourtail.jsmacros.core.library.impl.FJsMacros$EventAndContext;
type FileHandler = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.FileHandler;
type FishingBobberEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.specialized.projectile.FishingBobberEntityHelper;
type FluidStateHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.FluidStateHelper;
type FoodComponentHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.FoodComponentHelper;
type FormattingHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.FormattingHelper;
type HTTPRequest = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest;
type HTTPRequest$Response = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.HTTPRequest$Response;
type History = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.History;
type IContainerParent = Packages.xyz.wagyourtail.wagyourgui.containers.IContainerParent;
type IDraw2D<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IDraw2D<T>;
type IEventListener = Packages.xyz.wagyourtail.jsmacros.core.event.IEventListener;
type IOverlayParent = Packages.xyz.wagyourtail.wagyourgui.overlays.IOverlayParent;
type IScreen = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.IScreen;
type Image = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image;
type Image$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Image$Builder;
type Inventory<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.Inventory<T>;
type Item = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item;
type Item$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Item$Builder;
type ItemEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.ItemEntityHelper;
type ItemHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemHelper;
type ItemStackHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.inventory.ItemStackHelper;
type Library = Packages.xyz.wagyourtail.jsmacros.core.library.Library;
type LibraryBuilder = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.LibraryBuilder;
type LibraryRegistry = Packages.xyz.wagyourtail.jsmacros.core.library.LibraryRegistry;
type Line = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line;
type Line$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Line$Builder;
type Line3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D;
type Line3D$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Line3D$Builder;
type LivingEntityHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.LivingEntityHelper<T>;
type LockButtonWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper;
type LockButtonWidgetHelper$LockButtonBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.LockButtonWidgetHelper$LockButtonBuilder;
type Mappings = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings;
type Mappings$ClassData = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings$ClassData;
type Mappings$MappedClass<T = any> = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings$MappedClass<T>;
type Mappings$MethodData = Packages.xyz.wagyourtail.jsmacros.core.classes.Mappings$MethodData;
type MerchantEntityHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.MerchantEntityHelper<T>;
type MethodWrapper<T = any, U = any, R = any, C extends Packages.xyz.wagyourtail.jsmacros.core.language.BaseScriptContext<any> = any> = Packages.xyz.wagyourtail.jsmacros.core.MethodWrapper<T, U, R, C>;
type ModContainerHelper<T = any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.ModContainerHelper<T>;
type MultiElementContainer<T extends Packages.xyz.wagyourtail.wagyourgui.containers.IContainerParent = any> = Packages.xyz.wagyourtail.wagyourgui.containers.MultiElementContainer<T>;
type NBTElementHelper$NBTCompoundHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTCompoundHelper;
type NBTElementHelper$NBTListHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTListHelper;
type NBTElementHelper$NBTNumberHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper$NBTNumberHelper;
type NBTElementHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.NBTElementHelper<T>;
type OptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper;
type OptionsHelper$AccessibilityOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$AccessibilityOptionsHelper;
type OptionsHelper$ChatOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$ChatOptionsHelper;
type OptionsHelper$ControlOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$ControlOptionsHelper;
type OptionsHelper$MusicOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$MusicOptionsHelper;
type OptionsHelper$SkinOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$SkinOptionsHelper;
type OptionsHelper$VideoOptionsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.OptionsHelper$VideoOptionsHelper;
type OverlayContainer = Packages.xyz.wagyourtail.wagyourgui.overlays.OverlayContainer;
type PacketByteBufferHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.PacketByteBufferHelper;
type Pair<T = any, U = any> = Packages.xyz.wagyourtail.Pair<T, U>;
type PerLanguageLibrary = Packages.xyz.wagyourtail.jsmacros.core.library.PerLanguageLibrary;
type PlayerAbilitiesHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerAbilitiesHelper;
type PlayerEntityHelper<T = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.PlayerEntityHelper<T>;
type PlayerInput = Packages.xyz.wagyourtail.jsmacros.client.api.classes.PlayerInput;
type PlayerListEntryHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.PlayerListEntryHelper;
type Pos2D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos2D;
type Pos3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Pos3D;
type ProxyBuilder$MethodSigParts = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder$MethodSigParts;
type ProxyBuilder$ProxyReference<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder$ProxyReference<T>;
type ProxyBuilder<T = any> = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.ProxyBuilder<T>;
type Rect = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect;
type Rect$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Rect$Builder;
type RegistryHelper = Packages.xyz.wagyourtail.jsmacros.client.api.classes.RegistryHelper;
type RenderElement = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement;
type RenderElementBuilder<T extends Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElement = any> = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.RenderElementBuilder<T>;
type ScoreboardObjectiveHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.ScoreboardObjectiveHelper;
type ScoreboardsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ScoreboardsHelper;
type ScriptScreen = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.ScriptScreen;
type ScriptTrigger = Packages.xyz.wagyourtail.jsmacros.core.config.ScriptTrigger;
type ScriptTrigger$TriggerType = Packages.xyz.wagyourtail.jsmacros.core.config.ScriptTrigger$TriggerType;
type Scrollbar = Packages.xyz.wagyourtail.wagyourgui.elements.Scrollbar;
type SelectCursor = Packages.xyz.wagyourtail.jsmacros.client.gui.editor.SelectCursor;
type ServerInfoHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.ServerInfoHelper;
type ServiceManager = Packages.xyz.wagyourtail.jsmacros.core.service.ServiceManager;
type ServiceManager$ServiceStatus = Packages.xyz.wagyourtail.jsmacros.core.service.ServiceManager$ServiceStatus;
type ServiceTrigger = Packages.xyz.wagyourtail.jsmacros.core.service.ServiceTrigger;
type Slider = Packages.xyz.wagyourtail.wagyourgui.elements.Slider;
type SliderWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper;
type SliderWidgetHelper$SliderBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.SliderWidgetHelper$SliderBuilder;
type StateHelper<U = /* minecraft class */ any> = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.StateHelper<U>;
type StatsHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatsHelper;
type StatusEffectHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StatusEffectHelper;
type StringHashTrie = Packages.xyz.wagyourtail.StringHashTrie;
type StyleHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.StyleHelper;
type SuggestionsBuilderHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.SuggestionsBuilderHelper;
type Surface = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface;
type Surface$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components3d.Surface$Builder;
type TeamHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.TeamHelper;
type Text = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text;
type Text$Builder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.render.components.Text$Builder;
type TextBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.TextBuilder;
type TextFieldWidgetHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper;
type TextFieldWidgetHelper$TextFieldBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.screen.TextFieldWidgetHelper$TextFieldBuilder;
type TextHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.TextHelper;
type TradeOfferHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.TradeOfferHelper;
type UniversalBlockStateHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.UniversalBlockStateHelper;
type Vec2D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec2D;
type Vec3D = Packages.xyz.wagyourtail.jsmacros.client.api.classes.math.Vec3D;
type VillagerEntityHelper = Packages.xyz.wagyourtail.jsmacros.client.api.helpers.world.entity.VillagerEntityHelper;
type VillagerInventory = Packages.xyz.wagyourtail.jsmacros.client.api.classes.inventory.VillagerInventory;
type Websocket = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket;
type Websocket$Disconnected = Packages.xyz.wagyourtail.jsmacros.core.library.impl.classes.Websocket$Disconnected;
type WorldScanner = Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScanner;
type WorldScannerBuilder = Packages.xyz.wagyourtail.jsmacros.client.api.classes.worldscanner.WorldScannerBuilder;
type WrappedClassInstance<T = any> = Packages.xyz.wagyourtail.jsmacros.core.classes.WrappedClassInstance<T>;

// Enum types
type Bit    = 1 | 0;
type Trit   = 2 | Bit;
type Dit    = 3 | Trit;
type Pentit = 4 | Dit;
type Hexit  = 5 | Pentit;
type Septit = 6 | Hexit;
type Octit  = 7 | Septit;

type Side = Hexit;
type HotbarSlot = Octit | 8;
type HotbarSwapSlot = HotbarSlot | OffhandSlot;
type ClickSlotButton = HotbarSwapSlot | 9 | 10;
type OffhandSlot = 40;

type ArmorSlot = 'HEAD' | 'CHEST' | 'LEGS' | 'FEET';
type AttackIndicatorType = 'off' | 'crosshair' | 'hotbar';
type BlockUpdateType = 'STATE' | 'ENTITY';
type BossBarUpdateType = 'ADD' | 'REMOVE' | 'UPDATE_PERCENT'
| 'UPDATE_NAME' | 'UPDATE_STYLE' | 'UPDATE_PROPERTIES'
type ChatVisibility = 'FULL' | 'SYSTEM' | 'HIDDEN';
type ChunkBuilderMode = 'none' | 'nearby' | 'player_affected';
type CloudsMode = 'off' | 'fast' | 'fancy';
type Difficulty = 'peaceful' | 'easy' | 'normal' | 'hard';
type Direction = 'up' | 'down' | 'north' | 'south' | 'east' | 'west';
type GraphicsMode = 'fast' | 'fancy' | 'fabulous';
type HandledScreenName = 
| `${ 1 | 2 | 3 | 4 | 5 | 6 } Row Chest`
| '3x3 Container'
| 'Anvil'
| 'Beacon'
| 'Blast Furnace'
| 'Brewing Stand'
| 'Crafting Table'
| 'Enchanting Table'
| 'Furnace'
| 'Grindstone'
| 'Hopper'
| 'Loom'
| 'Villager'
| 'Shulker Box'
| 'Smithing Table'
| 'Smoker'
| 'Cartography Table'
| 'Stonecutter'
| 'Survival Inventory'
| 'Horse'
| 'Creative Inventory'
| 'Chat'
| 'unknown'
type HealSource = DamageSource;
type InvMapId = InvMapType.All;
declare namespace InvMapType {
    type _inv = 'hotber' | 'main';
    type _invio = _inv | 'input' | 'output';

    type Inventory = _inv | 'offhand' | 'boots' | 'leggings' | 'chestplate' | 'helmet'
    | 'crafting_in' | 'craft_out';
    type CreativeInvInvTab = Exclude<Inventory, 'crafting_in' | 'crafting_out'> | 'delete';
    type CreativeInv = 'hotbar' | 'creative';
    type Container        = _inv | 'container';
    type Beacon           = _inv | 'slot';
    type Furnace          = _invio | 'fuel';
    type BrewingStand     = _invio | 'fuel';
    type Crafting         = _invio;
    type Enchantment      = _inv | 'lapis' | 'item';
    type Loom             = _inv | 'output' | 'pattern' | 'dye' | 'banner';
    type Stonecutter      = _invio;
    type Horse            = _inv | 'saddle' | 'armor' | 'container';
    type Anvil            = _invio;
    type Merchant         = _invio;
    type Smithing         = _invio;
    type Grindstone       = _invio;
    type CartographyTable = _invio;

    type All =
    | Inventory
    | CreativeInvInvTab
    | CreativeInv
    | Container
    | Beacon
    | Furnace
    | BrewingStand
    | Crafting
    | Enchantment
    | Loom
    | Stonecutter
    | Horse
    | Anvil
    | Merchant
    | Smithing
    | Grindstone
    | CartographyTable
}
type KeyMods = KeyMod.shift | KeyMod.ctrl | KeyMod.alt
| `${KeyMod.shift}+${KeyMod.ctrl | KeyMod.alt}`
| `${KeyMod.ctrl}+${KeyMod.alt}`
| `${KeyMod.shift}+${KeyMod.ctrl}+${KeyMod.alt}`
declare namespace KeyMod {
    type shift = 'key.keyboard.left.shift';
    type ctrl = 'key.keyboard.left.control';
    type alt = 'key.keyboard.left.alt';
}
type MobCategory = 'UNDEAD' | 'DEFAULT' | 'ARTHROPOD' | 'ILLAGER' | 'AQUATIC' | 'UNKNOWN';
type NarratorMode = 'OFF' | 'ALL' | 'CHAT' | 'SYSTEM';
type ParticleMode = 'minimal' | 'decreased' | 'all';
type StringFilterMethod = 'EQUALS' | 'CONTAINS' | 'STARTS_WITH' | 'ENDS_WITH' | 'MATCHES';
type NumberFilterOperation = '>' | '>=' | '<' | '<=' | '==' | '!=';
type TitleType = 'TITLE' | 'SUBTITLE' | 'ACTIONBAR';
